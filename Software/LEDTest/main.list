
main.out:     file format elf32-littlearm


Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	e92d4010 	push	{r4, lr}
 800018c:	e59f4028 	ldr	r4, [pc, #40]	; 80001bc <__do_global_dtors_aux+0x34>
 8000190:	e5d43000 	ldrb	r3, [r4]
 8000194:	e3530000 	cmp	r3, #0
 8000198:	1a000005 	bne	80001b4 <__do_global_dtors_aux+0x2c>
 800019c:	e59f301c 	ldr	r3, [pc, #28]	; 80001c0 <__do_global_dtors_aux+0x38>
 80001a0:	e3530000 	cmp	r3, #0
 80001a4:	159f0018 	ldrne	r0, [pc, #24]	; 80001c4 <__do_global_dtors_aux+0x3c>
 80001a8:	1320f000 	nopne	{0}
 80001ac:	e3a03001 	mov	r3, #1
 80001b0:	e5c43000 	strb	r3, [r4]
 80001b4:	e8bd4010 	pop	{r4, lr}
 80001b8:	e12fff1e 	bx	lr
 80001bc:	20000430 	.word	0x20000430
 80001c0:	00000000 	.word	0x00000000
 80001c4:	08002704 	.word	0x08002704

080001c8 <frame_dummy>:
 80001c8:	e59f303c 	ldr	r3, [pc, #60]	; 800020c <frame_dummy+0x44>
 80001cc:	e3530000 	cmp	r3, #0
 80001d0:	e92d4010 	push	{r4, lr}
 80001d4:	159f0034 	ldrne	r0, [pc, #52]	; 8000210 <frame_dummy+0x48>
 80001d8:	159f1034 	ldrne	r1, [pc, #52]	; 8000214 <frame_dummy+0x4c>
 80001dc:	1320f000 	nopne	{0}
 80001e0:	e59f0030 	ldr	r0, [pc, #48]	; 8000218 <frame_dummy+0x50>
 80001e4:	e5903000 	ldr	r3, [r0]
 80001e8:	e3530000 	cmp	r3, #0
 80001ec:	1a000001 	bne	80001f8 <frame_dummy+0x30>
 80001f0:	e8bd4010 	pop	{r4, lr}
 80001f4:	e12fff1e 	bx	lr
 80001f8:	e59f301c 	ldr	r3, [pc, #28]	; 800021c <frame_dummy+0x54>
 80001fc:	e3530000 	cmp	r3, #0
 8000200:	0afffffa 	beq	80001f0 <frame_dummy+0x28>
 8000204:	e8bd4010 	pop	{r4, lr}
 8000208:	e12fff13 	bx	r3
 800020c:	00000000 	.word	0x00000000
 8000210:	08002704 	.word	0x08002704
 8000214:	20000434 	.word	0x20000434
 8000218:	20000430 	.word	0x20000430
 800021c:	00000000 	.word	0x00000000

08000220 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 8000220:	b410      	push	{r4}
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000222:	4911      	ldr	r1, [pc, #68]	; (8000268 <SystemInit+0x48>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8000224:	4b11      	ldr	r3, [pc, #68]	; (800026c <SystemInit+0x4c>)

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000226:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800022a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800022e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8000232:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000234:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8000236:	f042 0201 	orr.w	r2, r2, #1
 800023a:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800023c:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 800023e:	681a      	ldr	r2, [r3, #0]
 8000240:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8000244:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000800;
 8000248:	f44f 6400 	mov.w	r4, #2048	; 0x800

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 800024c:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000800;
 800024e:	60dc      	str	r4, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000250:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000252:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000800;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000256:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800025a:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 800025c:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800025e:	608c      	str	r4, [r1, #8]
#endif
}
 8000260:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000264:	4770      	bx	lr
 8000266:	bf00      	nop
 8000268:	e000ed00 	.word	0xe000ed00
 800026c:	40021000 	.word	0x40021000

08000270 <SystemCoreClockUpdate>:
  *
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 8000270:	b410      	push	{r4}
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
 8000272:	4b27      	ldr	r3, [pc, #156]	; (8000310 <SystemCoreClockUpdate+0xa0>)
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000274:	4c26      	ldr	r4, [pc, #152]	; (8000310 <SystemCoreClockUpdate+0xa0>)
void SystemCoreClockUpdate(void)
{
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
 8000276:	681a      	ldr	r2, [r3, #0]
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 8000278:	4826      	ldr	r0, [pc, #152]	; (8000314 <SystemCoreClockUpdate+0xa4>)
void SystemCoreClockUpdate(void)
{
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
 800027a:	0712      	lsls	r2, r2, #28
  { /* MSISRANGE from RCC_CSR applies */
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 800027c:	bf54      	ite	pl
 800027e:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
  }
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 8000282:	6819      	ldrmi	r1, [r3, #0]
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000284:	68a3      	ldr	r3, [r4, #8]
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
  { /* MSISRANGE from RCC_CSR applies */
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 8000286:	bf54      	ite	pl
 8000288:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
  }
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 800028c:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000290:	f003 030c 	and.w	r3, r3, #12
 8000294:	2b08      	cmp	r3, #8
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 8000296:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800029a:	d013      	beq.n	80002c4 <SystemCoreClockUpdate+0x54>
 800029c:	2b0c      	cmp	r3, #12
 800029e:	d013      	beq.n	80002c8 <SystemCoreClockUpdate+0x58>
 80002a0:	491d      	ldr	r1, [pc, #116]	; (8000318 <SystemCoreClockUpdate+0xa8>)
 80002a2:	2b04      	cmp	r3, #4
 80002a4:	bf14      	ite	ne
 80002a6:	4613      	movne	r3, r2
 80002a8:	460b      	moveq	r3, r1
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80002aa:	4a19      	ldr	r2, [pc, #100]	; (8000310 <SystemCoreClockUpdate+0xa0>)
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 80002ac:	491b      	ldr	r1, [pc, #108]	; (800031c <SystemCoreClockUpdate+0xac>)
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80002ae:	6892      	ldr	r2, [r2, #8]
 80002b0:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80002b4:	4402      	add	r2, r0
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 80002b6:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
 80002ba:	40d3      	lsrs	r3, r2
 80002bc:	600b      	str	r3, [r1, #0]
}
 80002be:	f85d 4b04 	ldr.w	r4, [sp], #4
 80002c2:	4770      	bx	lr
      SystemCoreClock = HSI_VALUE;
      break;

    case 0x08:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
      break;
 80002c4:	4b16      	ldr	r3, [pc, #88]	; (8000320 <SystemCoreClockUpdate+0xb0>)
 80002c6:	e7f0      	b.n	80002aa <SystemCoreClockUpdate+0x3a>

    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80002c8:	68e1      	ldr	r1, [r4, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;
 80002ca:	68e3      	ldr	r3, [r4, #12]

    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80002cc:	f001 0103 	and.w	r1, r1, #3
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;
 80002d0:	f3c3 1302 	ubfx	r3, r3, #4, #3

      switch (pllsource)
 80002d4:	2902      	cmp	r1, #2
    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;
 80002d6:	f103 0301 	add.w	r3, r3, #1

      switch (pllsource)
 80002da:	d012      	beq.n	8000302 <SystemCoreClockUpdate+0x92>
 80002dc:	2903      	cmp	r1, #3
 80002de:	d114      	bne.n	800030a <SystemCoreClockUpdate+0x9a>
        case 0x02:  /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm);
          break;

        case 0x03:  /* HSE used as PLL clock source */
          pllvco = (HSE_VALUE / pllm);
 80002e0:	4a0f      	ldr	r2, [pc, #60]	; (8000320 <SystemCoreClockUpdate+0xb0>)
 80002e2:	fbb2 f3f3 	udiv	r3, r2, r3

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80002e6:	4a0a      	ldr	r2, [pc, #40]	; (8000310 <SystemCoreClockUpdate+0xa0>)
 80002e8:	68d1      	ldr	r1, [r2, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1) * 2;
 80002ea:	68d4      	ldr	r4, [r2, #12]
 80002ec:	f3c4 6441 	ubfx	r4, r4, #25, #2
 80002f0:	3401      	adds	r4, #1

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80002f2:	f3c1 2106 	ubfx	r1, r1, #8, #7
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1) * 2;
 80002f6:	0064      	lsls	r4, r4, #1

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80002f8:	fb01 f303 	mul.w	r3, r1, r3
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1) * 2;
      SystemCoreClock = pllvco/pllr;
 80002fc:	fbb3 f3f4 	udiv	r3, r3, r4
      break;
 8000300:	e7d3      	b.n	80002aa <SystemCoreClockUpdate+0x3a>
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;

      switch (pllsource)
      {
        case 0x02:  /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm);
 8000302:	4a05      	ldr	r2, [pc, #20]	; (8000318 <SystemCoreClockUpdate+0xa8>)
 8000304:	fbb2 f3f3 	udiv	r3, r2, r3
          break;
 8000308:	e7ed      	b.n	80002e6 <SystemCoreClockUpdate+0x76>
        case 0x03:  /* HSE used as PLL clock source */
          pllvco = (HSE_VALUE / pllm);
          break;

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
 800030a:	fbb2 f3f3 	udiv	r3, r2, r3
          break;
 800030e:	e7ea      	b.n	80002e6 <SystemCoreClockUpdate+0x76>
 8000310:	40021000 	.word	0x40021000
 8000314:	08002738 	.word	0x08002738
 8000318:	00f42400 	.word	0x00f42400
 800031c:	20000000 	.word	0x20000000
 8000320:	007a1200 	.word	0x007a1200

08000324 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 8000324:	b510      	push	{r4, lr}
 8000326:	b096      	sub	sp, #88	; 0x58
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8000328:	2400      	movs	r4, #0
{

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800032a:	2102      	movs	r1, #2
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800032c:	f44f 7280 	mov.w	r2, #256	; 0x100
  RCC_OscInitStruct.HSICalibrationValue = 16;
 8000330:	2310      	movs	r3, #16
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8000332:	a806      	add	r0, sp, #24
{

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8000334:	9106      	str	r1, [sp, #24]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000336:	9209      	str	r2, [sp, #36]	; 0x24
  RCC_OscInitStruct.HSICalibrationValue = 16;
 8000338:	930a      	str	r3, [sp, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 800033a:	940f      	str	r4, [sp, #60]	; 0x3c
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 800033c:	f001 f8ba 	bl	80014b4 <HAL_RCC_OscConfig>
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);
 8000340:	4621      	mov	r1, r4
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000342:	220f      	movs	r2, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
 8000344:	2301      	movs	r3, #1
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);
 8000346:	a801      	add	r0, sp, #4
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000348:	9201      	str	r2, [sp, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
 800034a:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800034c:	9403      	str	r4, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800034e:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000350:	9405      	str	r4, [sp, #20]
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);
 8000352:	f001 fc99 	bl	8001c88 <HAL_RCC_ClockConfig>

  __PWR_CLK_ENABLE();
 8000356:	4b10      	ldr	r3, [pc, #64]	; (8000398 <SystemClock_Config+0x74>)
 8000358:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800035a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800035e:	659a      	str	r2, [r3, #88]	; 0x58
 8000360:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000362:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000366:	9300      	str	r3, [sp, #0]

  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000368:	f44f 7000 	mov.w	r0, #512	; 0x200
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);

  __PWR_CLK_ENABLE();
 800036c:	9b00      	ldr	r3, [sp, #0]

  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1);
 800036e:	f000 fc5d 	bl	8000c2c <HAL_PWREx_ControlVoltageScaling>

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8000372:	f001 fe5b 	bl	800202c <HAL_RCC_GetHCLKFreq>
 8000376:	4b09      	ldr	r3, [pc, #36]	; (800039c <SystemClock_Config+0x78>)
 8000378:	fba3 3000 	umull	r3, r0, r3, r0
 800037c:	0980      	lsrs	r0, r0, #6
 800037e:	f000 f9a9 	bl	80006d4 <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8000382:	2004      	movs	r0, #4
 8000384:	f000 fa2c 	bl	80007e0 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8000388:	4621      	mov	r1, r4
 800038a:	4622      	mov	r2, r4
 800038c:	f04f 30ff 	mov.w	r0, #4294967295
 8000390:	f000 f940 	bl	8000614 <HAL_NVIC_SetPriority>
}
 8000394:	b016      	add	sp, #88	; 0x58
 8000396:	bd10      	pop	{r4, pc}
 8000398:	40021000 	.word	0x40021000
 800039c:	10624dd3 	.word	0x10624dd3

080003a0 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80003a0:	b500      	push	{lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __SYSCFG_CLK_ENABLE();
 80003a2:	4b0b      	ldr	r3, [pc, #44]	; (80003d0 <HAL_MspInit+0x30>)
 80003a4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80003a6:	f042 0201 	orr.w	r2, r2, #1
 80003aa:	661a      	str	r2, [r3, #96]	; 0x60
 80003ac:	6e1b      	ldr	r3, [r3, #96]	; 0x60

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80003ae:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __SYSCFG_CLK_ENABLE();
 80003b0:	f003 0301 	and.w	r3, r3, #1
 80003b4:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80003b6:	2003      	movs	r0, #3
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __SYSCFG_CLK_ENABLE();
 80003b8:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80003ba:	f000 f919 	bl	80005f0 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80003be:	2100      	movs	r1, #0
 80003c0:	460a      	mov	r2, r1
 80003c2:	f04f 30ff 	mov.w	r0, #4294967295
 80003c6:	f000 f925 	bl	8000614 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80003ca:	b003      	add	sp, #12
 80003cc:	f85d fb04 	ldr.w	pc, [sp], #4
 80003d0:	40021000 	.word	0x40021000

080003d4 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80003d4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80003d6:	f000 f845 	bl	8000464 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80003da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 80003de:	f000 ba0d 	b.w	80007fc <HAL_SYSTICK_IRQHandler>
 80003e2:	bf00      	nop
/**
  * @brief  Initialize the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
 80003e4:	4770      	bx	lr
 80003e6:	bf00      	nop

080003e8 <HAL_MspDeInit>:
/**
  * @brief  DeInitialize the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
 80003e8:	4770      	bx	lr
 80003ea:	bf00      	nop

080003ec <HAL_DeInit>:
  * @brief De-initialize common part of the HAL and stop the source of time base.
  * @note This function is optional.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
 80003ec:	b510      	push	{r4, lr}
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
 80003ee:	4b09      	ldr	r3, [pc, #36]	; (8000414 <HAL_DeInit+0x28>)
 80003f0:	f04f 32ff 	mov.w	r2, #4294967295
  __HAL_RCC_APB1_RELEASE_RESET();
 80003f4:	2400      	movs	r4, #0
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
 80003f6:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_RCC_APB1_RELEASE_RESET();
 80003f8:	639c      	str	r4, [r3, #56]	; 0x38

  __HAL_RCC_APB2_FORCE_RESET();
 80003fa:	641a      	str	r2, [r3, #64]	; 0x40
  __HAL_RCC_APB2_RELEASE_RESET();
 80003fc:	641c      	str	r4, [r3, #64]	; 0x40

  __HAL_RCC_AHB1_FORCE_RESET();
 80003fe:	629a      	str	r2, [r3, #40]	; 0x28
  __HAL_RCC_AHB1_RELEASE_RESET();
 8000400:	629c      	str	r4, [r3, #40]	; 0x28

  __HAL_RCC_AHB2_FORCE_RESET();
 8000402:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_RCC_AHB2_RELEASE_RESET();
 8000404:	62dc      	str	r4, [r3, #44]	; 0x2c

  __HAL_RCC_AHB3_FORCE_RESET();
 8000406:	631a      	str	r2, [r3, #48]	; 0x30
  __HAL_RCC_AHB3_RELEASE_RESET();
 8000408:	631c      	str	r4, [r3, #48]	; 0x30

  /* De-Init the low level hardware */
  HAL_MspDeInit();
 800040a:	f7ff ffed 	bl	80003e8 <HAL_MspDeInit>

  /* Return function status */
  return HAL_OK;
}
 800040e:	4620      	mov	r0, r4
 8000410:	bd10      	pop	{r4, pc}
 8000412:	bf00      	nop
 8000414:	40021000 	.word	0x40021000

08000418 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000418:	b510      	push	{r4, lr}
 800041a:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 800041c:	f001 fe06 	bl	800202c <HAL_RCC_GetHCLKFreq>
 8000420:	4b06      	ldr	r3, [pc, #24]	; (800043c <HAL_InitTick+0x24>)
 8000422:	fba3 3000 	umull	r3, r0, r3, r0
 8000426:	0980      	lsrs	r0, r0, #6
 8000428:	f000 f954 	bl	80006d4 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 800042c:	4621      	mov	r1, r4
 800042e:	f04f 30ff 	mov.w	r0, #4294967295
 8000432:	2200      	movs	r2, #0
 8000434:	f000 f8ee 	bl	8000614 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8000438:	2000      	movs	r0, #0
 800043a:	bd10      	pop	{r4, pc}
 800043c:	10624dd3 	.word	0x10624dd3

08000440 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000440:	b508      	push	{r3, lr}
#if (DATA_CACHE_ENABLE == 0)
   __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000442:	4a07      	ldr	r2, [pc, #28]	; (8000460 <HAL_Init+0x20>)
 8000444:	6813      	ldr	r3, [r2, #0]
 8000446:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800044a:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800044c:	2003      	movs	r0, #3
 800044e:	f000 f8cf 	bl	80005f0 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000452:	2000      	movs	r0, #0
 8000454:	f7ff ffe0 	bl	8000418 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000458:	f7ff ffa2 	bl	80003a0 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 800045c:	2000      	movs	r0, #0
 800045e:	bd08      	pop	{r3, pc}
 8000460:	40022000 	.word	0x40022000

08000464 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000464:	4a02      	ldr	r2, [pc, #8]	; (8000470 <HAL_IncTick+0xc>)
 8000466:	6813      	ldr	r3, [r2, #0]
 8000468:	3301      	adds	r3, #1
 800046a:	6013      	str	r3, [r2, #0]
 800046c:	4770      	bx	lr
 800046e:	bf00      	nop
 8000470:	2000044c 	.word	0x2000044c

08000474 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000474:	4b01      	ldr	r3, [pc, #4]	; (800047c <HAL_GetTick+0x8>)
 8000476:	6818      	ldr	r0, [r3, #0]
}
 8000478:	4770      	bx	lr
 800047a:	bf00      	nop
 800047c:	2000044c 	.word	0x2000044c

08000480 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000480:	b538      	push	{r3, r4, r5, lr}
 8000482:	4605      	mov	r5, r0
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 8000484:	f7ff fff6 	bl	8000474 <HAL_GetTick>
 8000488:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 800048a:	f7ff fff3 	bl	8000474 <HAL_GetTick>
 800048e:	1b00      	subs	r0, r0, r4
 8000490:	42a8      	cmp	r0, r5
 8000492:	d3fa      	bcc.n	800048a <HAL_Delay+0xa>
  {
  }
}
 8000494:	bd38      	pop	{r3, r4, r5, pc}
 8000496:	bf00      	nop

08000498 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
 8000498:	4a02      	ldr	r2, [pc, #8]	; (80004a4 <HAL_SuspendTick+0xc>)
 800049a:	6813      	ldr	r3, [r2, #0]
 800049c:	f023 0302 	bic.w	r3, r3, #2
 80004a0:	6013      	str	r3, [r2, #0]
 80004a2:	4770      	bx	lr
 80004a4:	e000e010 	.word	0xe000e010

080004a8 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
 80004a8:	4a02      	ldr	r2, [pc, #8]	; (80004b4 <HAL_ResumeTick+0xc>)
 80004aa:	6813      	ldr	r3, [r2, #0]
 80004ac:	f043 0302 	orr.w	r3, r3, #2
 80004b0:	6013      	str	r3, [r2, #0]
 80004b2:	4770      	bx	lr
 80004b4:	e000e010 	.word	0xe000e010

080004b8 <HAL_GetHalVersion>:
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
 return __STM32L4xx_HAL_VERSION;
}
 80004b8:	4800      	ldr	r0, [pc, #0]	; (80004bc <HAL_GetHalVersion+0x4>)
 80004ba:	4770      	bx	lr
 80004bc:	01010100 	.word	0x01010100

080004c0 <HAL_GetREVID>:
  * @brief  Return the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE & DBGMCU_IDCODE_REV_ID) >> 16);
 80004c0:	4b01      	ldr	r3, [pc, #4]	; (80004c8 <HAL_GetREVID+0x8>)
 80004c2:	6818      	ldr	r0, [r3, #0]
}
 80004c4:	0c00      	lsrs	r0, r0, #16
 80004c6:	4770      	bx	lr
 80004c8:	e0042000 	.word	0xe0042000

080004cc <HAL_GetDEVID>:
  * @brief  Return the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
   return(DBGMCU->IDCODE & DBGMCU_IDCODE_DEV_ID);
 80004cc:	4b02      	ldr	r3, [pc, #8]	; (80004d8 <HAL_GetDEVID+0xc>)
 80004ce:	6818      	ldr	r0, [r3, #0]
}
 80004d0:	f3c0 000b 	ubfx	r0, r0, #0, #12
 80004d4:	4770      	bx	lr
 80004d6:	bf00      	nop
 80004d8:	e0042000 	.word	0xe0042000

080004dc <HAL_DBGMCU_EnableDBGSleepMode>:
  * @brief  Enable the Debug Module during SLEEP mode.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 80004dc:	4a02      	ldr	r2, [pc, #8]	; (80004e8 <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 80004de:	6853      	ldr	r3, [r2, #4]
 80004e0:	f043 0301 	orr.w	r3, r3, #1
 80004e4:	6053      	str	r3, [r2, #4]
 80004e6:	4770      	bx	lr
 80004e8:	e0042000 	.word	0xe0042000

080004ec <HAL_DBGMCU_DisableDBGSleepMode>:
  * @brief  Disable the Debug Module during SLEEP mode.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 80004ec:	4a02      	ldr	r2, [pc, #8]	; (80004f8 <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
 80004ee:	6853      	ldr	r3, [r2, #4]
 80004f0:	f023 0301 	bic.w	r3, r3, #1
 80004f4:	6053      	str	r3, [r2, #4]
 80004f6:	4770      	bx	lr
 80004f8:	e0042000 	.word	0xe0042000

080004fc <HAL_DBGMCU_EnableDBGStopMode>:
  * @brief  Enable the Debug Module during STOP1/STOP2 modes.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 80004fc:	4a02      	ldr	r2, [pc, #8]	; (8000508 <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 80004fe:	6853      	ldr	r3, [r2, #4]
 8000500:	f043 0302 	orr.w	r3, r3, #2
 8000504:	6053      	str	r3, [r2, #4]
 8000506:	4770      	bx	lr
 8000508:	e0042000 	.word	0xe0042000

0800050c <HAL_DBGMCU_DisableDBGStopMode>:
  * @brief  Disable the Debug Module during STOP1/STOP2 modes.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 800050c:	4a02      	ldr	r2, [pc, #8]	; (8000518 <HAL_DBGMCU_DisableDBGStopMode+0xc>)
 800050e:	6853      	ldr	r3, [r2, #4]
 8000510:	f023 0302 	bic.w	r3, r3, #2
 8000514:	6053      	str	r3, [r2, #4]
 8000516:	4770      	bx	lr
 8000518:	e0042000 	.word	0xe0042000

0800051c <HAL_DBGMCU_EnableDBGStandbyMode>:
  * @brief  Enable the Debug Module during STANDBY mode.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 800051c:	4a02      	ldr	r2, [pc, #8]	; (8000528 <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 800051e:	6853      	ldr	r3, [r2, #4]
 8000520:	f043 0304 	orr.w	r3, r3, #4
 8000524:	6053      	str	r3, [r2, #4]
 8000526:	4770      	bx	lr
 8000528:	e0042000 	.word	0xe0042000

0800052c <HAL_DBGMCU_DisableDBGStandbyMode>:
  * @brief  Disable the Debug Module during STANDBY mode.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 800052c:	4a02      	ldr	r2, [pc, #8]	; (8000538 <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
 800052e:	6853      	ldr	r3, [r2, #4]
 8000530:	f023 0304 	bic.w	r3, r3, #4
 8000534:	6053      	str	r3, [r2, #4]
 8000536:	4770      	bx	lr
 8000538:	e0042000 	.word	0xe0042000

0800053c <HAL_SYSCFG_SRAM2Erase>:
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
 800053c:	4b05      	ldr	r3, [pc, #20]	; (8000554 <HAL_SYSCFG_SRAM2Erase+0x18>)
  SYSCFG->SKR = 0x53;
  /* Starts a hardware SRAM2 erase operation*/
  *(__IO uint32_t *) SCSR_SRAM2ER_BB = (uint8_t)0x00000001;
 800053e:	4a06      	ldr	r2, [pc, #24]	; (8000558 <HAL_SYSCFG_SRAM2Erase+0x1c>)
  * @note   As long as SRAM2 is not erased the SRAM2ER bit will be set.
  *         This bit is automatically reset at the end of the SRAM2 erase operation.
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
 8000540:	b410      	push	{r4}
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
  SYSCFG->SKR = 0x53;
 8000542:	2053      	movs	r0, #83	; 0x53
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
 8000544:	24ca      	movs	r4, #202	; 0xca
  SYSCFG->SKR = 0x53;
  /* Starts a hardware SRAM2 erase operation*/
  *(__IO uint32_t *) SCSR_SRAM2ER_BB = (uint8_t)0x00000001;
 8000546:	2101      	movs	r1, #1
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
 8000548:	625c      	str	r4, [r3, #36]	; 0x24
  SYSCFG->SKR = 0x53;
 800054a:	6258      	str	r0, [r3, #36]	; 0x24
  /* Starts a hardware SRAM2 erase operation*/
  *(__IO uint32_t *) SCSR_SRAM2ER_BB = (uint8_t)0x00000001;
 800054c:	6011      	str	r1, [r2, #0]
}
 800054e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000552:	4770      	bx	lr
 8000554:	40010000 	.word	0x40010000
 8000558:	42200300 	.word	0x42200300

0800055c <HAL_SYSCFG_EnableMemorySwappingBank>:
  *
  * @retval None
  */
void HAL_SYSCFG_EnableMemorySwappingBank(void)
{
  *(__IO uint32_t *)FB_MODE_BB = (uint32_t)ENABLE;
 800055c:	4b01      	ldr	r3, [pc, #4]	; (8000564 <HAL_SYSCFG_EnableMemorySwappingBank+0x8>)
 800055e:	2201      	movs	r2, #1
 8000560:	601a      	str	r2, [r3, #0]
 8000562:	4770      	bx	lr
 8000564:	42200020 	.word	0x42200020

08000568 <HAL_SYSCFG_DisableMemorySwappingBank>:
  * @retval None
  */
void HAL_SYSCFG_DisableMemorySwappingBank(void)
{

  *(__IO uint32_t *)FB_MODE_BB = (uint32_t)DISABLE;
 8000568:	4b01      	ldr	r3, [pc, #4]	; (8000570 <HAL_SYSCFG_DisableMemorySwappingBank+0x8>)
 800056a:	2200      	movs	r2, #0
 800056c:	601a      	str	r2, [r3, #0]
 800056e:	4770      	bx	lr
 8000570:	42200020 	.word	0x42200020

08000574 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig>:
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));
  
  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
 8000574:	4a03      	ldr	r2, [pc, #12]	; (8000584 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x10>)
 8000576:	6813      	ldr	r3, [r2, #0]
 8000578:	f023 0304 	bic.w	r3, r3, #4
 800057c:	4318      	orrs	r0, r3
 800057e:	6010      	str	r0, [r2, #0]
 8000580:	4770      	bx	lr
 8000582:	bf00      	nop
 8000584:	40010030 	.word	0x40010030

08000588 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));
  
  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
 8000588:	4a03      	ldr	r2, [pc, #12]	; (8000598 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x10>)
 800058a:	6813      	ldr	r3, [r2, #0]
 800058c:	f023 0302 	bic.w	r3, r3, #2
 8000590:	4318      	orrs	r0, r3
 8000592:	6010      	str	r0, [r2, #0]
 8000594:	4770      	bx	lr
 8000596:	bf00      	nop
 8000598:	40010030 	.word	0x40010030

0800059c <HAL_SYSCFG_VREFBUF_TrimmingConfig>:
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));
  
  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
 800059c:	4a03      	ldr	r2, [pc, #12]	; (80005ac <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x10>)
 800059e:	6853      	ldr	r3, [r2, #4]
 80005a0:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80005a4:	4318      	orrs	r0, r3
 80005a6:	6050      	str	r0, [r2, #4]
 80005a8:	4770      	bx	lr
 80005aa:	bf00      	nop
 80005ac:	40010030 	.word	0x40010030

080005b0 <HAL_SYSCFG_EnableVREFBUF>:
/**
  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
  * @retval HAL_OK/HAL_TIMEOUT
  */
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
{
 80005b0:	b538      	push	{r3, r4, r5, lr}
  uint32_t  tickstart = 0;
  
  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
 80005b2:	4c0a      	ldr	r4, [pc, #40]	; (80005dc <HAL_SYSCFG_EnableVREFBUF+0x2c>)
 80005b4:	6823      	ldr	r3, [r4, #0]
 80005b6:	f043 0301 	orr.w	r3, r3, #1
 80005ba:	6023      	str	r3, [r4, #0]
  
  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80005bc:	f7ff ff5a 	bl	8000474 <HAL_GetTick>
 80005c0:	4605      	mov	r5, r0

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == RESET)
 80005c2:	e004      	b.n	80005ce <HAL_SYSCFG_EnableVREFBUF+0x1e>
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
 80005c4:	f7ff ff56 	bl	8000474 <HAL_GetTick>
 80005c8:	1b40      	subs	r0, r0, r5
 80005ca:	280a      	cmp	r0, #10
 80005cc:	d804      	bhi.n	80005d8 <HAL_SYSCFG_EnableVREFBUF+0x28>
  
  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == RESET)
 80005ce:	6823      	ldr	r3, [r4, #0]
 80005d0:	071b      	lsls	r3, r3, #28
 80005d2:	d5f7      	bpl.n	80005c4 <HAL_SYSCFG_EnableVREFBUF+0x14>
    {
      return HAL_TIMEOUT;
    }
  }
  
  return HAL_OK;
 80005d4:	2000      	movs	r0, #0
 80005d6:	bd38      	pop	{r3, r4, r5, pc}
  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == RESET)
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
 80005d8:	2003      	movs	r0, #3
    }
  }
  
  return HAL_OK;
}
 80005da:	bd38      	pop	{r3, r4, r5, pc}
 80005dc:	40010030 	.word	0x40010030

080005e0 <HAL_SYSCFG_DisableVREFBUF>:
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
 80005e0:	4a02      	ldr	r2, [pc, #8]	; (80005ec <HAL_SYSCFG_DisableVREFBUF+0xc>)
 80005e2:	6813      	ldr	r3, [r2, #0]
 80005e4:	f023 0301 	bic.w	r3, r3, #1
 80005e8:	6013      	str	r3, [r2, #0]
 80005ea:	4770      	bx	lr
 80005ec:	40010030 	.word	0x40010030

080005f0 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80005f0:	4a07      	ldr	r2, [pc, #28]	; (8000610 <HAL_NVIC_SetPriorityGrouping+0x20>)
 80005f2:	68d1      	ldr	r1, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80005f4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80005f8:	400b      	ands	r3, r1
 80005fa:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80005fe:	f000 0007 	and.w	r0, r0, #7
 8000602:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000606:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800060a:	60d3      	str	r3, [r2, #12]
 800060c:	4770      	bx	lr
 800060e:	bf00      	nop
 8000610:	e000ed00 	.word	0xe000ed00

08000614 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000614:	b430      	push	{r4, r5}

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000616:	4b18      	ldr	r3, [pc, #96]	; (8000678 <HAL_NVIC_SetPriority+0x64>)
 8000618:	68db      	ldr	r3, [r3, #12]
 800061a:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800061e:	f1c3 0507 	rsb	r5, r3, #7
 8000622:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000624:	f103 0404 	add.w	r4, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000628:	bf28      	it	cs
 800062a:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800062c:	2c06      	cmp	r4, #6
 800062e:	d917      	bls.n	8000660 <HAL_NVIC_SetPriority+0x4c>
 8000630:	3b03      	subs	r3, #3
 8000632:	2401      	movs	r4, #1
 8000634:	409c      	lsls	r4, r3
 8000636:	3c01      	subs	r4, #1
 8000638:	4022      	ands	r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800063a:	2401      	movs	r4, #1
 800063c:	40ac      	lsls	r4, r5
 800063e:	3c01      	subs	r4, #1
 8000640:	4021      	ands	r1, r4
 8000642:	4099      	lsls	r1, r3
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
 8000644:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000646:	ea42 0201 	orr.w	r2, r2, r1
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
 800064a:	db0c      	blt.n	8000666 <HAL_NVIC_SetPriority+0x52>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800064c:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000650:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000654:	0112      	lsls	r2, r2, #4
 8000656:	b2d2      	uxtb	r2, r2
 8000658:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800065c:	bc30      	pop	{r4, r5}
 800065e:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000660:	2200      	movs	r2, #0
 8000662:	4613      	mov	r3, r2
 8000664:	e7e9      	b.n	800063a <HAL_NVIC_SetPriority+0x26>
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000666:	4b05      	ldr	r3, [pc, #20]	; (800067c <HAL_NVIC_SetPriority+0x68>)
 8000668:	f000 000f 	and.w	r0, r0, #15
 800066c:	0112      	lsls	r2, r2, #4
 800066e:	4403      	add	r3, r0
 8000670:	b2d2      	uxtb	r2, r2
 8000672:	761a      	strb	r2, [r3, #24]
 8000674:	bc30      	pop	{r4, r5}
 8000676:	4770      	bx	lr
 8000678:	e000ed00 	.word	0xe000ed00
 800067c:	e000ecfc 	.word	0xe000ecfc

08000680 <HAL_NVIC_EnableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000680:	f000 011f 	and.w	r1, r0, #31
 8000684:	2301      	movs	r3, #1
 8000686:	0940      	lsrs	r0, r0, #5
 8000688:	4a02      	ldr	r2, [pc, #8]	; (8000694 <HAL_NVIC_EnableIRQ+0x14>)
 800068a:	408b      	lsls	r3, r1
 800068c:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 8000690:	4770      	bx	lr
 8000692:	bf00      	nop
 8000694:	e000e100 	.word	0xe000e100

08000698 <HAL_NVIC_DisableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000698:	0943      	lsrs	r3, r0, #5
 800069a:	3320      	adds	r3, #32
 800069c:	f000 001f 	and.w	r0, r0, #31
 80006a0:	2201      	movs	r2, #1
 80006a2:	4902      	ldr	r1, [pc, #8]	; (80006ac <HAL_NVIC_DisableIRQ+0x14>)
 80006a4:	4082      	lsls	r2, r0
 80006a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 80006aa:	4770      	bx	lr
 80006ac:	e000e100 	.word	0xe000e100

080006b0 <HAL_NVIC_SystemReset>:
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80006b0:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80006b4:	4905      	ldr	r1, [pc, #20]	; (80006cc <HAL_NVIC_SystemReset+0x1c>)
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80006b6:	4b06      	ldr	r3, [pc, #24]	; (80006d0 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80006b8:	68ca      	ldr	r2, [r1, #12]
 80006ba:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80006be:	4313      	orrs	r3, r2
 80006c0:	60cb      	str	r3, [r1, #12]
 80006c2:	f3bf 8f4f 	dsb	sy

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 80006c6:	bf00      	nop
 80006c8:	e7fd      	b.n	80006c6 <HAL_NVIC_SystemReset+0x16>
 80006ca:	bf00      	nop
 80006cc:	e000ed00 	.word	0xe000ed00
 80006d0:	05fa0004 	.word	0x05fa0004

080006d4 <HAL_SYSTICK_Config>:
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 80006d4:	3801      	subs	r0, #1
 80006d6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80006da:	d20e      	bcs.n	80006fa <HAL_SYSTICK_Config+0x26>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80006dc:	4b08      	ldr	r3, [pc, #32]	; (8000700 <HAL_SYSTICK_Config+0x2c>)
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80006de:	b410      	push	{r4}
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006e0:	4c08      	ldr	r4, [pc, #32]	; (8000704 <HAL_SYSTICK_Config+0x30>)
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80006e2:	6058      	str	r0, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80006e4:	2200      	movs	r2, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006e6:	20f0      	movs	r0, #240	; 0xf0
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80006e8:	2107      	movs	r1, #7
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006ea:	f884 0023 	strb.w	r0, [r4, #35]	; 0x23
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80006ee:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80006f0:	6019      	str	r1, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80006f2:	4610      	mov	r0, r2
   return SysTick_Config(TicksNumb);
}
 80006f4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80006f8:	4770      	bx	lr
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 80006fa:	2001      	movs	r0, #1
 80006fc:	4770      	bx	lr
 80006fe:	bf00      	nop
 8000700:	e000e010 	.word	0xe000e010
 8000704:	e000ed00 	.word	0xe000ed00

08000708 <HAL_NVIC_GetPriorityGrouping>:

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000708:	4b02      	ldr	r3, [pc, #8]	; (8000714 <HAL_NVIC_GetPriorityGrouping+0xc>)
 800070a:	68d8      	ldr	r0, [r3, #12]
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
}
 800070c:	f3c0 2002 	ubfx	r0, r0, #8, #3
 8000710:	4770      	bx	lr
 8000712:	bf00      	nop
 8000714:	e000ed00 	.word	0xe000ed00

08000718 <HAL_NVIC_GetPriority>:
                        priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if((int32_t)IRQn < 0) {
 8000718:	2800      	cmp	r0, #0
  * @param  pPreemptPriority: Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority: Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
 800071a:	b470      	push	{r4, r5, r6}
 800071c:	db23      	blt.n	8000766 <HAL_NVIC_GetPriority+0x4e>
    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
  }
  else {
    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - __NVIC_PRIO_BITS)));
 800071e:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000722:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000726:	f890 4300 	ldrb.w	r4, [r0, #768]	; 0x300
 800072a:	0924      	lsrs	r4, r4, #4
    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
    \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800072c:	f001 0107 	and.w	r1, r1, #7
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000730:	f1c1 0607 	rsb	r6, r1, #7
 8000734:	2e04      	cmp	r6, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000736:	f101 0004 	add.w	r0, r1, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800073a:	bf28      	it	cs
 800073c:	2604      	movcs	r6, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800073e:	2806      	cmp	r0, #6
 8000740:	d90e      	bls.n	8000760 <HAL_NVIC_GetPriority+0x48>
 8000742:	3903      	subs	r1, #3
 8000744:	2501      	movs	r5, #1
 8000746:	408d      	lsls	r5, r1
 8000748:	3d01      	subs	r5, #1
 800074a:	4025      	ands	r5, r4

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
 800074c:	2001      	movs	r0, #1
 800074e:	40b0      	lsls	r0, r6
 8000750:	40cc      	lsrs	r4, r1
 8000752:	3801      	subs	r0, #1
 8000754:	ea04 0100 	and.w	r1, r4, r0
 8000758:	6011      	str	r1, [r2, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
 800075a:	601d      	str	r5, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
}
 800075c:	bc70      	pop	{r4, r5, r6}
 800075e:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000760:	2500      	movs	r5, #0
 8000762:	4629      	mov	r1, r5
 8000764:	e7f2      	b.n	800074c <HAL_NVIC_GetPriority+0x34>
 */
__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if((int32_t)IRQn < 0) {
    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
 8000766:	4c03      	ldr	r4, [pc, #12]	; (8000774 <HAL_NVIC_GetPriority+0x5c>)
 8000768:	f000 000f 	and.w	r0, r0, #15
 800076c:	4404      	add	r4, r0
 800076e:	7e24      	ldrb	r4, [r4, #24]
 8000770:	0924      	lsrs	r4, r4, #4
 8000772:	e7db      	b.n	800072c <HAL_NVIC_GetPriority+0x14>
 8000774:	e000ecfc 	.word	0xe000ecfc

08000778 <HAL_NVIC_SetPendingIRQ>:

    \param [in]      IRQn  Interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000778:	0943      	lsrs	r3, r0, #5
 800077a:	3340      	adds	r3, #64	; 0x40
 800077c:	f000 001f 	and.w	r0, r0, #31
 8000780:	2201      	movs	r2, #1
 8000782:	4902      	ldr	r1, [pc, #8]	; (800078c <HAL_NVIC_SetPendingIRQ+0x14>)
 8000784:	4082      	lsls	r2, r0
 8000786:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 800078a:	4770      	bx	lr
 800078c:	e000e100 	.word	0xe000e100

08000790 <HAL_NVIC_GetPendingIRQ>:
    \return             0  Interrupt status is not pending.
    \return             1  Interrupt status is pending.
 */
__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 8000790:	0943      	lsrs	r3, r0, #5
 8000792:	3340      	adds	r3, #64	; 0x40
 8000794:	4a04      	ldr	r2, [pc, #16]	; (80007a8 <HAL_NVIC_GetPendingIRQ+0x18>)
 8000796:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800079a:	f000 031f 	and.w	r3, r0, #31
 800079e:	fa22 f003 	lsr.w	r0, r2, r3
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
}
 80007a2:	f000 0001 	and.w	r0, r0, #1
 80007a6:	4770      	bx	lr
 80007a8:	e000e100 	.word	0xe000e100

080007ac <HAL_NVIC_ClearPendingIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80007ac:	0943      	lsrs	r3, r0, #5
 80007ae:	3360      	adds	r3, #96	; 0x60
 80007b0:	f000 001f 	and.w	r0, r0, #31
 80007b4:	2201      	movs	r2, #1
 80007b6:	4902      	ldr	r1, [pc, #8]	; (80007c0 <HAL_NVIC_ClearPendingIRQ+0x14>)
 80007b8:	4082      	lsls	r2, r0
 80007ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 80007be:	4770      	bx	lr
 80007c0:	e000e100 	.word	0xe000e100

080007c4 <HAL_NVIC_GetActive>:
    \return             0  Interrupt status is not active.
    \return             1  Interrupt status is active.
 */
__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
{
  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 80007c4:	0943      	lsrs	r3, r0, #5
 80007c6:	3380      	adds	r3, #128	; 0x80
 80007c8:	4a04      	ldr	r2, [pc, #16]	; (80007dc <HAL_NVIC_GetActive+0x18>)
 80007ca:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80007ce:	f000 031f 	and.w	r3, r0, #31
 80007d2:	fa22 f003 	lsr.w	r0, r2, r3
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
}
 80007d6:	f000 0001 	and.w	r0, r0, #1
 80007da:	4770      	bx	lr
 80007dc:	e000e100 	.word	0xe000e100

080007e0 <HAL_SYSTICK_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80007e0:	4a04      	ldr	r2, [pc, #16]	; (80007f4 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 80007e2:	6813      	ldr	r3, [r2, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 80007e4:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80007e6:	bf0c      	ite	eq
 80007e8:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 80007ec:	f023 0304 	bicne.w	r3, r3, #4
 80007f0:	6013      	str	r3, [r2, #0]
 80007f2:	4770      	bx	lr
 80007f4:	e000e010 	.word	0xe000e010

080007f8 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 80007f8:	4770      	bx	lr
 80007fa:	bf00      	nop

080007fc <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  Handle SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 80007fc:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 80007fe:	f7ff fffb 	bl	80007f8 <HAL_SYSTICK_Callback>
 8000802:	bd08      	pop	{r3, pc}

08000804 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init: Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 8000804:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 8000808:	4d14      	ldr	r5, [pc, #80]	; (800085c <HAL_MPU_ConfigRegion+0x58>)
 800080a:	7843      	ldrb	r3, [r0, #1]
 800080c:	60ab      	str	r3, [r5, #8]

  if ((MPU_Init->Enable) != RESET)
 800080e:	7803      	ldrb	r3, [r0, #0]
 8000810:	b91b      	cbnz	r3, 800081a <HAL_MPU_ConfigRegion+0x16>
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable             << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00;
 8000812:	60eb      	str	r3, [r5, #12]
    MPU->RASR = 0x00;
 8000814:	612b      	str	r3, [r5, #16]
 8000816:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
 800081a:	6843      	ldr	r3, [r0, #4]
 800081c:	60eb      	str	r3, [r5, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
 800081e:	7ac6      	ldrb	r6, [r0, #11]
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
 8000820:	f890 800c 	ldrb.w	r8, [r0, #12]
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
 8000824:	7b42      	ldrb	r2, [r0, #13]
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
 8000826:	7bc3      	ldrb	r3, [r0, #15]
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable             << MPU_RASR_ENABLE_Pos);
 8000828:	7804      	ldrb	r4, [r0, #0]
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
 800082a:	7a81      	ldrb	r1, [r0, #10]
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
 800082c:	f890 c00e 	ldrb.w	ip, [r0, #14]
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
 8000830:	f890 e009 	ldrb.w	lr, [r0, #9]
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
 8000834:	7a07      	ldrb	r7, [r0, #8]
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
 8000836:	0630      	lsls	r0, r6, #24
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
 8000838:	ea40 7008 	orr.w	r0, r0, r8, lsl #28
 800083c:	4320      	orrs	r0, r4
 800083e:	ea40 41c1 	orr.w	r1, r0, r1, lsl #19
 8000842:	ea41 4182 	orr.w	r1, r1, r2, lsl #18
 8000846:	ea41 424c 	orr.w	r2, r1, ip, lsl #17
 800084a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 800084e:	ea42 230e 	orr.w	r3, r2, lr, lsl #8
                ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
 8000852:	ea43 0347 	orr.w	r3, r3, r7, lsl #1
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
 8000856:	612b      	str	r3, [r5, #16]
 8000858:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800085c:	e000ed90 	.word	0xe000ed90

08000860 <HAL_GPIO_Init>:
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000860:	680b      	ldr	r3, [r1, #0]
 8000862:	2b00      	cmp	r3, #0
 8000864:	f000 80e9 	beq.w	8000a3a <HAL_GPIO_Init+0x1da>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000868:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 800086c:	f04f 0800 	mov.w	r8, #0
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000870:	b082      	sub	sp, #8
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000872:	f8df c1e4 	ldr.w	ip, [pc, #484]	; 8000a58 <HAL_GPIO_Init+0x1f8>
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8000876:	4f71      	ldr	r7, [pc, #452]	; (8000a3c <HAL_GPIO_Init+0x1dc>)
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000878:	4644      	mov	r4, r8
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 800087a:	f04f 0e01 	mov.w	lr, #1
 800087e:	e06b      	b.n	8000958 <HAL_GPIO_Init+0xf8>
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
        GPIOx->ASCR = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8000880:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000882:	688a      	ldr	r2, [r1, #8]
        GPIOx->ASCR = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8000884:	402b      	ands	r3, r5
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000886:	40b2      	lsls	r2, r6
 8000888:	431a      	orrs	r2, r3
      GPIOx->PUPDR = temp;
 800088a:	60c2      	str	r2, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800088c:	684b      	ldr	r3, [r1, #4]
 800088e:	00db      	lsls	r3, r3, #3
 8000890:	d55c      	bpl.n	800094c <HAL_GPIO_Init+0xec>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000892:	f8dc 3060 	ldr.w	r3, [ip, #96]	; 0x60
 8000896:	f043 0301 	orr.w	r3, r3, #1
 800089a:	f8cc 3060 	str.w	r3, [ip, #96]	; 0x60
 800089e:	f8dc 2060 	ldr.w	r2, [ip, #96]	; 0x60
 80008a2:	f024 0303 	bic.w	r3, r4, #3
 80008a6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80008aa:	f002 0201 	and.w	r2, r2, #1
 80008ae:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 80008b2:	9201      	str	r2, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80008b4:	f004 0203 	and.w	r2, r4, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80008b8:	9d01      	ldr	r5, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2];
 80008ba:	689e      	ldr	r6, [r3, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80008bc:	0092      	lsls	r2, r2, #2
 80008be:	250f      	movs	r5, #15
 80008c0:	4095      	lsls	r5, r2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80008c2:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80008c6:	ea26 0505 	bic.w	r5, r6, r5
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80008ca:	f000 80a1 	beq.w	8000a10 <HAL_GPIO_Init+0x1b0>
 80008ce:	4e5c      	ldr	r6, [pc, #368]	; (8000a40 <HAL_GPIO_Init+0x1e0>)
 80008d0:	42b0      	cmp	r0, r6
 80008d2:	f000 809f 	beq.w	8000a14 <HAL_GPIO_Init+0x1b4>
 80008d6:	4e5b      	ldr	r6, [pc, #364]	; (8000a44 <HAL_GPIO_Init+0x1e4>)
 80008d8:	42b0      	cmp	r0, r6
 80008da:	f000 809e 	beq.w	8000a1a <HAL_GPIO_Init+0x1ba>
 80008de:	4e5a      	ldr	r6, [pc, #360]	; (8000a48 <HAL_GPIO_Init+0x1e8>)
 80008e0:	42b0      	cmp	r0, r6
 80008e2:	f000 809e 	beq.w	8000a22 <HAL_GPIO_Init+0x1c2>
 80008e6:	4e59      	ldr	r6, [pc, #356]	; (8000a4c <HAL_GPIO_Init+0x1ec>)
 80008e8:	42b0      	cmp	r0, r6
 80008ea:	f000 809e 	beq.w	8000a2a <HAL_GPIO_Init+0x1ca>
 80008ee:	4e58      	ldr	r6, [pc, #352]	; (8000a50 <HAL_GPIO_Init+0x1f0>)
 80008f0:	42b0      	cmp	r0, r6
 80008f2:	f000 809e 	beq.w	8000a32 <HAL_GPIO_Init+0x1d2>
 80008f6:	4e57      	ldr	r6, [pc, #348]	; (8000a54 <HAL_GPIO_Init+0x1f4>)
 80008f8:	42b0      	cmp	r0, r6
 80008fa:	bf0c      	ite	eq
 80008fc:	2606      	moveq	r6, #6
 80008fe:	2607      	movne	r6, #7
 8000900:	fa06 f202 	lsl.w	r2, r6, r2
 8000904:	432a      	orrs	r2, r5
        SYSCFG->EXTICR[position >> 2] = temp;
 8000906:	609a      	str	r2, [r3, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000908:	684b      	ldr	r3, [r1, #4]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 800090a:	683a      	ldr	r2, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 800090c:	ea6f 0509 	mvn.w	r5, r9
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000910:	03de      	lsls	r6, r3, #15
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
 8000912:	bf54      	ite	pl
 8000914:	402a      	andpl	r2, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8000916:	ea49 0202 	orrmi.w	r2, r9, r2
        }
        EXTI->IMR1 = temp;
 800091a:	603a      	str	r2, [r7, #0]

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800091c:	684b      	ldr	r3, [r1, #4]
        {
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
 800091e:	687a      	ldr	r2, [r7, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000920:	039b      	lsls	r3, r3, #14
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
 8000922:	bf54      	ite	pl
 8000924:	402a      	andpl	r2, r5
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8000926:	ea49 0202 	orrmi.w	r2, r9, r2
        }
        EXTI->EMR1 = temp;
 800092a:	607a      	str	r2, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800092c:	684b      	ldr	r3, [r1, #4]
          temp |= iocurrent;
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 800092e:	68ba      	ldr	r2, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000930:	02de      	lsls	r6, r3, #11
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
 8000932:	bf54      	ite	pl
 8000934:	402a      	andpl	r2, r5
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8000936:	ea49 0202 	orrmi.w	r2, r9, r2
        }
        EXTI->RTSR1 = temp;
 800093a:	60ba      	str	r2, [r7, #8]

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800093c:	684a      	ldr	r2, [r1, #4]
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
 800093e:	68fb      	ldr	r3, [r7, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000940:	0292      	lsls	r2, r2, #10
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
 8000942:	bf54      	ite	pl
 8000944:	402b      	andpl	r3, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8000946:	ea49 0303 	orrmi.w	r3, r9, r3
        }
        EXTI->FTSR1 = temp;
 800094a:	60fb      	str	r3, [r7, #12]
 800094c:	680b      	ldr	r3, [r1, #0]
      }
    }
    
    position++;
 800094e:	3401      	adds	r4, #1
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000950:	fa33 f204 	lsrs.w	r2, r3, r4
 8000954:	46a0      	mov	r8, r4
 8000956:	d058      	beq.n	8000a0a <HAL_GPIO_Init+0x1aa>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000958:	fa0e f508 	lsl.w	r5, lr, r8

    if(iocurrent)
 800095c:	ea13 0905 	ands.w	r9, r3, r5
 8000960:	d0f5      	beq.n	800094e <HAL_GPIO_Init+0xee>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000962:	684a      	ldr	r2, [r1, #4]
 8000964:	f022 0310 	bic.w	r3, r2, #16
 8000968:	2b02      	cmp	r3, #2
 800096a:	d112      	bne.n	8000992 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 800096c:	08e6      	lsrs	r6, r4, #3
 800096e:	eb00 0686 	add.w	r6, r0, r6, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000972:	f004 0207 	and.w	r2, r4, #7
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8000976:	6a33      	ldr	r3, [r6, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000978:	0092      	lsls	r2, r2, #2
 800097a:	f04f 0a0f 	mov.w	sl, #15
 800097e:	fa0a fa02 	lsl.w	sl, sl, r2
 8000982:	ea23 0a0a 	bic.w	sl, r3, sl
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000986:	690b      	ldr	r3, [r1, #16]
 8000988:	4093      	lsls	r3, r2
 800098a:	ea4a 0303 	orr.w	r3, sl, r3
        GPIOx->AFR[position >> 3] = temp;
 800098e:	6233      	str	r3, [r6, #32]
 8000990:	684a      	ldr	r2, [r1, #4]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8000992:	f8d0 a000 	ldr.w	sl, [r0]
 8000996:	0066      	lsls	r6, r4, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000998:	2303      	movs	r3, #3
 800099a:	40b3      	lsls	r3, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800099c:	f002 0203 	and.w	r2, r2, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80009a0:	43db      	mvns	r3, r3
 80009a2:	ea03 0a0a 	and.w	sl, r3, sl
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80009a6:	40b2      	lsls	r2, r6
 80009a8:	ea42 020a 	orr.w	r2, r2, sl
      GPIOx->MODER = temp;
 80009ac:	6002      	str	r2, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80009ae:	684a      	ldr	r2, [r1, #4]
 80009b0:	f022 0a10 	bic.w	sl, r2, #16
 80009b4:	f10a 3aff 	add.w	sl, sl, #4294967295
 80009b8:	f1ba 0f01 	cmp.w	sl, #1
 80009bc:	d814      	bhi.n	80009e8 <HAL_GPIO_Init+0x188>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 80009be:	6882      	ldr	r2, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80009c0:	ea03 0a02 	and.w	sl, r3, r2
        temp |= (GPIO_Init->Speed << (position * 2));
 80009c4:	68ca      	ldr	r2, [r1, #12]
 80009c6:	40b2      	lsls	r2, r6
 80009c8:	ea4a 0202 	orr.w	r2, sl, r2
        GPIOx->OSPEEDR = temp;
 80009cc:	6082      	str	r2, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 80009ce:	684a      	ldr	r2, [r1, #4]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
        temp |= (GPIO_Init->Speed << (position * 2));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80009d0:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 80009d4:	f3c2 1200 	ubfx	r2, r2, #4, #1
 80009d8:	fa02 f208 	lsl.w	r2, r2, r8
        temp |= (GPIO_Init->Speed << (position * 2));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80009dc:	ea2a 0a05 	bic.w	sl, sl, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 80009e0:	ea4a 0202 	orr.w	r2, sl, r2
        GPIOx->OTYPER = temp;
 80009e4:	6042      	str	r2, [r0, #4]
 80009e6:	684a      	ldr	r2, [r1, #4]
      }

      /* In case of Analog mode, check if ADC control mode is selected */
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
 80009e8:	f002 0a03 	and.w	sl, r2, #3
 80009ec:	f1ba 0f03 	cmp.w	sl, #3
 80009f0:	f47f af46 	bne.w	8000880 <HAL_GPIO_Init+0x20>
      {
        /* Configure the IO Output Type */
        temp = GPIOx->ASCR;
 80009f4:	f8d0 a02c 	ldr.w	sl, [r0, #44]	; 0x2c
        temp &= ~(GPIO_ASCR_EN_0 << position) ;
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 80009f8:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 80009fc:	fa02 f208 	lsl.w	r2, r2, r8
      /* In case of Analog mode, check if ADC control mode is selected */
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
      {
        /* Configure the IO Output Type */
        temp = GPIOx->ASCR;
        temp &= ~(GPIO_ASCR_EN_0 << position) ;
 8000a00:	ea2a 0505 	bic.w	r5, sl, r5
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 8000a04:	432a      	orrs	r2, r5
        GPIOx->ASCR = temp;
 8000a06:	62c2      	str	r2, [r0, #44]	; 0x2c
 8000a08:	e73a      	b.n	8000880 <HAL_GPIO_Init+0x20>
      }
    }
    
    position++;
  }
}
 8000a0a:	b002      	add	sp, #8
 8000a0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000a10:	2200      	movs	r2, #0
 8000a12:	e777      	b.n	8000904 <HAL_GPIO_Init+0xa4>
 8000a14:	fa0e f202 	lsl.w	r2, lr, r2
 8000a18:	e774      	b.n	8000904 <HAL_GPIO_Init+0xa4>
 8000a1a:	2602      	movs	r6, #2
 8000a1c:	fa06 f202 	lsl.w	r2, r6, r2
 8000a20:	e770      	b.n	8000904 <HAL_GPIO_Init+0xa4>
 8000a22:	2603      	movs	r6, #3
 8000a24:	fa06 f202 	lsl.w	r2, r6, r2
 8000a28:	e76c      	b.n	8000904 <HAL_GPIO_Init+0xa4>
 8000a2a:	2604      	movs	r6, #4
 8000a2c:	fa06 f202 	lsl.w	r2, r6, r2
 8000a30:	e768      	b.n	8000904 <HAL_GPIO_Init+0xa4>
 8000a32:	2605      	movs	r6, #5
 8000a34:	fa06 f202 	lsl.w	r2, r6, r2
 8000a38:	e764      	b.n	8000904 <HAL_GPIO_Init+0xa4>
 8000a3a:	4770      	bx	lr
 8000a3c:	40010400 	.word	0x40010400
 8000a40:	48000400 	.word	0x48000400
 8000a44:	48000800 	.word	0x48000800
 8000a48:	48000c00 	.word	0x48000c00
 8000a4c:	48001000 	.word	0x48001000
 8000a50:	48001400 	.word	0x48001400
 8000a54:	48001800 	.word	0x48001800
 8000a58:	40021000 	.word	0x40021000

08000a5c <HAL_GPIO_DeInit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8000a5c:	2900      	cmp	r1, #0
 8000a5e:	f000 8099 	beq.w	8000b94 <HAL_GPIO_DeInit+0x138>
 8000a62:	2300      	movs	r3, #0
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8000a64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8000a68:	461a      	mov	r2, r3
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 8000a6a:	f8df 8140 	ldr.w	r8, [pc, #320]	; 8000bac <HAL_GPIO_DeInit+0x150>
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8000a6e:	f8df b140 	ldr.w	fp, [pc, #320]	; 8000bb0 <HAL_GPIO_DeInit+0x154>

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
 8000a72:	f04f 0901 	mov.w	r9, #1

    if (iocurrent)
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
 8000a76:	f04f 0a03 	mov.w	sl, #3
 8000a7a:	e004      	b.n	8000a86 <HAL_GPIO_DeInit+0x2a>
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
      }
    }
    
    position++;
 8000a7c:	3201      	adds	r2, #1
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8000a7e:	fa31 f402 	lsrs.w	r4, r1, r2
 8000a82:	4613      	mov	r3, r2
 8000a84:	d070      	beq.n	8000b68 <HAL_GPIO_DeInit+0x10c>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
 8000a86:	fa09 f303 	lsl.w	r3, r9, r3

    if (iocurrent)
 8000a8a:	ea11 0e03 	ands.w	lr, r1, r3
 8000a8e:	d0f5      	beq.n	8000a7c <HAL_GPIO_DeInit+0x20>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
 8000a90:	6806      	ldr	r6, [r0, #0]
 8000a92:	0054      	lsls	r4, r2, #1
 8000a94:	fa0a f504 	lsl.w	r5, sl, r4

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000a98:	08d4      	lsrs	r4, r2, #3

    if (iocurrent)
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
 8000a9a:	432e      	orrs	r6, r5
 8000a9c:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8000aa0:	6006      	str	r6, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000aa2:	f002 0607 	and.w	r6, r2, #7
 8000aa6:	f8d4 c020 	ldr.w	ip, [r4, #32]
 8000aaa:	270f      	movs	r7, #15
 8000aac:	00b6      	lsls	r6, r6, #2
 8000aae:	fa07 f606 	lsl.w	r6, r7, r6
 8000ab2:	ea2c 0606 	bic.w	r6, ip, r6
 8000ab6:	6226      	str	r6, [r4, #32]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000ab8:	6884      	ldr	r4, [r0, #8]
 8000aba:	43ed      	mvns	r5, r5
 8000abc:	402c      	ands	r4, r5
 8000abe:	6084      	str	r4, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000ac0:	6844      	ldr	r4, [r0, #4]
 8000ac2:	43db      	mvns	r3, r3
 8000ac4:	401c      	ands	r4, r3
 8000ac6:	6044      	str	r4, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8000ac8:	68c4      	ldr	r4, [r0, #12]
 8000aca:	4025      	ands	r5, r4
 8000acc:	60c5      	str	r5, [r0, #12]

      /* Deactivate the Control bit of Analog mode for the current IO */
      GPIOx->ASCR &= ~(GPIO_ASCR_EN_0<< position);
 8000ace:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 8000ad0:	f022 0403 	bic.w	r4, r2, #3
 8000ad4:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8000ad8:	402b      	ands	r3, r5
 8000ada:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
 8000ade:	62c3      	str	r3, [r0, #44]	; 0x2c

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000ae0:	f002 0303 	and.w	r3, r2, #3
      GPIOx->ASCR &= ~(GPIO_ASCR_EN_0<< position);

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
 8000ae4:	68a5      	ldr	r5, [r4, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000ae6:	009b      	lsls	r3, r3, #2
 8000ae8:	409f      	lsls	r7, r3
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8000aea:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000aee:	ea05 0507 	and.w	r5, r5, r7
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8000af2:	d03b      	beq.n	8000b6c <HAL_GPIO_DeInit+0x110>
 8000af4:	4558      	cmp	r0, fp
 8000af6:	d03b      	beq.n	8000b70 <HAL_GPIO_DeInit+0x114>
 8000af8:	4e27      	ldr	r6, [pc, #156]	; (8000b98 <HAL_GPIO_DeInit+0x13c>)
 8000afa:	42b0      	cmp	r0, r6
 8000afc:	d03b      	beq.n	8000b76 <HAL_GPIO_DeInit+0x11a>
 8000afe:	4e27      	ldr	r6, [pc, #156]	; (8000b9c <HAL_GPIO_DeInit+0x140>)
 8000b00:	42b0      	cmp	r0, r6
 8000b02:	d03c      	beq.n	8000b7e <HAL_GPIO_DeInit+0x122>
 8000b04:	4e26      	ldr	r6, [pc, #152]	; (8000ba0 <HAL_GPIO_DeInit+0x144>)
 8000b06:	42b0      	cmp	r0, r6
 8000b08:	d03c      	beq.n	8000b84 <HAL_GPIO_DeInit+0x128>
 8000b0a:	4e26      	ldr	r6, [pc, #152]	; (8000ba4 <HAL_GPIO_DeInit+0x148>)
 8000b0c:	42b0      	cmp	r0, r6
 8000b0e:	d03d      	beq.n	8000b8c <HAL_GPIO_DeInit+0x130>
 8000b10:	4e25      	ldr	r6, [pc, #148]	; (8000ba8 <HAL_GPIO_DeInit+0x14c>)
 8000b12:	42b0      	cmp	r0, r6
 8000b14:	bf0c      	ite	eq
 8000b16:	2606      	moveq	r6, #6
 8000b18:	2607      	movne	r6, #7
 8000b1a:	fa06 f303 	lsl.w	r3, r6, r3
 8000b1e:	429d      	cmp	r5, r3
 8000b20:	d1ac      	bne.n	8000a7c <HAL_GPIO_DeInit+0x20>
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 8000b22:	68a3      	ldr	r3, [r4, #8]
 8000b24:	ea23 0707 	bic.w	r7, r3, r7
 8000b28:	60a7      	str	r7, [r4, #8]

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 8000b2a:	f8d8 3000 	ldr.w	r3, [r8]
 8000b2e:	ea6f 0e0e 	mvn.w	lr, lr
 8000b32:	ea0e 0303 	and.w	r3, lr, r3
 8000b36:	f8c8 3000 	str.w	r3, [r8]
        EXTI->EMR1 &= ~((uint32_t)iocurrent);
 8000b3a:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8000b3e:	ea0e 0303 	and.w	r3, lr, r3
 8000b42:	f8c8 3004 	str.w	r3, [r8, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
 8000b46:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8000b4a:	ea0e 0303 	and.w	r3, lr, r3
 8000b4e:	f8c8 3008 	str.w	r3, [r8, #8]
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 8000b52:	f8d8 300c 	ldr.w	r3, [r8, #12]
      }
    }
    
    position++;
 8000b56:	3201      	adds	r2, #1
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
        EXTI->EMR1 &= ~((uint32_t)iocurrent);

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 8000b58:	ea0e 0303 	and.w	r3, lr, r3
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8000b5c:	fa31 f402 	lsrs.w	r4, r1, r2
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
        EXTI->EMR1 &= ~((uint32_t)iocurrent);

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 8000b60:	f8c8 300c 	str.w	r3, [r8, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8000b64:	4613      	mov	r3, r2
 8000b66:	d18e      	bne.n	8000a86 <HAL_GPIO_DeInit+0x2a>
 8000b68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000b6c:	2300      	movs	r3, #0
 8000b6e:	e7d6      	b.n	8000b1e <HAL_GPIO_DeInit+0xc2>
 8000b70:	fa09 f303 	lsl.w	r3, r9, r3
 8000b74:	e7d3      	b.n	8000b1e <HAL_GPIO_DeInit+0xc2>
 8000b76:	2602      	movs	r6, #2
 8000b78:	fa06 f303 	lsl.w	r3, r6, r3
 8000b7c:	e7cf      	b.n	8000b1e <HAL_GPIO_DeInit+0xc2>
 8000b7e:	fa0a f303 	lsl.w	r3, sl, r3
 8000b82:	e7cc      	b.n	8000b1e <HAL_GPIO_DeInit+0xc2>
 8000b84:	2604      	movs	r6, #4
 8000b86:	fa06 f303 	lsl.w	r3, r6, r3
 8000b8a:	e7c8      	b.n	8000b1e <HAL_GPIO_DeInit+0xc2>
 8000b8c:	2605      	movs	r6, #5
 8000b8e:	fa06 f303 	lsl.w	r3, r6, r3
 8000b92:	e7c4      	b.n	8000b1e <HAL_GPIO_DeInit+0xc2>
 8000b94:	4770      	bx	lr
 8000b96:	bf00      	nop
 8000b98:	48000800 	.word	0x48000800
 8000b9c:	48000c00 	.word	0x48000c00
 8000ba0:	48001000 	.word	0x48001000
 8000ba4:	48001400 	.word	0x48001400
 8000ba8:	48001800 	.word	0x48001800
 8000bac:	40010400 	.word	0x40010400
 8000bb0:	48000400 	.word	0x48000400

08000bb4 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8000bb4:	6903      	ldr	r3, [r0, #16]
 8000bb6:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8000bb8:	bf14      	ite	ne
 8000bba:	2001      	movne	r0, #1
 8000bbc:	2000      	moveq	r0, #0
 8000bbe:	4770      	bx	lr

08000bc0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8000bc0:	b90a      	cbnz	r2, 8000bc6 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8000bc2:	6281      	str	r1, [r0, #40]	; 0x28
 8000bc4:	4770      	bx	lr
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8000bc6:	6181      	str	r1, [r0, #24]
 8000bc8:	4770      	bx	lr
 8000bca:	bf00      	nop

08000bcc <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8000bcc:	6943      	ldr	r3, [r0, #20]
 8000bce:	4059      	eors	r1, r3
 8000bd0:	6141      	str	r1, [r0, #20]
 8000bd2:	4770      	bx	lr

08000bd4 <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bits to be locked.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8000bd4:	b082      	sub	sp, #8
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
 8000bd6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000bda:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
 8000bdc:	9b01      	ldr	r3, [sp, #4]
 8000bde:	430b      	orrs	r3, r1
 8000be0:	9301      	str	r3, [sp, #4]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 8000be2:	9b01      	ldr	r3, [sp, #4]
 8000be4:	61c3      	str	r3, [r0, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
 8000be6:	61c1      	str	r1, [r0, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 8000be8:	9b01      	ldr	r3, [sp, #4]
 8000bea:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8000bec:	69c3      	ldr	r3, [r0, #28]
 8000bee:	9301      	str	r3, [sp, #4]

  if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
 8000bf0:	69c0      	ldr	r0, [r0, #28]
 8000bf2:	f480 3080 	eor.w	r0, r0, #65536	; 0x10000
  }
  else
  {
    return HAL_ERROR;
  }
}
 8000bf6:	f3c0 4000 	ubfx	r0, r0, #16, #1
 8000bfa:	b002      	add	sp, #8
 8000bfc:	4770      	bx	lr
 8000bfe:	bf00      	nop

08000c00 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 8000c00:	4770      	bx	lr
 8000c02:	bf00      	nop

08000c04 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8000c04:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 8000c06:	4a04      	ldr	r2, [pc, #16]	; (8000c18 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 8000c08:	6951      	ldr	r1, [r2, #20]
 8000c0a:	4208      	tst	r0, r1
 8000c0c:	d002      	beq.n	8000c14 <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8000c0e:	6150      	str	r0, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8000c10:	f7ff fff6 	bl	8000c00 <HAL_GPIO_EXTI_Callback>
 8000c14:	bd08      	pop	{r3, pc}
 8000c16:	bf00      	nop
 8000c18:	40010400 	.word	0x40010400

08000c1c <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return  (PWR->CR1 & PWR_CR1_VOS);
 8000c1c:	4b02      	ldr	r3, [pc, #8]	; (8000c28 <HAL_PWREx_GetVoltageRange+0xc>)
 8000c1e:	6818      	ldr	r0, [r3, #0]
}
 8000c20:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8000c24:	4770      	bx	lr
 8000c26:	bf00      	nop
 8000c28:	40007000 	.word	0x40007000

08000c2c <HAL_PWREx_ControlVoltageScaling>:
  uint32_t wait_loop_index = 0;  

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8000c2c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8000c30:	d00e      	beq.n	8000c50 <HAL_PWREx_ControlVoltageScaling+0x24>
      }
    }
  }
  else
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 8000c32:	4a1b      	ldr	r2, [pc, #108]	; (8000ca0 <HAL_PWREx_ControlVoltageScaling+0x74>)
 8000c34:	6813      	ldr	r3, [r2, #0]
 8000c36:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8000c3a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000c3e:	d02c      	beq.n	8000c9a <HAL_PWREx_ControlVoltageScaling+0x6e>
    {
      /* Set Range 2 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8000c40:	6813      	ldr	r3, [r2, #0]
 8000c42:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8000c46:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000c4a:	6013      	str	r3, [r2, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
  
  return HAL_OK;
 8000c4c:	2000      	movs	r0, #0
 8000c4e:	4770      	bx	lr
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8000c50:	4913      	ldr	r1, [pc, #76]	; (8000ca0 <HAL_PWREx_ControlVoltageScaling+0x74>)
 8000c52:	680b      	ldr	r3, [r1, #0]
 8000c54:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8000c58:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000c5c:	d01d      	beq.n	8000c9a <HAL_PWREx_ControlVoltageScaling+0x6e>
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8000c5e:	6808      	ldr	r0, [r1, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 8000c60:	4b10      	ldr	r3, [pc, #64]	; (8000ca4 <HAL_PWREx_ControlVoltageScaling+0x78>)
 8000c62:	4a11      	ldr	r2, [pc, #68]	; (8000ca8 <HAL_PWREx_ControlVoltageScaling+0x7c>)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8000c64:	f420 60c0 	bic.w	r0, r0, #1536	; 0x600
 8000c68:	f440 7000 	orr.w	r0, r0, #512	; 0x200
 8000c6c:	6008      	str	r0, [r1, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 8000c6e:	681b      	ldr	r3, [r3, #0]
 8000c70:	fba2 2303 	umull	r2, r3, r2, r3
 8000c74:	0c9a      	lsrs	r2, r3, #18
 8000c76:	2332      	movs	r3, #50	; 0x32
 8000c78:	fb03 f302 	mul.w	r3, r3, r2
      while ((wait_loop_index != 0) && (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)))
 8000c7c:	b913      	cbnz	r3, 8000c84 <HAL_PWREx_ControlVoltageScaling+0x58>
 8000c7e:	e004      	b.n	8000c8a <HAL_PWREx_ControlVoltageScaling+0x5e>
 8000c80:	3b01      	subs	r3, #1
 8000c82:	d002      	beq.n	8000c8a <HAL_PWREx_ControlVoltageScaling+0x5e>
 8000c84:	694a      	ldr	r2, [r1, #20]
 8000c86:	0552      	lsls	r2, r2, #21
 8000c88:	d4fa      	bmi.n	8000c80 <HAL_PWREx_ControlVoltageScaling+0x54>
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8000c8a:	4b05      	ldr	r3, [pc, #20]	; (8000ca0 <HAL_PWREx_ControlVoltageScaling+0x74>)
 8000c8c:	695b      	ldr	r3, [r3, #20]
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
  
  return HAL_OK;
 8000c8e:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8000c92:	bf14      	ite	ne
 8000c94:	2003      	movne	r0, #3
 8000c96:	2000      	moveq	r0, #0
 8000c98:	4770      	bx	lr
 8000c9a:	2000      	movs	r0, #0
}  
 8000c9c:	4770      	bx	lr
 8000c9e:	bf00      	nop
 8000ca0:	40007000 	.word	0x40007000
 8000ca4:	20000000 	.word	0x20000000
 8000ca8:	431bde83 	.word	0x431bde83

08000cac <HAL_PWREx_EnableBatteryCharging>:
void HAL_PWREx_EnableBatteryCharging(uint32_t ResistorSelection)
{
  assert_param(IS_PWR_BATTERY_RESISTOR_SELECT(ResistorSelection));
  
  /* Specify resistor selection */
  MODIFY_REG(PWR->CR4, PWR_CR4_VBRS, ResistorSelection);
 8000cac:	4a05      	ldr	r2, [pc, #20]	; (8000cc4 <HAL_PWREx_EnableBatteryCharging+0x18>)
 8000cae:	68d3      	ldr	r3, [r2, #12]
 8000cb0:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000cb4:	4318      	orrs	r0, r3
 8000cb6:	60d0      	str	r0, [r2, #12]
  
  /* Enable battery charging */
  SET_BIT(PWR->CR4, PWR_CR4_VBE);
 8000cb8:	68d3      	ldr	r3, [r2, #12]
 8000cba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000cbe:	60d3      	str	r3, [r2, #12]
 8000cc0:	4770      	bx	lr
 8000cc2:	bf00      	nop
 8000cc4:	40007000 	.word	0x40007000

08000cc8 <HAL_PWREx_DisableBatteryCharging>:
  * @brief Disable battery charging.  
  * @retval None
  */
void HAL_PWREx_DisableBatteryCharging(void)
{
  CLEAR_BIT(PWR->CR4, PWR_CR4_VBE); 
 8000cc8:	4a02      	ldr	r2, [pc, #8]	; (8000cd4 <HAL_PWREx_DisableBatteryCharging+0xc>)
 8000cca:	68d3      	ldr	r3, [r2, #12]
 8000ccc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000cd0:	60d3      	str	r3, [r2, #12]
 8000cd2:	4770      	bx	lr
 8000cd4:	40007000 	.word	0x40007000

08000cd8 <HAL_PWREx_EnableVddUSB>:
  * @note  Remove VDDUSB electrical and logical isolation, once VDDUSB supply is present.  
  * @retval None
  */
void HAL_PWREx_EnableVddUSB(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_USV);
 8000cd8:	4a02      	ldr	r2, [pc, #8]	; (8000ce4 <HAL_PWREx_EnableVddUSB+0xc>)
 8000cda:	6853      	ldr	r3, [r2, #4]
 8000cdc:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000ce0:	6053      	str	r3, [r2, #4]
 8000ce2:	4770      	bx	lr
 8000ce4:	40007000 	.word	0x40007000

08000ce8 <HAL_PWREx_DisableVddUSB>:
  * @brief Disable VDDUSB supply. 
  * @retval None
  */
void HAL_PWREx_DisableVddUSB(void)
{
  CLEAR_BIT(PWR->CR2, PWR_CR2_USV);
 8000ce8:	4a02      	ldr	r2, [pc, #8]	; (8000cf4 <HAL_PWREx_DisableVddUSB+0xc>)
 8000cea:	6853      	ldr	r3, [r2, #4]
 8000cec:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000cf0:	6053      	str	r3, [r2, #4]
 8000cf2:	4770      	bx	lr
 8000cf4:	40007000 	.word	0x40007000

08000cf8 <HAL_PWREx_EnableVddIO2>:
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present. 
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 8000cf8:	4a02      	ldr	r2, [pc, #8]	; (8000d04 <HAL_PWREx_EnableVddIO2+0xc>)
 8000cfa:	6853      	ldr	r3, [r2, #4]
 8000cfc:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000d00:	6053      	str	r3, [r2, #4]
 8000d02:	4770      	bx	lr
 8000d04:	40007000 	.word	0x40007000

08000d08 <HAL_PWREx_DisableVddIO2>:
  * @brief Disable VDDIO2 supply. 
  * @retval None
  */
void HAL_PWREx_DisableVddIO2(void)
{
  CLEAR_BIT(PWR->CR2, PWR_CR2_IOSV);
 8000d08:	4a02      	ldr	r2, [pc, #8]	; (8000d14 <HAL_PWREx_DisableVddIO2+0xc>)
 8000d0a:	6853      	ldr	r3, [r2, #4]
 8000d0c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000d10:	6053      	str	r3, [r2, #4]
 8000d12:	4770      	bx	lr
 8000d14:	40007000 	.word	0x40007000

08000d18 <HAL_PWREx_EnableInternalWakeUpLine>:
  * @brief Enable Internal Wake-up Line. 
  * @retval None
  */
void HAL_PWREx_EnableInternalWakeUpLine(void)
{
  SET_BIT(PWR->CR3, PWR_CR3_EIWF);
 8000d18:	4a02      	ldr	r2, [pc, #8]	; (8000d24 <HAL_PWREx_EnableInternalWakeUpLine+0xc>)
 8000d1a:	6893      	ldr	r3, [r2, #8]
 8000d1c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000d20:	6093      	str	r3, [r2, #8]
 8000d22:	4770      	bx	lr
 8000d24:	40007000 	.word	0x40007000

08000d28 <HAL_PWREx_DisableInternalWakeUpLine>:
  * @brief Disable Internal Wake-up Line. 
  * @retval None
  */
void HAL_PWREx_DisableInternalWakeUpLine(void)
{
  CLEAR_BIT(PWR->CR3, PWR_CR3_EIWF);
 8000d28:	4a02      	ldr	r2, [pc, #8]	; (8000d34 <HAL_PWREx_DisableInternalWakeUpLine+0xc>)
 8000d2a:	6893      	ldr	r3, [r2, #8]
 8000d2c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8000d30:	6093      	str	r3, [r2, #8]
 8000d32:	4770      	bx	lr
 8000d34:	40007000 	.word	0x40007000

08000d38 <HAL_PWREx_EnableGPIOPullUp>:
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{  
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
 8000d38:	2807      	cmp	r0, #7
 8000d3a:	d85d      	bhi.n	8000df8 <HAL_PWREx_EnableGPIOPullUp+0xc0>
 8000d3c:	e8df f000 	tbb	[pc, r0]
 8000d40:	342a1e10 	.word	0x342a1e10
 8000d44:	0452483e 	.word	0x0452483e
    case PWR_GPIO_G:
       SET_BIT(PWR->PUCRG, GPIONumber);
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 8000d48:	4b2c      	ldr	r3, [pc, #176]	; (8000dfc <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000d4a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000d4c:	f001 0103 	and.w	r1, r1, #3
 8000d50:	430a      	orrs	r2, r1
 8000d52:	659a      	str	r2, [r3, #88]	; 0x58
       CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));           
 8000d54:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8000d56:	ea22 0101 	bic.w	r1, r2, r1
 8000d5a:	65d9      	str	r1, [r3, #92]	; 0x5c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000d5c:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));           
       break;                                                   
 8000d5e:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
  {
    case PWR_GPIO_A:
       SET_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
 8000d60:	4b26      	ldr	r3, [pc, #152]	; (8000dfc <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000d62:	6a1a      	ldr	r2, [r3, #32]
 8000d64:	f421 4080 	bic.w	r0, r1, #16384	; 0x4000
 8000d68:	4302      	orrs	r2, r0
 8000d6a:	621a      	str	r2, [r3, #32]
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                       
 8000d6c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000d6e:	f421 4120 	bic.w	r1, r1, #40960	; 0xa000
 8000d72:	ea22 0101 	bic.w	r1, r2, r1
 8000d76:	6259      	str	r1, [r3, #36]	; 0x24
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000d78:	2000      	movs	r0, #0
  switch (GPIO)
  {
    case PWR_GPIO_A:
       SET_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                       
       break;
 8000d7a:	4770      	bx	lr
    case PWR_GPIO_B:
       SET_BIT(PWR->PUCRB, GPIONumber);
 8000d7c:	4b1f      	ldr	r3, [pc, #124]	; (8000dfc <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000d7e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000d80:	430a      	orrs	r2, r1
 8000d82:	629a      	str	r2, [r3, #40]	; 0x28
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));                  
 8000d84:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000d86:	f021 0110 	bic.w	r1, r1, #16
 8000d8a:	ea22 0101 	bic.w	r1, r2, r1
 8000d8e:	62d9      	str	r1, [r3, #44]	; 0x2c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000d90:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                       
       break;
    case PWR_GPIO_B:
       SET_BIT(PWR->PUCRB, GPIONumber);
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));                  
       break; 
 8000d92:	4770      	bx	lr
    case PWR_GPIO_C:
       SET_BIT(PWR->PUCRC, GPIONumber);
 8000d94:	4b19      	ldr	r3, [pc, #100]	; (8000dfc <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000d96:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000d98:	430a      	orrs	r2, r1
 8000d9a:	631a      	str	r2, [r3, #48]	; 0x30
       CLEAR_BIT(PWR->PDCRC, GPIONumber);         
 8000d9c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000d9e:	ea22 0101 	bic.w	r1, r2, r1
 8000da2:	6359      	str	r1, [r3, #52]	; 0x34
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000da4:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));                  
       break; 
    case PWR_GPIO_C:
       SET_BIT(PWR->PUCRC, GPIONumber);
       CLEAR_BIT(PWR->PDCRC, GPIONumber);         
       break; 
 8000da6:	4770      	bx	lr
    case PWR_GPIO_D:
       SET_BIT(PWR->PUCRD, GPIONumber);
 8000da8:	4b14      	ldr	r3, [pc, #80]	; (8000dfc <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000daa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000dac:	430a      	orrs	r2, r1
 8000dae:	639a      	str	r2, [r3, #56]	; 0x38
       CLEAR_BIT(PWR->PDCRD, GPIONumber);         
 8000db0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8000db2:	ea22 0101 	bic.w	r1, r2, r1
 8000db6:	63d9      	str	r1, [r3, #60]	; 0x3c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000db8:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRC, GPIONumber);         
       break; 
    case PWR_GPIO_D:
       SET_BIT(PWR->PUCRD, GPIONumber);
       CLEAR_BIT(PWR->PDCRD, GPIONumber);         
       break;
 8000dba:	4770      	bx	lr
    case PWR_GPIO_E:
       SET_BIT(PWR->PUCRE, GPIONumber);
 8000dbc:	4b0f      	ldr	r3, [pc, #60]	; (8000dfc <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000dbe:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000dc0:	430a      	orrs	r2, r1
 8000dc2:	641a      	str	r2, [r3, #64]	; 0x40
       CLEAR_BIT(PWR->PDCRE, GPIONumber);         
 8000dc4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000dc6:	ea22 0101 	bic.w	r1, r2, r1
 8000dca:	6459      	str	r1, [r3, #68]	; 0x44
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000dcc:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRD, GPIONumber);         
       break;
    case PWR_GPIO_E:
       SET_BIT(PWR->PUCRE, GPIONumber);
       CLEAR_BIT(PWR->PDCRE, GPIONumber);         
       break;
 8000dce:	4770      	bx	lr
    case PWR_GPIO_F:
       SET_BIT(PWR->PUCRF, GPIONumber);
 8000dd0:	4b0a      	ldr	r3, [pc, #40]	; (8000dfc <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000dd2:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8000dd4:	430a      	orrs	r2, r1
 8000dd6:	649a      	str	r2, [r3, #72]	; 0x48
       CLEAR_BIT(PWR->PDCRF, GPIONumber);         
 8000dd8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000dda:	ea22 0101 	bic.w	r1, r2, r1
 8000dde:	64d9      	str	r1, [r3, #76]	; 0x4c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000de0:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRE, GPIONumber);         
       break;
    case PWR_GPIO_F:
       SET_BIT(PWR->PUCRF, GPIONumber);
       CLEAR_BIT(PWR->PDCRF, GPIONumber);         
       break;
 8000de2:	4770      	bx	lr
    case PWR_GPIO_G:
       SET_BIT(PWR->PUCRG, GPIONumber);
 8000de4:	4b05      	ldr	r3, [pc, #20]	; (8000dfc <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000de6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8000de8:	430a      	orrs	r2, r1
 8000dea:	651a      	str	r2, [r3, #80]	; 0x50
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
 8000dec:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8000dee:	ea22 0101 	bic.w	r1, r2, r1
 8000df2:	6559      	str	r1, [r3, #84]	; 0x54
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000df4:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRF, GPIONumber);         
       break;
    case PWR_GPIO_G:
       SET_BIT(PWR->PUCRG, GPIONumber);
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
       break;
 8000df6:	4770      	bx	lr
    case PWR_GPIO_H:
       SET_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));           
       break;                                                   
    default:
        return HAL_ERROR;
 8000df8:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 8000dfa:	4770      	bx	lr
 8000dfc:	40007000 	.word	0x40007000

08000e00 <HAL_PWREx_DisableGPIOPullUp>:
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{  
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
 8000e00:	2807      	cmp	r0, #7
 8000e02:	d841      	bhi.n	8000e88 <HAL_PWREx_DisableGPIOPullUp+0x88>
 8000e04:	e8df f000 	tbb	[pc, r0]
 8000e08:	241d160d 	.word	0x241d160d
 8000e0c:	0439322b 	.word	0x0439322b
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 8000e10:	4a1e      	ldr	r2, [pc, #120]	; (8000e8c <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e12:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8000e14:	f001 0103 	and.w	r1, r1, #3
 8000e18:	ea23 0101 	bic.w	r1, r3, r1
 8000e1c:	6591      	str	r1, [r2, #88]	; 0x58
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e1e:	2000      	movs	r0, #0
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
 8000e20:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));         
 8000e22:	4a1a      	ldr	r2, [pc, #104]	; (8000e8c <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e24:	6a13      	ldr	r3, [r2, #32]
 8000e26:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8000e2a:	ea23 0101 	bic.w	r1, r3, r1
 8000e2e:	6211      	str	r1, [r2, #32]
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e30:	2000      	movs	r0, #0
  
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));         
       break;
 8000e32:	4770      	bx	lr
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
 8000e34:	4a15      	ldr	r2, [pc, #84]	; (8000e8c <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e36:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8000e38:	ea23 0101 	bic.w	r1, r3, r1
 8000e3c:	6291      	str	r1, [r2, #40]	; 0x28
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e3e:	2000      	movs	r0, #0
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));         
       break;
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
       break; 
 8000e40:	4770      	bx	lr
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
 8000e42:	4a12      	ldr	r2, [pc, #72]	; (8000e8c <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e44:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8000e46:	ea23 0101 	bic.w	r1, r3, r1
 8000e4a:	6311      	str	r1, [r2, #48]	; 0x30
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e4c:	2000      	movs	r0, #0
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
       break; 
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
       break; 
 8000e4e:	4770      	bx	lr
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
 8000e50:	4a0e      	ldr	r2, [pc, #56]	; (8000e8c <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e52:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8000e54:	ea23 0101 	bic.w	r1, r3, r1
 8000e58:	6391      	str	r1, [r2, #56]	; 0x38
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e5a:	2000      	movs	r0, #0
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
       break; 
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
       break;
 8000e5c:	4770      	bx	lr
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
 8000e5e:	4a0b      	ldr	r2, [pc, #44]	; (8000e8c <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e60:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8000e62:	ea23 0101 	bic.w	r1, r3, r1
 8000e66:	6411      	str	r1, [r2, #64]	; 0x40
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e68:	2000      	movs	r0, #0
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
       break;
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
       break;
 8000e6a:	4770      	bx	lr
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PUCRF, GPIONumber);
 8000e6c:	4a07      	ldr	r2, [pc, #28]	; (8000e8c <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e6e:	6c93      	ldr	r3, [r2, #72]	; 0x48
 8000e70:	ea23 0101 	bic.w	r1, r3, r1
 8000e74:	6491      	str	r1, [r2, #72]	; 0x48
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e76:	2000      	movs	r0, #0
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
       break;
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PUCRF, GPIONumber);
       break;
 8000e78:	4770      	bx	lr
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
 8000e7a:	4a04      	ldr	r2, [pc, #16]	; (8000e8c <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e7c:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8000e7e:	ea23 0101 	bic.w	r1, r3, r1
 8000e82:	6511      	str	r1, [r2, #80]	; 0x50
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e84:	2000      	movs	r0, #0
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PUCRF, GPIONumber);
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
       break;
 8000e86:	4770      	bx	lr
    case PWR_GPIO_H:
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
    default:
        return HAL_ERROR;
 8000e88:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 8000e8a:	4770      	bx	lr
 8000e8c:	40007000 	.word	0x40007000

08000e90 <HAL_PWREx_EnableGPIOPullDown>:
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
{
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
 8000e90:	2807      	cmp	r0, #7
 8000e92:	d85d      	bhi.n	8000f50 <HAL_PWREx_EnableGPIOPullDown+0xc0>
 8000e94:	e8df f000 	tbb	[pc, r0]
 8000e98:	342a1e10 	.word	0x342a1e10
 8000e9c:	0452483e 	.word	0x0452483e
    case PWR_GPIO_G:
       SET_BIT(PWR->PDCRG, GPIONumber);
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 8000ea0:	4b2c      	ldr	r3, [pc, #176]	; (8000f54 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000ea2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8000ea4:	f001 0103 	and.w	r1, r1, #3
 8000ea8:	430a      	orrs	r2, r1
 8000eaa:	65da      	str	r2, [r3, #92]	; 0x5c
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));          
 8000eac:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000eae:	ea22 0101 	bic.w	r1, r2, r1
 8000eb2:	6599      	str	r1, [r3, #88]	; 0x58
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000eb4:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));          
       break;                                                   
 8000eb6:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
  { 
    case PWR_GPIO_A:
       SET_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));        
 8000eb8:	4b26      	ldr	r3, [pc, #152]	; (8000f54 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000eba:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000ebc:	f421 4020 	bic.w	r0, r1, #40960	; 0xa000
 8000ec0:	4302      	orrs	r2, r0
 8000ec2:	625a      	str	r2, [r3, #36]	; 0x24
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));           
 8000ec4:	6a1a      	ldr	r2, [r3, #32]
 8000ec6:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8000eca:	ea22 0101 	bic.w	r1, r2, r1
 8000ece:	6219      	str	r1, [r3, #32]
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000ed0:	2000      	movs	r0, #0
  switch (GPIO)
  { 
    case PWR_GPIO_A:
       SET_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));        
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));           
       break;
 8000ed2:	4770      	bx	lr
    case PWR_GPIO_B:
       SET_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
 8000ed4:	4b1f      	ldr	r3, [pc, #124]	; (8000f54 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000ed6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000ed8:	f021 0010 	bic.w	r0, r1, #16
 8000edc:	4302      	orrs	r2, r0
 8000ede:	62da      	str	r2, [r3, #44]	; 0x2c
       CLEAR_BIT(PWR->PUCRB, GPIONumber);                    
 8000ee0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000ee2:	ea22 0101 	bic.w	r1, r2, r1
 8000ee6:	6299      	str	r1, [r3, #40]	; 0x28
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000ee8:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));           
       break;
    case PWR_GPIO_B:
       SET_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
       CLEAR_BIT(PWR->PUCRB, GPIONumber);                    
       break; 
 8000eea:	4770      	bx	lr
    case PWR_GPIO_C:
       SET_BIT(PWR->PDCRC, GPIONumber);
 8000eec:	4b19      	ldr	r3, [pc, #100]	; (8000f54 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000eee:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000ef0:	430a      	orrs	r2, r1
 8000ef2:	635a      	str	r2, [r3, #52]	; 0x34
       CLEAR_BIT(PWR->PUCRC, GPIONumber);        
 8000ef4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000ef6:	ea22 0101 	bic.w	r1, r2, r1
 8000efa:	6319      	str	r1, [r3, #48]	; 0x30
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000efc:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRB, GPIONumber);                    
       break; 
    case PWR_GPIO_C:
       SET_BIT(PWR->PDCRC, GPIONumber);
       CLEAR_BIT(PWR->PUCRC, GPIONumber);        
       break; 
 8000efe:	4770      	bx	lr
    case PWR_GPIO_D:
       SET_BIT(PWR->PDCRD, GPIONumber);
 8000f00:	4b14      	ldr	r3, [pc, #80]	; (8000f54 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f02:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8000f04:	430a      	orrs	r2, r1
 8000f06:	63da      	str	r2, [r3, #60]	; 0x3c
       CLEAR_BIT(PWR->PUCRD, GPIONumber);        
 8000f08:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000f0a:	ea22 0101 	bic.w	r1, r2, r1
 8000f0e:	6399      	str	r1, [r3, #56]	; 0x38
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f10:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRC, GPIONumber);        
       break; 
    case PWR_GPIO_D:
       SET_BIT(PWR->PDCRD, GPIONumber);
       CLEAR_BIT(PWR->PUCRD, GPIONumber);        
       break;
 8000f12:	4770      	bx	lr
    case PWR_GPIO_E:
       SET_BIT(PWR->PDCRE, GPIONumber);
 8000f14:	4b0f      	ldr	r3, [pc, #60]	; (8000f54 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f16:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000f18:	430a      	orrs	r2, r1
 8000f1a:	645a      	str	r2, [r3, #68]	; 0x44
       CLEAR_BIT(PWR->PUCRE, GPIONumber);        
 8000f1c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000f1e:	ea22 0101 	bic.w	r1, r2, r1
 8000f22:	6419      	str	r1, [r3, #64]	; 0x40
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f24:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRD, GPIONumber);        
       break;
    case PWR_GPIO_E:
       SET_BIT(PWR->PDCRE, GPIONumber);
       CLEAR_BIT(PWR->PUCRE, GPIONumber);        
       break;
 8000f26:	4770      	bx	lr
    case PWR_GPIO_F:
       SET_BIT(PWR->PDCRF, GPIONumber);
 8000f28:	4b0a      	ldr	r3, [pc, #40]	; (8000f54 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f2a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000f2c:	430a      	orrs	r2, r1
 8000f2e:	64da      	str	r2, [r3, #76]	; 0x4c
       CLEAR_BIT(PWR->PUCRF, GPIONumber);        
 8000f30:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8000f32:	ea22 0101 	bic.w	r1, r2, r1
 8000f36:	6499      	str	r1, [r3, #72]	; 0x48
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f38:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRE, GPIONumber);        
       break;
    case PWR_GPIO_F:
       SET_BIT(PWR->PDCRF, GPIONumber);
       CLEAR_BIT(PWR->PUCRF, GPIONumber);        
       break;
 8000f3a:	4770      	bx	lr
    case PWR_GPIO_G:
       SET_BIT(PWR->PDCRG, GPIONumber);
 8000f3c:	4b05      	ldr	r3, [pc, #20]	; (8000f54 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f3e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8000f40:	430a      	orrs	r2, r1
 8000f42:	655a      	str	r2, [r3, #84]	; 0x54
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
 8000f44:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8000f46:	ea22 0101 	bic.w	r1, r2, r1
 8000f4a:	6519      	str	r1, [r3, #80]	; 0x50
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f4c:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRF, GPIONumber);        
       break;
    case PWR_GPIO_G:
       SET_BIT(PWR->PDCRG, GPIONumber);
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
       break;
 8000f4e:	4770      	bx	lr
    case PWR_GPIO_H:
       SET_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));          
       break;                                                   
    default:
        return HAL_ERROR;
 8000f50:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 8000f52:	4770      	bx	lr
 8000f54:	40007000 	.word	0x40007000

08000f58 <HAL_PWREx_DisableGPIOPullDown>:
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
{
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
   
  switch (GPIO)
 8000f58:	2807      	cmp	r0, #7
 8000f5a:	d843      	bhi.n	8000fe4 <HAL_PWREx_DisableGPIOPullDown+0x8c>
 8000f5c:	e8df f000 	tbb	[pc, r0]
 8000f60:	261f160d 	.word	0x261f160d
 8000f64:	043b342d 	.word	0x043b342d
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
      CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 8000f68:	4a1f      	ldr	r2, [pc, #124]	; (8000fe8 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000f6a:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
 8000f6c:	f001 0103 	and.w	r1, r1, #3
 8000f70:	ea23 0101 	bic.w	r1, r3, r1
 8000f74:	65d1      	str	r1, [r2, #92]	; 0x5c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f76:	2000      	movs	r0, #0
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
      CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
 8000f78:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
   
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                        
 8000f7a:	4a1b      	ldr	r2, [pc, #108]	; (8000fe8 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000f7c:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8000f7e:	f421 4120 	bic.w	r1, r1, #40960	; 0xa000
 8000f82:	ea23 0101 	bic.w	r1, r3, r1
 8000f86:	6251      	str	r1, [r2, #36]	; 0x24
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f88:	2000      	movs	r0, #0
   
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                        
       break;
 8000f8a:	4770      	bx	lr
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));           
 8000f8c:	4a16      	ldr	r2, [pc, #88]	; (8000fe8 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000f8e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8000f90:	f021 0110 	bic.w	r1, r1, #16
 8000f94:	ea23 0101 	bic.w	r1, r3, r1
 8000f98:	62d1      	str	r1, [r2, #44]	; 0x2c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f9a:	2000      	movs	r0, #0
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                        
       break;
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));           
       break; 
 8000f9c:	4770      	bx	lr
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
 8000f9e:	4a12      	ldr	r2, [pc, #72]	; (8000fe8 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000fa0:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8000fa2:	ea23 0101 	bic.w	r1, r3, r1
 8000fa6:	6351      	str	r1, [r2, #52]	; 0x34
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000fa8:	2000      	movs	r0, #0
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));           
       break; 
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
       break; 
 8000faa:	4770      	bx	lr
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
 8000fac:	4a0e      	ldr	r2, [pc, #56]	; (8000fe8 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000fae:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8000fb0:	ea23 0101 	bic.w	r1, r3, r1
 8000fb4:	63d1      	str	r1, [r2, #60]	; 0x3c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000fb6:	2000      	movs	r0, #0
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
       break; 
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
       break;
 8000fb8:	4770      	bx	lr
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
 8000fba:	4a0b      	ldr	r2, [pc, #44]	; (8000fe8 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000fbc:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8000fbe:	ea23 0101 	bic.w	r1, r3, r1
 8000fc2:	6451      	str	r1, [r2, #68]	; 0x44
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000fc4:	2000      	movs	r0, #0
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
       break;
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
       break;
 8000fc6:	4770      	bx	lr
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PDCRF, GPIONumber);
 8000fc8:	4a07      	ldr	r2, [pc, #28]	; (8000fe8 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000fca:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8000fcc:	ea23 0101 	bic.w	r1, r3, r1
 8000fd0:	64d1      	str	r1, [r2, #76]	; 0x4c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000fd2:	2000      	movs	r0, #0
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
       break;
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PDCRF, GPIONumber);
       break;
 8000fd4:	4770      	bx	lr
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
 8000fd6:	4a04      	ldr	r2, [pc, #16]	; (8000fe8 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000fd8:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8000fda:	ea23 0101 	bic.w	r1, r3, r1
 8000fde:	6551      	str	r1, [r2, #84]	; 0x54
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000fe0:	2000      	movs	r0, #0
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PDCRF, GPIONumber);
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
       break;
 8000fe2:	4770      	bx	lr
    case PWR_GPIO_H:
      CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
    default:
        return HAL_ERROR;
 8000fe4:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 8000fe6:	4770      	bx	lr
 8000fe8:	40007000 	.word	0x40007000

08000fec <HAL_PWREx_EnablePullUpPullDownConfig>:
  *        is no conflict when setting PUy or PDy bit.         
  * @retval None
  */
void HAL_PWREx_EnablePullUpPullDownConfig(void)
{
  SET_BIT(PWR->CR3, PWR_CR3_APC);
 8000fec:	4a02      	ldr	r2, [pc, #8]	; (8000ff8 <HAL_PWREx_EnablePullUpPullDownConfig+0xc>)
 8000fee:	6893      	ldr	r3, [r2, #8]
 8000ff0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000ff4:	6093      	str	r3, [r2, #8]
 8000ff6:	4770      	bx	lr
 8000ff8:	40007000 	.word	0x40007000

08000ffc <HAL_PWREx_DisablePullUpPullDownConfig>:
  *        PWR_PUCRx and PWR_PDCRx registers are not applied in Standby and Shutdown modes.     
  * @retval None
  */
void HAL_PWREx_DisablePullUpPullDownConfig(void)
{
  CLEAR_BIT(PWR->CR3, PWR_CR3_APC);
 8000ffc:	4a02      	ldr	r2, [pc, #8]	; (8001008 <HAL_PWREx_DisablePullUpPullDownConfig+0xc>)
 8000ffe:	6893      	ldr	r3, [r2, #8]
 8001000:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001004:	6093      	str	r3, [r2, #8]
 8001006:	4770      	bx	lr
 8001008:	40007000 	.word	0x40007000

0800100c <HAL_PWREx_EnableSRAM2ContentRetention>:
  *         Standby mode and its content is kept.    
  * @retval None
  */
void HAL_PWREx_EnableSRAM2ContentRetention(void)
{
  SET_BIT(PWR->CR3, PWR_CR3_RRS);
 800100c:	4a02      	ldr	r2, [pc, #8]	; (8001018 <HAL_PWREx_EnableSRAM2ContentRetention+0xc>)
 800100e:	6893      	ldr	r3, [r2, #8]
 8001010:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001014:	6093      	str	r3, [r2, #8]
 8001016:	4770      	bx	lr
 8001018:	40007000 	.word	0x40007000

0800101c <HAL_PWREx_DisableSRAM2ContentRetention>:
  *        and its content is lost.      
  * @retval None
  */
void HAL_PWREx_DisableSRAM2ContentRetention(void)
{
  CLEAR_BIT(PWR->CR3, PWR_CR3_RRS);
 800101c:	4a02      	ldr	r2, [pc, #8]	; (8001028 <HAL_PWREx_DisableSRAM2ContentRetention+0xc>)
 800101e:	6893      	ldr	r3, [r2, #8]
 8001020:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001024:	6093      	str	r3, [r2, #8]
 8001026:	4770      	bx	lr
 8001028:	40007000 	.word	0x40007000

0800102c <HAL_PWREx_EnablePVM1>:
  * @brief Enable the Power Voltage Monitoring 1: VDDUSB versus 1.2V.
  * @retval None
  */
void HAL_PWREx_EnablePVM1(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_1);    
 800102c:	4a02      	ldr	r2, [pc, #8]	; (8001038 <HAL_PWREx_EnablePVM1+0xc>)
 800102e:	6853      	ldr	r3, [r2, #4]
 8001030:	f043 0310 	orr.w	r3, r3, #16
 8001034:	6053      	str	r3, [r2, #4]
 8001036:	4770      	bx	lr
 8001038:	40007000 	.word	0x40007000

0800103c <HAL_PWREx_DisablePVM1>:
  * @brief Disable the Power Voltage Monitoring 1: VDDUSB versus 1.2V.
  * @retval None
  */
void HAL_PWREx_DisablePVM1(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_1);    
 800103c:	4a02      	ldr	r2, [pc, #8]	; (8001048 <HAL_PWREx_DisablePVM1+0xc>)
 800103e:	6853      	ldr	r3, [r2, #4]
 8001040:	f023 0310 	bic.w	r3, r3, #16
 8001044:	6053      	str	r3, [r2, #4]
 8001046:	4770      	bx	lr
 8001048:	40007000 	.word	0x40007000

0800104c <HAL_PWREx_EnablePVM2>:
  * @brief Enable the Power Voltage Monitoring 2: VDDIO2 versus 0.9V.
  * @retval None
  */
void HAL_PWREx_EnablePVM2(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_2);    
 800104c:	4a02      	ldr	r2, [pc, #8]	; (8001058 <HAL_PWREx_EnablePVM2+0xc>)
 800104e:	6853      	ldr	r3, [r2, #4]
 8001050:	f043 0320 	orr.w	r3, r3, #32
 8001054:	6053      	str	r3, [r2, #4]
 8001056:	4770      	bx	lr
 8001058:	40007000 	.word	0x40007000

0800105c <HAL_PWREx_DisablePVM2>:
  * @brief Disable the Power Voltage Monitoring 2: VDDIO2 versus 0.9V.
  * @retval None
  */
void HAL_PWREx_DisablePVM2(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_2);    
 800105c:	4a02      	ldr	r2, [pc, #8]	; (8001068 <HAL_PWREx_DisablePVM2+0xc>)
 800105e:	6853      	ldr	r3, [r2, #4]
 8001060:	f023 0320 	bic.w	r3, r3, #32
 8001064:	6053      	str	r3, [r2, #4]
 8001066:	4770      	bx	lr
 8001068:	40007000 	.word	0x40007000

0800106c <HAL_PWREx_EnablePVM3>:
  * @brief Enable the Power Voltage Monitoring 3: VDDA versus 1.62V.
  * @retval None
  */
void HAL_PWREx_EnablePVM3(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_3);    
 800106c:	4a02      	ldr	r2, [pc, #8]	; (8001078 <HAL_PWREx_EnablePVM3+0xc>)
 800106e:	6853      	ldr	r3, [r2, #4]
 8001070:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001074:	6053      	str	r3, [r2, #4]
 8001076:	4770      	bx	lr
 8001078:	40007000 	.word	0x40007000

0800107c <HAL_PWREx_DisablePVM3>:
  * @brief Disable the Power Voltage Monitoring 3: VDDA versus 1.62V.
  * @retval None
  */
void HAL_PWREx_DisablePVM3(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_3);    
 800107c:	4a02      	ldr	r2, [pc, #8]	; (8001088 <HAL_PWREx_DisablePVM3+0xc>)
 800107e:	6853      	ldr	r3, [r2, #4]
 8001080:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001084:	6053      	str	r3, [r2, #4]
 8001086:	4770      	bx	lr
 8001088:	40007000 	.word	0x40007000

0800108c <HAL_PWREx_EnablePVM4>:
  * @brief Enable the Power Voltage Monitoring 4:  VDDA versus 2.2V.
  * @retval None
  */
void HAL_PWREx_EnablePVM4(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_4);    
 800108c:	4a02      	ldr	r2, [pc, #8]	; (8001098 <HAL_PWREx_EnablePVM4+0xc>)
 800108e:	6853      	ldr	r3, [r2, #4]
 8001090:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001094:	6053      	str	r3, [r2, #4]
 8001096:	4770      	bx	lr
 8001098:	40007000 	.word	0x40007000

0800109c <HAL_PWREx_DisablePVM4>:
  * @brief Disable the Power Voltage Monitoring 4:  VDDA versus 2.2V.
  * @retval None
  */
void HAL_PWREx_DisablePVM4(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_4);    
 800109c:	4a02      	ldr	r2, [pc, #8]	; (80010a8 <HAL_PWREx_DisablePVM4+0xc>)
 800109e:	6853      	ldr	r3, [r2, #4]
 80010a0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80010a4:	6053      	str	r3, [r2, #4]
 80010a6:	4770      	bx	lr
 80010a8:	40007000 	.word	0x40007000

080010ac <HAL_PWREx_ConfigPVM>:


  /* Configure EXTI 35 to 38 interrupts if so required:
     scan thru PVMType to detect which PVMx is set and
     configure the corresponding EXTI line accordingly. */
  switch (sConfigPVM->PVMType)
 80010ac:	6803      	ldr	r3, [r0, #0]
 80010ae:	2b20      	cmp	r3, #32
 80010b0:	f000 80a0 	beq.w	80011f4 <HAL_PWREx_ConfigPVM+0x148>
 80010b4:	d968      	bls.n	8001188 <HAL_PWREx_ConfigPVM+0xdc>
 80010b6:	2b40      	cmp	r3, #64	; 0x40
 80010b8:	d034      	beq.n	8001124 <HAL_PWREx_ConfigPVM+0x78>
 80010ba:	2b80      	cmp	r3, #128	; 0x80
 80010bc:	f040 8098 	bne.w	80011f0 <HAL_PWREx_ConfigPVM+0x144>
      }
      break;
      
    case PWR_PVM_4:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM4_EXTI_DISABLE_EVENT();
 80010c0:	4b65      	ldr	r3, [pc, #404]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 80010c2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80010c4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80010c8:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM4_EXTI_DISABLE_IT();
 80010ca:	6a1a      	ldr	r2, [r3, #32]
 80010cc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80010d0:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM4_EXTI_DISABLE_FALLING_EDGE(); 
 80010d2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80010d4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80010d8:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM4_EXTI_DISABLE_RISING_EDGE();
 80010da:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80010dc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80010e0:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 80010e2:	6842      	ldr	r2, [r0, #4]
 80010e4:	03d1      	lsls	r1, r2, #15
 80010e6:	d504      	bpl.n	80010f2 <HAL_PWREx_ConfigPVM+0x46>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_IT();
 80010e8:	6a1a      	ldr	r2, [r3, #32]
 80010ea:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80010ee:	621a      	str	r2, [r3, #32]
 80010f0:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 80010f2:	0393      	lsls	r3, r2, #14
 80010f4:	d505      	bpl.n	8001102 <HAL_PWREx_ConfigPVM+0x56>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_EVENT();
 80010f6:	4a58      	ldr	r2, [pc, #352]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 80010f8:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80010fa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80010fe:	6253      	str	r3, [r2, #36]	; 0x24
 8001100:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 8001102:	07d1      	lsls	r1, r2, #31
 8001104:	d505      	bpl.n	8001112 <HAL_PWREx_ConfigPVM+0x66>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_RISING_EDGE();
 8001106:	4a54      	ldr	r2, [pc, #336]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 8001108:	6a93      	ldr	r3, [r2, #40]	; 0x28
 800110a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800110e:	6293      	str	r3, [r2, #40]	; 0x28
 8001110:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 8001112:	0793      	lsls	r3, r2, #30
 8001114:	d56a      	bpl.n	80011ec <HAL_PWREx_ConfigPVM+0x140>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_FALLING_EDGE();
 8001116:	4a50      	ldr	r2, [pc, #320]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 8001118:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800111a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800111e:	62d3      	str	r3, [r2, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 8001120:	2000      	movs	r0, #0
 8001122:	4770      	bx	lr
      }
      break;
      
    case PWR_PVM_3:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM3_EXTI_DISABLE_EVENT();
 8001124:	4b4c      	ldr	r3, [pc, #304]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 8001126:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001128:	f022 0220 	bic.w	r2, r2, #32
 800112c:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM3_EXTI_DISABLE_IT();
 800112e:	6a1a      	ldr	r2, [r3, #32]
 8001130:	f022 0220 	bic.w	r2, r2, #32
 8001134:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM3_EXTI_DISABLE_FALLING_EDGE(); 
 8001136:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001138:	f022 0220 	bic.w	r2, r2, #32
 800113c:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM3_EXTI_DISABLE_RISING_EDGE();
 800113e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001140:	f022 0220 	bic.w	r2, r2, #32
 8001144:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 8001146:	6842      	ldr	r2, [r0, #4]
 8001148:	03d1      	lsls	r1, r2, #15
 800114a:	d504      	bpl.n	8001156 <HAL_PWREx_ConfigPVM+0xaa>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_IT();
 800114c:	6a1a      	ldr	r2, [r3, #32]
 800114e:	f042 0220 	orr.w	r2, r2, #32
 8001152:	621a      	str	r2, [r3, #32]
 8001154:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 8001156:	0391      	lsls	r1, r2, #14
 8001158:	d505      	bpl.n	8001166 <HAL_PWREx_ConfigPVM+0xba>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_EVENT();
 800115a:	4a3f      	ldr	r2, [pc, #252]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 800115c:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800115e:	f043 0320 	orr.w	r3, r3, #32
 8001162:	6253      	str	r3, [r2, #36]	; 0x24
 8001164:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 8001166:	07d3      	lsls	r3, r2, #31
 8001168:	d505      	bpl.n	8001176 <HAL_PWREx_ConfigPVM+0xca>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_RISING_EDGE();
 800116a:	4a3b      	ldr	r2, [pc, #236]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 800116c:	6a93      	ldr	r3, [r2, #40]	; 0x28
 800116e:	f043 0320 	orr.w	r3, r3, #32
 8001172:	6293      	str	r3, [r2, #40]	; 0x28
 8001174:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 8001176:	0790      	lsls	r0, r2, #30
 8001178:	d538      	bpl.n	80011ec <HAL_PWREx_ConfigPVM+0x140>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_FALLING_EDGE();
 800117a:	4a37      	ldr	r2, [pc, #220]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 800117c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800117e:	f043 0320 	orr.w	r3, r3, #32
 8001182:	62d3      	str	r3, [r2, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 8001184:	2000      	movs	r0, #0
 8001186:	4770      	bx	lr


  /* Configure EXTI 35 to 38 interrupts if so required:
     scan thru PVMType to detect which PVMx is set and
     configure the corresponding EXTI line accordingly. */
  switch (sConfigPVM->PVMType)
 8001188:	2b10      	cmp	r3, #16
 800118a:	d131      	bne.n	80011f0 <HAL_PWREx_ConfigPVM+0x144>
  {
#if defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx)
    case PWR_PVM_1:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM1_EXTI_DISABLE_EVENT();
 800118c:	4b32      	ldr	r3, [pc, #200]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 800118e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001190:	f022 0208 	bic.w	r2, r2, #8
 8001194:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM1_EXTI_DISABLE_IT();
 8001196:	6a1a      	ldr	r2, [r3, #32]
 8001198:	f022 0208 	bic.w	r2, r2, #8
 800119c:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM1_EXTI_DISABLE_FALLING_EDGE(); 
 800119e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80011a0:	f022 0208 	bic.w	r2, r2, #8
 80011a4:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM1_EXTI_DISABLE_RISING_EDGE();
 80011a6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80011a8:	f022 0208 	bic.w	r2, r2, #8
 80011ac:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 80011ae:	6842      	ldr	r2, [r0, #4]
 80011b0:	03d1      	lsls	r1, r2, #15
 80011b2:	d504      	bpl.n	80011be <HAL_PWREx_ConfigPVM+0x112>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_IT();
 80011b4:	6a1a      	ldr	r2, [r3, #32]
 80011b6:	f042 0208 	orr.w	r2, r2, #8
 80011ba:	621a      	str	r2, [r3, #32]
 80011bc:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 80011be:	0391      	lsls	r1, r2, #14
 80011c0:	d505      	bpl.n	80011ce <HAL_PWREx_ConfigPVM+0x122>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_EVENT();
 80011c2:	4a25      	ldr	r2, [pc, #148]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 80011c4:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80011c6:	f043 0308 	orr.w	r3, r3, #8
 80011ca:	6253      	str	r3, [r2, #36]	; 0x24
 80011cc:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 80011ce:	07d3      	lsls	r3, r2, #31
 80011d0:	d505      	bpl.n	80011de <HAL_PWREx_ConfigPVM+0x132>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_RISING_EDGE();
 80011d2:	4a21      	ldr	r2, [pc, #132]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 80011d4:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80011d6:	f043 0308 	orr.w	r3, r3, #8
 80011da:	6293      	str	r3, [r2, #40]	; 0x28
 80011dc:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 80011de:	0790      	lsls	r0, r2, #30
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_FALLING_EDGE();
 80011e0:	bf41      	itttt	mi
 80011e2:	4a1d      	ldrmi	r2, [pc, #116]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 80011e4:	6ad3      	ldrmi	r3, [r2, #44]	; 0x2c
 80011e6:	f043 0308 	orrmi.w	r3, r3, #8
 80011ea:	62d3      	strmi	r3, [r2, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 80011ec:	2000      	movs	r0, #0
 80011ee:	4770      	bx	lr
        __HAL_PWR_PVM4_EXTI_ENABLE_FALLING_EDGE();
      }
      break;  
      
    default:
      return HAL_ERROR;                      
 80011f0:	2001      	movs	r0, #1
    
  }   

  
  return HAL_OK;
}
 80011f2:	4770      	bx	lr
      break; 
#endif /* defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) */        
    
    case PWR_PVM_2:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM2_EXTI_DISABLE_EVENT();
 80011f4:	4b18      	ldr	r3, [pc, #96]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 80011f6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80011f8:	f022 0210 	bic.w	r2, r2, #16
 80011fc:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM2_EXTI_DISABLE_IT();
 80011fe:	6a1a      	ldr	r2, [r3, #32]
 8001200:	f022 0210 	bic.w	r2, r2, #16
 8001204:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM2_EXTI_DISABLE_FALLING_EDGE(); 
 8001206:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001208:	f022 0210 	bic.w	r2, r2, #16
 800120c:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM2_EXTI_DISABLE_RISING_EDGE();
 800120e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001210:	f022 0210 	bic.w	r2, r2, #16
 8001214:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 8001216:	6842      	ldr	r2, [r0, #4]
 8001218:	03d1      	lsls	r1, r2, #15
 800121a:	d504      	bpl.n	8001226 <HAL_PWREx_ConfigPVM+0x17a>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_IT();
 800121c:	6a1a      	ldr	r2, [r3, #32]
 800121e:	f042 0210 	orr.w	r2, r2, #16
 8001222:	621a      	str	r2, [r3, #32]
 8001224:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 8001226:	0391      	lsls	r1, r2, #14
 8001228:	d505      	bpl.n	8001236 <HAL_PWREx_ConfigPVM+0x18a>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_EVENT();
 800122a:	4a0b      	ldr	r2, [pc, #44]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 800122c:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800122e:	f043 0310 	orr.w	r3, r3, #16
 8001232:	6253      	str	r3, [r2, #36]	; 0x24
 8001234:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 8001236:	07d3      	lsls	r3, r2, #31
 8001238:	d505      	bpl.n	8001246 <HAL_PWREx_ConfigPVM+0x19a>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_RISING_EDGE();
 800123a:	4a07      	ldr	r2, [pc, #28]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 800123c:	6a93      	ldr	r3, [r2, #40]	; 0x28
 800123e:	f043 0310 	orr.w	r3, r3, #16
 8001242:	6293      	str	r3, [r2, #40]	; 0x28
 8001244:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 8001246:	0790      	lsls	r0, r2, #30
 8001248:	d5d0      	bpl.n	80011ec <HAL_PWREx_ConfigPVM+0x140>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_FALLING_EDGE();
 800124a:	4a03      	ldr	r2, [pc, #12]	; (8001258 <HAL_PWREx_ConfigPVM+0x1ac>)
 800124c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800124e:	f043 0310 	orr.w	r3, r3, #16
 8001252:	62d3      	str	r3, [r2, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 8001254:	2000      	movs	r0, #0
 8001256:	4770      	bx	lr
 8001258:	40010400 	.word	0x40010400

0800125c <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR); 
 800125c:	4a02      	ldr	r2, [pc, #8]	; (8001268 <HAL_PWREx_EnableLowPowerRunMode+0xc>)
 800125e:	6813      	ldr	r3, [r2, #0]
 8001260:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001264:	6013      	str	r3, [r2, #0]
 8001266:	4770      	bx	lr
 8001268:	40007000 	.word	0x40007000

0800126c <HAL_PWREx_DisableLowPowerRunMode>:
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index = 0;
  
  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR); 
 800126c:	490e      	ldr	r1, [pc, #56]	; (80012a8 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)

  /* Wait until REGLPF is reset */
  wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 800126e:	4b0f      	ldr	r3, [pc, #60]	; (80012ac <HAL_PWREx_DisableLowPowerRunMode+0x40>)
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index = 0;
  
  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR); 
 8001270:	6808      	ldr	r0, [r1, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 8001272:	4a0f      	ldr	r2, [pc, #60]	; (80012b0 <HAL_PWREx_DisableLowPowerRunMode+0x44>)
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index = 0;
  
  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR); 
 8001274:	f420 4080 	bic.w	r0, r0, #16384	; 0x4000
 8001278:	6008      	str	r0, [r1, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 800127a:	681b      	ldr	r3, [r3, #0]
 800127c:	fba2 2303 	umull	r2, r3, r2, r3
 8001280:	0c9a      	lsrs	r2, r3, #18
 8001282:	2332      	movs	r3, #50	; 0x32
 8001284:	fb03 f302 	mul.w	r3, r3, r2
  while ((wait_loop_index != 0) && (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)))
 8001288:	b913      	cbnz	r3, 8001290 <HAL_PWREx_DisableLowPowerRunMode+0x24>
 800128a:	e004      	b.n	8001296 <HAL_PWREx_DisableLowPowerRunMode+0x2a>
 800128c:	3b01      	subs	r3, #1
 800128e:	d002      	beq.n	8001296 <HAL_PWREx_DisableLowPowerRunMode+0x2a>
 8001290:	694a      	ldr	r2, [r1, #20]
 8001292:	0592      	lsls	r2, r2, #22
 8001294:	d4fa      	bmi.n	800128c <HAL_PWREx_DisableLowPowerRunMode+0x20>
  {
    wait_loop_index--;
  }
  if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 8001296:	4b04      	ldr	r3, [pc, #16]	; (80012a8 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 8001298:	695b      	ldr	r3, [r3, #20]
  {
    return HAL_TIMEOUT;
  }
  
  return HAL_OK;
 800129a:	f413 7f00 	tst.w	r3, #512	; 0x200
}
 800129e:	bf14      	ite	ne
 80012a0:	2003      	movne	r0, #3
 80012a2:	2000      	moveq	r0, #0
 80012a4:	4770      	bx	lr
 80012a6:	bf00      	nop
 80012a8:	40007000 	.word	0x40007000
 80012ac:	20000000 	.word	0x20000000
 80012b0:	431bde83 	.word	0x431bde83

080012b4 <HAL_PWREx_EnterSTOP1Mode>:
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* Stop 1 mode with Main Regulator */
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1MR);
 80012b4:	4a0c      	ldr	r2, [pc, #48]	; (80012e8 <HAL_PWREx_EnterSTOP1Mode+0x34>)
 80012b6:	6813      	ldr	r3, [r2, #0]
 80012b8:	f023 0307 	bic.w	r3, r3, #7
{
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    
  if (Regulator == PWR_MAINREGULATOR_ON)
 80012bc:	b108      	cbz	r0, 80012c2 <HAL_PWREx_EnterSTOP1Mode+0xe>
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1MR);
  }
  else
  {
    /* Stop 1 mode with Low-Power Regulator */
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1LPR);
 80012be:	f043 0301 	orr.w	r3, r3, #1
 80012c2:	6013      	str	r3, [r2, #0]
  }

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 80012c4:	4a09      	ldr	r2, [pc, #36]	; (80012ec <HAL_PWREx_EnterSTOP1Mode+0x38>)
 80012c6:	6913      	ldr	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 80012c8:	2901      	cmp	r1, #1
    /* Stop 1 mode with Low-Power Regulator */
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1LPR);
  }

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 80012ca:	f043 0304 	orr.w	r3, r3, #4
 80012ce:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 80012d0:	d008      	beq.n	80012e4 <HAL_PWREx_EnterSTOP1Mode+0x30>

    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
{
  __ASM volatile ("sev");
 80012d2:	bf40      	sev
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 80012d4:	bf20      	wfe
 80012d6:	bf20      	wfe
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 80012d8:	4a04      	ldr	r2, [pc, #16]	; (80012ec <HAL_PWREx_EnterSTOP1Mode+0x38>)
 80012da:	6913      	ldr	r3, [r2, #16]
 80012dc:	f023 0304 	bic.w	r3, r3, #4
 80012e0:	6113      	str	r3, [r2, #16]
 80012e2:	4770      	bx	lr
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 80012e4:	bf30      	wfi
 80012e6:	e7f7      	b.n	80012d8 <HAL_PWREx_EnterSTOP1Mode+0x24>
 80012e8:	40007000 	.word	0x40007000
 80012ec:	e000ed00 	.word	0xe000ed00

080012f0 <HAL_PWREx_EnterSTOP2Mode>:
{
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);
 80012f0:	490c      	ldr	r1, [pc, #48]	; (8001324 <HAL_PWREx_EnterSTOP2Mode+0x34>)


  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 80012f2:	4a0d      	ldr	r2, [pc, #52]	; (8001328 <HAL_PWREx_EnterSTOP2Mode+0x38>)
{
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);
 80012f4:	680b      	ldr	r3, [r1, #0]
 80012f6:	f023 0307 	bic.w	r3, r3, #7
 80012fa:	f043 0302 	orr.w	r3, r3, #2
 80012fe:	600b      	str	r3, [r1, #0]


  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 8001300:	6913      	ldr	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 8001302:	2801      	cmp	r0, #1
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);


  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 8001304:	f043 0304 	orr.w	r3, r3, #4
 8001308:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 800130a:	d008      	beq.n	800131e <HAL_PWREx_EnterSTOP2Mode+0x2e>

    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
{
  __ASM volatile ("sev");
 800130c:	bf40      	sev
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 800130e:	bf20      	wfe
 8001310:	bf20      	wfe
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 8001312:	4a05      	ldr	r2, [pc, #20]	; (8001328 <HAL_PWREx_EnterSTOP2Mode+0x38>)
 8001314:	6913      	ldr	r3, [r2, #16]
 8001316:	f023 0304 	bic.w	r3, r3, #4
 800131a:	6113      	str	r3, [r2, #16]
 800131c:	4770      	bx	lr
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 800131e:	bf30      	wfi
 8001320:	e7f7      	b.n	8001312 <HAL_PWREx_EnterSTOP2Mode+0x22>
 8001322:	bf00      	nop
 8001324:	40007000 	.word	0x40007000
 8001328:	e000ed00 	.word	0xe000ed00

0800132c <HAL_PWREx_EnterSHUTDOWNMode>:
  */
void HAL_PWREx_EnterSHUTDOWNMode(void)
{
  
  /* Set Shutdown mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_SHUTDOWN);
 800132c:	4906      	ldr	r1, [pc, #24]	; (8001348 <HAL_PWREx_EnterSHUTDOWNMode+0x1c>)
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800132e:	4a07      	ldr	r2, [pc, #28]	; (800134c <HAL_PWREx_EnterSHUTDOWNMode+0x20>)
  */
void HAL_PWREx_EnterSHUTDOWNMode(void)
{
  
  /* Set Shutdown mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_SHUTDOWN);
 8001330:	680b      	ldr	r3, [r1, #0]
 8001332:	f023 0307 	bic.w	r3, r3, #7
 8001336:	f043 0304 	orr.w	r3, r3, #4
 800133a:	600b      	str	r3, [r1, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800133c:	6913      	ldr	r3, [r2, #16]
 800133e:	f043 0304 	orr.w	r3, r3, #4
 8001342:	6113      	str	r3, [r2, #16]
 8001344:	bf30      	wfi
 8001346:	4770      	bx	lr
 8001348:	40007000 	.word	0x40007000
 800134c:	e000ed00 	.word	0xe000ed00

08001350 <HAL_PWREx_PVM1Callback>:
/**
  * @brief PWR PVM1 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM1Callback(void)
{
 8001350:	4770      	bx	lr
 8001352:	bf00      	nop

08001354 <HAL_PWREx_PVM2Callback>:
/**
  * @brief PWR PVM2 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM2Callback(void)
{
 8001354:	4770      	bx	lr
 8001356:	bf00      	nop

08001358 <HAL_PWREx_PVM3Callback>:
/**
  * @brief PWR PVM3 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM3Callback(void)
{
 8001358:	4770      	bx	lr
 800135a:	bf00      	nop

0800135c <HAL_PWREx_PVM4Callback>:
/**
  * @brief PWR PVM4 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM4Callback(void)
{
 800135c:	4770      	bx	lr
 800135e:	bf00      	nop

08001360 <HAL_PWREx_PVD_PVM_IRQHandler>:
  * @brief This function handles the PWR PVD/PVMx interrupt request.
  * @note This API should be called under the PVD_PVM_IRQHandler().  
  * @retval None
  */
void HAL_PWREx_PVD_PVM_IRQHandler(void)
{
 8001360:	b510      	push	{r4, lr}
  /* Check PWR exti flag */
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 8001362:	4c17      	ldr	r4, [pc, #92]	; (80013c0 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 8001364:	6963      	ldr	r3, [r4, #20]
 8001366:	03db      	lsls	r3, r3, #15
 8001368:	d423      	bmi.n	80013b2 <HAL_PWREx_PVD_PVM_IRQHandler+0x52>
    /* Clear PVD exti pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
  }
  /* Next, successively check PVMx exti flags */
#if defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx)
  if(__HAL_PWR_PVM1_EXTI_GET_FLAG() != RESET) 
 800136a:	4c15      	ldr	r4, [pc, #84]	; (80013c0 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 800136c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800136e:	0718      	lsls	r0, r3, #28
 8001370:	d41a      	bmi.n	80013a8 <HAL_PWREx_PVD_PVM_IRQHandler+0x48>
   
    /* Clear PVM1 exti pending bit */
    __HAL_PWR_PVM1_EXTI_CLEAR_FLAG();
  }
#endif /* defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) */
  if(__HAL_PWR_PVM2_EXTI_GET_FLAG() != RESET) 
 8001372:	4c13      	ldr	r4, [pc, #76]	; (80013c0 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 8001374:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001376:	06d9      	lsls	r1, r3, #27
 8001378:	d411      	bmi.n	800139e <HAL_PWREx_PVD_PVM_IRQHandler+0x3e>
    HAL_PWREx_PVM2Callback();
   
    /* Clear PVM2 exti pending bit */
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
  }
  if(__HAL_PWR_PVM3_EXTI_GET_FLAG() != RESET) 
 800137a:	4c11      	ldr	r4, [pc, #68]	; (80013c0 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 800137c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800137e:	069a      	lsls	r2, r3, #26
 8001380:	d408      	bmi.n	8001394 <HAL_PWREx_PVD_PVM_IRQHandler+0x34>
    HAL_PWREx_PVM3Callback();
   
    /* Clear PVM3 exti pending bit */
    __HAL_PWR_PVM3_EXTI_CLEAR_FLAG();
  }
  if(__HAL_PWR_PVM4_EXTI_GET_FLAG() != RESET) 
 8001382:	4c0f      	ldr	r4, [pc, #60]	; (80013c0 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 8001384:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001386:	065b      	lsls	r3, r3, #25
 8001388:	d503      	bpl.n	8001392 <HAL_PWREx_PVD_PVM_IRQHandler+0x32>
  {
    /* PWR PVM4 interrupt user callback */
    HAL_PWREx_PVM4Callback();
 800138a:	f7ff ffe7 	bl	800135c <HAL_PWREx_PVM4Callback>
   
    /* Clear PVM4 exti pending bit */
    __HAL_PWR_PVM4_EXTI_CLEAR_FLAG();
 800138e:	2340      	movs	r3, #64	; 0x40
 8001390:	6363      	str	r3, [r4, #52]	; 0x34
 8001392:	bd10      	pop	{r4, pc}
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
  }
  if(__HAL_PWR_PVM3_EXTI_GET_FLAG() != RESET) 
  {
    /* PWR PVM3 interrupt user callback */
    HAL_PWREx_PVM3Callback();
 8001394:	f7ff ffe0 	bl	8001358 <HAL_PWREx_PVM3Callback>
   
    /* Clear PVM3 exti pending bit */
    __HAL_PWR_PVM3_EXTI_CLEAR_FLAG();
 8001398:	2320      	movs	r3, #32
 800139a:	6363      	str	r3, [r4, #52]	; 0x34
 800139c:	e7f1      	b.n	8001382 <HAL_PWREx_PVD_PVM_IRQHandler+0x22>
  }
#endif /* defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) */
  if(__HAL_PWR_PVM2_EXTI_GET_FLAG() != RESET) 
  {
    /* PWR PVM2 interrupt user callback */
    HAL_PWREx_PVM2Callback();
 800139e:	f7ff ffd9 	bl	8001354 <HAL_PWREx_PVM2Callback>
   
    /* Clear PVM2 exti pending bit */
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
 80013a2:	2310      	movs	r3, #16
 80013a4:	6363      	str	r3, [r4, #52]	; 0x34
 80013a6:	e7e8      	b.n	800137a <HAL_PWREx_PVD_PVM_IRQHandler+0x1a>
  /* Next, successively check PVMx exti flags */
#if defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx)
  if(__HAL_PWR_PVM1_EXTI_GET_FLAG() != RESET) 
  {
    /* PWR PVM1 interrupt user callback */
    HAL_PWREx_PVM1Callback();
 80013a8:	f7ff ffd2 	bl	8001350 <HAL_PWREx_PVM1Callback>
   
    /* Clear PVM1 exti pending bit */
    __HAL_PWR_PVM1_EXTI_CLEAR_FLAG();
 80013ac:	2308      	movs	r3, #8
 80013ae:	6363      	str	r3, [r4, #52]	; 0x34
 80013b0:	e7df      	b.n	8001372 <HAL_PWREx_PVD_PVM_IRQHandler+0x12>
{
  /* Check PWR exti flag */
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
  {
    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback();
 80013b2:	f001 f829 	bl	8002408 <HAL_PWR_PVDCallback>

    /* Clear PVD exti pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 80013b6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80013ba:	6163      	str	r3, [r4, #20]
 80013bc:	e7d5      	b.n	800136a <HAL_PWREx_PVD_PVM_IRQHandler+0xa>
 80013be:	bf00      	nop
 80013c0:	40010400 	.word	0x40010400

080013c4 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 80013c4:	b530      	push	{r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 80013c6:	4d20      	ldr	r5, [pc, #128]	; (8001448 <RCC_SetFlashLatencyFromMSIRange+0x84>)
 80013c8:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80013ca:	00db      	lsls	r3, r3, #3
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 80013cc:	b083      	sub	sp, #12
 80013ce:	4604      	mov	r4, r0
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 80013d0:	d51a      	bpl.n	8001408 <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    vos = HAL_PWREx_GetVoltageRange();
 80013d2:	f7ff fc23 	bl	8000c1c <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80013d6:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80013da:	d027      	beq.n	800142c <RCC_SetFlashLatencyFromMSIRange+0x68>
    }
    /* else MSI <= 16Mhz default FLASH_LATENCY_0 0WS */
  }
  else
  {
    if(msirange > RCC_MSIRANGE_8)
 80013dc:	2c80      	cmp	r4, #128	; 0x80
 80013de:	d82c      	bhi.n	800143a <RCC_SetFlashLatencyFromMSIRange+0x76>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 80013e0:	d02f      	beq.n	8001442 <RCC_SetFlashLatencyFromMSIRange+0x7e>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else if(msirange == RCC_MSIRANGE_7) 
 80013e2:	f1a4 0270 	sub.w	r2, r4, #112	; 0x70
 80013e6:	fab2 f282 	clz	r2, r2
 80013ea:	0952      	lsrs	r2, r2, #5
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
  }
       
  __HAL_FLASH_SET_LATENCY(latency);
 80013ec:	4917      	ldr	r1, [pc, #92]	; (800144c <RCC_SetFlashLatencyFromMSIRange+0x88>)
 80013ee:	680b      	ldr	r3, [r1, #0]
 80013f0:	f023 0307 	bic.w	r3, r3, #7
 80013f4:	4313      	orrs	r3, r2
 80013f6:	600b      	str	r3, [r1, #0]
  
  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 80013f8:	6808      	ldr	r0, [r1, #0]
 80013fa:	f000 0007 	and.w	r0, r0, #7
  {
    return HAL_ERROR;
  }
  
  return HAL_OK;
}
 80013fe:	1a10      	subs	r0, r2, r0
 8001400:	bf18      	it	ne
 8001402:	2001      	movne	r0, #1
 8001404:	b003      	add	sp, #12
 8001406:	bd30      	pop	{r4, r5, pc}
  {
    vos = HAL_PWREx_GetVoltageRange();
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8001408:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800140a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800140e:	65ab      	str	r3, [r5, #88]	; 0x58
 8001410:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8001412:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001416:	9301      	str	r3, [sp, #4]
 8001418:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 800141a:	f7ff fbff 	bl	8000c1c <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 800141e:	6dab      	ldr	r3, [r5, #88]	; 0x58
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001420:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
 8001424:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001428:	65ab      	str	r3, [r5, #88]	; 0x58
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 800142a:	d1d7      	bne.n	80013dc <RCC_SetFlashLatencyFromMSIRange+0x18>
  {
    if(msirange > RCC_MSIRANGE_8)
 800142c:	2c80      	cmp	r4, #128	; 0x80
 800142e:	d906      	bls.n	800143e <RCC_SetFlashLatencyFromMSIRange+0x7a>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 8001430:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 8001432:	bf8c      	ite	hi
 8001434:	2202      	movhi	r2, #2
 8001436:	2201      	movls	r2, #1
 8001438:	e7d8      	b.n	80013ec <RCC_SetFlashLatencyFromMSIRange+0x28>
  else
  {
    if(msirange > RCC_MSIRANGE_8)
    {
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
 800143a:	2203      	movs	r2, #3
 800143c:	e7d6      	b.n	80013ec <RCC_SetFlashLatencyFromMSIRange+0x28>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 800143e:	2200      	movs	r2, #0
 8001440:	e7d4      	b.n	80013ec <RCC_SetFlashLatencyFromMSIRange+0x28>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 8001442:	2202      	movs	r2, #2
 8001444:	e7d2      	b.n	80013ec <RCC_SetFlashLatencyFromMSIRange+0x28>
 8001446:	bf00      	nop
 8001448:	40021000 	.word	0x40021000
 800144c:	40022000 	.word	0x40022000

08001450 <HAL_RCC_DeInit>:
  * @retval None
  */
void HAL_RCC_DeInit(void)
{
  /* Set MSION bit */
  SET_BIT(RCC->CR, RCC_CR_MSION);
 8001450:	4a16      	ldr	r2, [pc, #88]	; (80014ac <HAL_RCC_DeInit+0x5c>)
 8001452:	6813      	ldr	r3, [r2, #0]
 8001454:	f043 0301 	orr.w	r3, r3, #1
 8001458:	6013      	str	r3, [r2, #0]

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET) { __NOP(); }
 800145a:	6813      	ldr	r3, [r2, #0]
 800145c:	0799      	lsls	r1, r3, #30
 800145e:	d403      	bmi.n	8001468 <HAL_RCC_DeInit+0x18>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 8001460:	bf00      	nop
 8001462:	6813      	ldr	r3, [r2, #0]
 8001464:	079b      	lsls	r3, r3, #30
 8001466:	d5fb      	bpl.n	8001460 <HAL_RCC_DeInit+0x10>
  
  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 8001468:	4b10      	ldr	r3, [pc, #64]	; (80014ac <HAL_RCC_DeInit+0x5c>)
  
  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
 800146a:	4811      	ldr	r0, [pc, #68]	; (80014b0 <HAL_RCC_DeInit+0x60>)

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET) { __NOP(); }
  
  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 800146c:	6819      	ldr	r1, [r3, #0]
 800146e:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  
  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);
 8001472:	2200      	movs	r2, #0

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET) { __NOP(); }
  
  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 8001474:	f041 0160 	orr.w	r1, r1, #96	; 0x60
 8001478:	6019      	str	r1, [r3, #0]
  
  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);
 800147a:	609a      	str	r2, [r3, #8]

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
 800147c:	6819      	ldr	r1, [r3, #0]
 800147e:	4008      	ands	r0, r1
 8001480:	6018      	str	r0, [r3, #0]

  /* Reset PLLCFGR register */
  CLEAR_REG(RCC->PLLCFGR);
 8001482:	60da      	str	r2, [r3, #12]
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN_4 );
 8001484:	68d9      	ldr	r1, [r3, #12]
 8001486:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 800148a:	60d9      	str	r1, [r3, #12]

  /* Reset PLLSAI1CFGR register */
  CLEAR_REG(RCC->PLLSAI1CFGR);
 800148c:	611a      	str	r2, [r3, #16]
  SET_BIT(RCC->PLLSAI1CFGR,  RCC_PLLSAI1CFGR_PLLSAI1N_4 );
 800148e:	6919      	ldr	r1, [r3, #16]
 8001490:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8001494:	6119      	str	r1, [r3, #16]

  /* Reset PLLSAI2CFGR register */
  CLEAR_REG(RCC->PLLSAI2CFGR);
 8001496:	615a      	str	r2, [r3, #20]
  SET_BIT(RCC->PLLSAI2CFGR,  RCC_PLLSAI2CFGR_PLLSAI2N_4 );
 8001498:	6959      	ldr	r1, [r3, #20]
 800149a:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 800149e:	6159      	str	r1, [r3, #20]

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 80014a0:	6819      	ldr	r1, [r3, #0]
 80014a2:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 80014a6:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
 80014a8:	619a      	str	r2, [r3, #24]
 80014aa:	4770      	bx	lr
 80014ac:	40021000 	.word	0x40021000
 80014b0:	eaf6f4ff 	.word	0xeaf6f4ff

080014b4 <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80014b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80014b8:	6803      	ldr	r3, [r0, #0]
 80014ba:	06dd      	lsls	r5, r3, #27
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80014bc:	b083      	sub	sp, #12
 80014be:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80014c0:	d53f      	bpl.n	8001542 <HAL_RCC_OscConfig+0x8e>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 80014c2:	4bc4      	ldr	r3, [pc, #784]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
 80014c4:	689a      	ldr	r2, [r3, #8]
 80014c6:	f012 0f0c 	tst.w	r2, #12
 80014ca:	f040 8174 	bne.w	80017b6 <HAL_RCC_OscConfig+0x302>
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80014ce:	2202      	movs	r2, #2
 80014d0:	fa92 f1a2 	rbit	r1, r2
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 80014d4:	681b      	ldr	r3, [r3, #0]
 80014d6:	fa92 f2a2 	rbit	r2, r2
 80014da:	fab2 f282 	clz	r2, r2
 80014de:	f002 021f 	and.w	r2, r2, #31
 80014e2:	40d3      	lsrs	r3, r2
 80014e4:	07d8      	lsls	r0, r3, #31
 80014e6:	d503      	bpl.n	80014f0 <HAL_RCC_OscConfig+0x3c>
 80014e8:	69a3      	ldr	r3, [r4, #24]
 80014ea:	2b00      	cmp	r3, #0
 80014ec:	f000 81f9 	beq.w	80018e2 <HAL_RCC_OscConfig+0x42e>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80014f0:	4bb8      	ldr	r3, [pc, #736]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
 80014f2:	6a20      	ldr	r0, [r4, #32]
 80014f4:	681a      	ldr	r2, [r3, #0]
 80014f6:	0711      	lsls	r1, r2, #28
 80014f8:	f100 8239 	bmi.w	800196e <HAL_RCC_OscConfig+0x4ba>
 80014fc:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8001500:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8001504:	091b      	lsrs	r3, r3, #4
 8001506:	4283      	cmp	r3, r0
 8001508:	f080 8237 	bcs.w	800197a <HAL_RCC_OscConfig+0x4c6>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800150c:	f7ff ff5a 	bl	80013c4 <RCC_SetFlashLatencyFromMSIRange>
 8001510:	2800      	cmp	r0, #0
 8001512:	f040 81e6 	bne.w	80018e2 <HAL_RCC_OscConfig+0x42e>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8001516:	4baf      	ldr	r3, [pc, #700]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
 8001518:	681a      	ldr	r2, [r3, #0]
 800151a:	f042 0208 	orr.w	r2, r2, #8
 800151e:	601a      	str	r2, [r3, #0]
 8001520:	6819      	ldr	r1, [r3, #0]
 8001522:	6a22      	ldr	r2, [r4, #32]
 8001524:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8001528:	430a      	orrs	r2, r1
 800152a:	601a      	str	r2, [r3, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800152c:	685a      	ldr	r2, [r3, #4]
 800152e:	69e1      	ldr	r1, [r4, #28]
 8001530:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8001534:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001538:	605a      	str	r2, [r3, #4]
            return HAL_ERROR;
          }          
        }

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 800153a:	2000      	movs	r0, #0
 800153c:	f7fe ff6c 	bl	8000418 <HAL_InitTick>
 8001540:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001542:	07de      	lsls	r6, r3, #31
 8001544:	d563      	bpl.n	800160e <HAL_RCC_OscConfig+0x15a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
 8001546:	49a3      	ldr	r1, [pc, #652]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
 8001548:	688a      	ldr	r2, [r1, #8]
 800154a:	f002 020c 	and.w	r2, r2, #12
 800154e:	2a08      	cmp	r2, #8
 8001550:	f000 81b2 	beq.w	80018b8 <HAL_RCC_OscConfig+0x404>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8001554:	688a      	ldr	r2, [r1, #8]
 8001556:	f002 020c 	and.w	r2, r2, #12
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
 800155a:	2a0c      	cmp	r2, #12
 800155c:	f000 81a6 	beq.w	80018ac <HAL_RCC_OscConfig+0x3f8>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8001560:	4d9c      	ldr	r5, [pc, #624]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
 8001562:	682b      	ldr	r3, [r5, #0]
 8001564:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001568:	602b      	str	r3, [r5, #0]
 800156a:	682b      	ldr	r3, [r5, #0]
 800156c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001570:	602b      	str	r3, [r5, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001572:	f7fe ff7f 	bl	8000474 <HAL_GetTick>
 8001576:	f44f 3800 	mov.w	r8, #131072	; 0x20000
 800157a:	4607      	mov	r7, r0

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800157c:	f241 3688 	movw	r6, #5000	; 0x1388

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001580:	e005      	b.n	800158e <HAL_RCC_OscConfig+0xda>
      {
        if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001582:	f7fe ff77 	bl	8000474 <HAL_GetTick>
 8001586:	1bc0      	subs	r0, r0, r7
 8001588:	42b0      	cmp	r0, r6
 800158a:	f200 814d 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 800158e:	fa98 f3a8 	rbit	r3, r8

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001592:	4990      	ldr	r1, [pc, #576]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
 8001594:	682a      	ldr	r2, [r5, #0]
 8001596:	fa98 f3a8 	rbit	r3, r8
 800159a:	fab3 f383 	clz	r3, r3
 800159e:	f003 031f 	and.w	r3, r3, #31
 80015a2:	fa22 f303 	lsr.w	r3, r2, r3
 80015a6:	07d8      	lsls	r0, r3, #31
 80015a8:	d4eb      	bmi.n	8001582 <HAL_RCC_OscConfig+0xce>
          return HAL_TIMEOUT;
        }
      }

      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80015aa:	6863      	ldr	r3, [r4, #4]
 80015ac:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80015b0:	f000 82b7 	beq.w	8001b22 <HAL_RCC_OscConfig+0x66e>
 80015b4:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80015b8:	680b      	ldr	r3, [r1, #0]
 80015ba:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80015be:	600b      	str	r3, [r1, #0]
 80015c0:	680b      	ldr	r3, [r1, #0]
 80015c2:	f000 82ab 	beq.w	8001b1c <HAL_RCC_OscConfig+0x668>
 80015c6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80015ca:	600b      	str	r3, [r1, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80015cc:	6863      	ldr	r3, [r4, #4]
 80015ce:	2b00      	cmp	r3, #0
 80015d0:	f000 8284 	beq.w	8001adc <HAL_RCC_OscConfig+0x628>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80015d4:	f7fe ff4e 	bl	8000474 <HAL_GetTick>
 80015d8:	f44f 3800 	mov.w	r8, #131072	; 0x20000
 80015dc:	4607      	mov	r7, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80015de:	4d7d      	ldr	r5, [pc, #500]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80015e0:	f241 3688 	movw	r6, #5000	; 0x1388
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80015e4:	e005      	b.n	80015f2 <HAL_RCC_OscConfig+0x13e>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80015e6:	f7fe ff45 	bl	8000474 <HAL_GetTick>
 80015ea:	1bc0      	subs	r0, r0, r7
 80015ec:	42b0      	cmp	r0, r6
 80015ee:	f200 811b 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 80015f2:	fa98 f3a8 	rbit	r3, r8
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80015f6:	682a      	ldr	r2, [r5, #0]
 80015f8:	fa98 f3a8 	rbit	r3, r8
 80015fc:	fab3 f383 	clz	r3, r3
 8001600:	f003 031f 	and.w	r3, r3, #31
 8001604:	fa22 f303 	lsr.w	r3, r2, r3
 8001608:	07da      	lsls	r2, r3, #31
 800160a:	d5ec      	bpl.n	80015e6 <HAL_RCC_OscConfig+0x132>
 800160c:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800160e:	0798      	lsls	r0, r3, #30
 8001610:	f100 8093 	bmi.w	800173a <HAL_RCC_OscConfig+0x286>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001614:	0718      	lsls	r0, r3, #28
 8001616:	d528      	bpl.n	800166a <HAL_RCC_OscConfig+0x1b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001618:	6963      	ldr	r3, [r4, #20]
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800161a:	4e6e      	ldr	r6, [pc, #440]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800161c:	2b00      	cmp	r3, #0
 800161e:	f000 8182 	beq.w	8001926 <HAL_RCC_OscConfig+0x472>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001622:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8001626:	f043 0301 	orr.w	r3, r3, #1
 800162a:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800162e:	f7fe ff21 	bl	8000474 <HAL_GetTick>
 8001632:	2502      	movs	r5, #2
 8001634:	4607      	mov	r7, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001636:	e005      	b.n	8001644 <HAL_RCC_OscConfig+0x190>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001638:	f7fe ff1c 	bl	8000474 <HAL_GetTick>
 800163c:	1bc0      	subs	r0, r0, r7
 800163e:	2864      	cmp	r0, #100	; 0x64
 8001640:	f200 80f2 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 8001644:	fa95 f3a5 	rbit	r3, r5
 8001648:	fa95 f3a5 	rbit	r3, r5
 800164c:	fa95 f3a5 	rbit	r3, r5

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001650:	f8d6 2094 	ldr.w	r2, [r6, #148]	; 0x94
 8001654:	fa95 f3a5 	rbit	r3, r5
 8001658:	fab3 f383 	clz	r3, r3
 800165c:	f003 031f 	and.w	r3, r3, #31
 8001660:	fa22 f303 	lsr.w	r3, r2, r3
 8001664:	07d9      	lsls	r1, r3, #31
 8001666:	d5e7      	bpl.n	8001638 <HAL_RCC_OscConfig+0x184>
 8001668:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800166a:	075b      	lsls	r3, r3, #29
 800166c:	f140 80e8 	bpl.w	8001840 <HAL_RCC_OscConfig+0x38c>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8001670:	4b58      	ldr	r3, [pc, #352]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
 8001672:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001674:	00d7      	lsls	r7, r2, #3
 8001676:	f100 81e1 	bmi.w	8001a3c <HAL_RCC_OscConfig+0x588>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800167a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800167c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001680:	659a      	str	r2, [r3, #88]	; 0x58
 8001682:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001684:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001688:	9301      	str	r3, [sp, #4]
 800168a:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 800168c:	f04f 0801 	mov.w	r8, #1
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001690:	4d51      	ldr	r5, [pc, #324]	; (80017d8 <HAL_RCC_OscConfig+0x324>)
 8001692:	682b      	ldr	r3, [r5, #0]
 8001694:	05de      	lsls	r6, r3, #23
 8001696:	d410      	bmi.n	80016ba <HAL_RCC_OscConfig+0x206>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8001698:	682b      	ldr	r3, [r5, #0]
 800169a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800169e:	602b      	str	r3, [r5, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80016a0:	f7fe fee8 	bl	8000474 <HAL_GetTick>
 80016a4:	4606      	mov	r6, r0

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80016a6:	e005      	b.n	80016b4 <HAL_RCC_OscConfig+0x200>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80016a8:	f7fe fee4 	bl	8000474 <HAL_GetTick>
 80016ac:	1b80      	subs	r0, r0, r6
 80016ae:	2864      	cmp	r0, #100	; 0x64
 80016b0:	f200 80ba 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80016b4:	682b      	ldr	r3, [r5, #0]
 80016b6:	05d8      	lsls	r0, r3, #23
 80016b8:	d5f6      	bpl.n	80016a8 <HAL_RCC_OscConfig+0x1f4>
        }
      }
    }

    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 80016ba:	4d46      	ldr	r5, [pc, #280]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
 80016bc:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 80016c0:	f023 0301 	bic.w	r3, r3, #1
 80016c4:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
 80016c8:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 80016cc:	f023 0304 	bic.w	r3, r3, #4
 80016d0:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80016d4:	f7fe fece 	bl	8000474 <HAL_GetTick>
 80016d8:	f04f 0902 	mov.w	r9, #2
 80016dc:	4607      	mov	r7, r0

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    {
      if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80016de:	f241 3688 	movw	r6, #5000	; 0x1388

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80016e2:	e01c      	b.n	800171e <HAL_RCC_OscConfig+0x26a>
 80016e4:	fa99 f3a9 	rbit	r3, r9
 80016e8:	fab3 f383 	clz	r3, r3
 80016ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80016f0:	095b      	lsrs	r3, r3, #5
 80016f2:	2b03      	cmp	r3, #3
 80016f4:	bf0c      	ite	eq
 80016f6:	f8d5 2094 	ldreq.w	r2, [r5, #148]	; 0x94
 80016fa:	69ea      	ldrne	r2, [r5, #28]
 80016fc:	fa99 f3a9 	rbit	r3, r9
 8001700:	fab3 f383 	clz	r3, r3
 8001704:	f003 031f 	and.w	r3, r3, #31
 8001708:	fa22 f303 	lsr.w	r3, r2, r3
 800170c:	07d9      	lsls	r1, r3, #31
 800170e:	f140 8198 	bpl.w	8001a42 <HAL_RCC_OscConfig+0x58e>
    {
      if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001712:	f7fe feaf 	bl	8000474 <HAL_GetTick>
 8001716:	1bc0      	subs	r0, r0, r7
 8001718:	42b0      	cmp	r0, r6
 800171a:	f200 8085 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 800171e:	fa99 f3a9 	rbit	r3, r9
 8001722:	fa99 f3a9 	rbit	r3, r9

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001726:	fab3 f383 	clz	r3, r3
 800172a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800172e:	095b      	lsrs	r3, r3, #5
 8001730:	2b02      	cmp	r3, #2
 8001732:	d1d7      	bne.n	80016e4 <HAL_RCC_OscConfig+0x230>
 8001734:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8001738:	e7e0      	b.n	80016fc <HAL_RCC_OscConfig+0x248>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 800173a:	4a26      	ldr	r2, [pc, #152]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
 800173c:	6893      	ldr	r3, [r2, #8]
 800173e:	f003 030c 	and.w	r3, r3, #12
 8001742:	2b04      	cmp	r3, #4
 8001744:	f000 8138 	beq.w	80019b8 <HAL_RCC_OscConfig+0x504>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8001748:	6893      	ldr	r3, [r2, #8]
 800174a:	f003 030c 	and.w	r3, r3, #12
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 800174e:	2b0c      	cmp	r3, #12
 8001750:	f000 812c 	beq.w	80019ac <HAL_RCC_OscConfig+0x4f8>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8001754:	68e3      	ldr	r3, [r4, #12]
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001756:	4d1f      	ldr	r5, [pc, #124]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8001758:	2b00      	cmp	r3, #0
 800175a:	f000 8150 	beq.w	80019fe <HAL_RCC_OscConfig+0x54a>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800175e:	682b      	ldr	r3, [r5, #0]
 8001760:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001764:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001766:	f7fe fe85 	bl	8000474 <HAL_GetTick>
 800176a:	f44f 6780 	mov.w	r7, #1024	; 0x400
 800176e:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001770:	e004      	b.n	800177c <HAL_RCC_OscConfig+0x2c8>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001772:	f7fe fe7f 	bl	8000474 <HAL_GetTick>
 8001776:	1b80      	subs	r0, r0, r6
 8001778:	2864      	cmp	r0, #100	; 0x64
 800177a:	d855      	bhi.n	8001828 <HAL_RCC_OscConfig+0x374>
 800177c:	fa97 f3a7 	rbit	r3, r7

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001780:	4914      	ldr	r1, [pc, #80]	; (80017d4 <HAL_RCC_OscConfig+0x320>)
 8001782:	682a      	ldr	r2, [r5, #0]
 8001784:	fa97 f3a7 	rbit	r3, r7
 8001788:	fab3 f383 	clz	r3, r3
 800178c:	f003 031f 	and.w	r3, r3, #31
 8001790:	fa22 f303 	lsr.w	r3, r2, r3
 8001794:	07da      	lsls	r2, r3, #31
 8001796:	d5ec      	bpl.n	8001772 <HAL_RCC_OscConfig+0x2be>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001798:	684a      	ldr	r2, [r1, #4]
 800179a:	f04f 50f8 	mov.w	r0, #520093696	; 0x1f000000
 800179e:	fa90 f0a0 	rbit	r0, r0
 80017a2:	6923      	ldr	r3, [r4, #16]
 80017a4:	fab0 f080 	clz	r0, r0
 80017a8:	f022 52f8 	bic.w	r2, r2, #520093696	; 0x1f000000
 80017ac:	4083      	lsls	r3, r0
 80017ae:	4313      	orrs	r3, r2
 80017b0:	604b      	str	r3, [r1, #4]
 80017b2:	6823      	ldr	r3, [r4, #0]
 80017b4:	e72e      	b.n	8001614 <HAL_RCC_OscConfig+0x160>
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80017b6:	6982      	ldr	r2, [r0, #24]
 80017b8:	2a00      	cmp	r2, #0
 80017ba:	f000 8096 	beq.w	80018ea <HAL_RCC_OscConfig+0x436>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 80017be:	681a      	ldr	r2, [r3, #0]
 80017c0:	f042 0201 	orr.w	r2, r2, #1
 80017c4:	601a      	str	r2, [r3, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 80017c6:	461d      	mov	r5, r3
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();

        /* Get timeout */
        tickstart = HAL_GetTick();
 80017c8:	f7fe fe54 	bl	8000474 <HAL_GetTick>
 80017cc:	2702      	movs	r7, #2
 80017ce:	4606      	mov	r6, r0

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 80017d0:	e009      	b.n	80017e6 <HAL_RCC_OscConfig+0x332>
 80017d2:	bf00      	nop
 80017d4:	40021000 	.word	0x40021000
 80017d8:	40007000 	.word	0x40007000
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80017dc:	f7fe fe4a 	bl	8000474 <HAL_GetTick>
 80017e0:	1b80      	subs	r0, r0, r6
 80017e2:	2864      	cmp	r0, #100	; 0x64
 80017e4:	d820      	bhi.n	8001828 <HAL_RCC_OscConfig+0x374>
 80017e6:	fa97 f3a7 	rbit	r3, r7

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 80017ea:	49c1      	ldr	r1, [pc, #772]	; (8001af0 <HAL_RCC_OscConfig+0x63c>)
 80017ec:	682a      	ldr	r2, [r5, #0]
 80017ee:	fa97 f3a7 	rbit	r3, r7
 80017f2:	fab3 f383 	clz	r3, r3
 80017f6:	f003 031f 	and.w	r3, r3, #31
 80017fa:	fa22 f303 	lsr.w	r3, r2, r3
 80017fe:	07da      	lsls	r2, r3, #31
 8001800:	d5ec      	bpl.n	80017dc <HAL_RCC_OscConfig+0x328>
          {
            return HAL_TIMEOUT;
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8001802:	680b      	ldr	r3, [r1, #0]
 8001804:	f043 0308 	orr.w	r3, r3, #8
 8001808:	600b      	str	r3, [r1, #0]
 800180a:	680a      	ldr	r2, [r1, #0]
 800180c:	6a23      	ldr	r3, [r4, #32]
 800180e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001812:	4313      	orrs	r3, r2
 8001814:	600b      	str	r3, [r1, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8001816:	684b      	ldr	r3, [r1, #4]
 8001818:	69e2      	ldr	r2, [r4, #28]
 800181a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800181e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001822:	604b      	str	r3, [r1, #4]
 8001824:	6823      	ldr	r3, [r4, #0]
 8001826:	e68c      	b.n	8001542 <HAL_RCC_OscConfig+0x8e>
        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8001828:	2003      	movs	r0, #3
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 800182a:	b003      	add	sp, #12
 800182c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8001830:	f1b8 0f00 	cmp.w	r8, #0
 8001834:	d004      	beq.n	8001840 <HAL_RCC_OscConfig+0x38c>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001836:	4aae      	ldr	r2, [pc, #696]	; (8001af0 <HAL_RCC_OscConfig+0x63c>)
 8001838:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800183a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800183e:	6593      	str	r3, [r2, #88]	; 0x58
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8001840:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001842:	b37a      	cbz	r2, 80018a4 <HAL_RCC_OscConfig+0x3f0>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001844:	4baa      	ldr	r3, [pc, #680]	; (8001af0 <HAL_RCC_OscConfig+0x63c>)
 8001846:	6899      	ldr	r1, [r3, #8]
 8001848:	f001 010c 	and.w	r1, r1, #12
 800184c:	290c      	cmp	r1, #12
 800184e:	d048      	beq.n	80018e2 <HAL_RCC_OscConfig+0x42e>
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8001850:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001852:	681a      	ldr	r2, [r3, #0]
 8001854:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8001858:	601a      	str	r2, [r3, #0]
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 800185a:	f000 81a3 	beq.w	8001ba4 <HAL_RCC_OscConfig+0x6f0>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Disable all PLL outputs to save power */
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 800185e:	68da      	ldr	r2, [r3, #12]
 8001860:	f022 0203 	bic.w	r2, r2, #3
 8001864:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 8001866:	68da      	ldr	r2, [r3, #12]
 8001868:	f022 7288 	bic.w	r2, r2, #17825792	; 0x1100000
 800186c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001870:	60da      	str	r2, [r3, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001872:	461c      	mov	r4, r3
        /* Disable all PLL outputs to save power */
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001874:	f7fe fdfe 	bl	8000474 <HAL_GetTick>
 8001878:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
 800187c:	4606      	mov	r6, r0

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800187e:	e004      	b.n	800188a <HAL_RCC_OscConfig+0x3d6>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001880:	f7fe fdf8 	bl	8000474 <HAL_GetTick>
 8001884:	1b80      	subs	r0, r0, r6
 8001886:	2864      	cmp	r0, #100	; 0x64
 8001888:	d8ce      	bhi.n	8001828 <HAL_RCC_OscConfig+0x374>
 800188a:	fa95 f3a5 	rbit	r3, r5

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800188e:	6822      	ldr	r2, [r4, #0]
 8001890:	fa95 f3a5 	rbit	r3, r5
 8001894:	fab3 f383 	clz	r3, r3
 8001898:	f003 031f 	and.w	r3, r3, #31
 800189c:	fa22 f303 	lsr.w	r3, r2, r3
 80018a0:	07db      	lsls	r3, r3, #31
 80018a2:	d4ed      	bmi.n	8001880 <HAL_RCC_OscConfig+0x3cc>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80018a4:	2000      	movs	r0, #0
}
 80018a6:	b003      	add	sp, #12
 80018a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80018ac:	68ca      	ldr	r2, [r1, #12]
 80018ae:	f002 0203 	and.w	r2, r2, #3
 80018b2:	2a03      	cmp	r2, #3
 80018b4:	f47f ae54 	bne.w	8001560 <HAL_RCC_OscConfig+0xac>
 80018b8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 80018bc:	fa92 f1a2 	rbit	r1, r2
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80018c0:	498b      	ldr	r1, [pc, #556]	; (8001af0 <HAL_RCC_OscConfig+0x63c>)
 80018c2:	6809      	ldr	r1, [r1, #0]
 80018c4:	fa92 f2a2 	rbit	r2, r2
 80018c8:	fab2 f282 	clz	r2, r2
 80018cc:	f002 021f 	and.w	r2, r2, #31
 80018d0:	fa21 f202 	lsr.w	r2, r1, r2
 80018d4:	07d5      	lsls	r5, r2, #31
 80018d6:	f57f ae9a 	bpl.w	800160e <HAL_RCC_OscConfig+0x15a>
 80018da:	6862      	ldr	r2, [r4, #4]
 80018dc:	2a00      	cmp	r2, #0
 80018de:	f47f ae96 	bne.w	800160e <HAL_RCC_OscConfig+0x15a>
    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
      {
        return HAL_ERROR;
 80018e2:	2001      	movs	r0, #1
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 80018e4:	b003      	add	sp, #12
 80018e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 80018ea:	681a      	ldr	r2, [r3, #0]
 80018ec:	f022 0201 	bic.w	r2, r2, #1
 80018f0:	601a      	str	r2, [r3, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 80018f2:	461d      	mov	r5, r3
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();

        /* Get timeout */
        tickstart = HAL_GetTick();
 80018f4:	f7fe fdbe 	bl	8000474 <HAL_GetTick>
 80018f8:	2702      	movs	r7, #2
 80018fa:	4606      	mov	r6, r0

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 80018fc:	e004      	b.n	8001908 <HAL_RCC_OscConfig+0x454>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80018fe:	f7fe fdb9 	bl	8000474 <HAL_GetTick>
 8001902:	1b80      	subs	r0, r0, r6
 8001904:	2864      	cmp	r0, #100	; 0x64
 8001906:	d88f      	bhi.n	8001828 <HAL_RCC_OscConfig+0x374>
 8001908:	fa97 f3a7 	rbit	r3, r7

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 800190c:	682a      	ldr	r2, [r5, #0]
 800190e:	fa97 f3a7 	rbit	r3, r7
 8001912:	fab3 f383 	clz	r3, r3
 8001916:	f003 031f 	and.w	r3, r3, #31
 800191a:	fa22 f303 	lsr.w	r3, r2, r3
 800191e:	07db      	lsls	r3, r3, #31
 8001920:	d4ed      	bmi.n	80018fe <HAL_RCC_OscConfig+0x44a>
 8001922:	6823      	ldr	r3, [r4, #0]
 8001924:	e60d      	b.n	8001542 <HAL_RCC_OscConfig+0x8e>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001926:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 800192a:	f023 0301 	bic.w	r3, r3, #1
 800192e:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001932:	f7fe fd9f 	bl	8000474 <HAL_GetTick>
 8001936:	2502      	movs	r5, #2
 8001938:	4607      	mov	r7, r0

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800193a:	e005      	b.n	8001948 <HAL_RCC_OscConfig+0x494>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800193c:	f7fe fd9a 	bl	8000474 <HAL_GetTick>
 8001940:	1bc0      	subs	r0, r0, r7
 8001942:	2864      	cmp	r0, #100	; 0x64
 8001944:	f63f af70 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 8001948:	fa95 f3a5 	rbit	r3, r5
 800194c:	fa95 f3a5 	rbit	r3, r5
 8001950:	fa95 f3a5 	rbit	r3, r5

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001954:	f8d6 2094 	ldr.w	r2, [r6, #148]	; 0x94
 8001958:	fa95 f3a5 	rbit	r3, r5
 800195c:	fab3 f383 	clz	r3, r3
 8001960:	f003 031f 	and.w	r3, r3, #31
 8001964:	fa22 f303 	lsr.w	r3, r2, r3
 8001968:	07da      	lsls	r2, r3, #31
 800196a:	d4e7      	bmi.n	800193c <HAL_RCC_OscConfig+0x488>
 800196c:	e67c      	b.n	8001668 <HAL_RCC_OscConfig+0x1b4>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 800196e:	681b      	ldr	r3, [r3, #0]
 8001970:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001974:	4283      	cmp	r3, r0
 8001976:	f4ff adc9 	bcc.w	800150c <HAL_RCC_OscConfig+0x58>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800197a:	4b5d      	ldr	r3, [pc, #372]	; (8001af0 <HAL_RCC_OscConfig+0x63c>)
 800197c:	681a      	ldr	r2, [r3, #0]
 800197e:	f042 0208 	orr.w	r2, r2, #8
 8001982:	601a      	str	r2, [r3, #0]
 8001984:	6819      	ldr	r1, [r3, #0]
 8001986:	6a22      	ldr	r2, [r4, #32]
 8001988:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 800198c:	430a      	orrs	r2, r1
 800198e:	601a      	str	r2, [r3, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8001990:	685a      	ldr	r2, [r3, #4]
 8001992:	69e1      	ldr	r1, [r4, #28]
 8001994:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8001998:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800199c:	605a      	str	r2, [r3, #4]

          /* Decrease number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800199e:	6a20      	ldr	r0, [r4, #32]
 80019a0:	f7ff fd10 	bl	80013c4 <RCC_SetFlashLatencyFromMSIRange>
 80019a4:	2800      	cmp	r0, #0
 80019a6:	f43f adc8 	beq.w	800153a <HAL_RCC_OscConfig+0x86>
 80019aa:	e79a      	b.n	80018e2 <HAL_RCC_OscConfig+0x42e>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 80019ac:	68d3      	ldr	r3, [r2, #12]
 80019ae:	f003 0303 	and.w	r3, r3, #3
 80019b2:	2b02      	cmp	r3, #2
 80019b4:	f47f aece 	bne.w	8001754 <HAL_RCC_OscConfig+0x2a0>
 80019b8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80019bc:	fa93 f2a3 	rbit	r2, r3
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80019c0:	4a4b      	ldr	r2, [pc, #300]	; (8001af0 <HAL_RCC_OscConfig+0x63c>)
 80019c2:	6812      	ldr	r2, [r2, #0]
 80019c4:	fa93 f3a3 	rbit	r3, r3
 80019c8:	fab3 f383 	clz	r3, r3
 80019cc:	f003 031f 	and.w	r3, r3, #31
 80019d0:	fa22 f303 	lsr.w	r3, r2, r3
 80019d4:	07d9      	lsls	r1, r3, #31
 80019d6:	d502      	bpl.n	80019de <HAL_RCC_OscConfig+0x52a>
 80019d8:	68e3      	ldr	r3, [r4, #12]
 80019da:	2b00      	cmp	r3, #0
 80019dc:	d081      	beq.n	80018e2 <HAL_RCC_OscConfig+0x42e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80019de:	4844      	ldr	r0, [pc, #272]	; (8001af0 <HAL_RCC_OscConfig+0x63c>)
 80019e0:	f04f 51f8 	mov.w	r1, #520093696	; 0x1f000000
 80019e4:	6842      	ldr	r2, [r0, #4]
 80019e6:	fa91 f1a1 	rbit	r1, r1
 80019ea:	6923      	ldr	r3, [r4, #16]
 80019ec:	fab1 f181 	clz	r1, r1
 80019f0:	f022 52f8 	bic.w	r2, r2, #520093696	; 0x1f000000
 80019f4:	408b      	lsls	r3, r1
 80019f6:	4313      	orrs	r3, r2
 80019f8:	6043      	str	r3, [r0, #4]
 80019fa:	6823      	ldr	r3, [r4, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80019fc:	e60a      	b.n	8001614 <HAL_RCC_OscConfig+0x160>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 80019fe:	682b      	ldr	r3, [r5, #0]
 8001a00:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001a04:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001a06:	f7fe fd35 	bl	8000474 <HAL_GetTick>
 8001a0a:	f44f 6780 	mov.w	r7, #1024	; 0x400
 8001a0e:	4606      	mov	r6, r0

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001a10:	e005      	b.n	8001a1e <HAL_RCC_OscConfig+0x56a>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001a12:	f7fe fd2f 	bl	8000474 <HAL_GetTick>
 8001a16:	1b80      	subs	r0, r0, r6
 8001a18:	2864      	cmp	r0, #100	; 0x64
 8001a1a:	f63f af05 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 8001a1e:	fa97 f3a7 	rbit	r3, r7

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001a22:	682a      	ldr	r2, [r5, #0]
 8001a24:	fa97 f3a7 	rbit	r3, r7
 8001a28:	fab3 f383 	clz	r3, r3
 8001a2c:	f003 031f 	and.w	r3, r3, #31
 8001a30:	fa22 f303 	lsr.w	r3, r2, r3
 8001a34:	07db      	lsls	r3, r3, #31
 8001a36:	d4ec      	bmi.n	8001a12 <HAL_RCC_OscConfig+0x55e>
 8001a38:	6823      	ldr	r3, [r4, #0]
 8001a3a:	e5eb      	b.n	8001614 <HAL_RCC_OscConfig+0x160>
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 8001a3c:	f04f 0800 	mov.w	r8, #0
 8001a40:	e626      	b.n	8001690 <HAL_RCC_OscConfig+0x1dc>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001a42:	68a3      	ldr	r3, [r4, #8]
 8001a44:	2b01      	cmp	r3, #1
 8001a46:	d071      	beq.n	8001b2c <HAL_RCC_OscConfig+0x678>
 8001a48:	2b00      	cmp	r3, #0
 8001a4a:	f040 8100 	bne.w	8001c4e <HAL_RCC_OscConfig+0x79a>
 8001a4e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001a52:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8001a56:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001a5a:	f022 0201 	bic.w	r2, r2, #1
 8001a5e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001a62:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001a66:	f022 0204 	bic.w	r2, r2, #4
 8001a6a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8001a6e:	68a3      	ldr	r3, [r4, #8]
 8001a70:	2b00      	cmp	r3, #0
 8001a72:	d063      	beq.n	8001b3c <HAL_RCC_OscConfig+0x688>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001a74:	f7fe fcfe 	bl	8000474 <HAL_GetTick>
 8001a78:	f04f 0902 	mov.w	r9, #2
 8001a7c:	4607      	mov	r7, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001a7e:	4d1c      	ldr	r5, [pc, #112]	; (8001af0 <HAL_RCC_OscConfig+0x63c>)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001a80:	f241 3688 	movw	r6, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001a84:	e01c      	b.n	8001ac0 <HAL_RCC_OscConfig+0x60c>
 8001a86:	fa99 f3a9 	rbit	r3, r9
 8001a8a:	fab3 f383 	clz	r3, r3
 8001a8e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001a92:	095b      	lsrs	r3, r3, #5
 8001a94:	2b03      	cmp	r3, #3
 8001a96:	bf0c      	ite	eq
 8001a98:	f8d5 2094 	ldreq.w	r2, [r5, #148]	; 0x94
 8001a9c:	69ea      	ldrne	r2, [r5, #28]
 8001a9e:	fa99 f3a9 	rbit	r3, r9
 8001aa2:	fab3 f383 	clz	r3, r3
 8001aa6:	f003 031f 	and.w	r3, r3, #31
 8001aaa:	fa22 f303 	lsr.w	r3, r2, r3
 8001aae:	07da      	lsls	r2, r3, #31
 8001ab0:	f53f aebe 	bmi.w	8001830 <HAL_RCC_OscConfig+0x37c>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001ab4:	f7fe fcde 	bl	8000474 <HAL_GetTick>
 8001ab8:	1bc0      	subs	r0, r0, r7
 8001aba:	42b0      	cmp	r0, r6
 8001abc:	f63f aeb4 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 8001ac0:	fa99 f3a9 	rbit	r3, r9
 8001ac4:	fa99 f3a9 	rbit	r3, r9
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001ac8:	fab3 f383 	clz	r3, r3
 8001acc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001ad0:	095b      	lsrs	r3, r3, #5
 8001ad2:	2b02      	cmp	r3, #2
 8001ad4:	d1d7      	bne.n	8001a86 <HAL_RCC_OscConfig+0x5d2>
 8001ad6:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8001ada:	e7e0      	b.n	8001a9e <HAL_RCC_OscConfig+0x5ea>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001adc:	f7fe fcca 	bl	8000474 <HAL_GetTick>
 8001ae0:	f44f 3800 	mov.w	r8, #131072	; 0x20000
 8001ae4:	4607      	mov	r7, r0

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001ae6:	4d02      	ldr	r5, [pc, #8]	; (8001af0 <HAL_RCC_OscConfig+0x63c>)
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001ae8:	f241 3688 	movw	r6, #5000	; 0x1388
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001aec:	e008      	b.n	8001b00 <HAL_RCC_OscConfig+0x64c>
 8001aee:	bf00      	nop
 8001af0:	40021000 	.word	0x40021000
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001af4:	f7fe fcbe 	bl	8000474 <HAL_GetTick>
 8001af8:	1bc0      	subs	r0, r0, r7
 8001afa:	42b0      	cmp	r0, r6
 8001afc:	f63f ae94 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 8001b00:	fa98 f3a8 	rbit	r3, r8
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001b04:	682a      	ldr	r2, [r5, #0]
 8001b06:	fa98 f3a8 	rbit	r3, r8
 8001b0a:	fab3 f383 	clz	r3, r3
 8001b0e:	f003 031f 	and.w	r3, r3, #31
 8001b12:	fa22 f303 	lsr.w	r3, r2, r3
 8001b16:	07db      	lsls	r3, r3, #31
 8001b18:	d4ec      	bmi.n	8001af4 <HAL_RCC_OscConfig+0x640>
 8001b1a:	e577      	b.n	800160c <HAL_RCC_OscConfig+0x158>
          return HAL_TIMEOUT;
        }
      }

      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001b1c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001b20:	600b      	str	r3, [r1, #0]
 8001b22:	680b      	ldr	r3, [r1, #0]
 8001b24:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001b28:	600b      	str	r3, [r1, #0]
 8001b2a:	e54f      	b.n	80015cc <HAL_RCC_OscConfig+0x118>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001b2c:	4a55      	ldr	r2, [pc, #340]	; (8001c84 <HAL_RCC_OscConfig+0x7d0>)
 8001b2e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8001b32:	f043 0301 	orr.w	r3, r3, #1
 8001b36:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8001b3a:	e798      	b.n	8001a6e <HAL_RCC_OscConfig+0x5ba>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001b3c:	f7fe fc9a 	bl	8000474 <HAL_GetTick>
 8001b40:	f04f 0902 	mov.w	r9, #2
 8001b44:	4607      	mov	r7, r0

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001b46:	4d4f      	ldr	r5, [pc, #316]	; (8001c84 <HAL_RCC_OscConfig+0x7d0>)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001b48:	f241 3688 	movw	r6, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001b4c:	e01c      	b.n	8001b88 <HAL_RCC_OscConfig+0x6d4>
 8001b4e:	fa99 f3a9 	rbit	r3, r9
 8001b52:	fab3 f383 	clz	r3, r3
 8001b56:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001b5a:	095b      	lsrs	r3, r3, #5
 8001b5c:	2b03      	cmp	r3, #3
 8001b5e:	bf0c      	ite	eq
 8001b60:	f8d5 2094 	ldreq.w	r2, [r5, #148]	; 0x94
 8001b64:	69ea      	ldrne	r2, [r5, #28]
 8001b66:	fa99 f3a9 	rbit	r3, r9
 8001b6a:	fab3 f383 	clz	r3, r3
 8001b6e:	f003 031f 	and.w	r3, r3, #31
 8001b72:	fa22 f303 	lsr.w	r3, r2, r3
 8001b76:	07db      	lsls	r3, r3, #31
 8001b78:	f57f ae5a 	bpl.w	8001830 <HAL_RCC_OscConfig+0x37c>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001b7c:	f7fe fc7a 	bl	8000474 <HAL_GetTick>
 8001b80:	1bc0      	subs	r0, r0, r7
 8001b82:	42b0      	cmp	r0, r6
 8001b84:	f63f ae50 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 8001b88:	fa99 f3a9 	rbit	r3, r9
 8001b8c:	fa99 f3a9 	rbit	r3, r9
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001b90:	fab3 f383 	clz	r3, r3
 8001b94:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001b98:	095b      	lsrs	r3, r3, #5
 8001b9a:	2b02      	cmp	r3, #2
 8001b9c:	d1d7      	bne.n	8001b4e <HAL_RCC_OscConfig+0x69a>
 8001b9e:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8001ba2:	e7e0      	b.n	8001b66 <HAL_RCC_OscConfig+0x6b2>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001ba4:	461d      	mov	r5, r3

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001ba6:	f7fe fc65 	bl	8000474 <HAL_GetTick>
 8001baa:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
 8001bae:	4606      	mov	r6, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001bb0:	e005      	b.n	8001bbe <HAL_RCC_OscConfig+0x70a>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001bb2:	f7fe fc5f 	bl	8000474 <HAL_GetTick>
 8001bb6:	1b80      	subs	r0, r0, r6
 8001bb8:	2864      	cmp	r0, #100	; 0x64
 8001bba:	f63f ae35 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 8001bbe:	fa97 f3a7 	rbit	r3, r7

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001bc2:	4930      	ldr	r1, [pc, #192]	; (8001c84 <HAL_RCC_OscConfig+0x7d0>)
 8001bc4:	682a      	ldr	r2, [r5, #0]
 8001bc6:	fa97 f3a7 	rbit	r3, r7
 8001bca:	fab3 f383 	clz	r3, r3
 8001bce:	f003 031f 	and.w	r3, r3, #31
 8001bd2:	fa22 f303 	lsr.w	r3, r2, r3
 8001bd6:	07d8      	lsls	r0, r3, #31
 8001bd8:	d4eb      	bmi.n	8001bb2 <HAL_RCC_OscConfig+0x6fe>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001bda:	f104 0328 	add.w	r3, r4, #40	; 0x28
 8001bde:	cbc8      	ldmia	r3, {r3, r6, r7}
 8001be0:	6b65      	ldr	r5, [r4, #52]	; 0x34
 8001be2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8001be4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001be6:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
 8001bea:	1e74      	subs	r4, r6, #1
 8001bec:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8001bf0:	0840      	lsrs	r0, r0, #1
 8001bf2:	092c      	lsrs	r4, r5, #4
 8001bf4:	ea43 4344 	orr.w	r3, r3, r4, lsl #17
 8001bf8:	3801      	subs	r0, #1
 8001bfa:	0852      	lsrs	r2, r2, #1
 8001bfc:	ea43 5340 	orr.w	r3, r3, r0, lsl #21
 8001c00:	3a01      	subs	r2, #1
 8001c02:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8001c06:	60cb      	str	r3, [r1, #12]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8001c08:	680b      	ldr	r3, [r1, #0]
 8001c0a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001c0e:	600b      	str	r3, [r1, #0]

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8001c10:	68cb      	ldr	r3, [r1, #12]
 8001c12:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001c16:	60cb      	str	r3, [r1, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001c18:	460c      	mov	r4, r1

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001c1a:	f7fe fc2b 	bl	8000474 <HAL_GetTick>
 8001c1e:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
 8001c22:	4606      	mov	r6, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001c24:	e005      	b.n	8001c32 <HAL_RCC_OscConfig+0x77e>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001c26:	f7fe fc25 	bl	8000474 <HAL_GetTick>
 8001c2a:	1b80      	subs	r0, r0, r6
 8001c2c:	2864      	cmp	r0, #100	; 0x64
 8001c2e:	f63f adfb 	bhi.w	8001828 <HAL_RCC_OscConfig+0x374>
 8001c32:	fa95 f3a5 	rbit	r3, r5

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001c36:	6822      	ldr	r2, [r4, #0]
 8001c38:	fa95 f3a5 	rbit	r3, r5
 8001c3c:	fab3 f383 	clz	r3, r3
 8001c40:	f003 031f 	and.w	r3, r3, #31
 8001c44:	fa22 f303 	lsr.w	r3, r2, r3
 8001c48:	07da      	lsls	r2, r3, #31
 8001c4a:	d5ec      	bpl.n	8001c26 <HAL_RCC_OscConfig+0x772>
 8001c4c:	e62a      	b.n	80018a4 <HAL_RCC_OscConfig+0x3f0>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001c4e:	2b05      	cmp	r3, #5
 8001c50:	4b0c      	ldr	r3, [pc, #48]	; (8001c84 <HAL_RCC_OscConfig+0x7d0>)
 8001c52:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001c56:	f022 0201 	bic.w	r2, r2, #1
 8001c5a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001c5e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001c62:	d004      	beq.n	8001c6e <HAL_RCC_OscConfig+0x7ba>
 8001c64:	f022 0204 	bic.w	r2, r2, #4
 8001c68:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001c6c:	e6ff      	b.n	8001a6e <HAL_RCC_OscConfig+0x5ba>
 8001c6e:	f042 0204 	orr.w	r2, r2, #4
 8001c72:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001c76:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001c7a:	f042 0201 	orr.w	r2, r2, #1
 8001c7e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001c82:	e6f4      	b.n	8001a6e <HAL_RCC_OscConfig+0x5ba>
 8001c84:	40021000 	.word	0x40021000

08001c88 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001c88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001c8c:	4a93      	ldr	r2, [pc, #588]	; (8001edc <HAL_RCC_ClockConfig+0x254>)
 8001c8e:	6813      	ldr	r3, [r2, #0]
 8001c90:	f003 0307 	and.w	r3, r3, #7
 8001c94:	428b      	cmp	r3, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001c96:	460c      	mov	r4, r1
 8001c98:	4605      	mov	r5, r0
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001c9a:	d20f      	bcs.n	8001cbc <HAL_RCC_ClockConfig+0x34>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001c9c:	6813      	ldr	r3, [r2, #0]
 8001c9e:	4a8f      	ldr	r2, [pc, #572]	; (8001edc <HAL_RCC_ClockConfig+0x254>)
 8001ca0:	2904      	cmp	r1, #4
 8001ca2:	bf9c      	itt	ls
 8001ca4:	f023 0307 	bicls.w	r3, r3, #7
 8001ca8:	430b      	orrls	r3, r1
 8001caa:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001cac:	6813      	ldr	r3, [r2, #0]
 8001cae:	f003 0307 	and.w	r3, r3, #7
 8001cb2:	428b      	cmp	r3, r1
 8001cb4:	d06a      	beq.n	8001d8c <HAL_RCC_ClockConfig+0x104>
    {
      return HAL_ERROR;
 8001cb6:	2001      	movs	r0, #1
 8001cb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001cbc:	6803      	ldr	r3, [r0, #0]
 8001cbe:	079e      	lsls	r6, r3, #30
 8001cc0:	d507      	bpl.n	8001cd2 <HAL_RCC_ClockConfig+0x4a>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001cc2:	4987      	ldr	r1, [pc, #540]	; (8001ee0 <HAL_RCC_ClockConfig+0x258>)
 8001cc4:	6883      	ldr	r3, [r0, #8]
 8001cc6:	688a      	ldr	r2, [r1, #8]
 8001cc8:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001ccc:	4313      	orrs	r3, r2
 8001cce:	608b      	str	r3, [r1, #8]
 8001cd0:	6803      	ldr	r3, [r0, #0]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001cd2:	07d8      	lsls	r0, r3, #31
 8001cd4:	d534      	bpl.n	8001d40 <HAL_RCC_ClockConfig+0xb8>
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001cd6:	686b      	ldr	r3, [r5, #4]
 8001cd8:	2b02      	cmp	r3, #2
 8001cda:	f000 80a0 	beq.w	8001e1e <HAL_RCC_ClockConfig+0x196>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001cde:	2b00      	cmp	r3, #0
 8001ce0:	f040 80a0 	bne.w	8001e24 <HAL_RCC_ClockConfig+0x19c>
 8001ce4:	2202      	movs	r2, #2
 8001ce6:	fa92 f1a2 	rbit	r1, r2
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001cea:	497d      	ldr	r1, [pc, #500]	; (8001ee0 <HAL_RCC_ClockConfig+0x258>)
 8001cec:	6809      	ldr	r1, [r1, #0]
 8001cee:	fa92 f2a2 	rbit	r2, r2
 8001cf2:	fab2 f282 	clz	r2, r2
 8001cf6:	f002 021f 	and.w	r2, r2, #31
 8001cfa:	fa21 f202 	lsr.w	r2, r1, r2
 8001cfe:	07d1      	lsls	r1, r2, #31
 8001d00:	d5d9      	bpl.n	8001cb6 <HAL_RCC_ClockConfig+0x2e>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8001d02:	4e77      	ldr	r6, [pc, #476]	; (8001ee0 <HAL_RCC_ClockConfig+0x258>)
 8001d04:	68b2      	ldr	r2, [r6, #8]
 8001d06:	f022 0203 	bic.w	r2, r2, #3
 8001d0a:	4313      	orrs	r3, r2
 8001d0c:	60b3      	str	r3, [r6, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d0e:	f7fe fbb1 	bl	8000474 <HAL_GetTick>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001d12:	686b      	ldr	r3, [r5, #4]
 8001d14:	2b02      	cmp	r3, #2
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d16:	4607      	mov	r7, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001d18:	f000 80be 	beq.w	8001e98 <HAL_RCC_ClockConfig+0x210>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001d1c:	2b03      	cmp	r3, #3
 8001d1e:	f000 80c9 	beq.w	8001eb4 <HAL_RCC_ClockConfig+0x22c>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001d22:	2b00      	cmp	r3, #0
 8001d24:	f040 80a7 	bne.w	8001e76 <HAL_RCC_ClockConfig+0x1ee>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
        {
          if((HAL_GetTick() - tickstart) >= CLOCKSWITCH_TIMEOUT_VALUE)
 8001d28:	f241 3887 	movw	r8, #4999	; 0x1387
 8001d2c:	e004      	b.n	8001d38 <HAL_RCC_ClockConfig+0xb0>
 8001d2e:	f7fe fba1 	bl	8000474 <HAL_GetTick>
 8001d32:	1bc0      	subs	r0, r0, r7
 8001d34:	4540      	cmp	r0, r8
 8001d36:	d869      	bhi.n	8001e0c <HAL_RCC_ClockConfig+0x184>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 8001d38:	68b3      	ldr	r3, [r6, #8]
 8001d3a:	f013 0f0c 	tst.w	r3, #12
 8001d3e:	d1f6      	bne.n	8001d2e <HAL_RCC_ClockConfig+0xa6>
        }
      }
    }

    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001d40:	2c04      	cmp	r4, #4
 8001d42:	d966      	bls.n	8001e12 <HAL_RCC_ClockConfig+0x18a>
 8001d44:	4b65      	ldr	r3, [pc, #404]	; (8001edc <HAL_RCC_ClockConfig+0x254>)
 8001d46:	681b      	ldr	r3, [r3, #0]
 8001d48:	4a64      	ldr	r2, [pc, #400]	; (8001edc <HAL_RCC_ClockConfig+0x254>)
 8001d4a:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001d4c:	6813      	ldr	r3, [r2, #0]
 8001d4e:	f003 0307 	and.w	r3, r3, #7
 8001d52:	42a3      	cmp	r3, r4
 8001d54:	d1af      	bne.n	8001cb6 <HAL_RCC_ClockConfig+0x2e>
 8001d56:	682b      	ldr	r3, [r5, #0]
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001d58:	075a      	lsls	r2, r3, #29
 8001d5a:	d507      	bpl.n	8001d6c <HAL_RCC_ClockConfig+0xe4>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001d5c:	4960      	ldr	r1, [pc, #384]	; (8001ee0 <HAL_RCC_ClockConfig+0x258>)
 8001d5e:	68eb      	ldr	r3, [r5, #12]
 8001d60:	688a      	ldr	r2, [r1, #8]
 8001d62:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8001d66:	4313      	orrs	r3, r2
 8001d68:	608b      	str	r3, [r1, #8]
 8001d6a:	682b      	ldr	r3, [r5, #0]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001d6c:	071b      	lsls	r3, r3, #28
 8001d6e:	d507      	bpl.n	8001d80 <HAL_RCC_ClockConfig+0xf8>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001d70:	4a5b      	ldr	r2, [pc, #364]	; (8001ee0 <HAL_RCC_ClockConfig+0x258>)
 8001d72:	6929      	ldr	r1, [r5, #16]
 8001d74:	6893      	ldr	r3, [r2, #8]
 8001d76:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8001d7a:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001d7e:	6093      	str	r3, [r2, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8001d80:	2000      	movs	r0, #0
 8001d82:	f7fe fb49 	bl	8000418 <HAL_InitTick>

  return HAL_OK;
 8001d86:	2000      	movs	r0, #0
}
 8001d88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    {
      return HAL_ERROR;
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001d8c:	6803      	ldr	r3, [r0, #0]
 8001d8e:	0799      	lsls	r1, r3, #30
 8001d90:	d507      	bpl.n	8001da2 <HAL_RCC_ClockConfig+0x11a>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001d92:	4953      	ldr	r1, [pc, #332]	; (8001ee0 <HAL_RCC_ClockConfig+0x258>)
 8001d94:	6883      	ldr	r3, [r0, #8]
 8001d96:	688a      	ldr	r2, [r1, #8]
 8001d98:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001d9c:	4313      	orrs	r3, r2
 8001d9e:	608b      	str	r3, [r1, #8]
 8001da0:	6803      	ldr	r3, [r0, #0]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001da2:	07da      	lsls	r2, r3, #31
 8001da4:	d5d8      	bpl.n	8001d58 <HAL_RCC_ClockConfig+0xd0>
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001da6:	686b      	ldr	r3, [r5, #4]
 8001da8:	2b02      	cmp	r3, #2
 8001daa:	f000 8091 	beq.w	8001ed0 <HAL_RCC_ClockConfig+0x248>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001dae:	2b03      	cmp	r3, #3
 8001db0:	d06f      	beq.n	8001e92 <HAL_RCC_ClockConfig+0x20a>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001db2:	2b00      	cmp	r3, #0
 8001db4:	f040 808f 	bne.w	8001ed6 <HAL_RCC_ClockConfig+0x24e>
 8001db8:	2202      	movs	r2, #2
 8001dba:	fa92 f1a2 	rbit	r1, r2
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001dbe:	4948      	ldr	r1, [pc, #288]	; (8001ee0 <HAL_RCC_ClockConfig+0x258>)
 8001dc0:	6809      	ldr	r1, [r1, #0]
 8001dc2:	fa92 f2a2 	rbit	r2, r2
 8001dc6:	fab2 f282 	clz	r2, r2
 8001dca:	f002 021f 	and.w	r2, r2, #31
 8001dce:	fa21 f202 	lsr.w	r2, r1, r2
 8001dd2:	07d7      	lsls	r7, r2, #31
 8001dd4:	f57f af6f 	bpl.w	8001cb6 <HAL_RCC_ClockConfig+0x2e>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8001dd8:	4c41      	ldr	r4, [pc, #260]	; (8001ee0 <HAL_RCC_ClockConfig+0x258>)
 8001dda:	68a2      	ldr	r2, [r4, #8]
 8001ddc:	f022 0203 	bic.w	r2, r2, #3
 8001de0:	4313      	orrs	r3, r2
 8001de2:	60a3      	str	r3, [r4, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001de4:	f7fe fb46 	bl	8000474 <HAL_GetTick>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001de8:	686b      	ldr	r3, [r5, #4]
 8001dea:	2b02      	cmp	r3, #2
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001dec:	4606      	mov	r6, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001dee:	f241 3788 	movw	r7, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001df2:	d01e      	beq.n	8001e32 <HAL_RCC_ClockConfig+0x1aa>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001df4:	2b03      	cmp	r3, #3
 8001df6:	d032      	beq.n	8001e5e <HAL_RCC_ClockConfig+0x1d6>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001df8:	bb33      	cbnz	r3, 8001e48 <HAL_RCC_ClockConfig+0x1c0>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 8001dfa:	68a3      	ldr	r3, [r4, #8]
 8001dfc:	f013 0f0c 	tst.w	r3, #12
 8001e00:	d0a9      	beq.n	8001d56 <HAL_RCC_ClockConfig+0xce>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001e02:	f7fe fb37 	bl	8000474 <HAL_GetTick>
 8001e06:	1b80      	subs	r0, r0, r6
 8001e08:	42b8      	cmp	r0, r7
 8001e0a:	d9f6      	bls.n	8001dfa <HAL_RCC_ClockConfig+0x172>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8001e0c:	2003      	movs	r0, #3
 8001e0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }

    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001e12:	4b32      	ldr	r3, [pc, #200]	; (8001edc <HAL_RCC_ClockConfig+0x254>)
 8001e14:	681b      	ldr	r3, [r3, #0]
 8001e16:	f023 0307 	bic.w	r3, r3, #7
 8001e1a:	4323      	orrs	r3, r4
 8001e1c:	e794      	b.n	8001d48 <HAL_RCC_ClockConfig+0xc0>
 8001e1e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8001e22:	e760      	b.n	8001ce6 <HAL_RCC_ClockConfig+0x5e>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001e24:	2b03      	cmp	r3, #3
 8001e26:	bf0c      	ite	eq
 8001e28:	f04f 7200 	moveq.w	r2, #33554432	; 0x2000000
 8001e2c:	f44f 6280 	movne.w	r2, #1024	; 0x400
 8001e30:	e759      	b.n	8001ce6 <HAL_RCC_ClockConfig+0x5e>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8001e32:	68a3      	ldr	r3, [r4, #8]
 8001e34:	f003 030c 	and.w	r3, r3, #12
 8001e38:	2b08      	cmp	r3, #8
 8001e3a:	d08c      	beq.n	8001d56 <HAL_RCC_ClockConfig+0xce>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001e3c:	f7fe fb1a 	bl	8000474 <HAL_GetTick>
 8001e40:	1b80      	subs	r0, r0, r6
 8001e42:	42b8      	cmp	r0, r7
 8001e44:	d9f5      	bls.n	8001e32 <HAL_RCC_ClockConfig+0x1aa>
 8001e46:	e7e1      	b.n	8001e0c <HAL_RCC_ClockConfig+0x184>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 8001e48:	68a3      	ldr	r3, [r4, #8]
 8001e4a:	f003 030c 	and.w	r3, r3, #12
 8001e4e:	2b04      	cmp	r3, #4
 8001e50:	d081      	beq.n	8001d56 <HAL_RCC_ClockConfig+0xce>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001e52:	f7fe fb0f 	bl	8000474 <HAL_GetTick>
 8001e56:	1b80      	subs	r0, r0, r6
 8001e58:	42b8      	cmp	r0, r7
 8001e5a:	d9f5      	bls.n	8001e48 <HAL_RCC_ClockConfig+0x1c0>
 8001e5c:	e7d6      	b.n	8001e0c <HAL_RCC_ClockConfig+0x184>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001e5e:	68a3      	ldr	r3, [r4, #8]
 8001e60:	f003 030c 	and.w	r3, r3, #12
 8001e64:	2b0c      	cmp	r3, #12
 8001e66:	f43f af76 	beq.w	8001d56 <HAL_RCC_ClockConfig+0xce>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001e6a:	f7fe fb03 	bl	8000474 <HAL_GetTick>
 8001e6e:	1b80      	subs	r0, r0, r6
 8001e70:	42b8      	cmp	r0, r7
 8001e72:	d9f4      	bls.n	8001e5e <HAL_RCC_ClockConfig+0x1d6>
 8001e74:	e7ca      	b.n	8001e0c <HAL_RCC_ClockConfig+0x184>
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001e76:	f241 3888 	movw	r8, #5000	; 0x1388
 8001e7a:	e004      	b.n	8001e86 <HAL_RCC_ClockConfig+0x1fe>
 8001e7c:	f7fe fafa 	bl	8000474 <HAL_GetTick>
 8001e80:	1bc0      	subs	r0, r0, r7
 8001e82:	4540      	cmp	r0, r8
 8001e84:	d8c2      	bhi.n	8001e0c <HAL_RCC_ClockConfig+0x184>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 8001e86:	68b3      	ldr	r3, [r6, #8]
 8001e88:	f003 030c 	and.w	r3, r3, #12
 8001e8c:	2b04      	cmp	r3, #4
 8001e8e:	d1f5      	bne.n	8001e7c <HAL_RCC_ClockConfig+0x1f4>
 8001e90:	e756      	b.n	8001d40 <HAL_RCC_ClockConfig+0xb8>
 8001e92:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8001e96:	e790      	b.n	8001dba <HAL_RCC_ClockConfig+0x132>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001e98:	f241 3888 	movw	r8, #5000	; 0x1388
 8001e9c:	e004      	b.n	8001ea8 <HAL_RCC_ClockConfig+0x220>
 8001e9e:	f7fe fae9 	bl	8000474 <HAL_GetTick>
 8001ea2:	1bc0      	subs	r0, r0, r7
 8001ea4:	4540      	cmp	r0, r8
 8001ea6:	d8b1      	bhi.n	8001e0c <HAL_RCC_ClockConfig+0x184>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8001ea8:	68b3      	ldr	r3, [r6, #8]
 8001eaa:	f003 030c 	and.w	r3, r3, #12
 8001eae:	2b08      	cmp	r3, #8
 8001eb0:	d1f5      	bne.n	8001e9e <HAL_RCC_ClockConfig+0x216>
 8001eb2:	e745      	b.n	8001d40 <HAL_RCC_ClockConfig+0xb8>
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001eb4:	f241 3888 	movw	r8, #5000	; 0x1388
 8001eb8:	e004      	b.n	8001ec4 <HAL_RCC_ClockConfig+0x23c>
 8001eba:	f7fe fadb 	bl	8000474 <HAL_GetTick>
 8001ebe:	1bc0      	subs	r0, r0, r7
 8001ec0:	4540      	cmp	r0, r8
 8001ec2:	d8a3      	bhi.n	8001e0c <HAL_RCC_ClockConfig+0x184>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001ec4:	68b3      	ldr	r3, [r6, #8]
 8001ec6:	f003 030c 	and.w	r3, r3, #12
 8001eca:	2b0c      	cmp	r3, #12
 8001ecc:	d1f5      	bne.n	8001eba <HAL_RCC_ClockConfig+0x232>
 8001ece:	e737      	b.n	8001d40 <HAL_RCC_ClockConfig+0xb8>
 8001ed0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8001ed4:	e771      	b.n	8001dba <HAL_RCC_ClockConfig+0x132>
 8001ed6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001eda:	e76e      	b.n	8001dba <HAL_RCC_ClockConfig+0x132>
 8001edc:	40022000 	.word	0x40022000
 8001ee0:	40021000 	.word	0x40021000

08001ee4 <HAL_RCC_MCOConfig>:
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8001ee4:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 8001ee6:	4c12      	ldr	r4, [pc, #72]	; (8001f30 <HAL_RCC_MCOConfig+0x4c>)
 8001ee8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001eea:	f043 0301 	orr.w	r3, r3, #1
 8001eee:	64e3      	str	r3, [r4, #76]	; 0x4c
 8001ef0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8001ef2:	b087      	sub	sp, #28
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 8001ef4:	f003 0301 	and.w	r3, r3, #1
 8001ef8:	9300      	str	r3, [sp, #0]
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8001efa:	460d      	mov	r5, r1

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001efc:	2300      	movs	r3, #0

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
 8001efe:	f44f 7e80 	mov.w	lr, #256	; 0x100
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001f02:	2602      	movs	r6, #2
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8001f04:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001f08:	a901      	add	r1, sp, #4
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8001f0a:	4617      	mov	r7, r2

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001f0c:	9303      	str	r3, [sp, #12]
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 8001f0e:	9a00      	ldr	r2, [sp, #0]
  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8001f10:	9305      	str	r3, [sp, #20]

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
 8001f12:	f8cd e004 	str.w	lr, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001f16:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8001f18:	9604      	str	r6, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8001f1a:	f7fe fca1 	bl	8000860 <HAL_GPIO_Init>

  /* Mask MCOSEL[] and MCOPRE[] bits then set MCO1 clock source and prescaler */
  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCO_PRE), (RCC_MCOSource | RCC_MCODiv ));
 8001f1e:	68a3      	ldr	r3, [r4, #8]
 8001f20:	f023 43ee 	bic.w	r3, r3, #1996488704	; 0x77000000
 8001f24:	ea47 0203 	orr.w	r2, r7, r3
 8001f28:	432a      	orrs	r2, r5
 8001f2a:	60a2      	str	r2, [r4, #8]
}
 8001f2c:	b007      	add	sp, #28
 8001f2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f30:	40021000 	.word	0x40021000

08001f34 <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
  uint32_t sysclockfreq = 0;

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8001f34:	4a39      	ldr	r2, [pc, #228]	; (800201c <HAL_RCC_GetSysClockFreq+0xe8>)
 8001f36:	6893      	ldr	r3, [r2, #8]
 8001f38:	f003 030c 	and.w	r3, r3, #12
 8001f3c:	2b04      	cmp	r3, #4
 8001f3e:	d04e      	beq.n	8001fde <HAL_RCC_GetSysClockFreq+0xaa>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8001f40:	6893      	ldr	r3, [r2, #8]
 8001f42:	f003 030c 	and.w	r3, r3, #12
 8001f46:	2b08      	cmp	r3, #8
 8001f48:	d04c      	beq.n	8001fe4 <HAL_RCC_GetSysClockFreq+0xb0>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8001f4a:	6893      	ldr	r3, [r2, #8]
 8001f4c:	f013 0f0c 	tst.w	r3, #12
 8001f50:	d11c      	bne.n	8001f8c <HAL_RCC_GetSysClockFreq+0x58>
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 8001f52:	4b32      	ldr	r3, [pc, #200]	; (800201c <HAL_RCC_GetSysClockFreq+0xe8>)
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8001f54:	4932      	ldr	r1, [pc, #200]	; (8002020 <HAL_RCC_GetSysClockFreq+0xec>)
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 8001f56:	681a      	ldr	r2, [r3, #0]
 8001f58:	0712      	lsls	r2, r2, #28
    { /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 8001f5a:	bf54      	ite	pl
 8001f5c:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 8001f60:	681b      	ldrmi	r3, [r3, #0]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 8001f62:	4a2e      	ldr	r2, [pc, #184]	; (800201c <HAL_RCC_GetSysClockFreq+0xe8>)
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
    { /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 8001f64:	bf54      	ite	pl
 8001f66:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 8001f6a:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 8001f6e:	6892      	ldr	r2, [r2, #8]
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8001f70:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 8001f74:	f012 0f0c 	tst.w	r2, #12
 8001f78:	bf0c      	ite	eq
 8001f7a:	4618      	moveq	r0, r3
 8001f7c:	2000      	movne	r0, #0
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8001f7e:	4927      	ldr	r1, [pc, #156]	; (800201c <HAL_RCC_GetSysClockFreq+0xe8>)
 8001f80:	688a      	ldr	r2, [r1, #8]
 8001f82:	f002 020c 	and.w	r2, r2, #12
 8001f86:	2a0c      	cmp	r2, #12
 8001f88:	d00d      	beq.n	8001fa6 <HAL_RCC_GetSysClockFreq+0x72>
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>25) + 1 ) *2;
    sysclockfreq = pllvco/pllr;
  }

  return sysclockfreq;
}
 8001f8a:	4770      	bx	lr
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8001f8c:	6893      	ldr	r3, [r2, #8]
 8001f8e:	f003 030c 	and.w	r3, r3, #12
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8001f92:	2b0c      	cmp	r3, #12
 8001f94:	d032      	beq.n	8001ffc <HAL_RCC_GetSysClockFreq+0xc8>
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8001f96:	4921      	ldr	r1, [pc, #132]	; (800201c <HAL_RCC_GetSysClockFreq+0xe8>)
 8001f98:	688a      	ldr	r2, [r1, #8]
 8001f9a:	f002 020c 	and.w	r2, r2, #12
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
  uint32_t sysclockfreq = 0;
 8001f9e:	2000      	movs	r0, #0
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8001fa0:	2a0c      	cmp	r2, #12
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
 8001fa2:	4603      	mov	r3, r0
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8001fa4:	d1f1      	bne.n	8001f8a <HAL_RCC_GetSysClockFreq+0x56>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8001fa6:	68ca      	ldr	r2, [r1, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
 8001fa8:	68c8      	ldr	r0, [r1, #12]
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8001faa:	f002 0203 	and.w	r2, r2, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
 8001fae:	f3c0 1002 	ubfx	r0, r0, #4, #3

    switch (pllsource)
 8001fb2:	2a02      	cmp	r2, #2

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
 8001fb4:	f100 0001 	add.w	r0, r0, #1

    switch (pllsource)
 8001fb8:	d026      	beq.n	8002008 <HAL_RCC_GetSysClockFreq+0xd4>
 8001fba:	2a03      	cmp	r2, #3
 8001fbc:	d015      	beq.n	8001fea <HAL_RCC_GetSysClockFreq+0xb6>
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
      break;

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 8001fbe:	fbb3 f3f0 	udiv	r3, r3, r0
 8001fc2:	68ca      	ldr	r2, [r1, #12]
 8001fc4:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8001fc8:	fb02 f303 	mul.w	r3, r2, r3
      break;
    }
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>25) + 1 ) *2;
 8001fcc:	4a13      	ldr	r2, [pc, #76]	; (800201c <HAL_RCC_GetSysClockFreq+0xe8>)
 8001fce:	68d0      	ldr	r0, [r2, #12]
 8001fd0:	f3c0 6041 	ubfx	r0, r0, #25, #2
 8001fd4:	3001      	adds	r0, #1
 8001fd6:	0040      	lsls	r0, r0, #1
    sysclockfreq = pllvco/pllr;
 8001fd8:	fbb3 f0f0 	udiv	r0, r3, r0
  }

  return sysclockfreq;
}
 8001fdc:	4770      	bx	lr
  uint32_t sysclockfreq = 0;

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8001fde:	4811      	ldr	r0, [pc, #68]	; (8002024 <HAL_RCC_GetSysClockFreq+0xf0>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
 8001fe0:	2300      	movs	r3, #0
 8001fe2:	e7cc      	b.n	8001f7e <HAL_RCC_GetSysClockFreq+0x4a>
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 8001fe4:	4810      	ldr	r0, [pc, #64]	; (8002028 <HAL_RCC_GetSysClockFreq+0xf4>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
 8001fe6:	2300      	movs	r3, #0
 8001fe8:	e7c9      	b.n	8001f7e <HAL_RCC_GetSysClockFreq+0x4a>
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 8001fea:	68ca      	ldr	r2, [r1, #12]
 8001fec:	4b0e      	ldr	r3, [pc, #56]	; (8002028 <HAL_RCC_GetSysClockFreq+0xf4>)
 8001fee:	fbb3 f0f0 	udiv	r0, r3, r0
 8001ff2:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8001ff6:	fb02 f300 	mul.w	r3, r2, r0
      break;
 8001ffa:	e7e7      	b.n	8001fcc <HAL_RCC_GetSysClockFreq+0x98>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8001ffc:	68d3      	ldr	r3, [r2, #12]
 8001ffe:	f003 0303 	and.w	r3, r3, #3
 8002002:	2b01      	cmp	r3, #1
 8002004:	d1c7      	bne.n	8001f96 <HAL_RCC_GetSysClockFreq+0x62>
 8002006:	e7a4      	b.n	8001f52 <HAL_RCC_GetSysClockFreq+0x1e>
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;

    switch (pllsource)
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 8002008:	68cb      	ldr	r3, [r1, #12]
 800200a:	4a06      	ldr	r2, [pc, #24]	; (8002024 <HAL_RCC_GetSysClockFreq+0xf0>)
 800200c:	fbb2 f0f0 	udiv	r0, r2, r0
 8002010:	f3c3 2306 	ubfx	r3, r3, #8, #7
 8002014:	fb03 f300 	mul.w	r3, r3, r0
      break;
 8002018:	e7d8      	b.n	8001fcc <HAL_RCC_GetSysClockFreq+0x98>
 800201a:	bf00      	nop
 800201c:	40021000 	.word	0x40021000
 8002020:	08002738 	.word	0x08002738
 8002024:	00f42400 	.word	0x00f42400
 8002028:	007a1200 	.word	0x007a1200

0800202c <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800202c:	b510      	push	{r4, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 800202e:	f7ff ff81 	bl	8001f34 <HAL_RCC_GetSysClockFreq>
 8002032:	4b08      	ldr	r3, [pc, #32]	; (8002054 <HAL_RCC_GetHCLKFreq+0x28>)
 8002034:	22f0      	movs	r2, #240	; 0xf0
 8002036:	689b      	ldr	r3, [r3, #8]
 8002038:	fa92 f2a2 	rbit	r2, r2
 800203c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8002040:	fab2 f282 	clz	r2, r2
 8002044:	4c04      	ldr	r4, [pc, #16]	; (8002058 <HAL_RCC_GetHCLKFreq+0x2c>)
 8002046:	4905      	ldr	r1, [pc, #20]	; (800205c <HAL_RCC_GetHCLKFreq+0x30>)
 8002048:	40d3      	lsrs	r3, r2
 800204a:	5ce3      	ldrb	r3, [r4, r3]
 800204c:	40d8      	lsrs	r0, r3
 800204e:	6008      	str	r0, [r1, #0]
  return SystemCoreClock;
}
 8002050:	bd10      	pop	{r4, pc}
 8002052:	bf00      	nop
 8002054:	40021000 	.word	0x40021000
 8002058:	08002768 	.word	0x08002768
 800205c:	20000000 	.word	0x20000000

08002060 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8002060:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8002062:	f7ff ffe3 	bl	800202c <HAL_RCC_GetHCLKFreq>
 8002066:	4b07      	ldr	r3, [pc, #28]	; (8002084 <HAL_RCC_GetPCLK1Freq+0x24>)
 8002068:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 800206c:	689b      	ldr	r3, [r3, #8]
 800206e:	fa92 f2a2 	rbit	r2, r2
 8002072:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8002076:	fab2 f282 	clz	r2, r2
 800207a:	4903      	ldr	r1, [pc, #12]	; (8002088 <HAL_RCC_GetPCLK1Freq+0x28>)
 800207c:	40d3      	lsrs	r3, r2
 800207e:	5ccb      	ldrb	r3, [r1, r3]
}
 8002080:	40d8      	lsrs	r0, r3
 8002082:	bd08      	pop	{r3, pc}
 8002084:	40021000 	.word	0x40021000
 8002088:	08002778 	.word	0x08002778

0800208c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800208c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 800208e:	f7ff ffcd 	bl	800202c <HAL_RCC_GetHCLKFreq>
 8002092:	4b07      	ldr	r3, [pc, #28]	; (80020b0 <HAL_RCC_GetPCLK2Freq+0x24>)
 8002094:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002098:	689b      	ldr	r3, [r3, #8]
 800209a:	fa92 f2a2 	rbit	r2, r2
 800209e:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 80020a2:	fab2 f282 	clz	r2, r2
 80020a6:	4903      	ldr	r1, [pc, #12]	; (80020b4 <HAL_RCC_GetPCLK2Freq+0x28>)
 80020a8:	40d3      	lsrs	r3, r2
 80020aa:	5ccb      	ldrb	r3, [r1, r3]
}
 80020ac:	40d8      	lsrs	r0, r3
 80020ae:	bd08      	pop	{r3, pc}
 80020b0:	40021000 	.word	0x40021000
 80020b4:	08002778 	.word	0x08002778

080020b8 <HAL_RCC_GetOscConfig>:
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
 80020b8:	221f      	movs	r2, #31
                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;

  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 80020ba:	4b49      	ldr	r3, [pc, #292]	; (80021e0 <HAL_RCC_GetOscConfig+0x128>)
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
 80020bc:	6002      	str	r2, [r0, #0]
                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;

  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 80020be:	681a      	ldr	r2, [r3, #0]
 80020c0:	0352      	lsls	r2, r2, #13
 80020c2:	d57d      	bpl.n	80021c0 <HAL_RCC_GetOscConfig+0x108>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
 80020c4:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
 80020c8:	6043      	str	r3, [r0, #4]
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }

   /* Get the MSI configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_MSION) == RCC_CR_MSION)
 80020ca:	4b45      	ldr	r3, [pc, #276]	; (80021e0 <HAL_RCC_GetOscConfig+0x128>)
  else
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
  }

  RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->CR & RCC_ICSCR_MSITRIM) >> POSITION_VAL(RCC_ICSCR_MSITRIM));
 80020cc:	4944      	ldr	r1, [pc, #272]	; (80021e0 <HAL_RCC_GetOscConfig+0x128>)
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }

   /* Get the MSI configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_MSION) == RCC_CR_MSION)
 80020ce:	681b      	ldr	r3, [r3, #0]
 80020d0:	f013 0301 	ands.w	r3, r3, #1
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_ON;
 80020d4:	bf18      	it	ne
 80020d6:	2301      	movne	r3, #1
  }
  else
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
 80020d8:	6183      	str	r3, [r0, #24]
 80020da:	f44f 427f 	mov.w	r2, #65280	; 0xff00
  }

  RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->CR & RCC_ICSCR_MSITRIM) >> POSITION_VAL(RCC_ICSCR_MSITRIM));
 80020de:	680b      	ldr	r3, [r1, #0]
 80020e0:	fa92 f2a2 	rbit	r2, r2
 80020e4:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80020e8:	fab2 f282 	clz	r2, r2
 80020ec:	40d3      	lsrs	r3, r2
 80020ee:	61c3      	str	r3, [r0, #28]
  RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->CR & RCC_CR_MSIRANGE) );
 80020f0:	680b      	ldr	r3, [r1, #0]
 80020f2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80020f6:	6203      	str	r3, [r0, #32]

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSION) == RCC_CR_HSION)
 80020f8:	680b      	ldr	r3, [r1, #0]
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
  }

  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_HSITRIM) >> POSITION_VAL(RCC_ICSCR_HSITRIM));
 80020fa:	4939      	ldr	r1, [pc, #228]	; (80021e0 <HAL_RCC_GetOscConfig+0x128>)

  RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->CR & RCC_ICSCR_MSITRIM) >> POSITION_VAL(RCC_ICSCR_MSITRIM));
  RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->CR & RCC_CR_MSIRANGE) );

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSION) == RCC_CR_HSION)
 80020fc:	f413 7380 	ands.w	r3, r3, #256	; 0x100
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
 8002100:	bf18      	it	ne
 8002102:	f44f 7380 	movne.w	r3, #256	; 0x100
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
 8002106:	60c3      	str	r3, [r0, #12]
 8002108:	f04f 52f8 	mov.w	r2, #520093696	; 0x1f000000
  }

  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_HSITRIM) >> POSITION_VAL(RCC_ICSCR_HSITRIM));
 800210c:	684b      	ldr	r3, [r1, #4]
 800210e:	fa92 f2a2 	rbit	r2, r2
 8002112:	f003 53f8 	and.w	r3, r3, #520093696	; 0x1f000000
 8002116:	fab2 f282 	clz	r2, r2
 800211a:	40d3      	lsrs	r3, r2
 800211c:	6103      	str	r3, [r0, #16]

  /* Get the LSE configuration -----------------------------------------------*/
  if((RCC->BDCR & RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
 800211e:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
 8002122:	075b      	lsls	r3, r3, #29
 8002124:	d554      	bpl.n	80021d0 <HAL_RCC_GetOscConfig+0x118>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
 8002126:	2305      	movs	r3, #5
 8002128:	6083      	str	r3, [r0, #8]
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
  }

  /* Get the LSI configuration -----------------------------------------------*/
  if((RCC->CSR & RCC_CSR_LSION) == RCC_CSR_LSION)
 800212a:	4b2d      	ldr	r3, [pc, #180]	; (80021e0 <HAL_RCC_GetOscConfig+0x128>)
 800212c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002130:	f013 0301 	ands.w	r3, r3, #1
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
 8002134:	bf18      	it	ne
 8002136:	2301      	movne	r3, #1
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
 8002138:	6143      	str	r3, [r0, #20]
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_PLLON) == RCC_CR_PLLON)
 800213a:	4b29      	ldr	r3, [pc, #164]	; (80021e0 <HAL_RCC_GetOscConfig+0x128>)
 800213c:	681b      	ldr	r3, [r3, #0]
 800213e:	01da      	lsls	r2, r3, #7
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
 8002140:	bf4c      	ite	mi
 8002142:	2302      	movmi	r3, #2
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
 8002144:	2301      	movpl	r3, #1
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8002146:	4a26      	ldr	r2, [pc, #152]	; (80021e0 <HAL_RCC_GetOscConfig+0x128>)
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
 8002148:	6243      	str	r3, [r0, #36]	; 0x24
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 800214a:	68d3      	ldr	r3, [r2, #12]
 800214c:	f003 0303 	and.w	r3, r3, #3
 8002150:	6283      	str	r3, [r0, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)(((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1);
 8002152:	68d3      	ldr	r3, [r2, #12]
 8002154:	2170      	movs	r1, #112	; 0x70
 8002156:	fa91 f1a1 	rbit	r1, r1
 800215a:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800215e:	fab1 f181 	clz	r1, r1
 8002162:	40cb      	lsrs	r3, r1
 8002164:	3301      	adds	r3, #1
 8002166:	62c3      	str	r3, [r0, #44]	; 0x2c
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 8002168:	68d3      	ldr	r3, [r2, #12]
 800216a:	f44f 41fe 	mov.w	r1, #32512	; 0x7f00
 800216e:	fa91 f1a1 	rbit	r1, r1
 8002172:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 8002176:	fab1 f181 	clz	r1, r1
 800217a:	40cb      	lsrs	r3, r1
 800217c:	6303      	str	r3, [r0, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> POSITION_VAL(RCC_PLLCFGR_PLLQ)) + 1) << 1U);
 800217e:	68d3      	ldr	r3, [r2, #12]
 8002180:	f44f 01c0 	mov.w	r1, #6291456	; 0x600000
 8002184:	fa91 f1a1 	rbit	r1, r1
 8002188:	f403 03c0 	and.w	r3, r3, #6291456	; 0x600000
 800218c:	fab1 f181 	clz	r1, r1
 8002190:	40cb      	lsrs	r3, r1
 8002192:	3301      	adds	r3, #1
 8002194:	005b      	lsls	r3, r3, #1
 8002196:	6383      	str	r3, [r0, #56]	; 0x38
  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> POSITION_VAL(RCC_PLLCFGR_PLLR)) + 1) << 1U);
 8002198:	68d3      	ldr	r3, [r2, #12]
 800219a:	f04f 61c0 	mov.w	r1, #100663296	; 0x6000000
 800219e:	fa91 f1a1 	rbit	r1, r1
 80021a2:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 80021a6:	fab1 f181 	clz	r1, r1
 80021aa:	40cb      	lsrs	r3, r1
 80021ac:	3301      	adds	r3, #1
 80021ae:	005b      	lsls	r3, r3, #1
 80021b0:	63c3      	str	r3, [r0, #60]	; 0x3c
  if((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) != RESET)
 80021b2:	68d3      	ldr	r3, [r2, #12]
 80021b4:	039b      	lsls	r3, r3, #14
  {
    RCC_OscInitStruct->PLL.PLLP = RCC_PLLP_DIV17;
 80021b6:	bf4c      	ite	mi
 80021b8:	2311      	movmi	r3, #17
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLP = RCC_PLLP_DIV7;
 80021ba:	2307      	movpl	r3, #7
 80021bc:	6343      	str	r3, [r0, #52]	; 0x34
 80021be:	4770      	bx	lr
  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
  }
  else if((RCC->CR & RCC_CR_HSEON) == RCC_CR_HSEON)
 80021c0:	681b      	ldr	r3, [r3, #0]
 80021c2:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
 80021c6:	bf18      	it	ne
 80021c8:	f44f 3380 	movne.w	r3, #65536	; 0x10000
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
 80021cc:	6043      	str	r3, [r0, #4]
 80021ce:	e77c      	b.n	80020ca <HAL_RCC_GetOscConfig+0x12>
  /* Get the LSE configuration -----------------------------------------------*/
  if((RCC->BDCR & RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
  }
  else if((RCC->BDCR & RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
 80021d0:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
 80021d4:	f013 0301 	ands.w	r3, r3, #1
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
 80021d8:	bf18      	it	ne
 80021da:	2301      	movne	r3, #1
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
 80021dc:	6083      	str	r3, [r0, #8]
 80021de:	e7a4      	b.n	800212a <HAL_RCC_GetOscConfig+0x72>
 80021e0:	40021000 	.word	0x40021000

080021e4 <HAL_RCC_GetClockConfig>:
  *         will be configured.
  * @param  pFLatency  Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 80021e4:	b410      	push	{r4}

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80021e6:	4b0e      	ldr	r3, [pc, #56]	; (8002220 <HAL_RCC_GetClockConfig+0x3c>)

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 80021e8:	4c0e      	ldr	r4, [pc, #56]	; (8002224 <HAL_RCC_GetClockConfig+0x40>)
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != NULL);
  assert_param(pFLatency != NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 80021ea:	220f      	movs	r2, #15
 80021ec:	6002      	str	r2, [r0, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80021ee:	689a      	ldr	r2, [r3, #8]
 80021f0:	f002 0203 	and.w	r2, r2, #3
 80021f4:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 80021f6:	689a      	ldr	r2, [r3, #8]
 80021f8:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80021fc:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 80021fe:	689a      	ldr	r2, [r3, #8]
 8002200:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8002204:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8002206:	689b      	ldr	r3, [r3, #8]
 8002208:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 800220c:	08db      	lsrs	r3, r3, #3
 800220e:	6103      	str	r3, [r0, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8002210:	6823      	ldr	r3, [r4, #0]
}
 8002212:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8002216:	f003 0307 	and.w	r3, r3, #7
 800221a:	600b      	str	r3, [r1, #0]
}
 800221c:	4770      	bx	lr
 800221e:	bf00      	nop
 8002220:	40021000 	.word	0x40021000
 8002224:	40022000 	.word	0x40022000

08002228 <HAL_RCC_EnableCSS>:
  * @note   The Clock Security System can only be cleared by reset.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
  SET_BIT(RCC->CR, RCC_CR_CSSON) ;
 8002228:	4a02      	ldr	r2, [pc, #8]	; (8002234 <HAL_RCC_EnableCSS+0xc>)
 800222a:	6813      	ldr	r3, [r2, #0]
 800222c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8002230:	6013      	str	r3, [r2, #0]
 8002232:	4770      	bx	lr
 8002234:	40021000 	.word	0x40021000

08002238 <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCC_CSSCallback(void)
{
 8002238:	4770      	bx	lr
 800223a:	bf00      	nop

0800223c <HAL_RCC_NMI_IRQHandler>:
  * @brief Handle the RCC Clock Security System interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
 800223c:	b510      	push	{r4, lr}
  /* Check RCC CSSF interrupt flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
 800223e:	4c05      	ldr	r4, [pc, #20]	; (8002254 <HAL_RCC_NMI_IRQHandler+0x18>)
 8002240:	69e3      	ldr	r3, [r4, #28]
 8002242:	05db      	lsls	r3, r3, #23
 8002244:	d504      	bpl.n	8002250 <HAL_RCC_NMI_IRQHandler+0x14>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CSSCallback();
 8002246:	f7ff fff7 	bl	8002238 <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 800224a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800224e:	6223      	str	r3, [r4, #32]
 8002250:	bd10      	pop	{r4, pc}
 8002252:	bf00      	nop
 8002254:	40021000 	.word	0x40021000

08002258 <HAL_PWR_DeInit>:
  * @brief Deinitialize the HAL PWR peripheral registers to their default reset values.
  * @retval None
  */
void HAL_PWR_DeInit(void)
{
  __HAL_RCC_PWR_FORCE_RESET();
 8002258:	4b04      	ldr	r3, [pc, #16]	; (800226c <HAL_PWR_DeInit+0x14>)
 800225a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800225c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002260:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_RCC_PWR_RELEASE_RESET();
 8002262:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002264:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8002268:	639a      	str	r2, [r3, #56]	; 0x38
 800226a:	4770      	bx	lr
 800226c:	40021000 	.word	0x40021000

08002270 <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.                
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);    
 8002270:	4a02      	ldr	r2, [pc, #8]	; (800227c <HAL_PWR_EnableBkUpAccess+0xc>)
 8002272:	6813      	ldr	r3, [r2, #0]
 8002274:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002278:	6013      	str	r3, [r2, #0]
 800227a:	4770      	bx	lr
 800227c:	40007000 	.word	0x40007000

08002280 <HAL_PWR_DisableBkUpAccess>:
  *        (RTC registers, RTC backup data registers).    
  * @retval None
  */
void HAL_PWR_DisableBkUpAccess(void)
{
  CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);   
 8002280:	4a02      	ldr	r2, [pc, #8]	; (800228c <HAL_PWR_DisableBkUpAccess+0xc>)
 8002282:	6813      	ldr	r3, [r2, #0]
 8002284:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002288:	6013      	str	r3, [r2, #0]
 800228a:	4770      	bx	lr
 800228c:	40007000 	.word	0x40007000

08002290 <HAL_PWR_ConfigPVD>:
  *         more details about the voltage thresholds corresponding to each
  *         detection level.
  * @retval None
  */
HAL_StatusTypeDef HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
{
 8002290:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));

  /* Set PLS bits according to PVDLevel value */
  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, sConfigPVD->PVDLevel);
 8002292:	4c1d      	ldr	r4, [pc, #116]	; (8002308 <HAL_PWR_ConfigPVD+0x78>)
  
  /* Clear any previous config. Keep it clear if no event or IT mode is selected */
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 8002294:	4b1d      	ldr	r3, [pc, #116]	; (800230c <HAL_PWR_ConfigPVD+0x7c>)
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));

  /* Set PLS bits according to PVDLevel value */
  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, sConfigPVD->PVDLevel);
 8002296:	6862      	ldr	r2, [r4, #4]
 8002298:	f022 010e 	bic.w	r1, r2, #14
 800229c:	6802      	ldr	r2, [r0, #0]
 800229e:	430a      	orrs	r2, r1
 80022a0:	6062      	str	r2, [r4, #4]
  
  /* Clear any previous config. Keep it clear if no event or IT mode is selected */
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 80022a2:	685a      	ldr	r2, [r3, #4]
 80022a4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80022a8:	605a      	str	r2, [r3, #4]
  __HAL_PWR_PVD_EXTI_DISABLE_IT();
 80022aa:	681a      	ldr	r2, [r3, #0]
 80022ac:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80022b0:	601a      	str	r2, [r3, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
 80022b2:	68da      	ldr	r2, [r3, #12]
 80022b4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80022b8:	60da      	str	r2, [r3, #12]
  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
 80022ba:	689a      	ldr	r2, [r3, #8]
 80022bc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80022c0:	609a      	str	r2, [r3, #8]

  /* Configure interrupt mode */
  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
 80022c2:	6842      	ldr	r2, [r0, #4]
 80022c4:	03d1      	lsls	r1, r2, #15
 80022c6:	d504      	bpl.n	80022d2 <HAL_PWR_ConfigPVD+0x42>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT();
 80022c8:	681a      	ldr	r2, [r3, #0]
 80022ca:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80022ce:	601a      	str	r2, [r3, #0]
 80022d0:	6842      	ldr	r2, [r0, #4]
  }
  
  /* Configure event mode */
  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 80022d2:	0394      	lsls	r4, r2, #14
 80022d4:	d505      	bpl.n	80022e2 <HAL_PWR_ConfigPVD+0x52>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
 80022d6:	4a0d      	ldr	r2, [pc, #52]	; (800230c <HAL_PWR_ConfigPVD+0x7c>)
 80022d8:	6853      	ldr	r3, [r2, #4]
 80022da:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80022de:	6053      	str	r3, [r2, #4]
 80022e0:	6842      	ldr	r2, [r0, #4]
  }
  
  /* Configure the edge */
  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 80022e2:	07d1      	lsls	r1, r2, #31
 80022e4:	d505      	bpl.n	80022f2 <HAL_PWR_ConfigPVD+0x62>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 80022e6:	4a09      	ldr	r2, [pc, #36]	; (800230c <HAL_PWR_ConfigPVD+0x7c>)
 80022e8:	6893      	ldr	r3, [r2, #8]
 80022ea:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80022ee:	6093      	str	r3, [r2, #8]
 80022f0:	6842      	ldr	r2, [r0, #4]
  }
  
  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 80022f2:	0793      	lsls	r3, r2, #30
 80022f4:	d504      	bpl.n	8002300 <HAL_PWR_ConfigPVD+0x70>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 80022f6:	4a05      	ldr	r2, [pc, #20]	; (800230c <HAL_PWR_ConfigPVD+0x7c>)
 80022f8:	68d3      	ldr	r3, [r2, #12]
 80022fa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80022fe:	60d3      	str	r3, [r2, #12]
  }
  
  return HAL_OK;
}
 8002300:	2000      	movs	r0, #0
 8002302:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002306:	4770      	bx	lr
 8002308:	40007000 	.word	0x40007000
 800230c:	40010400 	.word	0x40010400

08002310 <HAL_PWR_EnablePVD>:
  * @brief Enable the Power Voltage Detector (PVD).
  * @retval None
  */
void HAL_PWR_EnablePVD(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_PVDE);  
 8002310:	4a02      	ldr	r2, [pc, #8]	; (800231c <HAL_PWR_EnablePVD+0xc>)
 8002312:	6853      	ldr	r3, [r2, #4]
 8002314:	f043 0301 	orr.w	r3, r3, #1
 8002318:	6053      	str	r3, [r2, #4]
 800231a:	4770      	bx	lr
 800231c:	40007000 	.word	0x40007000

08002320 <HAL_PWR_DisablePVD>:
  * @brief Disable the Power Voltage Detector (PVD).
  * @retval None
  */
void HAL_PWR_DisablePVD(void)
{
  CLEAR_BIT(PWR->CR2, PWR_CR2_PVDE);   
 8002320:	4a02      	ldr	r2, [pc, #8]	; (800232c <HAL_PWR_DisablePVD+0xc>)
 8002322:	6853      	ldr	r3, [r2, #4]
 8002324:	f023 0301 	bic.w	r3, r3, #1
 8002328:	6053      	str	r3, [r2, #4]
 800232a:	4770      	bx	lr
 800232c:	40007000 	.word	0x40007000

08002330 <HAL_PWR_EnableWakeUpPin>:
{
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinPolarity)); 
  
  /* Specifies the Wake-Up pin polarity for the event detection 
    (rising or falling edge) */
  MODIFY_REG(PWR->CR4, (PWR_CR3_EWUP & WakeUpPinPolarity), (WakeUpPinPolarity >> PWR_WUP_POLARITY_SHIFT)); 
 8002330:	4a06      	ldr	r2, [pc, #24]	; (800234c <HAL_PWR_EnableWakeUpPin+0x1c>)
 8002332:	68d3      	ldr	r3, [r2, #12]
 8002334:	f000 011f 	and.w	r1, r0, #31
 8002338:	ea23 0301 	bic.w	r3, r3, r1
 800233c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8002340:	60d0      	str	r0, [r2, #12]
    
  /* Enable wake-up pin */
  SET_BIT(PWR->CR3, (PWR_CR3_EWUP & WakeUpPinPolarity));
 8002342:	6893      	ldr	r3, [r2, #8]
 8002344:	430b      	orrs	r3, r1
 8002346:	6093      	str	r3, [r2, #8]
 8002348:	4770      	bx	lr
 800234a:	bf00      	nop
 800234c:	40007000 	.word	0x40007000

08002350 <HAL_PWR_DisableWakeUpPin>:
  */
void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
{
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));

  CLEAR_BIT(PWR->CR3, WakeUpPinx); 
 8002350:	4a02      	ldr	r2, [pc, #8]	; (800235c <HAL_PWR_DisableWakeUpPin+0xc>)
 8002352:	6893      	ldr	r3, [r2, #8]
 8002354:	ea23 0000 	bic.w	r0, r3, r0
 8002358:	6090      	str	r0, [r2, #8]
 800235a:	4770      	bx	lr
 800235c:	40007000 	.word	0x40007000

08002360 <HAL_PWR_EnterSLEEPMode>:
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as 
  *        the interrupt wake up source.   
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
 8002360:	b510      	push	{r4, lr}

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 8002362:	4b0d      	ldr	r3, [pc, #52]	; (8002398 <HAL_PWR_EnterSLEEPMode+0x38>)
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as 
  *        the interrupt wake up source.   
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
 8002364:	460c      	mov	r4, r1

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 8002366:	695b      	ldr	r3, [r3, #20]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 8002368:	b960      	cbnz	r0, 8002384 <HAL_PWR_EnterSLEEPMode+0x24>
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 800236a:	059a      	lsls	r2, r3, #22
 800236c:	d40f      	bmi.n	800238e <HAL_PWR_EnterSLEEPMode+0x2e>
      HAL_PWREx_EnableLowPowerRunMode();  
    } 
  } 
    
  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800236e:	4a0b      	ldr	r2, [pc, #44]	; (800239c <HAL_PWR_EnterSLEEPMode+0x3c>)
 8002370:	6913      	ldr	r3, [r2, #16]
  
  /* Select SLEEP mode entry -------------------------------------------------*/
  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 8002372:	2c01      	cmp	r4, #1
      HAL_PWREx_EnableLowPowerRunMode();  
    } 
  } 
    
  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8002374:	f023 0304 	bic.w	r3, r3, #4
 8002378:	6113      	str	r3, [r2, #16]
  
  /* Select SLEEP mode entry -------------------------------------------------*/
  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 800237a:	d00b      	beq.n	8002394 <HAL_PWR_EnterSLEEPMode+0x34>

    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
{
  __ASM volatile ("sev");
 800237c:	bf40      	sev
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 800237e:	bf20      	wfe
 8002380:	bf20      	wfe
 8002382:	bd10      	pop	{r4, pc}
  }
  else
  {
    /* If in run mode, first move to low-power run mode.
       The system clock frequency must be below 2 MHz at this point. */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF) == RESET)
 8002384:	059b      	lsls	r3, r3, #22
 8002386:	d4f2      	bmi.n	800236e <HAL_PWR_EnterSLEEPMode+0xe>
    {
      HAL_PWREx_EnableLowPowerRunMode();  
 8002388:	f7fe ff68 	bl	800125c <HAL_PWREx_EnableLowPowerRunMode>
 800238c:	e7ef      	b.n	800236e <HAL_PWR_EnterSLEEPMode+0xe>
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
    {
      HAL_PWREx_DisableLowPowerRunMode();  
 800238e:	f7fe ff6d 	bl	800126c <HAL_PWREx_DisableLowPowerRunMode>
 8002392:	e7ec      	b.n	800236e <HAL_PWR_EnterSLEEPMode+0xe>
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8002394:	bf30      	wfi
 8002396:	bd10      	pop	{r4, pc}
 8002398:	40007000 	.word	0x40007000
 800239c:	e000ed00 	.word	0xe000ed00

080023a0 <HAL_PWR_EnterSTOPMode>:
  *            @arg PWR_STOPENTRY_WFE: Enter Stop 1 mode with WFE instruction           
  * @retval None
  */
void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
{
  HAL_PWREx_EnterSTOP1Mode(Regulator, STOPEntry);
 80023a0:	f7fe bf88 	b.w	80012b4 <HAL_PWREx_EnterSTOP1Mode>

080023a4 <HAL_PWR_EnterSTANDBYMode>:
  * @retval None
  */
void HAL_PWR_EnterSTANDBYMode(void)
{
  /* Set Stand-by mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STANDBY);
 80023a4:	4906      	ldr	r1, [pc, #24]	; (80023c0 <HAL_PWR_EnterSTANDBYMode+0x1c>)

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 80023a6:	4a07      	ldr	r2, [pc, #28]	; (80023c4 <HAL_PWR_EnterSTANDBYMode+0x20>)
  * @retval None
  */
void HAL_PWR_EnterSTANDBYMode(void)
{
  /* Set Stand-by mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STANDBY);
 80023a8:	680b      	ldr	r3, [r1, #0]
 80023aa:	f023 0307 	bic.w	r3, r3, #7
 80023ae:	f043 0303 	orr.w	r3, r3, #3
 80023b2:	600b      	str	r3, [r1, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 80023b4:	6913      	ldr	r3, [r2, #16]
 80023b6:	f043 0304 	orr.w	r3, r3, #4
 80023ba:	6113      	str	r3, [r2, #16]
 80023bc:	bf30      	wfi
 80023be:	4770      	bx	lr
 80023c0:	40007000 	.word	0x40007000
 80023c4:	e000ed00 	.word	0xe000ed00

080023c8 <HAL_PWR_EnableSleepOnExit>:
  * @retval None
  */
void HAL_PWR_EnableSleepOnExit(void)
{
  /* Set SLEEPONEXIT bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 80023c8:	4a02      	ldr	r2, [pc, #8]	; (80023d4 <HAL_PWR_EnableSleepOnExit+0xc>)
 80023ca:	6913      	ldr	r3, [r2, #16]
 80023cc:	f043 0302 	orr.w	r3, r3, #2
 80023d0:	6113      	str	r3, [r2, #16]
 80023d2:	4770      	bx	lr
 80023d4:	e000ed00 	.word	0xe000ed00

080023d8 <HAL_PWR_DisableSleepOnExit>:
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit(void)
{
  /* Clear SLEEPONEXIT bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 80023d8:	4a02      	ldr	r2, [pc, #8]	; (80023e4 <HAL_PWR_DisableSleepOnExit+0xc>)
 80023da:	6913      	ldr	r3, [r2, #16]
 80023dc:	f023 0302 	bic.w	r3, r3, #2
 80023e0:	6113      	str	r3, [r2, #16]
 80023e2:	4770      	bx	lr
 80023e4:	e000ed00 	.word	0xe000ed00

080023e8 <HAL_PWR_EnableSEVOnPend>:
  * @retval None
  */
void HAL_PWR_EnableSEVOnPend(void)
{
  /* Set SEVONPEND bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 80023e8:	4a02      	ldr	r2, [pc, #8]	; (80023f4 <HAL_PWR_EnableSEVOnPend+0xc>)
 80023ea:	6913      	ldr	r3, [r2, #16]
 80023ec:	f043 0310 	orr.w	r3, r3, #16
 80023f0:	6113      	str	r3, [r2, #16]
 80023f2:	4770      	bx	lr
 80023f4:	e000ed00 	.word	0xe000ed00

080023f8 <HAL_PWR_DisableSEVOnPend>:
  * @retval None
  */
void HAL_PWR_DisableSEVOnPend(void)
{
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 80023f8:	4a02      	ldr	r2, [pc, #8]	; (8002404 <HAL_PWR_DisableSEVOnPend+0xc>)
 80023fa:	6913      	ldr	r3, [r2, #16]
 80023fc:	f023 0310 	bic.w	r3, r3, #16
 8002400:	6113      	str	r3, [r2, #16]
 8002402:	4770      	bx	lr
 8002404:	e000ed00 	.word	0xe000ed00

08002408 <HAL_PWR_PVDCallback>:
/**
  * @brief PWR PVD interrupt callback
  * @retval None
  */
__weak void HAL_PWR_PVDCallback(void)
{
 8002408:	4770      	bx	lr
 800240a:	bf00      	nop

0800240c <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800240c:	f8df d034 	ldr.w	sp, [pc, #52]	; 8002444 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8002410:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8002412:	e003      	b.n	800241c <LoopCopyDataInit>

08002414 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8002414:	4b0c      	ldr	r3, [pc, #48]	; (8002448 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8002416:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8002418:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800241a:	3104      	adds	r1, #4

0800241c <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 800241c:	480b      	ldr	r0, [pc, #44]	; (800244c <LoopForever+0xa>)
	ldr	r3, =_edata
 800241e:	4b0c      	ldr	r3, [pc, #48]	; (8002450 <LoopForever+0xe>)
	adds	r2, r0, r1
 8002420:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8002422:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8002424:	d3f6      	bcc.n	8002414 <CopyDataInit>
	ldr	r2, =_sbss
 8002426:	4a0b      	ldr	r2, [pc, #44]	; (8002454 <LoopForever+0x12>)
	b	LoopFillZerobss
 8002428:	e002      	b.n	8002430 <LoopFillZerobss>

0800242a <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 800242a:	2300      	movs	r3, #0
	str	r3, [r2], #4
 800242c:	f842 3b04 	str.w	r3, [r2], #4

08002430 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8002430:	4b09      	ldr	r3, [pc, #36]	; (8002458 <LoopForever+0x16>)
	cmp	r2, r3
 8002432:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8002434:	d3f9      	bcc.n	800242a <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8002436:	f7fd fef3 	bl	8000220 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800243a:	f000 f86d 	bl	8002518 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 800243e:	f000 f80f 	bl	8002460 <main>

08002442 <LoopForever>:

LoopForever:
    b LoopForever
 8002442:	e7fe      	b.n	8002442 <LoopForever>

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8002444:	20018000 	.word	0x20018000
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8002448:	08002798 	.word	0x08002798
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 800244c:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8002450:	20000430 	.word	0x20000430
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 8002454:	20000430 	.word	0x20000430
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 8002458:	20000450 	.word	0x20000450

0800245c <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 800245c:	e7fe      	b.n	800245c <ADC1_2_IRQHandler>
	...

08002460 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 8002460:	b500      	push	{lr}
 8002462:	b089      	sub	sp, #36	; 0x24
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8002464:	f7fd ffec 	bl	8000440 <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 8002468:	f7fd ff5c 	bl	8000324 <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOB_CLK_ENABLE();
 800246c:	4b27      	ldr	r3, [pc, #156]	; (800250c <main+0xac>)
  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);
 800246e:	4828      	ldr	r0, [pc, #160]	; (8002510 <main+0xb0>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOB_CLK_ENABLE();
 8002470:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002472:	f042 0202 	orr.w	r2, r2, #2
 8002476:	64da      	str	r2, [r3, #76]	; 0x4c
 8002478:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800247a:	f002 0202 	and.w	r2, r2, #2
 800247e:	9200      	str	r2, [sp, #0]
 8002480:	9a00      	ldr	r2, [sp, #0]
  __GPIOE_CLK_ENABLE();
 8002482:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002484:	f042 0210 	orr.w	r2, r2, #16
 8002488:	64da      	str	r2, [r3, #76]	; 0x4c
 800248a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800248c:	f002 0210 	and.w	r2, r2, #16
 8002490:	9201      	str	r2, [sp, #4]
 8002492:	9a01      	ldr	r2, [sp, #4]
  __GPIOA_CLK_ENABLE();
 8002494:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002496:	f042 0201 	orr.w	r2, r2, #1
 800249a:	64da      	str	r2, [r3, #76]	; 0x4c
 800249c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800249e:	f003 0301 	and.w	r3, r3, #1

  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80024a2:	2401      	movs	r4, #1
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOB_CLK_ENABLE();
  __GPIOE_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
 80024a4:	9302      	str	r3, [sp, #8]
  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);
 80024a6:	a903      	add	r1, sp, #12
  __GPIOB_CLK_ENABLE();
  __GPIOE_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();

  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
 80024a8:	2304      	movs	r3, #4
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80024aa:	2503      	movs	r5, #3
  __GPIOB_CLK_ENABLE();
  __GPIOE_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();

  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
 80024ac:	9303      	str	r3, [sp, #12]
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOB_CLK_ENABLE();
  __GPIOE_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
 80024ae:	9a02      	ldr	r2, [sp, #8]

  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80024b0:	9404      	str	r4, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80024b2:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80024b4:	9506      	str	r5, [sp, #24]
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);
 80024b6:	f7fe f9d3 	bl	8000860 <HAL_GPIO_Init>

  /*Configure GPIO pin : GREEN_LED_Pin */
  GPIO_InitStruct.Pin = GREEN_LED_Pin;
 80024ba:	f44f 7380 	mov.w	r3, #256	; 0x100
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GREEN_LED_GPIO_Port, &GPIO_InitStruct);
 80024be:	a903      	add	r1, sp, #12
 80024c0:	4814      	ldr	r0, [pc, #80]	; (8002514 <main+0xb4>)
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : GREEN_LED_Pin */
  GPIO_InitStruct.Pin = GREEN_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80024c2:	9404      	str	r4, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80024c4:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80024c6:	9506      	str	r5, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : GREEN_LED_Pin */
  GPIO_InitStruct.Pin = GREEN_LED_Pin;
 80024c8:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GREEN_LED_GPIO_Port, &GPIO_InitStruct);
 80024ca:	f7fe f9c9 	bl	8000860 <HAL_GPIO_Init>
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
  /* USER CODE END WHILE */
    HAL_GPIO_WritePin(RED_LED_GPIO_Port, RED_LED_Pin, GPIO_PIN_SET);
 80024ce:	4810      	ldr	r0, [pc, #64]	; (8002510 <main+0xb0>)
 80024d0:	2104      	movs	r1, #4
 80024d2:	2201      	movs	r2, #1
 80024d4:	f7fe fb74 	bl	8000bc0 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GREEN_LED_GPIO_Port, GREEN_LED_Pin, GPIO_PIN_SET);
 80024d8:	f44f 7180 	mov.w	r1, #256	; 0x100
 80024dc:	2201      	movs	r2, #1
 80024de:	480d      	ldr	r0, [pc, #52]	; (8002514 <main+0xb4>)
 80024e0:	f7fe fb6e 	bl	8000bc0 <HAL_GPIO_WritePin>

    HAL_Delay(500);
 80024e4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80024e8:	f7fd ffca 	bl	8000480 <HAL_Delay>

    HAL_GPIO_WritePin(RED_LED_GPIO_Port, RED_LED_Pin, GPIO_PIN_RESET);
 80024ec:	4808      	ldr	r0, [pc, #32]	; (8002510 <main+0xb0>)
 80024ee:	2104      	movs	r1, #4
 80024f0:	2200      	movs	r2, #0
 80024f2:	f7fe fb65 	bl	8000bc0 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GREEN_LED_GPIO_Port, GREEN_LED_Pin, GPIO_PIN_RESET);
 80024f6:	4807      	ldr	r0, [pc, #28]	; (8002514 <main+0xb4>)
 80024f8:	f44f 7180 	mov.w	r1, #256	; 0x100
 80024fc:	2200      	movs	r2, #0
 80024fe:	f7fe fb5f 	bl	8000bc0 <HAL_GPIO_WritePin>

    HAL_Delay(500);
 8002502:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002506:	f7fd ffbb 	bl	8000480 <HAL_Delay>



  /* USER CODE BEGIN 3 */

  }
 800250a:	e7e0      	b.n	80024ce <main+0x6e>
 800250c:	40021000 	.word	0x40021000
 8002510:	48000400 	.word	0x48000400
 8002514:	48001000 	.word	0x48001000

08002518 <__libc_init_array>:
 8002518:	e92d4070 	push	{r4, r5, r6, lr}
 800251c:	e59f6064 	ldr	r6, [pc, #100]	; 8002588 <__libc_init_array+0x70>
 8002520:	e59f5064 	ldr	r5, [pc, #100]	; 800258c <__libc_init_array+0x74>
 8002524:	e0656006 	rsb	r6, r5, r6
 8002528:	e1b06146 	asrs	r6, r6, #2
 800252c:	13a04000 	movne	r4, #0
 8002530:	0a000005 	beq	800254c <__libc_init_array+0x34>
 8002534:	e2844001 	add	r4, r4, #1
 8002538:	e4953004 	ldr	r3, [r5], #4
 800253c:	e1a0e00f 	mov	lr, pc
 8002540:	e12fff13 	bx	r3
 8002544:	e1560004 	cmp	r6, r4
 8002548:	1afffff9 	bne	8002534 <__libc_init_array+0x1c>
 800254c:	e59f603c 	ldr	r6, [pc, #60]	; 8002590 <__libc_init_array+0x78>
 8002550:	e59f503c 	ldr	r5, [pc, #60]	; 8002594 <__libc_init_array+0x7c>
 8002554:	e0656006 	rsb	r6, r5, r6
 8002558:	eb000069 	bl	8002704 <_init>
 800255c:	e1b06146 	asrs	r6, r6, #2
 8002560:	13a04000 	movne	r4, #0
 8002564:	0a000005 	beq	8002580 <__libc_init_array+0x68>
 8002568:	e2844001 	add	r4, r4, #1
 800256c:	e4953004 	ldr	r3, [r5], #4
 8002570:	e1a0e00f 	mov	lr, pc
 8002574:	e12fff13 	bx	r3
 8002578:	e1560004 	cmp	r6, r4
 800257c:	1afffff9 	bne	8002568 <__libc_init_array+0x50>
 8002580:	e8bd4070 	pop	{r4, r5, r6, lr}
 8002584:	e12fff1e 	bx	lr
 8002588:	08002788 	.word	0x08002788
 800258c:	08002788 	.word	0x08002788
 8002590:	08002790 	.word	0x08002790
 8002594:	08002788 	.word	0x08002788

08002598 <register_fini>:
 8002598:	e92d4008 	push	{r3, lr}
 800259c:	e59f3010 	ldr	r3, [pc, #16]	; 80025b4 <register_fini+0x1c>
 80025a0:	e3530000 	cmp	r3, #0
 80025a4:	159f000c 	ldrne	r0, [pc, #12]	; 80025b8 <register_fini+0x20>
 80025a8:	1b000003 	blne	80025bc <atexit>
 80025ac:	e8bd4008 	pop	{r3, lr}
 80025b0:	e12fff1e 	bx	lr
 80025b4:	00000000 	.word	0x00000000
 80025b8:	080025dc 	.word	0x080025dc

080025bc <atexit>:
 80025bc:	e1a01000 	mov	r1, r0
 80025c0:	e3a00000 	mov	r0, #0
 80025c4:	e92d4008 	push	{r3, lr}
 80025c8:	e1a02000 	mov	r2, r0
 80025cc:	e1a03000 	mov	r3, r0
 80025d0:	eb000013 	bl	8002624 <__register_exitproc>
 80025d4:	e8bd4008 	pop	{r3, lr}
 80025d8:	e12fff1e 	bx	lr

080025dc <__libc_fini_array>:
 80025dc:	e92d4038 	push	{r3, r4, r5, lr}
 80025e0:	e59f5034 	ldr	r5, [pc, #52]	; 800261c <__libc_fini_array+0x40>
 80025e4:	e59f3034 	ldr	r3, [pc, #52]	; 8002620 <__libc_fini_array+0x44>
 80025e8:	e0653003 	rsb	r3, r5, r3
 80025ec:	e1b04143 	asrs	r4, r3, #2
 80025f0:	10835005 	addne	r5, r3, r5
 80025f4:	0a000005 	beq	8002610 <__libc_fini_array+0x34>
 80025f8:	e2444001 	sub	r4, r4, #1
 80025fc:	e5353004 	ldr	r3, [r5, #-4]!
 8002600:	e1a0e00f 	mov	lr, pc
 8002604:	e12fff13 	bx	r3
 8002608:	e3540000 	cmp	r4, #0
 800260c:	1afffff9 	bne	80025f8 <__libc_fini_array+0x1c>
 8002610:	eb000041 	bl	800271c <_fini>
 8002614:	e8bd4038 	pop	{r3, r4, r5, lr}
 8002618:	e12fff1e 	bx	lr
 800261c:	08002790 	.word	0x08002790
 8002620:	08002794 	.word	0x08002794

08002624 <__register_exitproc>:
 8002624:	e59fc0d0 	ldr	ip, [pc, #208]	; 80026fc <__register_exitproc+0xd8>
 8002628:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 800262c:	e59c4000 	ldr	r4, [ip]
 8002630:	e594c148 	ldr	ip, [r4, #328]	; 0x148
 8002634:	e35c0000 	cmp	ip, #0
 8002638:	0284cf53 	addeq	ip, r4, #332	; 0x14c
 800263c:	e59ce004 	ldr	lr, [ip, #4]
 8002640:	0584c148 	streq	ip, [r4, #328]	; 0x148
 8002644:	e35e001f 	cmp	lr, #31
 8002648:	e1a06001 	mov	r6, r1
 800264c:	e1a05000 	mov	r5, r0
 8002650:	e1a08002 	mov	r8, r2
 8002654:	e1a07003 	mov	r7, r3
 8002658:	d28e1001 	addle	r1, lr, #1
 800265c:	da00000f 	ble	80026a0 <__register_exitproc+0x7c>
 8002660:	e59f3098 	ldr	r3, [pc, #152]	; 8002700 <__register_exitproc+0xdc>
 8002664:	e3530000 	cmp	r3, #0
 8002668:	0a000021 	beq	80026f4 <__register_exitproc+0xd0>
 800266c:	e3a00e19 	mov	r0, #400	; 0x190
 8002670:	e320f000 	nop	{0}
 8002674:	e250c000 	subs	ip, r0, #0
 8002678:	0a00001d 	beq	80026f4 <__register_exitproc+0xd0>
 800267c:	e3a00000 	mov	r0, #0
 8002680:	e3a01001 	mov	r1, #1
 8002684:	e1a0e000 	mov	lr, r0
 8002688:	e5943148 	ldr	r3, [r4, #328]	; 0x148
 800268c:	e58c0004 	str	r0, [ip, #4]
 8002690:	e58c3000 	str	r3, [ip]
 8002694:	e584c148 	str	ip, [r4, #328]	; 0x148
 8002698:	e58c0188 	str	r0, [ip, #392]	; 0x188
 800269c:	e58c018c 	str	r0, [ip, #396]	; 0x18c
 80026a0:	e3550000 	cmp	r5, #0
 80026a4:	1a000005 	bne	80026c0 <__register_exitproc+0x9c>
 80026a8:	e3a00000 	mov	r0, #0
 80026ac:	e28ee002 	add	lr, lr, #2
 80026b0:	e58c1004 	str	r1, [ip, #4]
 80026b4:	e78c610e 	str	r6, [ip, lr, lsl #2]
 80026b8:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
 80026bc:	e12fff1e 	bx	lr
 80026c0:	e3a00001 	mov	r0, #1
 80026c4:	e08c310e 	add	r3, ip, lr, lsl #2
 80026c8:	e5838088 	str	r8, [r3, #136]	; 0x88
 80026cc:	e59c4188 	ldr	r4, [ip, #392]	; 0x188
 80026d0:	e1a02e10 	lsl	r2, r0, lr
 80026d4:	e1840002 	orr	r0, r4, r2
 80026d8:	e58c0188 	str	r0, [ip, #392]	; 0x188
 80026dc:	e5837108 	str	r7, [r3, #264]	; 0x108
 80026e0:	e3550002 	cmp	r5, #2
 80026e4:	059c318c 	ldreq	r3, [ip, #396]	; 0x18c
 80026e8:	01832002 	orreq	r2, r3, r2
 80026ec:	058c218c 	streq	r2, [ip, #396]	; 0x18c
 80026f0:	eaffffec 	b	80026a8 <__register_exitproc+0x84>
 80026f4:	e3e00000 	mvn	r0, #0
 80026f8:	eaffffee 	b	80026b8 <__register_exitproc+0x94>
 80026fc:	08002784 	.word	0x08002784
 8002700:	00000000 	.word	0x00000000

08002704 <_init>:
 8002704:	e1a0c00d 	mov	ip, sp
 8002708:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 800270c:	e24cb004 	sub	fp, ip, #4
 8002710:	e24bd028 	sub	sp, fp, #40	; 0x28
 8002714:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
 8002718:	e12fff1e 	bx	lr

0800271c <_fini>:
 800271c:	e1a0c00d 	mov	ip, sp
 8002720:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 8002724:	e24cb004 	sub	fp, ip, #4
 8002728:	e24bd028 	sub	sp, fp, #40	; 0x28
 800272c:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
 8002730:	e12fff1e 	bx	lr
 8002734:	00000000 	andeq	r0, r0, r0
