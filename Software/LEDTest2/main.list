
main.out:     file format elf32-littlearm


Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	e92d4010 	push	{r4, lr}
 800018c:	e59f4028 	ldr	r4, [pc, #40]	; 80001bc <__do_global_dtors_aux+0x34>
 8000190:	e5d43000 	ldrb	r3, [r4]
 8000194:	e3530000 	cmp	r3, #0
 8000198:	1a000005 	bne	80001b4 <__do_global_dtors_aux+0x2c>
 800019c:	e59f301c 	ldr	r3, [pc, #28]	; 80001c0 <__do_global_dtors_aux+0x38>
 80001a0:	e3530000 	cmp	r3, #0
 80001a4:	159f0018 	ldrne	r0, [pc, #24]	; 80001c4 <__do_global_dtors_aux+0x3c>
 80001a8:	1320f000 	nopne	{0}
 80001ac:	e3a03001 	mov	r3, #1
 80001b0:	e5c43000 	strb	r3, [r4]
 80001b4:	e8bd4010 	pop	{r4, lr}
 80001b8:	e12fff1e 	bx	lr
 80001bc:	20000430 	.word	0x20000430
 80001c0:	00000000 	.word	0x00000000
 80001c4:	0800281c 	.word	0x0800281c

080001c8 <frame_dummy>:
 80001c8:	e92d4008 	push	{r3, lr}
 80001cc:	e59f3034 	ldr	r3, [pc, #52]	; 8000208 <frame_dummy+0x40>
 80001d0:	e3530000 	cmp	r3, #0
 80001d4:	159f0030 	ldrne	r0, [pc, #48]	; 800020c <frame_dummy+0x44>
 80001d8:	159f1030 	ldrne	r1, [pc, #48]	; 8000210 <frame_dummy+0x48>
 80001dc:	1320f000 	nopne	{0}
 80001e0:	e59f002c 	ldr	r0, [pc, #44]	; 8000214 <frame_dummy+0x4c>
 80001e4:	e5903000 	ldr	r3, [r0]
 80001e8:	e3530000 	cmp	r3, #0
 80001ec:	0a000003 	beq	8000200 <frame_dummy+0x38>
 80001f0:	e59f3020 	ldr	r3, [pc, #32]	; 8000218 <frame_dummy+0x50>
 80001f4:	e3530000 	cmp	r3, #0
 80001f8:	11a0e00f 	movne	lr, pc
 80001fc:	112fff13 	bxne	r3
 8000200:	e8bd4008 	pop	{r3, lr}
 8000204:	e12fff1e 	bx	lr
 8000208:	00000000 	.word	0x00000000
 800020c:	0800281c 	.word	0x0800281c
 8000210:	20000434 	.word	0x20000434
 8000214:	20000430 	.word	0x20000430
 8000218:	00000000 	.word	0x00000000

0800021c <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 800021c:	b410      	push	{r4}
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800021e:	4a11      	ldr	r2, [pc, #68]	; (8000264 <SystemInit+0x48>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8000220:	4b11      	ldr	r3, [pc, #68]	; (8000268 <SystemInit+0x4c>)

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000222:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 8000226:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800022a:	f8c2 1088 	str.w	r1, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 800022e:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000230:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8000232:	f041 0101 	orr.w	r1, r1, #1
 8000236:	6019      	str	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000238:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 800023a:	6819      	ldr	r1, [r3, #0]
 800023c:	f021 51a8 	bic.w	r1, r1, #352321536	; 0x15000000
 8000240:	f421 2110 	bic.w	r1, r1, #589824	; 0x90000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000800;
 8000244:	f44f 6400 	mov.w	r4, #2048	; 0x800

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 8000248:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000800;
 800024a:	60dc      	str	r4, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800024c:	681c      	ldr	r4, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800024e:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000800;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000252:	f424 2480 	bic.w	r4, r4, #262144	; 0x40000
 8000256:	601c      	str	r4, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 8000258:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800025a:	6091      	str	r1, [r2, #8]
#endif
}
 800025c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000260:	4770      	bx	lr
 8000262:	bf00      	nop
 8000264:	e000ed00 	.word	0xe000ed00
 8000268:	40021000 	.word	0x40021000

0800026c <SystemCoreClockUpdate>:
  *
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 800026c:	b410      	push	{r4}
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
 800026e:	4b27      	ldr	r3, [pc, #156]	; (800030c <SystemCoreClockUpdate+0xa0>)
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000270:	4926      	ldr	r1, [pc, #152]	; (800030c <SystemCoreClockUpdate+0xa0>)
void SystemCoreClockUpdate(void)
{
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
 8000272:	681a      	ldr	r2, [r3, #0]
 8000274:	0712      	lsls	r2, r2, #28
  { /* MSISRANGE from RCC_CSR applies */
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 8000276:	bf54      	ite	pl
 8000278:	f8d3 0094 	ldrpl.w	r0, [r3, #148]	; 0x94
  }
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 800027c:	6818      	ldrmi	r0, [r3, #0]
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800027e:	688b      	ldr	r3, [r1, #8]
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 8000280:	4a23      	ldr	r2, [pc, #140]	; (8000310 <SystemCoreClockUpdate+0xa4>)
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
  { /* MSISRANGE from RCC_CSR applies */
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 8000282:	bf54      	ite	pl
 8000284:	f3c0 2003 	ubfxpl	r0, r0, #8, #4
  }
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 8000288:	f3c0 1003 	ubfxmi	r0, r0, #4, #4
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800028c:	f003 030c 	and.w	r3, r3, #12
 8000290:	2b08      	cmp	r3, #8
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 8000292:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000296:	d013      	beq.n	80002c0 <SystemCoreClockUpdate+0x54>
 8000298:	2b0c      	cmp	r3, #12
 800029a:	d013      	beq.n	80002c4 <SystemCoreClockUpdate+0x58>
 800029c:	491d      	ldr	r1, [pc, #116]	; (8000314 <SystemCoreClockUpdate+0xa8>)
 800029e:	2b04      	cmp	r3, #4
 80002a0:	bf14      	ite	ne
 80002a2:	4603      	movne	r3, r0
 80002a4:	460b      	moveq	r3, r1
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80002a6:	4819      	ldr	r0, [pc, #100]	; (800030c <SystemCoreClockUpdate+0xa0>)
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 80002a8:	491b      	ldr	r1, [pc, #108]	; (8000318 <SystemCoreClockUpdate+0xac>)
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80002aa:	6880      	ldr	r0, [r0, #8]
 80002ac:	f3c0 1003 	ubfx	r0, r0, #4, #4
 80002b0:	4402      	add	r2, r0
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 80002b2:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
 80002b6:	40d3      	lsrs	r3, r2
 80002b8:	600b      	str	r3, [r1, #0]
}
 80002ba:	f85d 4b04 	ldr.w	r4, [sp], #4
 80002be:	4770      	bx	lr
      SystemCoreClock = HSI_VALUE;
      break;

    case 0x08:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
      break;
 80002c0:	4b16      	ldr	r3, [pc, #88]	; (800031c <SystemCoreClockUpdate+0xb0>)
 80002c2:	e7f0      	b.n	80002a6 <SystemCoreClockUpdate+0x3a>

    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80002c4:	68cc      	ldr	r4, [r1, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;
 80002c6:	68cb      	ldr	r3, [r1, #12]

    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80002c8:	f004 0103 	and.w	r1, r4, #3
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;
 80002cc:	f3c3 1302 	ubfx	r3, r3, #4, #3

      switch (pllsource)
 80002d0:	2902      	cmp	r1, #2
    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;
 80002d2:	f103 0301 	add.w	r3, r3, #1

      switch (pllsource)
 80002d6:	d012      	beq.n	80002fe <SystemCoreClockUpdate+0x92>
 80002d8:	2903      	cmp	r1, #3
 80002da:	d114      	bne.n	8000306 <SystemCoreClockUpdate+0x9a>
        case 0x02:  /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm);
          break;

        case 0x03:  /* HSE used as PLL clock source */
          pllvco = (HSE_VALUE / pllm);
 80002dc:	480f      	ldr	r0, [pc, #60]	; (800031c <SystemCoreClockUpdate+0xb0>)
 80002de:	fbb0 f3f3 	udiv	r3, r0, r3

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80002e2:	490a      	ldr	r1, [pc, #40]	; (800030c <SystemCoreClockUpdate+0xa0>)
 80002e4:	68cc      	ldr	r4, [r1, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1) * 2;
 80002e6:	68c9      	ldr	r1, [r1, #12]
 80002e8:	f3c1 6141 	ubfx	r1, r1, #25, #2
 80002ec:	3101      	adds	r1, #1

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80002ee:	f3c4 2406 	ubfx	r4, r4, #8, #7
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1) * 2;
 80002f2:	0049      	lsls	r1, r1, #1

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80002f4:	fb04 f303 	mul.w	r3, r4, r3
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1) * 2;
      SystemCoreClock = pllvco/pllr;
 80002f8:	fbb3 f3f1 	udiv	r3, r3, r1
      break;
 80002fc:	e7d3      	b.n	80002a6 <SystemCoreClockUpdate+0x3a>
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;

      switch (pllsource)
      {
        case 0x02:  /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm);
 80002fe:	4805      	ldr	r0, [pc, #20]	; (8000314 <SystemCoreClockUpdate+0xa8>)
 8000300:	fbb0 f3f3 	udiv	r3, r0, r3
          break;
 8000304:	e7ed      	b.n	80002e2 <SystemCoreClockUpdate+0x76>
        case 0x03:  /* HSE used as PLL clock source */
          pllvco = (HSE_VALUE / pllm);
          break;

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
 8000306:	fbb0 f3f3 	udiv	r3, r0, r3
          break;
 800030a:	e7ea      	b.n	80002e2 <SystemCoreClockUpdate+0x76>
 800030c:	40021000 	.word	0x40021000
 8000310:	08002850 	.word	0x08002850
 8000314:	00f42400 	.word	0x00f42400
 8000318:	20000000 	.word	0x20000000
 800031c:	007a1200 	.word	0x007a1200

08000320 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 8000320:	b530      	push	{r4, r5, lr}
 8000322:	b097      	sub	sp, #92	; 0x5c

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8000324:	2400      	movs	r4, #0
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000326:	f44f 7280 	mov.w	r2, #256	; 0x100
{

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSE;
 800032a:	2106      	movs	r1, #6
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800032c:	2501      	movs	r5, #1
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 800032e:	2310      	movs	r3, #16
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8000330:	a806      	add	r0, sp, #24
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000332:	9209      	str	r2, [sp, #36]	; 0x24
{

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSE;
 8000334:	9106      	str	r1, [sp, #24]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 8000336:	930a      	str	r3, [sp, #40]	; 0x28

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8000338:	9508      	str	r5, [sp, #32]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 800033a:	940f      	str	r4, [sp, #60]	; 0x3c
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 800033c:	f001 f8e4 	bl	8001508 <HAL_RCC_OscConfig>

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000340:	230f      	movs	r3, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);
 8000342:	4621      	mov	r1, r4
 8000344:	a801      	add	r0, sp, #4
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000346:	9301      	str	r3, [sp, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
 8000348:	9502      	str	r5, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800034a:	9403      	str	r4, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800034c:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800034e:	9405      	str	r4, [sp, #20]
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);
 8000350:	f001 fcd0 	bl	8001cf4 <HAL_RCC_ClockConfig>

  HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_LSE, RCC_MCODIV_1);
 8000354:	f04f 61e0 	mov.w	r1, #117440512	; 0x7000000
 8000358:	4620      	mov	r0, r4
 800035a:	4622      	mov	r2, r4
 800035c:	f001 fe1a 	bl	8001f94 <HAL_RCC_MCOConfig>

  __PWR_CLK_ENABLE();
 8000360:	4b10      	ldr	r3, [pc, #64]	; (80003a4 <SystemClock_Config+0x84>)
 8000362:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000364:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000368:	659a      	str	r2, [r3, #88]	; 0x58
 800036a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800036c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000370:	9300      	str	r3, [sp, #0]

  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000372:	f44f 7000 	mov.w	r0, #512	; 0x200
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);

  HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_LSE, RCC_MCODIV_1);

  __PWR_CLK_ENABLE();
 8000376:	9b00      	ldr	r3, [sp, #0]

  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000378:	f000 fc84 	bl	8000c84 <HAL_PWREx_ControlVoltageScaling>

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 800037c:	f001 feb2 	bl	80020e4 <HAL_RCC_GetHCLKFreq>
 8000380:	4b09      	ldr	r3, [pc, #36]	; (80003a8 <SystemClock_Config+0x88>)
 8000382:	fba3 2000 	umull	r2, r0, r3, r0
 8000386:	0980      	lsrs	r0, r0, #6
 8000388:	f000 f9ae 	bl	80006e8 <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 800038c:	2004      	movs	r0, #4
 800038e:	f000 fa37 	bl	8000800 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8000392:	4621      	mov	r1, r4
 8000394:	4622      	mov	r2, r4
 8000396:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800039a:	f000 f941 	bl	8000620 <HAL_NVIC_SetPriority>
}
 800039e:	b017      	add	sp, #92	; 0x5c
 80003a0:	bd30      	pop	{r4, r5, pc}
 80003a2:	bf00      	nop
 80003a4:	40021000 	.word	0x40021000
 80003a8:	10624dd3 	.word	0x10624dd3

080003ac <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80003ac:	b500      	push	{lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __SYSCFG_CLK_ENABLE();
 80003ae:	4b0b      	ldr	r3, [pc, #44]	; (80003dc <HAL_MspInit+0x30>)
 80003b0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80003b2:	f042 0201 	orr.w	r2, r2, #1
 80003b6:	661a      	str	r2, [r3, #96]	; 0x60
 80003b8:	6e1b      	ldr	r3, [r3, #96]	; 0x60

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80003ba:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __SYSCFG_CLK_ENABLE();
 80003bc:	f003 0301 	and.w	r3, r3, #1
 80003c0:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80003c2:	2003      	movs	r0, #3
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __SYSCFG_CLK_ENABLE();
 80003c4:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80003c6:	f000 f919 	bl	80005fc <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80003ca:	2100      	movs	r1, #0
 80003cc:	460a      	mov	r2, r1
 80003ce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80003d2:	f000 f925 	bl	8000620 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80003d6:	b003      	add	sp, #12
 80003d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80003dc:	40021000 	.word	0x40021000

080003e0 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80003e0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80003e2:	f000 f845 	bl	8000470 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80003e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 80003ea:	f000 ba17 	b.w	800081c <HAL_SYSTICK_IRQHandler>
 80003ee:	bf00      	nop
/**
  * @brief  Initialize the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
 80003f0:	4770      	bx	lr
 80003f2:	bf00      	nop

080003f4 <HAL_MspDeInit>:
/**
  * @brief  DeInitialize the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
 80003f4:	4770      	bx	lr
 80003f6:	bf00      	nop

080003f8 <HAL_DeInit>:
  * @brief De-initialize common part of the HAL and stop the source of time base.
  * @note This function is optional.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
 80003f8:	b510      	push	{r4, lr}
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
 80003fa:	4b09      	ldr	r3, [pc, #36]	; (8000420 <HAL_DeInit+0x28>)
 80003fc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  __HAL_RCC_APB1_RELEASE_RESET();
 8000400:	2400      	movs	r4, #0
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
 8000402:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_RCC_APB1_RELEASE_RESET();
 8000404:	639c      	str	r4, [r3, #56]	; 0x38

  __HAL_RCC_APB2_FORCE_RESET();
 8000406:	641a      	str	r2, [r3, #64]	; 0x40
  __HAL_RCC_APB2_RELEASE_RESET();
 8000408:	641c      	str	r4, [r3, #64]	; 0x40

  __HAL_RCC_AHB1_FORCE_RESET();
 800040a:	629a      	str	r2, [r3, #40]	; 0x28
  __HAL_RCC_AHB1_RELEASE_RESET();
 800040c:	629c      	str	r4, [r3, #40]	; 0x28

  __HAL_RCC_AHB2_FORCE_RESET();
 800040e:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_RCC_AHB2_RELEASE_RESET();
 8000410:	62dc      	str	r4, [r3, #44]	; 0x2c

  __HAL_RCC_AHB3_FORCE_RESET();
 8000412:	631a      	str	r2, [r3, #48]	; 0x30
  __HAL_RCC_AHB3_RELEASE_RESET();
 8000414:	631c      	str	r4, [r3, #48]	; 0x30

  /* De-Init the low level hardware */
  HAL_MspDeInit();
 8000416:	f7ff ffed 	bl	80003f4 <HAL_MspDeInit>

  /* Return function status */
  return HAL_OK;
}
 800041a:	4620      	mov	r0, r4
 800041c:	bd10      	pop	{r4, pc}
 800041e:	bf00      	nop
 8000420:	40021000 	.word	0x40021000

08000424 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000424:	b510      	push	{r4, lr}
 8000426:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8000428:	f001 fe5c 	bl	80020e4 <HAL_RCC_GetHCLKFreq>
 800042c:	4b06      	ldr	r3, [pc, #24]	; (8000448 <HAL_InitTick+0x24>)
 800042e:	fba3 2000 	umull	r2, r0, r3, r0
 8000432:	0980      	lsrs	r0, r0, #6
 8000434:	f000 f958 	bl	80006e8 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8000438:	4621      	mov	r1, r4
 800043a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800043e:	2200      	movs	r2, #0
 8000440:	f000 f8ee 	bl	8000620 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8000444:	2000      	movs	r0, #0
 8000446:	bd10      	pop	{r4, pc}
 8000448:	10624dd3 	.word	0x10624dd3

0800044c <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800044c:	b508      	push	{r3, lr}
#if (DATA_CACHE_ENABLE == 0)
   __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800044e:	4b07      	ldr	r3, [pc, #28]	; (800046c <HAL_Init+0x20>)
 8000450:	681a      	ldr	r2, [r3, #0]
 8000452:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000456:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000458:	2003      	movs	r0, #3
 800045a:	f000 f8cf 	bl	80005fc <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800045e:	2000      	movs	r0, #0
 8000460:	f7ff ffe0 	bl	8000424 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000464:	f7ff ffa2 	bl	80003ac <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8000468:	2000      	movs	r0, #0
 800046a:	bd08      	pop	{r3, pc}
 800046c:	40022000 	.word	0x40022000

08000470 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000470:	4b02      	ldr	r3, [pc, #8]	; (800047c <HAL_IncTick+0xc>)
 8000472:	681a      	ldr	r2, [r3, #0]
 8000474:	3201      	adds	r2, #1
 8000476:	601a      	str	r2, [r3, #0]
 8000478:	4770      	bx	lr
 800047a:	bf00      	nop
 800047c:	2000044c 	.word	0x2000044c

08000480 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000480:	4b01      	ldr	r3, [pc, #4]	; (8000488 <HAL_GetTick+0x8>)
 8000482:	6818      	ldr	r0, [r3, #0]
}
 8000484:	4770      	bx	lr
 8000486:	bf00      	nop
 8000488:	2000044c 	.word	0x2000044c

0800048c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800048c:	b538      	push	{r3, r4, r5, lr}
 800048e:	4605      	mov	r5, r0
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 8000490:	f7ff fff6 	bl	8000480 <HAL_GetTick>
 8000494:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8000496:	f7ff fff3 	bl	8000480 <HAL_GetTick>
 800049a:	1b00      	subs	r0, r0, r4
 800049c:	42a8      	cmp	r0, r5
 800049e:	d3fa      	bcc.n	8000496 <HAL_Delay+0xa>
  {
  }
}
 80004a0:	bd38      	pop	{r3, r4, r5, pc}
 80004a2:	bf00      	nop

080004a4 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
 80004a4:	4b02      	ldr	r3, [pc, #8]	; (80004b0 <HAL_SuspendTick+0xc>)
 80004a6:	681a      	ldr	r2, [r3, #0]
 80004a8:	f022 0202 	bic.w	r2, r2, #2
 80004ac:	601a      	str	r2, [r3, #0]
 80004ae:	4770      	bx	lr
 80004b0:	e000e010 	.word	0xe000e010

080004b4 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
 80004b4:	4b02      	ldr	r3, [pc, #8]	; (80004c0 <HAL_ResumeTick+0xc>)
 80004b6:	681a      	ldr	r2, [r3, #0]
 80004b8:	f042 0202 	orr.w	r2, r2, #2
 80004bc:	601a      	str	r2, [r3, #0]
 80004be:	4770      	bx	lr
 80004c0:	e000e010 	.word	0xe000e010

080004c4 <HAL_GetHalVersion>:
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
 return __STM32L4xx_HAL_VERSION;
}
 80004c4:	4800      	ldr	r0, [pc, #0]	; (80004c8 <HAL_GetHalVersion+0x4>)
 80004c6:	4770      	bx	lr
 80004c8:	01010100 	.word	0x01010100

080004cc <HAL_GetREVID>:
  * @brief  Return the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE & DBGMCU_IDCODE_REV_ID) >> 16);
 80004cc:	4b01      	ldr	r3, [pc, #4]	; (80004d4 <HAL_GetREVID+0x8>)
 80004ce:	6818      	ldr	r0, [r3, #0]
}
 80004d0:	0c00      	lsrs	r0, r0, #16
 80004d2:	4770      	bx	lr
 80004d4:	e0042000 	.word	0xe0042000

080004d8 <HAL_GetDEVID>:
  * @brief  Return the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
   return(DBGMCU->IDCODE & DBGMCU_IDCODE_DEV_ID);
 80004d8:	4b02      	ldr	r3, [pc, #8]	; (80004e4 <HAL_GetDEVID+0xc>)
 80004da:	6818      	ldr	r0, [r3, #0]
}
 80004dc:	f3c0 000b 	ubfx	r0, r0, #0, #12
 80004e0:	4770      	bx	lr
 80004e2:	bf00      	nop
 80004e4:	e0042000 	.word	0xe0042000

080004e8 <HAL_DBGMCU_EnableDBGSleepMode>:
  * @brief  Enable the Debug Module during SLEEP mode.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 80004e8:	4b02      	ldr	r3, [pc, #8]	; (80004f4 <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 80004ea:	685a      	ldr	r2, [r3, #4]
 80004ec:	f042 0201 	orr.w	r2, r2, #1
 80004f0:	605a      	str	r2, [r3, #4]
 80004f2:	4770      	bx	lr
 80004f4:	e0042000 	.word	0xe0042000

080004f8 <HAL_DBGMCU_DisableDBGSleepMode>:
  * @brief  Disable the Debug Module during SLEEP mode.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 80004f8:	4b02      	ldr	r3, [pc, #8]	; (8000504 <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
 80004fa:	685a      	ldr	r2, [r3, #4]
 80004fc:	f022 0201 	bic.w	r2, r2, #1
 8000500:	605a      	str	r2, [r3, #4]
 8000502:	4770      	bx	lr
 8000504:	e0042000 	.word	0xe0042000

08000508 <HAL_DBGMCU_EnableDBGStopMode>:
  * @brief  Enable the Debug Module during STOP1/STOP2 modes.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8000508:	4b02      	ldr	r3, [pc, #8]	; (8000514 <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 800050a:	685a      	ldr	r2, [r3, #4]
 800050c:	f042 0202 	orr.w	r2, r2, #2
 8000510:	605a      	str	r2, [r3, #4]
 8000512:	4770      	bx	lr
 8000514:	e0042000 	.word	0xe0042000

08000518 <HAL_DBGMCU_DisableDBGStopMode>:
  * @brief  Disable the Debug Module during STOP1/STOP2 modes.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8000518:	4b02      	ldr	r3, [pc, #8]	; (8000524 <HAL_DBGMCU_DisableDBGStopMode+0xc>)
 800051a:	685a      	ldr	r2, [r3, #4]
 800051c:	f022 0202 	bic.w	r2, r2, #2
 8000520:	605a      	str	r2, [r3, #4]
 8000522:	4770      	bx	lr
 8000524:	e0042000 	.word	0xe0042000

08000528 <HAL_DBGMCU_EnableDBGStandbyMode>:
  * @brief  Enable the Debug Module during STANDBY mode.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 8000528:	4b02      	ldr	r3, [pc, #8]	; (8000534 <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 800052a:	685a      	ldr	r2, [r3, #4]
 800052c:	f042 0204 	orr.w	r2, r2, #4
 8000530:	605a      	str	r2, [r3, #4]
 8000532:	4770      	bx	lr
 8000534:	e0042000 	.word	0xe0042000

08000538 <HAL_DBGMCU_DisableDBGStandbyMode>:
  * @brief  Disable the Debug Module during STANDBY mode.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 8000538:	4b02      	ldr	r3, [pc, #8]	; (8000544 <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
 800053a:	685a      	ldr	r2, [r3, #4]
 800053c:	f022 0204 	bic.w	r2, r2, #4
 8000540:	605a      	str	r2, [r3, #4]
 8000542:	4770      	bx	lr
 8000544:	e0042000 	.word	0xe0042000

08000548 <HAL_SYSCFG_SRAM2Erase>:
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
 8000548:	4b05      	ldr	r3, [pc, #20]	; (8000560 <HAL_SYSCFG_SRAM2Erase+0x18>)
  SYSCFG->SKR = 0x53;
  /* Starts a hardware SRAM2 erase operation*/
  *(__IO uint32_t *) SCSR_SRAM2ER_BB = (uint8_t)0x00000001;
 800054a:	4a06      	ldr	r2, [pc, #24]	; (8000564 <HAL_SYSCFG_SRAM2Erase+0x1c>)
  * @note   As long as SRAM2 is not erased the SRAM2ER bit will be set.
  *         This bit is automatically reset at the end of the SRAM2 erase operation.
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
 800054c:	b410      	push	{r4}
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
  SYSCFG->SKR = 0x53;
 800054e:	2053      	movs	r0, #83	; 0x53
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
 8000550:	24ca      	movs	r4, #202	; 0xca
  SYSCFG->SKR = 0x53;
  /* Starts a hardware SRAM2 erase operation*/
  *(__IO uint32_t *) SCSR_SRAM2ER_BB = (uint8_t)0x00000001;
 8000552:	2101      	movs	r1, #1
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
 8000554:	625c      	str	r4, [r3, #36]	; 0x24
  SYSCFG->SKR = 0x53;
 8000556:	6258      	str	r0, [r3, #36]	; 0x24
  /* Starts a hardware SRAM2 erase operation*/
  *(__IO uint32_t *) SCSR_SRAM2ER_BB = (uint8_t)0x00000001;
 8000558:	6011      	str	r1, [r2, #0]
}
 800055a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800055e:	4770      	bx	lr
 8000560:	40010000 	.word	0x40010000
 8000564:	42200300 	.word	0x42200300

08000568 <HAL_SYSCFG_EnableMemorySwappingBank>:
  *
  * @retval None
  */
void HAL_SYSCFG_EnableMemorySwappingBank(void)
{
  *(__IO uint32_t *)FB_MODE_BB = (uint32_t)ENABLE;
 8000568:	4b01      	ldr	r3, [pc, #4]	; (8000570 <HAL_SYSCFG_EnableMemorySwappingBank+0x8>)
 800056a:	2201      	movs	r2, #1
 800056c:	601a      	str	r2, [r3, #0]
 800056e:	4770      	bx	lr
 8000570:	42200020 	.word	0x42200020

08000574 <HAL_SYSCFG_DisableMemorySwappingBank>:
  * @retval None
  */
void HAL_SYSCFG_DisableMemorySwappingBank(void)
{

  *(__IO uint32_t *)FB_MODE_BB = (uint32_t)DISABLE;
 8000574:	4b01      	ldr	r3, [pc, #4]	; (800057c <HAL_SYSCFG_DisableMemorySwappingBank+0x8>)
 8000576:	2200      	movs	r2, #0
 8000578:	601a      	str	r2, [r3, #0]
 800057a:	4770      	bx	lr
 800057c:	42200020 	.word	0x42200020

08000580 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig>:
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));
  
  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
 8000580:	4b03      	ldr	r3, [pc, #12]	; (8000590 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x10>)
 8000582:	681a      	ldr	r2, [r3, #0]
 8000584:	f022 0204 	bic.w	r2, r2, #4
 8000588:	4310      	orrs	r0, r2
 800058a:	6018      	str	r0, [r3, #0]
 800058c:	4770      	bx	lr
 800058e:	bf00      	nop
 8000590:	40010030 	.word	0x40010030

08000594 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));
  
  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
 8000594:	4b03      	ldr	r3, [pc, #12]	; (80005a4 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x10>)
 8000596:	681a      	ldr	r2, [r3, #0]
 8000598:	f022 0202 	bic.w	r2, r2, #2
 800059c:	4310      	orrs	r0, r2
 800059e:	6018      	str	r0, [r3, #0]
 80005a0:	4770      	bx	lr
 80005a2:	bf00      	nop
 80005a4:	40010030 	.word	0x40010030

080005a8 <HAL_SYSCFG_VREFBUF_TrimmingConfig>:
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));
  
  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
 80005a8:	4b03      	ldr	r3, [pc, #12]	; (80005b8 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x10>)
 80005aa:	685a      	ldr	r2, [r3, #4]
 80005ac:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 80005b0:	4310      	orrs	r0, r2
 80005b2:	6058      	str	r0, [r3, #4]
 80005b4:	4770      	bx	lr
 80005b6:	bf00      	nop
 80005b8:	40010030 	.word	0x40010030

080005bc <HAL_SYSCFG_EnableVREFBUF>:
/**
  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
  * @retval HAL_OK/HAL_TIMEOUT
  */
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
{
 80005bc:	b538      	push	{r3, r4, r5, lr}
  uint32_t  tickstart = 0;
  
  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
 80005be:	4c0a      	ldr	r4, [pc, #40]	; (80005e8 <HAL_SYSCFG_EnableVREFBUF+0x2c>)
 80005c0:	6823      	ldr	r3, [r4, #0]
 80005c2:	f043 0301 	orr.w	r3, r3, #1
 80005c6:	6023      	str	r3, [r4, #0]
  
  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80005c8:	f7ff ff5a 	bl	8000480 <HAL_GetTick>
 80005cc:	4605      	mov	r5, r0

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == RESET)
 80005ce:	e004      	b.n	80005da <HAL_SYSCFG_EnableVREFBUF+0x1e>
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
 80005d0:	f7ff ff56 	bl	8000480 <HAL_GetTick>
 80005d4:	1b40      	subs	r0, r0, r5
 80005d6:	280a      	cmp	r0, #10
 80005d8:	d804      	bhi.n	80005e4 <HAL_SYSCFG_EnableVREFBUF+0x28>
  
  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == RESET)
 80005da:	6823      	ldr	r3, [r4, #0]
 80005dc:	071b      	lsls	r3, r3, #28
 80005de:	d5f7      	bpl.n	80005d0 <HAL_SYSCFG_EnableVREFBUF+0x14>
    {
      return HAL_TIMEOUT;
    }
  }
  
  return HAL_OK;
 80005e0:	2000      	movs	r0, #0
 80005e2:	bd38      	pop	{r3, r4, r5, pc}
  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == RESET)
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
 80005e4:	2003      	movs	r0, #3
    }
  }
  
  return HAL_OK;
}
 80005e6:	bd38      	pop	{r3, r4, r5, pc}
 80005e8:	40010030 	.word	0x40010030

080005ec <HAL_SYSCFG_DisableVREFBUF>:
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
 80005ec:	4b02      	ldr	r3, [pc, #8]	; (80005f8 <HAL_SYSCFG_DisableVREFBUF+0xc>)
 80005ee:	681a      	ldr	r2, [r3, #0]
 80005f0:	f022 0201 	bic.w	r2, r2, #1
 80005f4:	601a      	str	r2, [r3, #0]
 80005f6:	4770      	bx	lr
 80005f8:	40010030 	.word	0x40010030

080005fc <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80005fc:	4a07      	ldr	r2, [pc, #28]	; (800061c <HAL_NVIC_SetPriorityGrouping+0x20>)
 80005fe:	68d1      	ldr	r1, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8000600:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8000604:	400b      	ands	r3, r1
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000606:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800060a:	f000 0007 	and.w	r0, r0, #7

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800060e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000612:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000616:	60d3      	str	r3, [r2, #12]
 8000618:	4770      	bx	lr
 800061a:	bf00      	nop
 800061c:	e000ed00 	.word	0xe000ed00

08000620 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000620:	b430      	push	{r4, r5}

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000622:	4b19      	ldr	r3, [pc, #100]	; (8000688 <HAL_NVIC_SetPriority+0x68>)
 8000624:	68dc      	ldr	r4, [r3, #12]
 8000626:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800062a:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800062e:	1d25      	adds	r5, r4, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000630:	2b04      	cmp	r3, #4
 8000632:	bf28      	it	cs
 8000634:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000636:	2d06      	cmp	r5, #6
 8000638:	d919      	bls.n	800066e <HAL_NVIC_SetPriority+0x4e>
 800063a:	3c03      	subs	r4, #3
 800063c:	2501      	movs	r5, #1
 800063e:	40a5      	lsls	r5, r4
 8000640:	3d01      	subs	r5, #1
 8000642:	402a      	ands	r2, r5

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000644:	2501      	movs	r5, #1
 8000646:	fa05 f303 	lsl.w	r3, r5, r3
 800064a:	3b01      	subs	r3, #1
 800064c:	4019      	ands	r1, r3
 800064e:	fa01 f404 	lsl.w	r4, r1, r4
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
 8000652:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000654:	ea44 0402 	orr.w	r4, r4, r2
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
 8000658:	db0c      	blt.n	8000674 <HAL_NVIC_SetPriority+0x54>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800065a:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800065e:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000662:	0124      	lsls	r4, r4, #4
 8000664:	b2e4      	uxtb	r4, r4
 8000666:	f880 4300 	strb.w	r4, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800066a:	bc30      	pop	{r4, r5}
 800066c:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800066e:	2200      	movs	r2, #0
 8000670:	4614      	mov	r4, r2
 8000672:	e7e7      	b.n	8000644 <HAL_NVIC_SetPriority+0x24>
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000674:	4b05      	ldr	r3, [pc, #20]	; (800068c <HAL_NVIC_SetPriority+0x6c>)
 8000676:	f000 000f 	and.w	r0, r0, #15
 800067a:	0124      	lsls	r4, r4, #4
 800067c:	4403      	add	r3, r0
 800067e:	b2e4      	uxtb	r4, r4
 8000680:	761c      	strb	r4, [r3, #24]
 8000682:	bc30      	pop	{r4, r5}
 8000684:	4770      	bx	lr
 8000686:	bf00      	nop
 8000688:	e000ed00 	.word	0xe000ed00
 800068c:	e000ecfc 	.word	0xe000ecfc

08000690 <HAL_NVIC_EnableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000690:	f000 021f 	and.w	r2, r0, #31
 8000694:	2101      	movs	r1, #1
 8000696:	0940      	lsrs	r0, r0, #5
 8000698:	4b02      	ldr	r3, [pc, #8]	; (80006a4 <HAL_NVIC_EnableIRQ+0x14>)
 800069a:	fa01 f202 	lsl.w	r2, r1, r2
 800069e:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
 80006a2:	4770      	bx	lr
 80006a4:	e000e100 	.word	0xe000e100

080006a8 <HAL_NVIC_DisableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80006a8:	0942      	lsrs	r2, r0, #5
 80006aa:	3220      	adds	r2, #32
 80006ac:	f000 001f 	and.w	r0, r0, #31
 80006b0:	2101      	movs	r1, #1
 80006b2:	4b03      	ldr	r3, [pc, #12]	; (80006c0 <HAL_NVIC_DisableIRQ+0x18>)
 80006b4:	fa01 f000 	lsl.w	r0, r1, r0
 80006b8:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 80006bc:	4770      	bx	lr
 80006be:	bf00      	nop
 80006c0:	e000e100 	.word	0xe000e100

080006c4 <HAL_NVIC_SystemReset>:
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80006c4:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80006c8:	4a05      	ldr	r2, [pc, #20]	; (80006e0 <HAL_NVIC_SystemReset+0x1c>)
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80006ca:	4b06      	ldr	r3, [pc, #24]	; (80006e4 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80006cc:	68d1      	ldr	r1, [r2, #12]
 80006ce:	f401 61e0 	and.w	r1, r1, #1792	; 0x700
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80006d2:	430b      	orrs	r3, r1
 80006d4:	60d3      	str	r3, [r2, #12]
 80006d6:	f3bf 8f4f 	dsb	sy

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 80006da:	bf00      	nop
 80006dc:	e7fd      	b.n	80006da <HAL_NVIC_SystemReset+0x16>
 80006de:	bf00      	nop
 80006e0:	e000ed00 	.word	0xe000ed00
 80006e4:	05fa0004 	.word	0x05fa0004

080006e8 <HAL_SYSTICK_Config>:
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 80006e8:	3801      	subs	r0, #1
 80006ea:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80006ee:	b410      	push	{r4}
 80006f0:	d20d      	bcs.n	800070e <HAL_SYSTICK_Config+0x26>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80006f2:	4b09      	ldr	r3, [pc, #36]	; (8000718 <HAL_SYSTICK_Config+0x30>)
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006f4:	4c09      	ldr	r4, [pc, #36]	; (800071c <HAL_SYSTICK_Config+0x34>)
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80006f6:	6058      	str	r0, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80006f8:	2200      	movs	r2, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006fa:	20f0      	movs	r0, #240	; 0xf0
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80006fc:	2107      	movs	r1, #7
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006fe:	f884 0023 	strb.w	r0, [r4, #35]	; 0x23
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000702:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000704:	6019      	str	r1, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8000706:	4610      	mov	r0, r2
   return SysTick_Config(TicksNumb);
}
 8000708:	f85d 4b04 	ldr.w	r4, [sp], #4
 800070c:	4770      	bx	lr
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 800070e:	2001      	movs	r0, #1
 8000710:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000714:	4770      	bx	lr
 8000716:	bf00      	nop
 8000718:	e000e010 	.word	0xe000e010
 800071c:	e000ed00 	.word	0xe000ed00

08000720 <HAL_NVIC_GetPriorityGrouping>:

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000720:	4b02      	ldr	r3, [pc, #8]	; (800072c <HAL_NVIC_GetPriorityGrouping+0xc>)
 8000722:	68d8      	ldr	r0, [r3, #12]
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
}
 8000724:	f3c0 2002 	ubfx	r0, r0, #8, #3
 8000728:	4770      	bx	lr
 800072a:	bf00      	nop
 800072c:	e000ed00 	.word	0xe000ed00

08000730 <HAL_NVIC_GetPriority>:
                        priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if((int32_t)IRQn < 0) {
 8000730:	2800      	cmp	r0, #0
  * @param  pPreemptPriority: Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority: Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
 8000732:	b470      	push	{r4, r5, r6}
 8000734:	db23      	blt.n	800077e <HAL_NVIC_GetPriority+0x4e>
    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
  }
  else {
    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - __NVIC_PRIO_BITS)));
 8000736:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800073a:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 800073e:	f890 4300 	ldrb.w	r4, [r0, #768]	; 0x300
 8000742:	0924      	lsrs	r4, r4, #4
    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
    \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000744:	f001 0107 	and.w	r1, r1, #7
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000748:	f1c1 0007 	rsb	r0, r1, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800074c:	1d0d      	adds	r5, r1, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800074e:	2804      	cmp	r0, #4
 8000750:	bf28      	it	cs
 8000752:	2004      	movcs	r0, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000754:	2d06      	cmp	r5, #6
 8000756:	d90f      	bls.n	8000778 <HAL_NVIC_GetPriority+0x48>
 8000758:	3903      	subs	r1, #3
 800075a:	2501      	movs	r5, #1
 800075c:	408d      	lsls	r5, r1
 800075e:	3d01      	subs	r5, #1
 8000760:	4025      	ands	r5, r4

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
 8000762:	2601      	movs	r6, #1
 8000764:	fa06 f000 	lsl.w	r0, r6, r0
 8000768:	fa24 f101 	lsr.w	r1, r4, r1
 800076c:	3801      	subs	r0, #1
 800076e:	4001      	ands	r1, r0
 8000770:	6011      	str	r1, [r2, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
 8000772:	601d      	str	r5, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
}
 8000774:	bc70      	pop	{r4, r5, r6}
 8000776:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000778:	2500      	movs	r5, #0
 800077a:	4629      	mov	r1, r5
 800077c:	e7f1      	b.n	8000762 <HAL_NVIC_GetPriority+0x32>
 */
__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if((int32_t)IRQn < 0) {
    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
 800077e:	4c03      	ldr	r4, [pc, #12]	; (800078c <HAL_NVIC_GetPriority+0x5c>)
 8000780:	f000 000f 	and.w	r0, r0, #15
 8000784:	4404      	add	r4, r0
 8000786:	7e24      	ldrb	r4, [r4, #24]
 8000788:	0924      	lsrs	r4, r4, #4
 800078a:	e7db      	b.n	8000744 <HAL_NVIC_GetPriority+0x14>
 800078c:	e000ecfc 	.word	0xe000ecfc

08000790 <HAL_NVIC_SetPendingIRQ>:

    \param [in]      IRQn  Interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000790:	0942      	lsrs	r2, r0, #5
 8000792:	3240      	adds	r2, #64	; 0x40
 8000794:	f000 001f 	and.w	r0, r0, #31
 8000798:	2101      	movs	r1, #1
 800079a:	4b03      	ldr	r3, [pc, #12]	; (80007a8 <HAL_NVIC_SetPendingIRQ+0x18>)
 800079c:	fa01 f000 	lsl.w	r0, r1, r0
 80007a0:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 80007a4:	4770      	bx	lr
 80007a6:	bf00      	nop
 80007a8:	e000e100 	.word	0xe000e100

080007ac <HAL_NVIC_GetPendingIRQ>:
    \return             0  Interrupt status is not pending.
    \return             1  Interrupt status is pending.
 */
__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 80007ac:	0942      	lsrs	r2, r0, #5
 80007ae:	3240      	adds	r2, #64	; 0x40
 80007b0:	4b04      	ldr	r3, [pc, #16]	; (80007c4 <HAL_NVIC_GetPendingIRQ+0x18>)
 80007b2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80007b6:	f000 001f 	and.w	r0, r0, #31
 80007ba:	fa23 f000 	lsr.w	r0, r3, r0
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
}
 80007be:	f000 0001 	and.w	r0, r0, #1
 80007c2:	4770      	bx	lr
 80007c4:	e000e100 	.word	0xe000e100

080007c8 <HAL_NVIC_ClearPendingIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80007c8:	0942      	lsrs	r2, r0, #5
 80007ca:	3260      	adds	r2, #96	; 0x60
 80007cc:	f000 001f 	and.w	r0, r0, #31
 80007d0:	2101      	movs	r1, #1
 80007d2:	4b03      	ldr	r3, [pc, #12]	; (80007e0 <HAL_NVIC_ClearPendingIRQ+0x18>)
 80007d4:	fa01 f000 	lsl.w	r0, r1, r0
 80007d8:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 80007dc:	4770      	bx	lr
 80007de:	bf00      	nop
 80007e0:	e000e100 	.word	0xe000e100

080007e4 <HAL_NVIC_GetActive>:
    \return             0  Interrupt status is not active.
    \return             1  Interrupt status is active.
 */
__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
{
  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 80007e4:	0942      	lsrs	r2, r0, #5
 80007e6:	3280      	adds	r2, #128	; 0x80
 80007e8:	4b04      	ldr	r3, [pc, #16]	; (80007fc <HAL_NVIC_GetActive+0x18>)
 80007ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80007ee:	f000 001f 	and.w	r0, r0, #31
 80007f2:	fa23 f000 	lsr.w	r0, r3, r0
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
}
 80007f6:	f000 0001 	and.w	r0, r0, #1
 80007fa:	4770      	bx	lr
 80007fc:	e000e100 	.word	0xe000e100

08000800 <HAL_SYSTICK_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000800:	4b04      	ldr	r3, [pc, #16]	; (8000814 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 8000802:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000804:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000806:	bf0c      	ite	eq
 8000808:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 800080c:	f022 0204 	bicne.w	r2, r2, #4
 8000810:	601a      	str	r2, [r3, #0]
 8000812:	4770      	bx	lr
 8000814:	e000e010 	.word	0xe000e010

08000818 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000818:	4770      	bx	lr
 800081a:	bf00      	nop

0800081c <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  Handle SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 800081c:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 800081e:	f7ff fffb 	bl	8000818 <HAL_SYSTICK_Callback>
 8000822:	bd08      	pop	{r3, pc}

08000824 <HAL_MPU_ConfigRegion>:
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 8000824:	4b17      	ldr	r3, [pc, #92]	; (8000884 <HAL_MPU_ConfigRegion+0x60>)
 8000826:	7842      	ldrb	r2, [r0, #1]
  * @param  MPU_Init: Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 8000828:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 800082c:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != RESET)
 800082e:	7802      	ldrb	r2, [r0, #0]
 8000830:	b922      	cbnz	r2, 800083c <HAL_MPU_ConfigRegion+0x18>
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable             << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00;
 8000832:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
 8000834:	611a      	str	r2, [r3, #16]
  }
}
 8000836:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 800083a:	4770      	bx	lr
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
 800083c:	6842      	ldr	r2, [r0, #4]
 800083e:	60da      	str	r2, [r3, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
 8000840:	7ac2      	ldrb	r2, [r0, #11]
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
 8000842:	f890 900c 	ldrb.w	r9, [r0, #12]
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable             << MPU_RASR_ENABLE_Pos);
 8000846:	f890 8000 	ldrb.w	r8, [r0]
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
 800084a:	f890 c00a 	ldrb.w	ip, [r0, #10]
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
 800084e:	7b47      	ldrb	r7, [r0, #13]
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
 8000850:	7b86      	ldrb	r6, [r0, #14]
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
 8000852:	7bc5      	ldrb	r5, [r0, #15]
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
 8000854:	7a44      	ldrb	r4, [r0, #9]
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
 8000856:	7a01      	ldrb	r1, [r0, #8]
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
 8000858:	0612      	lsls	r2, r2, #24
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
 800085a:	ea42 7209 	orr.w	r2, r2, r9, lsl #28
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
 800085e:	ea42 0208 	orr.w	r2, r2, r8
                ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
 8000862:	ea42 42cc 	orr.w	r2, r2, ip, lsl #19
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
 8000866:	ea42 4287 	orr.w	r2, r2, r7, lsl #18
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
 800086a:	ea42 4246 	orr.w	r2, r2, r6, lsl #17
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
 800086e:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
 8000872:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
 8000876:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
 800087a:	611a      	str	r2, [r3, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
 800087c:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8000880:	4770      	bx	lr
 8000882:	bf00      	nop
 8000884:	e000ed90 	.word	0xe000ed90

08000888 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000888:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 800088c:	680d      	ldr	r5, [r1, #0]
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800088e:	b084      	sub	sp, #16
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000890:	2d00      	cmp	r5, #0
 8000892:	f000 80db 	beq.w	8000a4c <HAL_GPIO_Init+0x1c4>
 8000896:	2400      	movs	r4, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000898:	f8df b1f4 	ldr.w	fp, [pc, #500]	; 8000a90 <HAL_GPIO_Init+0x208>
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 800089c:	4e78      	ldr	r6, [pc, #480]	; (8000a80 <HAL_GPIO_Init+0x1f8>)
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0x00;
 800089e:	4623      	mov	r3, r4

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 80008a0:	f04f 0801 	mov.w	r8, #1
 80008a4:	e074      	b.n	8000990 <HAL_GPIO_Init+0x108>
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
      temp |= ((GPIO_Init->Pull) << (position * 2));
 80008a6:	688a      	ldr	r2, [r1, #8]
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
        GPIOx->ASCR = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80008a8:	68c4      	ldr	r4, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
      temp |= ((GPIO_Init->Pull) << (position * 2));
 80008aa:	fa02 f505 	lsl.w	r5, r2, r5
        GPIOx->ASCR = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 80008ae:	ea09 0904 	and.w	r9, r9, r4
      temp |= ((GPIO_Init->Pull) << (position * 2));
 80008b2:	ea49 0205 	orr.w	r2, r9, r5
      GPIOx->PUPDR = temp;
 80008b6:	60c2      	str	r2, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80008b8:	684a      	ldr	r2, [r1, #4]
 80008ba:	00d2      	lsls	r2, r2, #3
 80008bc:	d562      	bpl.n	8000984 <HAL_GPIO_Init+0xfc>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80008be:	f8db 2060 	ldr.w	r2, [fp, #96]	; 0x60
 80008c2:	f042 0201 	orr.w	r2, r2, #1
 80008c6:	f8cb 2060 	str.w	r2, [fp, #96]	; 0x60
 80008ca:	f8db 4060 	ldr.w	r4, [fp, #96]	; 0x60
 80008ce:	f023 0203 	bic.w	r2, r3, #3
 80008d2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 80008d6:	f004 0401 	and.w	r4, r4, #1
 80008da:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
 80008de:	9403      	str	r4, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80008e0:	f003 0403 	and.w	r4, r3, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80008e4:	9d03      	ldr	r5, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 80008e6:	6897      	ldr	r7, [r2, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80008e8:	00a4      	lsls	r4, r4, #2
 80008ea:	250f      	movs	r5, #15
 80008ec:	40a5      	lsls	r5, r4
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80008ee:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80008f2:	ea27 0505 	bic.w	r5, r7, r5
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80008f6:	f000 80ad 	beq.w	8000a54 <HAL_GPIO_Init+0x1cc>
 80008fa:	f8df a198 	ldr.w	sl, [pc, #408]	; 8000a94 <HAL_GPIO_Init+0x20c>
 80008fe:	4550      	cmp	r0, sl
 8000900:	f000 80aa 	beq.w	8000a58 <HAL_GPIO_Init+0x1d0>
 8000904:	4f5f      	ldr	r7, [pc, #380]	; (8000a84 <HAL_GPIO_Init+0x1fc>)
 8000906:	42b8      	cmp	r0, r7
 8000908:	f000 80a9 	beq.w	8000a5e <HAL_GPIO_Init+0x1d6>
 800090c:	f8df a188 	ldr.w	sl, [pc, #392]	; 8000a98 <HAL_GPIO_Init+0x210>
 8000910:	4550      	cmp	r0, sl
 8000912:	f000 80a8 	beq.w	8000a66 <HAL_GPIO_Init+0x1de>
 8000916:	4f5c      	ldr	r7, [pc, #368]	; (8000a88 <HAL_GPIO_Init+0x200>)
 8000918:	42b8      	cmp	r0, r7
 800091a:	f000 80a8 	beq.w	8000a6e <HAL_GPIO_Init+0x1e6>
 800091e:	f8df a17c 	ldr.w	sl, [pc, #380]	; 8000a9c <HAL_GPIO_Init+0x214>
 8000922:	4550      	cmp	r0, sl
 8000924:	f000 80a7 	beq.w	8000a76 <HAL_GPIO_Init+0x1ee>
 8000928:	4f58      	ldr	r7, [pc, #352]	; (8000a8c <HAL_GPIO_Init+0x204>)
 800092a:	42b8      	cmp	r0, r7
 800092c:	bf0c      	ite	eq
 800092e:	2706      	moveq	r7, #6
 8000930:	2707      	movne	r7, #7
 8000932:	fa07 f404 	lsl.w	r4, r7, r4
 8000936:	432c      	orrs	r4, r5
        SYSCFG->EXTICR[position >> 2] = temp;
 8000938:	6094      	str	r4, [r2, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800093a:	684c      	ldr	r4, [r1, #4]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 800093c:	6835      	ldr	r5, [r6, #0]
        temp &= ~((uint32_t)iocurrent);
 800093e:	ea6f 020c 	mvn.w	r2, ip
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000942:	03e7      	lsls	r7, r4, #15
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
 8000944:	bf54      	ite	pl
 8000946:	ea02 0405 	andpl.w	r4, r2, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 800094a:	ea4c 0405 	orrmi.w	r4, ip, r5
        }
        EXTI->IMR1 = temp;
 800094e:	6034      	str	r4, [r6, #0]

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000950:	684c      	ldr	r4, [r1, #4]
        {
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
 8000952:	6875      	ldr	r5, [r6, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000954:	03a4      	lsls	r4, r4, #14
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
 8000956:	bf54      	ite	pl
 8000958:	ea02 0405 	andpl.w	r4, r2, r5
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 800095c:	ea4c 0405 	orrmi.w	r4, ip, r5
        }
        EXTI->EMR1 = temp;
 8000960:	6074      	str	r4, [r6, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000962:	684c      	ldr	r4, [r1, #4]
          temp |= iocurrent;
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8000964:	68b5      	ldr	r5, [r6, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000966:	02e7      	lsls	r7, r4, #11
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
 8000968:	bf54      	ite	pl
 800096a:	ea02 0405 	andpl.w	r4, r2, r5
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 800096e:	ea4c 0405 	orrmi.w	r4, ip, r5
        }
        EXTI->RTSR1 = temp;
 8000972:	60b4      	str	r4, [r6, #8]

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000974:	684c      	ldr	r4, [r1, #4]
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
 8000976:	68f5      	ldr	r5, [r6, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000978:	02a4      	lsls	r4, r4, #10
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
 800097a:	bf54      	ite	pl
 800097c:	402a      	andpl	r2, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 800097e:	ea4c 0205 	orrmi.w	r2, ip, r5
        }
        EXTI->FTSR1 = temp;
 8000982:	60f2      	str	r2, [r6, #12]
 8000984:	680d      	ldr	r5, [r1, #0]
      }
    }
    
    position++;
 8000986:	3301      	adds	r3, #1
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000988:	fa35 fa03 	lsrs.w	sl, r5, r3
 800098c:	461c      	mov	r4, r3
 800098e:	d05d      	beq.n	8000a4c <HAL_GPIO_Init+0x1c4>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000990:	fa08 f204 	lsl.w	r2, r8, r4

    if(iocurrent)
 8000994:	ea15 0c02 	ands.w	ip, r5, r2
 8000998:	d0f5      	beq.n	8000986 <HAL_GPIO_Init+0xfe>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800099a:	684f      	ldr	r7, [r1, #4]
 800099c:	f027 0510 	bic.w	r5, r7, #16
 80009a0:	2d02      	cmp	r5, #2
 80009a2:	d114      	bne.n	80009ce <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 80009a4:	08df      	lsrs	r7, r3, #3
 80009a6:	eb00 0787 	add.w	r7, r0, r7, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80009aa:	f003 0907 	and.w	r9, r3, #7
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 80009ae:	6a3d      	ldr	r5, [r7, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80009b0:	ea4f 0989 	mov.w	r9, r9, lsl #2
 80009b4:	f04f 0a0f 	mov.w	sl, #15
 80009b8:	fa0a fa09 	lsl.w	sl, sl, r9
 80009bc:	ea25 0a0a 	bic.w	sl, r5, sl
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 80009c0:	690d      	ldr	r5, [r1, #16]
 80009c2:	fa05 f909 	lsl.w	r9, r5, r9
 80009c6:	ea4a 0509 	orr.w	r5, sl, r9
        GPIOx->AFR[position >> 3] = temp;
 80009ca:	623d      	str	r5, [r7, #32]
 80009cc:	684f      	ldr	r7, [r1, #4]
 80009ce:	005d      	lsls	r5, r3, #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80009d0:	f04f 0903 	mov.w	r9, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80009d4:	f8d0 a000 	ldr.w	sl, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80009d8:	fa09 f905 	lsl.w	r9, r9, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80009dc:	f007 0703 	and.w	r7, r7, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80009e0:	ea6f 0909 	mvn.w	r9, r9
 80009e4:	ea09 0a0a 	and.w	sl, r9, sl
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80009e8:	40af      	lsls	r7, r5
 80009ea:	ea47 070a 	orr.w	r7, r7, sl
      GPIOx->MODER = temp;
 80009ee:	6007      	str	r7, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80009f0:	684f      	ldr	r7, [r1, #4]
 80009f2:	f027 0a10 	bic.w	sl, r7, #16
 80009f6:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 80009fa:	f1ba 0f01 	cmp.w	sl, #1
 80009fe:	d814      	bhi.n	8000a2a <HAL_GPIO_Init+0x1a2>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8000a00:	f8d0 a008 	ldr.w	sl, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
        temp |= (GPIO_Init->Speed << (position * 2));
 8000a04:	68cf      	ldr	r7, [r1, #12]
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000a06:	ea09 0a0a 	and.w	sl, r9, sl
        temp |= (GPIO_Init->Speed << (position * 2));
 8000a0a:	40af      	lsls	r7, r5
 8000a0c:	ea4a 0707 	orr.w	r7, sl, r7
        GPIOx->OSPEEDR = temp;
 8000a10:	6087      	str	r7, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000a12:	684f      	ldr	r7, [r1, #4]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
        temp |= (GPIO_Init->Speed << (position * 2));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8000a14:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000a18:	f3c7 1700 	ubfx	r7, r7, #4, #1
 8000a1c:	40a7      	lsls	r7, r4
        temp |= (GPIO_Init->Speed << (position * 2));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000a1e:	ea2a 0a02 	bic.w	sl, sl, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000a22:	ea4a 0707 	orr.w	r7, sl, r7
        GPIOx->OTYPER = temp;
 8000a26:	6047      	str	r7, [r0, #4]
 8000a28:	684f      	ldr	r7, [r1, #4]
      }

      /* In case of Analog mode, check if ADC control mode is selected */
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
 8000a2a:	f007 0a03 	and.w	sl, r7, #3
 8000a2e:	f1ba 0f03 	cmp.w	sl, #3
 8000a32:	f47f af38 	bne.w	80008a6 <HAL_GPIO_Init+0x1e>
      {
        /* Configure the IO Output Type */
        temp = GPIOx->ASCR;
 8000a36:	f8d0 a02c 	ldr.w	sl, [r0, #44]	; 0x2c
        temp &= ~(GPIO_ASCR_EN_0 << position) ;
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 8000a3a:	f3c7 07c0 	ubfx	r7, r7, #3, #1
 8000a3e:	fa07 f404 	lsl.w	r4, r7, r4
      /* In case of Analog mode, check if ADC control mode is selected */
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
      {
        /* Configure the IO Output Type */
        temp = GPIOx->ASCR;
        temp &= ~(GPIO_ASCR_EN_0 << position) ;
 8000a42:	ea2a 0202 	bic.w	r2, sl, r2
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 8000a46:	4322      	orrs	r2, r4
        GPIOx->ASCR = temp;
 8000a48:	62c2      	str	r2, [r0, #44]	; 0x2c
 8000a4a:	e72c      	b.n	80008a6 <HAL_GPIO_Init+0x1e>
      }
    }
    
    position++;
  }
}
 8000a4c:	b004      	add	sp, #16
 8000a4e:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8000a52:	4770      	bx	lr
 8000a54:	2400      	movs	r4, #0
 8000a56:	e76e      	b.n	8000936 <HAL_GPIO_Init+0xae>
 8000a58:	fa08 f404 	lsl.w	r4, r8, r4
 8000a5c:	e76b      	b.n	8000936 <HAL_GPIO_Init+0xae>
 8000a5e:	2702      	movs	r7, #2
 8000a60:	fa07 f404 	lsl.w	r4, r7, r4
 8000a64:	e767      	b.n	8000936 <HAL_GPIO_Init+0xae>
 8000a66:	2703      	movs	r7, #3
 8000a68:	fa07 f404 	lsl.w	r4, r7, r4
 8000a6c:	e763      	b.n	8000936 <HAL_GPIO_Init+0xae>
 8000a6e:	2704      	movs	r7, #4
 8000a70:	fa07 f404 	lsl.w	r4, r7, r4
 8000a74:	e75f      	b.n	8000936 <HAL_GPIO_Init+0xae>
 8000a76:	2705      	movs	r7, #5
 8000a78:	fa07 f404 	lsl.w	r4, r7, r4
 8000a7c:	e75b      	b.n	8000936 <HAL_GPIO_Init+0xae>
 8000a7e:	bf00      	nop
 8000a80:	40010400 	.word	0x40010400
 8000a84:	48000800 	.word	0x48000800
 8000a88:	48001000 	.word	0x48001000
 8000a8c:	48001800 	.word	0x48001800
 8000a90:	40021000 	.word	0x40021000
 8000a94:	48000400 	.word	0x48000400
 8000a98:	48000c00 	.word	0x48000c00
 8000a9c:	48001400 	.word	0x48001400

08000aa0 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8000aa0:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8000aa4:	2900      	cmp	r1, #0
 8000aa6:	f000 8088 	beq.w	8000bba <HAL_GPIO_DeInit+0x11a>
 8000aaa:	2200      	movs	r2, #0
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 8000aac:	4f50      	ldr	r7, [pc, #320]	; (8000bf0 <HAL_GPIO_DeInit+0x150>)
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
  uint32_t position = 0x00;
 8000aae:	4613      	mov	r3, r2

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
 8000ab0:	f04f 0c01 	mov.w	ip, #1

    if (iocurrent)
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
 8000ab4:	f04f 0b03 	mov.w	fp, #3
 8000ab8:	e004      	b.n	8000ac4 <HAL_GPIO_DeInit+0x24>
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
      }
    }
    
    position++;
 8000aba:	3301      	adds	r3, #1
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8000abc:	fa31 f403 	lsrs.w	r4, r1, r3
 8000ac0:	461a      	mov	r2, r3
 8000ac2:	d07a      	beq.n	8000bba <HAL_GPIO_DeInit+0x11a>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
 8000ac4:	fa0c f202 	lsl.w	r2, ip, r2

    if (iocurrent)
 8000ac8:	ea11 0602 	ands.w	r6, r1, r2
 8000acc:	d0f5      	beq.n	8000aba <HAL_GPIO_DeInit+0x1a>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
 8000ace:	6805      	ldr	r5, [r0, #0]
 8000ad0:	005c      	lsls	r4, r3, #1
 8000ad2:	fa0b f404 	lsl.w	r4, fp, r4

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000ad6:	ea4f 08d3 	mov.w	r8, r3, lsr #3

    if (iocurrent)
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
 8000ada:	4325      	orrs	r5, r4
 8000adc:	eb00 0888 	add.w	r8, r0, r8, lsl #2
 8000ae0:	6005      	str	r5, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000ae2:	f003 0907 	and.w	r9, r3, #7
 8000ae6:	f8d8 a020 	ldr.w	sl, [r8, #32]
 8000aea:	250f      	movs	r5, #15
 8000aec:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8000af0:	fa05 f909 	lsl.w	r9, r5, r9
 8000af4:	ea2a 0909 	bic.w	r9, sl, r9
 8000af8:	f8c8 9020 	str.w	r9, [r8, #32]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000afc:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8000b00:	43e4      	mvns	r4, r4
 8000b02:	ea04 0808 	and.w	r8, r4, r8
 8000b06:	f8c0 8008 	str.w	r8, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000b0a:	f8d0 8004 	ldr.w	r8, [r0, #4]
 8000b0e:	43d2      	mvns	r2, r2
 8000b10:	ea02 0808 	and.w	r8, r2, r8
 8000b14:	f8c0 8004 	str.w	r8, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8000b18:	f8d0 800c 	ldr.w	r8, [r0, #12]
 8000b1c:	ea04 0408 	and.w	r4, r4, r8
 8000b20:	60c4      	str	r4, [r0, #12]

      /* Deactivate the Control bit of Analog mode for the current IO */
      GPIOx->ASCR &= ~(GPIO_ASCR_EN_0<< position);
 8000b22:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
 8000b26:	f023 0403 	bic.w	r4, r3, #3
 8000b2a:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8000b2e:	ea02 0208 	and.w	r2, r2, r8
 8000b32:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
 8000b36:	62c2      	str	r2, [r0, #44]	; 0x2c

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000b38:	f003 0203 	and.w	r2, r3, #3
      GPIOx->ASCR &= ~(GPIO_ASCR_EN_0<< position);

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
 8000b3c:	f8d4 8008 	ldr.w	r8, [r4, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000b40:	0092      	lsls	r2, r2, #2
 8000b42:	4095      	lsls	r5, r2
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8000b44:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000b48:	ea05 0808 	and.w	r8, r5, r8
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8000b4c:	d038      	beq.n	8000bc0 <HAL_GPIO_DeInit+0x120>
 8000b4e:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8000bf4 <HAL_GPIO_DeInit+0x154>
 8000b52:	4548      	cmp	r0, r9
 8000b54:	d036      	beq.n	8000bc4 <HAL_GPIO_DeInit+0x124>
 8000b56:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 8000bf8 <HAL_GPIO_DeInit+0x158>
 8000b5a:	4548      	cmp	r0, r9
 8000b5c:	d035      	beq.n	8000bca <HAL_GPIO_DeInit+0x12a>
 8000b5e:	f8df 909c 	ldr.w	r9, [pc, #156]	; 8000bfc <HAL_GPIO_DeInit+0x15c>
 8000b62:	4548      	cmp	r0, r9
 8000b64:	d036      	beq.n	8000bd4 <HAL_GPIO_DeInit+0x134>
 8000b66:	f8df 9098 	ldr.w	r9, [pc, #152]	; 8000c00 <HAL_GPIO_DeInit+0x160>
 8000b6a:	4548      	cmp	r0, r9
 8000b6c:	d035      	beq.n	8000bda <HAL_GPIO_DeInit+0x13a>
 8000b6e:	f8df 9094 	ldr.w	r9, [pc, #148]	; 8000c04 <HAL_GPIO_DeInit+0x164>
 8000b72:	4548      	cmp	r0, r9
 8000b74:	d036      	beq.n	8000be4 <HAL_GPIO_DeInit+0x144>
 8000b76:	f8df 9090 	ldr.w	r9, [pc, #144]	; 8000c08 <HAL_GPIO_DeInit+0x168>
 8000b7a:	4548      	cmp	r0, r9
 8000b7c:	bf0c      	ite	eq
 8000b7e:	f04f 0906 	moveq.w	r9, #6
 8000b82:	f04f 0907 	movne.w	r9, #7
 8000b86:	fa09 f202 	lsl.w	r2, r9, r2
 8000b8a:	4590      	cmp	r8, r2
 8000b8c:	d195      	bne.n	8000aba <HAL_GPIO_DeInit+0x1a>
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 8000b8e:	68a2      	ldr	r2, [r4, #8]
 8000b90:	ea22 0505 	bic.w	r5, r2, r5
 8000b94:	60a5      	str	r5, [r4, #8]

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 8000b96:	683a      	ldr	r2, [r7, #0]
 8000b98:	43f6      	mvns	r6, r6
 8000b9a:	4032      	ands	r2, r6
 8000b9c:	603a      	str	r2, [r7, #0]
        EXTI->EMR1 &= ~((uint32_t)iocurrent);
 8000b9e:	687a      	ldr	r2, [r7, #4]
 8000ba0:	4032      	ands	r2, r6
 8000ba2:	607a      	str	r2, [r7, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
 8000ba4:	68ba      	ldr	r2, [r7, #8]
 8000ba6:	4032      	ands	r2, r6
 8000ba8:	60ba      	str	r2, [r7, #8]
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 8000baa:	68fa      	ldr	r2, [r7, #12]
      }
    }
    
    position++;
 8000bac:	3301      	adds	r3, #1
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
        EXTI->EMR1 &= ~((uint32_t)iocurrent);

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 8000bae:	4016      	ands	r6, r2
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8000bb0:	fa31 f403 	lsrs.w	r4, r1, r3
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
        EXTI->EMR1 &= ~((uint32_t)iocurrent);

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 8000bb4:	60fe      	str	r6, [r7, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8000bb6:	461a      	mov	r2, r3
 8000bb8:	d184      	bne.n	8000ac4 <HAL_GPIO_DeInit+0x24>
      }
    }
    
    position++;
  }
}
 8000bba:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8000bbe:	4770      	bx	lr
 8000bc0:	2200      	movs	r2, #0
 8000bc2:	e7e2      	b.n	8000b8a <HAL_GPIO_DeInit+0xea>
 8000bc4:	fa0c f202 	lsl.w	r2, ip, r2
 8000bc8:	e7df      	b.n	8000b8a <HAL_GPIO_DeInit+0xea>
 8000bca:	f04f 0902 	mov.w	r9, #2
 8000bce:	fa09 f202 	lsl.w	r2, r9, r2
 8000bd2:	e7da      	b.n	8000b8a <HAL_GPIO_DeInit+0xea>
 8000bd4:	fa0b f202 	lsl.w	r2, fp, r2
 8000bd8:	e7d7      	b.n	8000b8a <HAL_GPIO_DeInit+0xea>
 8000bda:	f04f 0904 	mov.w	r9, #4
 8000bde:	fa09 f202 	lsl.w	r2, r9, r2
 8000be2:	e7d2      	b.n	8000b8a <HAL_GPIO_DeInit+0xea>
 8000be4:	f04f 0905 	mov.w	r9, #5
 8000be8:	fa09 f202 	lsl.w	r2, r9, r2
 8000bec:	e7cd      	b.n	8000b8a <HAL_GPIO_DeInit+0xea>
 8000bee:	bf00      	nop
 8000bf0:	40010400 	.word	0x40010400
 8000bf4:	48000400 	.word	0x48000400
 8000bf8:	48000800 	.word	0x48000800
 8000bfc:	48000c00 	.word	0x48000c00
 8000c00:	48001000 	.word	0x48001000
 8000c04:	48001400 	.word	0x48001400
 8000c08:	48001800 	.word	0x48001800

08000c0c <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8000c0c:	6903      	ldr	r3, [r0, #16]
 8000c0e:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8000c10:	bf0c      	ite	eq
 8000c12:	2000      	moveq	r0, #0
 8000c14:	2001      	movne	r0, #1
 8000c16:	4770      	bx	lr

08000c18 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8000c18:	b90a      	cbnz	r2, 8000c1e <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8000c1a:	6281      	str	r1, [r0, #40]	; 0x28
 8000c1c:	4770      	bx	lr
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8000c1e:	6181      	str	r1, [r0, #24]
 8000c20:	4770      	bx	lr
 8000c22:	bf00      	nop

08000c24 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8000c24:	6943      	ldr	r3, [r0, #20]
 8000c26:	4059      	eors	r1, r3
 8000c28:	6141      	str	r1, [r0, #20]
 8000c2a:	4770      	bx	lr

08000c2c <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bits to be locked.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8000c2c:	b082      	sub	sp, #8
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
 8000c2e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000c32:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
 8000c34:	9b01      	ldr	r3, [sp, #4]
 8000c36:	430b      	orrs	r3, r1
 8000c38:	9301      	str	r3, [sp, #4]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 8000c3a:	9b01      	ldr	r3, [sp, #4]
 8000c3c:	61c3      	str	r3, [r0, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
 8000c3e:	61c1      	str	r1, [r0, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 8000c40:	9b01      	ldr	r3, [sp, #4]
 8000c42:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8000c44:	69c3      	ldr	r3, [r0, #28]
 8000c46:	9301      	str	r3, [sp, #4]

  if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
 8000c48:	69c0      	ldr	r0, [r0, #28]
 8000c4a:	f480 3080 	eor.w	r0, r0, #65536	; 0x10000
  }
  else
  {
    return HAL_ERROR;
  }
}
 8000c4e:	f3c0 4000 	ubfx	r0, r0, #16, #1
 8000c52:	b002      	add	sp, #8
 8000c54:	4770      	bx	lr
 8000c56:	bf00      	nop

08000c58 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 8000c58:	4770      	bx	lr
 8000c5a:	bf00      	nop

08000c5c <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8000c5c:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 8000c5e:	4b04      	ldr	r3, [pc, #16]	; (8000c70 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 8000c60:	6959      	ldr	r1, [r3, #20]
 8000c62:	4208      	tst	r0, r1
 8000c64:	d002      	beq.n	8000c6c <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8000c66:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8000c68:	f7ff fff6 	bl	8000c58 <HAL_GPIO_EXTI_Callback>
 8000c6c:	bd08      	pop	{r3, pc}
 8000c6e:	bf00      	nop
 8000c70:	40010400 	.word	0x40010400

08000c74 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return  (PWR->CR1 & PWR_CR1_VOS);
 8000c74:	4b02      	ldr	r3, [pc, #8]	; (8000c80 <HAL_PWREx_GetVoltageRange+0xc>)
 8000c76:	6818      	ldr	r0, [r3, #0]
}
 8000c78:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8000c7c:	4770      	bx	lr
 8000c7e:	bf00      	nop
 8000c80:	40007000 	.word	0x40007000

08000c84 <HAL_PWREx_ControlVoltageScaling>:
  uint32_t wait_loop_index = 0;  

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8000c84:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8000c88:	d00e      	beq.n	8000ca8 <HAL_PWREx_ControlVoltageScaling+0x24>
      }
    }
  }
  else
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 8000c8a:	4b1b      	ldr	r3, [pc, #108]	; (8000cf8 <HAL_PWREx_ControlVoltageScaling+0x74>)
 8000c8c:	681a      	ldr	r2, [r3, #0]
 8000c8e:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 8000c92:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8000c96:	d02c      	beq.n	8000cf2 <HAL_PWREx_ControlVoltageScaling+0x6e>
    {
      /* Set Range 2 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8000c98:	681a      	ldr	r2, [r3, #0]
 8000c9a:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8000c9e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000ca2:	601a      	str	r2, [r3, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
  
  return HAL_OK;
 8000ca4:	2000      	movs	r0, #0
 8000ca6:	4770      	bx	lr
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8000ca8:	4913      	ldr	r1, [pc, #76]	; (8000cf8 <HAL_PWREx_ControlVoltageScaling+0x74>)
 8000caa:	680b      	ldr	r3, [r1, #0]
 8000cac:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8000cb0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000cb4:	d01d      	beq.n	8000cf2 <HAL_PWREx_ControlVoltageScaling+0x6e>
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8000cb6:	6808      	ldr	r0, [r1, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 8000cb8:	4a10      	ldr	r2, [pc, #64]	; (8000cfc <HAL_PWREx_ControlVoltageScaling+0x78>)
 8000cba:	4b11      	ldr	r3, [pc, #68]	; (8000d00 <HAL_PWREx_ControlVoltageScaling+0x7c>)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8000cbc:	f420 60c0 	bic.w	r0, r0, #1536	; 0x600
 8000cc0:	f440 7000 	orr.w	r0, r0, #512	; 0x200
 8000cc4:	6008      	str	r0, [r1, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 8000cc6:	6812      	ldr	r2, [r2, #0]
 8000cc8:	fba3 0302 	umull	r0, r3, r3, r2
 8000ccc:	0c9b      	lsrs	r3, r3, #18
 8000cce:	2232      	movs	r2, #50	; 0x32
 8000cd0:	fb02 f303 	mul.w	r3, r2, r3
      while ((wait_loop_index != 0) && (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)))
 8000cd4:	b913      	cbnz	r3, 8000cdc <HAL_PWREx_ControlVoltageScaling+0x58>
 8000cd6:	e004      	b.n	8000ce2 <HAL_PWREx_ControlVoltageScaling+0x5e>
 8000cd8:	3b01      	subs	r3, #1
 8000cda:	d002      	beq.n	8000ce2 <HAL_PWREx_ControlVoltageScaling+0x5e>
 8000cdc:	694a      	ldr	r2, [r1, #20]
 8000cde:	0552      	lsls	r2, r2, #21
 8000ce0:	d4fa      	bmi.n	8000cd8 <HAL_PWREx_ControlVoltageScaling+0x54>
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8000ce2:	4b05      	ldr	r3, [pc, #20]	; (8000cf8 <HAL_PWREx_ControlVoltageScaling+0x74>)
 8000ce4:	695b      	ldr	r3, [r3, #20]
      {
        return HAL_TIMEOUT;
 8000ce6:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8000cea:	bf0c      	ite	eq
 8000cec:	2000      	moveq	r0, #0
 8000cee:	2003      	movne	r0, #3
 8000cf0:	4770      	bx	lr
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
  
  return HAL_OK;
 8000cf2:	2000      	movs	r0, #0
}  
 8000cf4:	4770      	bx	lr
 8000cf6:	bf00      	nop
 8000cf8:	40007000 	.word	0x40007000
 8000cfc:	20000000 	.word	0x20000000
 8000d00:	431bde83 	.word	0x431bde83

08000d04 <HAL_PWREx_EnableBatteryCharging>:
void HAL_PWREx_EnableBatteryCharging(uint32_t ResistorSelection)
{
  assert_param(IS_PWR_BATTERY_RESISTOR_SELECT(ResistorSelection));
  
  /* Specify resistor selection */
  MODIFY_REG(PWR->CR4, PWR_CR4_VBRS, ResistorSelection);
 8000d04:	4b05      	ldr	r3, [pc, #20]	; (8000d1c <HAL_PWREx_EnableBatteryCharging+0x18>)
 8000d06:	68da      	ldr	r2, [r3, #12]
 8000d08:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8000d0c:	4310      	orrs	r0, r2
 8000d0e:	60d8      	str	r0, [r3, #12]
  
  /* Enable battery charging */
  SET_BIT(PWR->CR4, PWR_CR4_VBE);
 8000d10:	68da      	ldr	r2, [r3, #12]
 8000d12:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000d16:	60da      	str	r2, [r3, #12]
 8000d18:	4770      	bx	lr
 8000d1a:	bf00      	nop
 8000d1c:	40007000 	.word	0x40007000

08000d20 <HAL_PWREx_DisableBatteryCharging>:
  * @brief Disable battery charging.  
  * @retval None
  */
void HAL_PWREx_DisableBatteryCharging(void)
{
  CLEAR_BIT(PWR->CR4, PWR_CR4_VBE); 
 8000d20:	4b02      	ldr	r3, [pc, #8]	; (8000d2c <HAL_PWREx_DisableBatteryCharging+0xc>)
 8000d22:	68da      	ldr	r2, [r3, #12]
 8000d24:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8000d28:	60da      	str	r2, [r3, #12]
 8000d2a:	4770      	bx	lr
 8000d2c:	40007000 	.word	0x40007000

08000d30 <HAL_PWREx_EnableVddUSB>:
  * @note  Remove VDDUSB electrical and logical isolation, once VDDUSB supply is present.  
  * @retval None
  */
void HAL_PWREx_EnableVddUSB(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_USV);
 8000d30:	4b02      	ldr	r3, [pc, #8]	; (8000d3c <HAL_PWREx_EnableVddUSB+0xc>)
 8000d32:	685a      	ldr	r2, [r3, #4]
 8000d34:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000d38:	605a      	str	r2, [r3, #4]
 8000d3a:	4770      	bx	lr
 8000d3c:	40007000 	.word	0x40007000

08000d40 <HAL_PWREx_DisableVddUSB>:
  * @brief Disable VDDUSB supply. 
  * @retval None
  */
void HAL_PWREx_DisableVddUSB(void)
{
  CLEAR_BIT(PWR->CR2, PWR_CR2_USV);
 8000d40:	4b02      	ldr	r3, [pc, #8]	; (8000d4c <HAL_PWREx_DisableVddUSB+0xc>)
 8000d42:	685a      	ldr	r2, [r3, #4]
 8000d44:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000d48:	605a      	str	r2, [r3, #4]
 8000d4a:	4770      	bx	lr
 8000d4c:	40007000 	.word	0x40007000

08000d50 <HAL_PWREx_EnableVddIO2>:
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present. 
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 8000d50:	4b02      	ldr	r3, [pc, #8]	; (8000d5c <HAL_PWREx_EnableVddIO2+0xc>)
 8000d52:	685a      	ldr	r2, [r3, #4]
 8000d54:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000d58:	605a      	str	r2, [r3, #4]
 8000d5a:	4770      	bx	lr
 8000d5c:	40007000 	.word	0x40007000

08000d60 <HAL_PWREx_DisableVddIO2>:
  * @brief Disable VDDIO2 supply. 
  * @retval None
  */
void HAL_PWREx_DisableVddIO2(void)
{
  CLEAR_BIT(PWR->CR2, PWR_CR2_IOSV);
 8000d60:	4b02      	ldr	r3, [pc, #8]	; (8000d6c <HAL_PWREx_DisableVddIO2+0xc>)
 8000d62:	685a      	ldr	r2, [r3, #4]
 8000d64:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8000d68:	605a      	str	r2, [r3, #4]
 8000d6a:	4770      	bx	lr
 8000d6c:	40007000 	.word	0x40007000

08000d70 <HAL_PWREx_EnableInternalWakeUpLine>:
  * @brief Enable Internal Wake-up Line. 
  * @retval None
  */
void HAL_PWREx_EnableInternalWakeUpLine(void)
{
  SET_BIT(PWR->CR3, PWR_CR3_EIWF);
 8000d70:	4b02      	ldr	r3, [pc, #8]	; (8000d7c <HAL_PWREx_EnableInternalWakeUpLine+0xc>)
 8000d72:	689a      	ldr	r2, [r3, #8]
 8000d74:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000d78:	609a      	str	r2, [r3, #8]
 8000d7a:	4770      	bx	lr
 8000d7c:	40007000 	.word	0x40007000

08000d80 <HAL_PWREx_DisableInternalWakeUpLine>:
  * @brief Disable Internal Wake-up Line. 
  * @retval None
  */
void HAL_PWREx_DisableInternalWakeUpLine(void)
{
  CLEAR_BIT(PWR->CR3, PWR_CR3_EIWF);
 8000d80:	4b02      	ldr	r3, [pc, #8]	; (8000d8c <HAL_PWREx_DisableInternalWakeUpLine+0xc>)
 8000d82:	689a      	ldr	r2, [r3, #8]
 8000d84:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8000d88:	609a      	str	r2, [r3, #8]
 8000d8a:	4770      	bx	lr
 8000d8c:	40007000 	.word	0x40007000

08000d90 <HAL_PWREx_EnableGPIOPullUp>:
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{  
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
 8000d90:	2807      	cmp	r0, #7
 8000d92:	d85d      	bhi.n	8000e50 <HAL_PWREx_EnableGPIOPullUp+0xc0>
 8000d94:	e8df f000 	tbb	[pc, r0]
 8000d98:	342a1e10 	.word	0x342a1e10
 8000d9c:	0452483e 	.word	0x0452483e
    case PWR_GPIO_G:
       SET_BIT(PWR->PUCRG, GPIONumber);
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 8000da0:	4b2c      	ldr	r3, [pc, #176]	; (8000e54 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000da2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000da4:	f001 0103 	and.w	r1, r1, #3
 8000da8:	430a      	orrs	r2, r1
 8000daa:	659a      	str	r2, [r3, #88]	; 0x58
       CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));           
 8000dac:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8000dae:	ea22 0101 	bic.w	r1, r2, r1
 8000db2:	65d9      	str	r1, [r3, #92]	; 0x5c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000db4:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));           
       break;                                                   
 8000db6:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
  {
    case PWR_GPIO_A:
       SET_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
 8000db8:	4b26      	ldr	r3, [pc, #152]	; (8000e54 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000dba:	6a1a      	ldr	r2, [r3, #32]
 8000dbc:	f421 4080 	bic.w	r0, r1, #16384	; 0x4000
 8000dc0:	4302      	orrs	r2, r0
 8000dc2:	621a      	str	r2, [r3, #32]
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                       
 8000dc4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000dc6:	f421 4120 	bic.w	r1, r1, #40960	; 0xa000
 8000dca:	ea22 0101 	bic.w	r1, r2, r1
 8000dce:	6259      	str	r1, [r3, #36]	; 0x24
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000dd0:	2000      	movs	r0, #0
  switch (GPIO)
  {
    case PWR_GPIO_A:
       SET_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                       
       break;
 8000dd2:	4770      	bx	lr
    case PWR_GPIO_B:
       SET_BIT(PWR->PUCRB, GPIONumber);
 8000dd4:	4b1f      	ldr	r3, [pc, #124]	; (8000e54 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000dd6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000dd8:	430a      	orrs	r2, r1
 8000dda:	629a      	str	r2, [r3, #40]	; 0x28
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));                  
 8000ddc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000dde:	f021 0110 	bic.w	r1, r1, #16
 8000de2:	ea22 0101 	bic.w	r1, r2, r1
 8000de6:	62d9      	str	r1, [r3, #44]	; 0x2c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000de8:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                       
       break;
    case PWR_GPIO_B:
       SET_BIT(PWR->PUCRB, GPIONumber);
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));                  
       break; 
 8000dea:	4770      	bx	lr
    case PWR_GPIO_C:
       SET_BIT(PWR->PUCRC, GPIONumber);
 8000dec:	4b19      	ldr	r3, [pc, #100]	; (8000e54 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000dee:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000df0:	430a      	orrs	r2, r1
 8000df2:	631a      	str	r2, [r3, #48]	; 0x30
       CLEAR_BIT(PWR->PDCRC, GPIONumber);         
 8000df4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000df6:	ea22 0101 	bic.w	r1, r2, r1
 8000dfa:	6359      	str	r1, [r3, #52]	; 0x34
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000dfc:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));                  
       break; 
    case PWR_GPIO_C:
       SET_BIT(PWR->PUCRC, GPIONumber);
       CLEAR_BIT(PWR->PDCRC, GPIONumber);         
       break; 
 8000dfe:	4770      	bx	lr
    case PWR_GPIO_D:
       SET_BIT(PWR->PUCRD, GPIONumber);
 8000e00:	4b14      	ldr	r3, [pc, #80]	; (8000e54 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000e02:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000e04:	430a      	orrs	r2, r1
 8000e06:	639a      	str	r2, [r3, #56]	; 0x38
       CLEAR_BIT(PWR->PDCRD, GPIONumber);         
 8000e08:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8000e0a:	ea22 0101 	bic.w	r1, r2, r1
 8000e0e:	63d9      	str	r1, [r3, #60]	; 0x3c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e10:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRC, GPIONumber);         
       break; 
    case PWR_GPIO_D:
       SET_BIT(PWR->PUCRD, GPIONumber);
       CLEAR_BIT(PWR->PDCRD, GPIONumber);         
       break;
 8000e12:	4770      	bx	lr
    case PWR_GPIO_E:
       SET_BIT(PWR->PUCRE, GPIONumber);
 8000e14:	4b0f      	ldr	r3, [pc, #60]	; (8000e54 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000e16:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000e18:	430a      	orrs	r2, r1
 8000e1a:	641a      	str	r2, [r3, #64]	; 0x40
       CLEAR_BIT(PWR->PDCRE, GPIONumber);         
 8000e1c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000e1e:	ea22 0101 	bic.w	r1, r2, r1
 8000e22:	6459      	str	r1, [r3, #68]	; 0x44
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e24:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRD, GPIONumber);         
       break;
    case PWR_GPIO_E:
       SET_BIT(PWR->PUCRE, GPIONumber);
       CLEAR_BIT(PWR->PDCRE, GPIONumber);         
       break;
 8000e26:	4770      	bx	lr
    case PWR_GPIO_F:
       SET_BIT(PWR->PUCRF, GPIONumber);
 8000e28:	4b0a      	ldr	r3, [pc, #40]	; (8000e54 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000e2a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8000e2c:	430a      	orrs	r2, r1
 8000e2e:	649a      	str	r2, [r3, #72]	; 0x48
       CLEAR_BIT(PWR->PDCRF, GPIONumber);         
 8000e30:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000e32:	ea22 0101 	bic.w	r1, r2, r1
 8000e36:	64d9      	str	r1, [r3, #76]	; 0x4c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e38:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRE, GPIONumber);         
       break;
    case PWR_GPIO_F:
       SET_BIT(PWR->PUCRF, GPIONumber);
       CLEAR_BIT(PWR->PDCRF, GPIONumber);         
       break;
 8000e3a:	4770      	bx	lr
    case PWR_GPIO_G:
       SET_BIT(PWR->PUCRG, GPIONumber);
 8000e3c:	4b05      	ldr	r3, [pc, #20]	; (8000e54 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8000e3e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8000e40:	430a      	orrs	r2, r1
 8000e42:	651a      	str	r2, [r3, #80]	; 0x50
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
 8000e44:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8000e46:	ea22 0101 	bic.w	r1, r2, r1
 8000e4a:	6559      	str	r1, [r3, #84]	; 0x54
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e4c:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRF, GPIONumber);         
       break;
    case PWR_GPIO_G:
       SET_BIT(PWR->PUCRG, GPIONumber);
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
       break;
 8000e4e:	4770      	bx	lr
    case PWR_GPIO_H:
       SET_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));           
       break;                                                   
    default:
        return HAL_ERROR;
 8000e50:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 8000e52:	4770      	bx	lr
 8000e54:	40007000 	.word	0x40007000

08000e58 <HAL_PWREx_DisableGPIOPullUp>:
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{  
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
 8000e58:	2807      	cmp	r0, #7
 8000e5a:	d841      	bhi.n	8000ee0 <HAL_PWREx_DisableGPIOPullUp+0x88>
 8000e5c:	e8df f000 	tbb	[pc, r0]
 8000e60:	241d160d 	.word	0x241d160d
 8000e64:	0439322b 	.word	0x0439322b
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 8000e68:	4b1e      	ldr	r3, [pc, #120]	; (8000ee4 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e6a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000e6c:	f001 0103 	and.w	r1, r1, #3
 8000e70:	ea22 0101 	bic.w	r1, r2, r1
 8000e74:	6599      	str	r1, [r3, #88]	; 0x58
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e76:	2000      	movs	r0, #0
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
 8000e78:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));         
 8000e7a:	4b1a      	ldr	r3, [pc, #104]	; (8000ee4 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e7c:	6a1a      	ldr	r2, [r3, #32]
 8000e7e:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8000e82:	ea22 0101 	bic.w	r1, r2, r1
 8000e86:	6219      	str	r1, [r3, #32]
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e88:	2000      	movs	r0, #0
  
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));         
       break;
 8000e8a:	4770      	bx	lr
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
 8000e8c:	4b15      	ldr	r3, [pc, #84]	; (8000ee4 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e8e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000e90:	ea22 0101 	bic.w	r1, r2, r1
 8000e94:	6299      	str	r1, [r3, #40]	; 0x28
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000e96:	2000      	movs	r0, #0
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));         
       break;
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
       break; 
 8000e98:	4770      	bx	lr
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
 8000e9a:	4b12      	ldr	r3, [pc, #72]	; (8000ee4 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000e9c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000e9e:	ea22 0101 	bic.w	r1, r2, r1
 8000ea2:	6319      	str	r1, [r3, #48]	; 0x30
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000ea4:	2000      	movs	r0, #0
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
       break; 
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
       break; 
 8000ea6:	4770      	bx	lr
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
 8000ea8:	4b0e      	ldr	r3, [pc, #56]	; (8000ee4 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000eaa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000eac:	ea22 0101 	bic.w	r1, r2, r1
 8000eb0:	6399      	str	r1, [r3, #56]	; 0x38
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000eb2:	2000      	movs	r0, #0
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
       break; 
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
       break;
 8000eb4:	4770      	bx	lr
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
 8000eb6:	4b0b      	ldr	r3, [pc, #44]	; (8000ee4 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000eb8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000eba:	ea22 0101 	bic.w	r1, r2, r1
 8000ebe:	6419      	str	r1, [r3, #64]	; 0x40
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000ec0:	2000      	movs	r0, #0
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
       break;
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
       break;
 8000ec2:	4770      	bx	lr
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PUCRF, GPIONumber);
 8000ec4:	4b07      	ldr	r3, [pc, #28]	; (8000ee4 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000ec6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8000ec8:	ea22 0101 	bic.w	r1, r2, r1
 8000ecc:	6499      	str	r1, [r3, #72]	; 0x48
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000ece:	2000      	movs	r0, #0
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
       break;
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PUCRF, GPIONumber);
       break;
 8000ed0:	4770      	bx	lr
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
 8000ed2:	4b04      	ldr	r3, [pc, #16]	; (8000ee4 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 8000ed4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8000ed6:	ea22 0101 	bic.w	r1, r2, r1
 8000eda:	6519      	str	r1, [r3, #80]	; 0x50
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000edc:	2000      	movs	r0, #0
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PUCRF, GPIONumber);
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
       break;
 8000ede:	4770      	bx	lr
    case PWR_GPIO_H:
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
    default:
        return HAL_ERROR;
 8000ee0:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 8000ee2:	4770      	bx	lr
 8000ee4:	40007000 	.word	0x40007000

08000ee8 <HAL_PWREx_EnableGPIOPullDown>:
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
{
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
 8000ee8:	2807      	cmp	r0, #7
 8000eea:	d85d      	bhi.n	8000fa8 <HAL_PWREx_EnableGPIOPullDown+0xc0>
 8000eec:	e8df f000 	tbb	[pc, r0]
 8000ef0:	342a1e10 	.word	0x342a1e10
 8000ef4:	0452483e 	.word	0x0452483e
    case PWR_GPIO_G:
       SET_BIT(PWR->PDCRG, GPIONumber);
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 8000ef8:	4b2c      	ldr	r3, [pc, #176]	; (8000fac <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000efa:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8000efc:	f001 0103 	and.w	r1, r1, #3
 8000f00:	430a      	orrs	r2, r1
 8000f02:	65da      	str	r2, [r3, #92]	; 0x5c
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));          
 8000f04:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000f06:	ea22 0101 	bic.w	r1, r2, r1
 8000f0a:	6599      	str	r1, [r3, #88]	; 0x58
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f0c:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));          
       break;                                                   
 8000f0e:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
  { 
    case PWR_GPIO_A:
       SET_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));        
 8000f10:	4b26      	ldr	r3, [pc, #152]	; (8000fac <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f12:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000f14:	f421 4020 	bic.w	r0, r1, #40960	; 0xa000
 8000f18:	4302      	orrs	r2, r0
 8000f1a:	625a      	str	r2, [r3, #36]	; 0x24
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));           
 8000f1c:	6a1a      	ldr	r2, [r3, #32]
 8000f1e:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8000f22:	ea22 0101 	bic.w	r1, r2, r1
 8000f26:	6219      	str	r1, [r3, #32]
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f28:	2000      	movs	r0, #0
  switch (GPIO)
  { 
    case PWR_GPIO_A:
       SET_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));        
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));           
       break;
 8000f2a:	4770      	bx	lr
    case PWR_GPIO_B:
       SET_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
 8000f2c:	4b1f      	ldr	r3, [pc, #124]	; (8000fac <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f2e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000f30:	f021 0010 	bic.w	r0, r1, #16
 8000f34:	4302      	orrs	r2, r0
 8000f36:	62da      	str	r2, [r3, #44]	; 0x2c
       CLEAR_BIT(PWR->PUCRB, GPIONumber);                    
 8000f38:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000f3a:	ea22 0101 	bic.w	r1, r2, r1
 8000f3e:	6299      	str	r1, [r3, #40]	; 0x28
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f40:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));           
       break;
    case PWR_GPIO_B:
       SET_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
       CLEAR_BIT(PWR->PUCRB, GPIONumber);                    
       break; 
 8000f42:	4770      	bx	lr
    case PWR_GPIO_C:
       SET_BIT(PWR->PDCRC, GPIONumber);
 8000f44:	4b19      	ldr	r3, [pc, #100]	; (8000fac <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f46:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000f48:	430a      	orrs	r2, r1
 8000f4a:	635a      	str	r2, [r3, #52]	; 0x34
       CLEAR_BIT(PWR->PUCRC, GPIONumber);        
 8000f4c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000f4e:	ea22 0101 	bic.w	r1, r2, r1
 8000f52:	6319      	str	r1, [r3, #48]	; 0x30
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f54:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRB, GPIONumber);                    
       break; 
    case PWR_GPIO_C:
       SET_BIT(PWR->PDCRC, GPIONumber);
       CLEAR_BIT(PWR->PUCRC, GPIONumber);        
       break; 
 8000f56:	4770      	bx	lr
    case PWR_GPIO_D:
       SET_BIT(PWR->PDCRD, GPIONumber);
 8000f58:	4b14      	ldr	r3, [pc, #80]	; (8000fac <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f5a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8000f5c:	430a      	orrs	r2, r1
 8000f5e:	63da      	str	r2, [r3, #60]	; 0x3c
       CLEAR_BIT(PWR->PUCRD, GPIONumber);        
 8000f60:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000f62:	ea22 0101 	bic.w	r1, r2, r1
 8000f66:	6399      	str	r1, [r3, #56]	; 0x38
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f68:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRC, GPIONumber);        
       break; 
    case PWR_GPIO_D:
       SET_BIT(PWR->PDCRD, GPIONumber);
       CLEAR_BIT(PWR->PUCRD, GPIONumber);        
       break;
 8000f6a:	4770      	bx	lr
    case PWR_GPIO_E:
       SET_BIT(PWR->PDCRE, GPIONumber);
 8000f6c:	4b0f      	ldr	r3, [pc, #60]	; (8000fac <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f6e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000f70:	430a      	orrs	r2, r1
 8000f72:	645a      	str	r2, [r3, #68]	; 0x44
       CLEAR_BIT(PWR->PUCRE, GPIONumber);        
 8000f74:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000f76:	ea22 0101 	bic.w	r1, r2, r1
 8000f7a:	6419      	str	r1, [r3, #64]	; 0x40
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f7c:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRD, GPIONumber);        
       break;
    case PWR_GPIO_E:
       SET_BIT(PWR->PDCRE, GPIONumber);
       CLEAR_BIT(PWR->PUCRE, GPIONumber);        
       break;
 8000f7e:	4770      	bx	lr
    case PWR_GPIO_F:
       SET_BIT(PWR->PDCRF, GPIONumber);
 8000f80:	4b0a      	ldr	r3, [pc, #40]	; (8000fac <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f82:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000f84:	430a      	orrs	r2, r1
 8000f86:	64da      	str	r2, [r3, #76]	; 0x4c
       CLEAR_BIT(PWR->PUCRF, GPIONumber);        
 8000f88:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8000f8a:	ea22 0101 	bic.w	r1, r2, r1
 8000f8e:	6499      	str	r1, [r3, #72]	; 0x48
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000f90:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRE, GPIONumber);        
       break;
    case PWR_GPIO_F:
       SET_BIT(PWR->PDCRF, GPIONumber);
       CLEAR_BIT(PWR->PUCRF, GPIONumber);        
       break;
 8000f92:	4770      	bx	lr
    case PWR_GPIO_G:
       SET_BIT(PWR->PDCRG, GPIONumber);
 8000f94:	4b05      	ldr	r3, [pc, #20]	; (8000fac <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8000f96:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8000f98:	430a      	orrs	r2, r1
 8000f9a:	655a      	str	r2, [r3, #84]	; 0x54
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
 8000f9c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8000f9e:	ea22 0101 	bic.w	r1, r2, r1
 8000fa2:	6519      	str	r1, [r3, #80]	; 0x50
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000fa4:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRF, GPIONumber);        
       break;
    case PWR_GPIO_G:
       SET_BIT(PWR->PDCRG, GPIONumber);
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
       break;
 8000fa6:	4770      	bx	lr
    case PWR_GPIO_H:
       SET_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));          
       break;                                                   
    default:
        return HAL_ERROR;
 8000fa8:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 8000faa:	4770      	bx	lr
 8000fac:	40007000 	.word	0x40007000

08000fb0 <HAL_PWREx_DisableGPIOPullDown>:
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
{
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
   
  switch (GPIO)
 8000fb0:	2807      	cmp	r0, #7
 8000fb2:	d843      	bhi.n	800103c <HAL_PWREx_DisableGPIOPullDown+0x8c>
 8000fb4:	e8df f000 	tbb	[pc, r0]
 8000fb8:	261f160d 	.word	0x261f160d
 8000fbc:	043b342d 	.word	0x043b342d
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
      CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 8000fc0:	4b1f      	ldr	r3, [pc, #124]	; (8001040 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000fc2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8000fc4:	f001 0103 	and.w	r1, r1, #3
 8000fc8:	ea22 0101 	bic.w	r1, r2, r1
 8000fcc:	65d9      	str	r1, [r3, #92]	; 0x5c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000fce:	2000      	movs	r0, #0
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
      CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
 8000fd0:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
   
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                        
 8000fd2:	4b1b      	ldr	r3, [pc, #108]	; (8001040 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000fd4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000fd6:	f421 4120 	bic.w	r1, r1, #40960	; 0xa000
 8000fda:	ea22 0101 	bic.w	r1, r2, r1
 8000fde:	6259      	str	r1, [r3, #36]	; 0x24
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000fe0:	2000      	movs	r0, #0
   
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                        
       break;
 8000fe2:	4770      	bx	lr
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));           
 8000fe4:	4b16      	ldr	r3, [pc, #88]	; (8001040 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000fe6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000fe8:	f021 0110 	bic.w	r1, r1, #16
 8000fec:	ea22 0101 	bic.w	r1, r2, r1
 8000ff0:	62d9      	str	r1, [r3, #44]	; 0x2c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8000ff2:	2000      	movs	r0, #0
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                        
       break;
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));           
       break; 
 8000ff4:	4770      	bx	lr
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
 8000ff6:	4b12      	ldr	r3, [pc, #72]	; (8001040 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8000ff8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000ffa:	ea22 0101 	bic.w	r1, r2, r1
 8000ffe:	6359      	str	r1, [r3, #52]	; 0x34
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8001000:	2000      	movs	r0, #0
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));           
       break; 
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
       break; 
 8001002:	4770      	bx	lr
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
 8001004:	4b0e      	ldr	r3, [pc, #56]	; (8001040 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8001006:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001008:	ea22 0101 	bic.w	r1, r2, r1
 800100c:	63d9      	str	r1, [r3, #60]	; 0x3c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 800100e:	2000      	movs	r0, #0
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
       break; 
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
       break;
 8001010:	4770      	bx	lr
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
 8001012:	4b0b      	ldr	r3, [pc, #44]	; (8001040 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8001014:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001016:	ea22 0101 	bic.w	r1, r2, r1
 800101a:	6459      	str	r1, [r3, #68]	; 0x44
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 800101c:	2000      	movs	r0, #0
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
       break;
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
       break;
 800101e:	4770      	bx	lr
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PDCRF, GPIONumber);
 8001020:	4b07      	ldr	r3, [pc, #28]	; (8001040 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8001022:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001024:	ea22 0101 	bic.w	r1, r2, r1
 8001028:	64d9      	str	r1, [r3, #76]	; 0x4c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 800102a:	2000      	movs	r0, #0
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
       break;
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PDCRF, GPIONumber);
       break;
 800102c:	4770      	bx	lr
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
 800102e:	4b04      	ldr	r3, [pc, #16]	; (8001040 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8001030:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8001032:	ea22 0101 	bic.w	r1, r2, r1
 8001036:	6559      	str	r1, [r3, #84]	; 0x54
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8001038:	2000      	movs	r0, #0
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PDCRF, GPIONumber);
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
       break;
 800103a:	4770      	bx	lr
    case PWR_GPIO_H:
      CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
    default:
        return HAL_ERROR;
 800103c:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 800103e:	4770      	bx	lr
 8001040:	40007000 	.word	0x40007000

08001044 <HAL_PWREx_EnablePullUpPullDownConfig>:
  *        is no conflict when setting PUy or PDy bit.         
  * @retval None
  */
void HAL_PWREx_EnablePullUpPullDownConfig(void)
{
  SET_BIT(PWR->CR3, PWR_CR3_APC);
 8001044:	4b02      	ldr	r3, [pc, #8]	; (8001050 <HAL_PWREx_EnablePullUpPullDownConfig+0xc>)
 8001046:	689a      	ldr	r2, [r3, #8]
 8001048:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800104c:	609a      	str	r2, [r3, #8]
 800104e:	4770      	bx	lr
 8001050:	40007000 	.word	0x40007000

08001054 <HAL_PWREx_DisablePullUpPullDownConfig>:
  *        PWR_PUCRx and PWR_PDCRx registers are not applied in Standby and Shutdown modes.     
  * @retval None
  */
void HAL_PWREx_DisablePullUpPullDownConfig(void)
{
  CLEAR_BIT(PWR->CR3, PWR_CR3_APC);
 8001054:	4b02      	ldr	r3, [pc, #8]	; (8001060 <HAL_PWREx_DisablePullUpPullDownConfig+0xc>)
 8001056:	689a      	ldr	r2, [r3, #8]
 8001058:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800105c:	609a      	str	r2, [r3, #8]
 800105e:	4770      	bx	lr
 8001060:	40007000 	.word	0x40007000

08001064 <HAL_PWREx_EnableSRAM2ContentRetention>:
  *         Standby mode and its content is kept.    
  * @retval None
  */
void HAL_PWREx_EnableSRAM2ContentRetention(void)
{
  SET_BIT(PWR->CR3, PWR_CR3_RRS);
 8001064:	4b02      	ldr	r3, [pc, #8]	; (8001070 <HAL_PWREx_EnableSRAM2ContentRetention+0xc>)
 8001066:	689a      	ldr	r2, [r3, #8]
 8001068:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800106c:	609a      	str	r2, [r3, #8]
 800106e:	4770      	bx	lr
 8001070:	40007000 	.word	0x40007000

08001074 <HAL_PWREx_DisableSRAM2ContentRetention>:
  *        and its content is lost.      
  * @retval None
  */
void HAL_PWREx_DisableSRAM2ContentRetention(void)
{
  CLEAR_BIT(PWR->CR3, PWR_CR3_RRS);
 8001074:	4b02      	ldr	r3, [pc, #8]	; (8001080 <HAL_PWREx_DisableSRAM2ContentRetention+0xc>)
 8001076:	689a      	ldr	r2, [r3, #8]
 8001078:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800107c:	609a      	str	r2, [r3, #8]
 800107e:	4770      	bx	lr
 8001080:	40007000 	.word	0x40007000

08001084 <HAL_PWREx_EnablePVM1>:
  * @brief Enable the Power Voltage Monitoring 1: VDDUSB versus 1.2V.
  * @retval None
  */
void HAL_PWREx_EnablePVM1(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_1);    
 8001084:	4b02      	ldr	r3, [pc, #8]	; (8001090 <HAL_PWREx_EnablePVM1+0xc>)
 8001086:	685a      	ldr	r2, [r3, #4]
 8001088:	f042 0210 	orr.w	r2, r2, #16
 800108c:	605a      	str	r2, [r3, #4]
 800108e:	4770      	bx	lr
 8001090:	40007000 	.word	0x40007000

08001094 <HAL_PWREx_DisablePVM1>:
  * @brief Disable the Power Voltage Monitoring 1: VDDUSB versus 1.2V.
  * @retval None
  */
void HAL_PWREx_DisablePVM1(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_1);    
 8001094:	4b02      	ldr	r3, [pc, #8]	; (80010a0 <HAL_PWREx_DisablePVM1+0xc>)
 8001096:	685a      	ldr	r2, [r3, #4]
 8001098:	f022 0210 	bic.w	r2, r2, #16
 800109c:	605a      	str	r2, [r3, #4]
 800109e:	4770      	bx	lr
 80010a0:	40007000 	.word	0x40007000

080010a4 <HAL_PWREx_EnablePVM2>:
  * @brief Enable the Power Voltage Monitoring 2: VDDIO2 versus 0.9V.
  * @retval None
  */
void HAL_PWREx_EnablePVM2(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_2);    
 80010a4:	4b02      	ldr	r3, [pc, #8]	; (80010b0 <HAL_PWREx_EnablePVM2+0xc>)
 80010a6:	685a      	ldr	r2, [r3, #4]
 80010a8:	f042 0220 	orr.w	r2, r2, #32
 80010ac:	605a      	str	r2, [r3, #4]
 80010ae:	4770      	bx	lr
 80010b0:	40007000 	.word	0x40007000

080010b4 <HAL_PWREx_DisablePVM2>:
  * @brief Disable the Power Voltage Monitoring 2: VDDIO2 versus 0.9V.
  * @retval None
  */
void HAL_PWREx_DisablePVM2(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_2);    
 80010b4:	4b02      	ldr	r3, [pc, #8]	; (80010c0 <HAL_PWREx_DisablePVM2+0xc>)
 80010b6:	685a      	ldr	r2, [r3, #4]
 80010b8:	f022 0220 	bic.w	r2, r2, #32
 80010bc:	605a      	str	r2, [r3, #4]
 80010be:	4770      	bx	lr
 80010c0:	40007000 	.word	0x40007000

080010c4 <HAL_PWREx_EnablePVM3>:
  * @brief Enable the Power Voltage Monitoring 3: VDDA versus 1.62V.
  * @retval None
  */
void HAL_PWREx_EnablePVM3(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_3);    
 80010c4:	4b02      	ldr	r3, [pc, #8]	; (80010d0 <HAL_PWREx_EnablePVM3+0xc>)
 80010c6:	685a      	ldr	r2, [r3, #4]
 80010c8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80010cc:	605a      	str	r2, [r3, #4]
 80010ce:	4770      	bx	lr
 80010d0:	40007000 	.word	0x40007000

080010d4 <HAL_PWREx_DisablePVM3>:
  * @brief Disable the Power Voltage Monitoring 3: VDDA versus 1.62V.
  * @retval None
  */
void HAL_PWREx_DisablePVM3(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_3);    
 80010d4:	4b02      	ldr	r3, [pc, #8]	; (80010e0 <HAL_PWREx_DisablePVM3+0xc>)
 80010d6:	685a      	ldr	r2, [r3, #4]
 80010d8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80010dc:	605a      	str	r2, [r3, #4]
 80010de:	4770      	bx	lr
 80010e0:	40007000 	.word	0x40007000

080010e4 <HAL_PWREx_EnablePVM4>:
  * @brief Enable the Power Voltage Monitoring 4:  VDDA versus 2.2V.
  * @retval None
  */
void HAL_PWREx_EnablePVM4(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_4);    
 80010e4:	4b02      	ldr	r3, [pc, #8]	; (80010f0 <HAL_PWREx_EnablePVM4+0xc>)
 80010e6:	685a      	ldr	r2, [r3, #4]
 80010e8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80010ec:	605a      	str	r2, [r3, #4]
 80010ee:	4770      	bx	lr
 80010f0:	40007000 	.word	0x40007000

080010f4 <HAL_PWREx_DisablePVM4>:
  * @brief Disable the Power Voltage Monitoring 4:  VDDA versus 2.2V.
  * @retval None
  */
void HAL_PWREx_DisablePVM4(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_4);    
 80010f4:	4b02      	ldr	r3, [pc, #8]	; (8001100 <HAL_PWREx_DisablePVM4+0xc>)
 80010f6:	685a      	ldr	r2, [r3, #4]
 80010f8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80010fc:	605a      	str	r2, [r3, #4]
 80010fe:	4770      	bx	lr
 8001100:	40007000 	.word	0x40007000

08001104 <HAL_PWREx_ConfigPVM>:


  /* Configure EXTI 35 to 38 interrupts if so required:
     scan thru PVMType to detect which PVMx is set and
     configure the corresponding EXTI line accordingly. */
  switch (sConfigPVM->PVMType)
 8001104:	6803      	ldr	r3, [r0, #0]
 8001106:	2b20      	cmp	r3, #32
 8001108:	f000 80a0 	beq.w	800124c <HAL_PWREx_ConfigPVM+0x148>
 800110c:	d968      	bls.n	80011e0 <HAL_PWREx_ConfigPVM+0xdc>
 800110e:	2b40      	cmp	r3, #64	; 0x40
 8001110:	d034      	beq.n	800117c <HAL_PWREx_ConfigPVM+0x78>
 8001112:	2b80      	cmp	r3, #128	; 0x80
 8001114:	f040 8098 	bne.w	8001248 <HAL_PWREx_ConfigPVM+0x144>
      }
      break;
      
    case PWR_PVM_4:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM4_EXTI_DISABLE_EVENT();
 8001118:	4b65      	ldr	r3, [pc, #404]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 800111a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800111c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001120:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM4_EXTI_DISABLE_IT();
 8001122:	6a1a      	ldr	r2, [r3, #32]
 8001124:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001128:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM4_EXTI_DISABLE_FALLING_EDGE(); 
 800112a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800112c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001130:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM4_EXTI_DISABLE_RISING_EDGE();
 8001132:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001134:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001138:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 800113a:	6842      	ldr	r2, [r0, #4]
 800113c:	03d1      	lsls	r1, r2, #15
 800113e:	d504      	bpl.n	800114a <HAL_PWREx_ConfigPVM+0x46>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_IT();
 8001140:	6a1a      	ldr	r2, [r3, #32]
 8001142:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001146:	621a      	str	r2, [r3, #32]
 8001148:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 800114a:	0393      	lsls	r3, r2, #14
 800114c:	d505      	bpl.n	800115a <HAL_PWREx_ConfigPVM+0x56>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_EVENT();
 800114e:	4b58      	ldr	r3, [pc, #352]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 8001150:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001152:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001156:	625a      	str	r2, [r3, #36]	; 0x24
 8001158:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 800115a:	07d1      	lsls	r1, r2, #31
 800115c:	d505      	bpl.n	800116a <HAL_PWREx_ConfigPVM+0x66>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_RISING_EDGE();
 800115e:	4b54      	ldr	r3, [pc, #336]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 8001160:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001162:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001166:	629a      	str	r2, [r3, #40]	; 0x28
 8001168:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 800116a:	0793      	lsls	r3, r2, #30
 800116c:	d56a      	bpl.n	8001244 <HAL_PWREx_ConfigPVM+0x140>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_FALLING_EDGE();
 800116e:	4b50      	ldr	r3, [pc, #320]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 8001170:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001172:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001176:	62da      	str	r2, [r3, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 8001178:	2000      	movs	r0, #0
 800117a:	4770      	bx	lr
      }
      break;
      
    case PWR_PVM_3:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM3_EXTI_DISABLE_EVENT();
 800117c:	4b4c      	ldr	r3, [pc, #304]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 800117e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001180:	f022 0220 	bic.w	r2, r2, #32
 8001184:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM3_EXTI_DISABLE_IT();
 8001186:	6a1a      	ldr	r2, [r3, #32]
 8001188:	f022 0220 	bic.w	r2, r2, #32
 800118c:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM3_EXTI_DISABLE_FALLING_EDGE(); 
 800118e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001190:	f022 0220 	bic.w	r2, r2, #32
 8001194:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM3_EXTI_DISABLE_RISING_EDGE();
 8001196:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001198:	f022 0220 	bic.w	r2, r2, #32
 800119c:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 800119e:	6842      	ldr	r2, [r0, #4]
 80011a0:	03d1      	lsls	r1, r2, #15
 80011a2:	d504      	bpl.n	80011ae <HAL_PWREx_ConfigPVM+0xaa>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_IT();
 80011a4:	6a1a      	ldr	r2, [r3, #32]
 80011a6:	f042 0220 	orr.w	r2, r2, #32
 80011aa:	621a      	str	r2, [r3, #32]
 80011ac:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 80011ae:	0391      	lsls	r1, r2, #14
 80011b0:	d505      	bpl.n	80011be <HAL_PWREx_ConfigPVM+0xba>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_EVENT();
 80011b2:	4b3f      	ldr	r3, [pc, #252]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 80011b4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80011b6:	f042 0220 	orr.w	r2, r2, #32
 80011ba:	625a      	str	r2, [r3, #36]	; 0x24
 80011bc:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 80011be:	07d3      	lsls	r3, r2, #31
 80011c0:	d505      	bpl.n	80011ce <HAL_PWREx_ConfigPVM+0xca>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_RISING_EDGE();
 80011c2:	4b3b      	ldr	r3, [pc, #236]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 80011c4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80011c6:	f042 0220 	orr.w	r2, r2, #32
 80011ca:	629a      	str	r2, [r3, #40]	; 0x28
 80011cc:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 80011ce:	0790      	lsls	r0, r2, #30
 80011d0:	d538      	bpl.n	8001244 <HAL_PWREx_ConfigPVM+0x140>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_FALLING_EDGE();
 80011d2:	4b37      	ldr	r3, [pc, #220]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 80011d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80011d6:	f042 0220 	orr.w	r2, r2, #32
 80011da:	62da      	str	r2, [r3, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 80011dc:	2000      	movs	r0, #0
 80011de:	4770      	bx	lr


  /* Configure EXTI 35 to 38 interrupts if so required:
     scan thru PVMType to detect which PVMx is set and
     configure the corresponding EXTI line accordingly. */
  switch (sConfigPVM->PVMType)
 80011e0:	2b10      	cmp	r3, #16
 80011e2:	d131      	bne.n	8001248 <HAL_PWREx_ConfigPVM+0x144>
  {
#if defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx)
    case PWR_PVM_1:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM1_EXTI_DISABLE_EVENT();
 80011e4:	4b32      	ldr	r3, [pc, #200]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 80011e6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80011e8:	f022 0208 	bic.w	r2, r2, #8
 80011ec:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM1_EXTI_DISABLE_IT();
 80011ee:	6a1a      	ldr	r2, [r3, #32]
 80011f0:	f022 0208 	bic.w	r2, r2, #8
 80011f4:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM1_EXTI_DISABLE_FALLING_EDGE(); 
 80011f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80011f8:	f022 0208 	bic.w	r2, r2, #8
 80011fc:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM1_EXTI_DISABLE_RISING_EDGE();
 80011fe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001200:	f022 0208 	bic.w	r2, r2, #8
 8001204:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 8001206:	6842      	ldr	r2, [r0, #4]
 8001208:	03d1      	lsls	r1, r2, #15
 800120a:	d504      	bpl.n	8001216 <HAL_PWREx_ConfigPVM+0x112>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_IT();
 800120c:	6a1a      	ldr	r2, [r3, #32]
 800120e:	f042 0208 	orr.w	r2, r2, #8
 8001212:	621a      	str	r2, [r3, #32]
 8001214:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 8001216:	0391      	lsls	r1, r2, #14
 8001218:	d505      	bpl.n	8001226 <HAL_PWREx_ConfigPVM+0x122>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_EVENT();
 800121a:	4b25      	ldr	r3, [pc, #148]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 800121c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800121e:	f042 0208 	orr.w	r2, r2, #8
 8001222:	625a      	str	r2, [r3, #36]	; 0x24
 8001224:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 8001226:	07d3      	lsls	r3, r2, #31
 8001228:	d505      	bpl.n	8001236 <HAL_PWREx_ConfigPVM+0x132>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_RISING_EDGE();
 800122a:	4b21      	ldr	r3, [pc, #132]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 800122c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800122e:	f042 0208 	orr.w	r2, r2, #8
 8001232:	629a      	str	r2, [r3, #40]	; 0x28
 8001234:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 8001236:	0790      	lsls	r0, r2, #30
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_FALLING_EDGE();
 8001238:	bf41      	itttt	mi
 800123a:	4b1d      	ldrmi	r3, [pc, #116]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 800123c:	6ada      	ldrmi	r2, [r3, #44]	; 0x2c
 800123e:	f042 0208 	orrmi.w	r2, r2, #8
 8001242:	62da      	strmi	r2, [r3, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 8001244:	2000      	movs	r0, #0
 8001246:	4770      	bx	lr
        __HAL_PWR_PVM4_EXTI_ENABLE_FALLING_EDGE();
      }
      break;  
      
    default:
      return HAL_ERROR;                      
 8001248:	2001      	movs	r0, #1
    
  }   

  
  return HAL_OK;
}
 800124a:	4770      	bx	lr
      break; 
#endif /* defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) */        
    
    case PWR_PVM_2:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM2_EXTI_DISABLE_EVENT();
 800124c:	4b18      	ldr	r3, [pc, #96]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 800124e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001250:	f022 0210 	bic.w	r2, r2, #16
 8001254:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM2_EXTI_DISABLE_IT();
 8001256:	6a1a      	ldr	r2, [r3, #32]
 8001258:	f022 0210 	bic.w	r2, r2, #16
 800125c:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM2_EXTI_DISABLE_FALLING_EDGE(); 
 800125e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001260:	f022 0210 	bic.w	r2, r2, #16
 8001264:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM2_EXTI_DISABLE_RISING_EDGE();
 8001266:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001268:	f022 0210 	bic.w	r2, r2, #16
 800126c:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 800126e:	6842      	ldr	r2, [r0, #4]
 8001270:	03d1      	lsls	r1, r2, #15
 8001272:	d504      	bpl.n	800127e <HAL_PWREx_ConfigPVM+0x17a>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_IT();
 8001274:	6a1a      	ldr	r2, [r3, #32]
 8001276:	f042 0210 	orr.w	r2, r2, #16
 800127a:	621a      	str	r2, [r3, #32]
 800127c:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 800127e:	0391      	lsls	r1, r2, #14
 8001280:	d505      	bpl.n	800128e <HAL_PWREx_ConfigPVM+0x18a>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_EVENT();
 8001282:	4b0b      	ldr	r3, [pc, #44]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 8001284:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001286:	f042 0210 	orr.w	r2, r2, #16
 800128a:	625a      	str	r2, [r3, #36]	; 0x24
 800128c:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 800128e:	07d3      	lsls	r3, r2, #31
 8001290:	d505      	bpl.n	800129e <HAL_PWREx_ConfigPVM+0x19a>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_RISING_EDGE();
 8001292:	4b07      	ldr	r3, [pc, #28]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 8001294:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001296:	f042 0210 	orr.w	r2, r2, #16
 800129a:	629a      	str	r2, [r3, #40]	; 0x28
 800129c:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 800129e:	0790      	lsls	r0, r2, #30
 80012a0:	d5d0      	bpl.n	8001244 <HAL_PWREx_ConfigPVM+0x140>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_FALLING_EDGE();
 80012a2:	4b03      	ldr	r3, [pc, #12]	; (80012b0 <HAL_PWREx_ConfigPVM+0x1ac>)
 80012a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80012a6:	f042 0210 	orr.w	r2, r2, #16
 80012aa:	62da      	str	r2, [r3, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 80012ac:	2000      	movs	r0, #0
 80012ae:	4770      	bx	lr
 80012b0:	40010400 	.word	0x40010400

080012b4 <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR); 
 80012b4:	4b02      	ldr	r3, [pc, #8]	; (80012c0 <HAL_PWREx_EnableLowPowerRunMode+0xc>)
 80012b6:	681a      	ldr	r2, [r3, #0]
 80012b8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80012bc:	601a      	str	r2, [r3, #0]
 80012be:	4770      	bx	lr
 80012c0:	40007000 	.word	0x40007000

080012c4 <HAL_PWREx_DisableLowPowerRunMode>:
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index = 0;
  
  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR); 
 80012c4:	490e      	ldr	r1, [pc, #56]	; (8001300 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)

  /* Wait until REGLPF is reset */
  wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 80012c6:	4a0f      	ldr	r2, [pc, #60]	; (8001304 <HAL_PWREx_DisableLowPowerRunMode+0x40>)
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index = 0;
  
  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR); 
 80012c8:	6808      	ldr	r0, [r1, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 80012ca:	4b0f      	ldr	r3, [pc, #60]	; (8001308 <HAL_PWREx_DisableLowPowerRunMode+0x44>)
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index = 0;
  
  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR); 
 80012cc:	f420 4080 	bic.w	r0, r0, #16384	; 0x4000
 80012d0:	6008      	str	r0, [r1, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 80012d2:	6812      	ldr	r2, [r2, #0]
 80012d4:	fba3 0302 	umull	r0, r3, r3, r2
 80012d8:	0c9b      	lsrs	r3, r3, #18
 80012da:	2232      	movs	r2, #50	; 0x32
 80012dc:	fb02 f303 	mul.w	r3, r2, r3
  while ((wait_loop_index != 0) && (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)))
 80012e0:	b913      	cbnz	r3, 80012e8 <HAL_PWREx_DisableLowPowerRunMode+0x24>
 80012e2:	e004      	b.n	80012ee <HAL_PWREx_DisableLowPowerRunMode+0x2a>
 80012e4:	3b01      	subs	r3, #1
 80012e6:	d002      	beq.n	80012ee <HAL_PWREx_DisableLowPowerRunMode+0x2a>
 80012e8:	694a      	ldr	r2, [r1, #20]
 80012ea:	0592      	lsls	r2, r2, #22
 80012ec:	d4fa      	bmi.n	80012e4 <HAL_PWREx_DisableLowPowerRunMode+0x20>
  {
    wait_loop_index--;
  }
  if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 80012ee:	4b04      	ldr	r3, [pc, #16]	; (8001300 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 80012f0:	695b      	ldr	r3, [r3, #20]
  {
    return HAL_TIMEOUT;
 80012f2:	f413 7f00 	tst.w	r3, #512	; 0x200
  }
  
  return HAL_OK;
}
 80012f6:	bf14      	ite	ne
 80012f8:	2003      	movne	r0, #3
 80012fa:	2000      	moveq	r0, #0
 80012fc:	4770      	bx	lr
 80012fe:	bf00      	nop
 8001300:	40007000 	.word	0x40007000
 8001304:	20000000 	.word	0x20000000
 8001308:	431bde83 	.word	0x431bde83

0800130c <HAL_PWREx_EnterSTOP1Mode>:
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* Stop 1 mode with Main Regulator */
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1MR);
 800130c:	4b0c      	ldr	r3, [pc, #48]	; (8001340 <HAL_PWREx_EnterSTOP1Mode+0x34>)
 800130e:	681a      	ldr	r2, [r3, #0]
 8001310:	f022 0207 	bic.w	r2, r2, #7
{
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    
  if (Regulator == PWR_MAINREGULATOR_ON)
 8001314:	b108      	cbz	r0, 800131a <HAL_PWREx_EnterSTOP1Mode+0xe>
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1MR);
  }
  else
  {
    /* Stop 1 mode with Low-Power Regulator */
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1LPR);
 8001316:	f042 0201 	orr.w	r2, r2, #1
 800131a:	601a      	str	r2, [r3, #0]
  }

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 800131c:	4b09      	ldr	r3, [pc, #36]	; (8001344 <HAL_PWREx_EnterSTOP1Mode+0x38>)
 800131e:	691a      	ldr	r2, [r3, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 8001320:	2901      	cmp	r1, #1
    /* Stop 1 mode with Low-Power Regulator */
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1LPR);
  }

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 8001322:	f042 0204 	orr.w	r2, r2, #4
 8001326:	611a      	str	r2, [r3, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 8001328:	d008      	beq.n	800133c <HAL_PWREx_EnterSTOP1Mode+0x30>

    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
{
  __ASM volatile ("sev");
 800132a:	bf40      	sev
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 800132c:	bf20      	wfe
 800132e:	bf20      	wfe
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 8001330:	4b04      	ldr	r3, [pc, #16]	; (8001344 <HAL_PWREx_EnterSTOP1Mode+0x38>)
 8001332:	691a      	ldr	r2, [r3, #16]
 8001334:	f022 0204 	bic.w	r2, r2, #4
 8001338:	611a      	str	r2, [r3, #16]
 800133a:	4770      	bx	lr
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 800133c:	bf30      	wfi
 800133e:	e7f7      	b.n	8001330 <HAL_PWREx_EnterSTOP1Mode+0x24>
 8001340:	40007000 	.word	0x40007000
 8001344:	e000ed00 	.word	0xe000ed00

08001348 <HAL_PWREx_EnterSTOP2Mode>:
{
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);
 8001348:	4a0c      	ldr	r2, [pc, #48]	; (800137c <HAL_PWREx_EnterSTOP2Mode+0x34>)


  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 800134a:	4b0d      	ldr	r3, [pc, #52]	; (8001380 <HAL_PWREx_EnterSTOP2Mode+0x38>)
{
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);
 800134c:	6811      	ldr	r1, [r2, #0]
 800134e:	f021 0107 	bic.w	r1, r1, #7
 8001352:	f041 0102 	orr.w	r1, r1, #2
 8001356:	6011      	str	r1, [r2, #0]


  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 8001358:	691a      	ldr	r2, [r3, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 800135a:	2801      	cmp	r0, #1
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);


  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 800135c:	f042 0204 	orr.w	r2, r2, #4
 8001360:	611a      	str	r2, [r3, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 8001362:	d008      	beq.n	8001376 <HAL_PWREx_EnterSTOP2Mode+0x2e>

    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
{
  __ASM volatile ("sev");
 8001364:	bf40      	sev
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 8001366:	bf20      	wfe
 8001368:	bf20      	wfe
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 800136a:	4b05      	ldr	r3, [pc, #20]	; (8001380 <HAL_PWREx_EnterSTOP2Mode+0x38>)
 800136c:	691a      	ldr	r2, [r3, #16]
 800136e:	f022 0204 	bic.w	r2, r2, #4
 8001372:	611a      	str	r2, [r3, #16]
 8001374:	4770      	bx	lr
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8001376:	bf30      	wfi
 8001378:	e7f7      	b.n	800136a <HAL_PWREx_EnterSTOP2Mode+0x22>
 800137a:	bf00      	nop
 800137c:	40007000 	.word	0x40007000
 8001380:	e000ed00 	.word	0xe000ed00

08001384 <HAL_PWREx_EnterSHUTDOWNMode>:
  */
void HAL_PWREx_EnterSHUTDOWNMode(void)
{
  
  /* Set Shutdown mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_SHUTDOWN);
 8001384:	4a06      	ldr	r2, [pc, #24]	; (80013a0 <HAL_PWREx_EnterSHUTDOWNMode+0x1c>)
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8001386:	4b07      	ldr	r3, [pc, #28]	; (80013a4 <HAL_PWREx_EnterSHUTDOWNMode+0x20>)
  */
void HAL_PWREx_EnterSHUTDOWNMode(void)
{
  
  /* Set Shutdown mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_SHUTDOWN);
 8001388:	6811      	ldr	r1, [r2, #0]
 800138a:	f021 0107 	bic.w	r1, r1, #7
 800138e:	f041 0104 	orr.w	r1, r1, #4
 8001392:	6011      	str	r1, [r2, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8001394:	691a      	ldr	r2, [r3, #16]
 8001396:	f042 0204 	orr.w	r2, r2, #4
 800139a:	611a      	str	r2, [r3, #16]
 800139c:	bf30      	wfi
 800139e:	4770      	bx	lr
 80013a0:	40007000 	.word	0x40007000
 80013a4:	e000ed00 	.word	0xe000ed00

080013a8 <HAL_PWREx_PVM1Callback>:
/**
  * @brief PWR PVM1 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM1Callback(void)
{
 80013a8:	4770      	bx	lr
 80013aa:	bf00      	nop

080013ac <HAL_PWREx_PVM2Callback>:
/**
  * @brief PWR PVM2 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM2Callback(void)
{
 80013ac:	4770      	bx	lr
 80013ae:	bf00      	nop

080013b0 <HAL_PWREx_PVM3Callback>:
/**
  * @brief PWR PVM3 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM3Callback(void)
{
 80013b0:	4770      	bx	lr
 80013b2:	bf00      	nop

080013b4 <HAL_PWREx_PVM4Callback>:
/**
  * @brief PWR PVM4 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM4Callback(void)
{
 80013b4:	4770      	bx	lr
 80013b6:	bf00      	nop

080013b8 <HAL_PWREx_PVD_PVM_IRQHandler>:
  * @brief This function handles the PWR PVD/PVMx interrupt request.
  * @note This API should be called under the PVD_PVM_IRQHandler().  
  * @retval None
  */
void HAL_PWREx_PVD_PVM_IRQHandler(void)
{
 80013b8:	b510      	push	{r4, lr}
  /* Check PWR exti flag */
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 80013ba:	4c17      	ldr	r4, [pc, #92]	; (8001418 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 80013bc:	6963      	ldr	r3, [r4, #20]
 80013be:	03db      	lsls	r3, r3, #15
 80013c0:	d423      	bmi.n	800140a <HAL_PWREx_PVD_PVM_IRQHandler+0x52>
    /* Clear PVD exti pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
  }
  /* Next, successively check PVMx exti flags */
#if defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx)
  if(__HAL_PWR_PVM1_EXTI_GET_FLAG() != RESET) 
 80013c2:	4c15      	ldr	r4, [pc, #84]	; (8001418 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 80013c4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80013c6:	0718      	lsls	r0, r3, #28
 80013c8:	d41a      	bmi.n	8001400 <HAL_PWREx_PVD_PVM_IRQHandler+0x48>
   
    /* Clear PVM1 exti pending bit */
    __HAL_PWR_PVM1_EXTI_CLEAR_FLAG();
  }
#endif /* defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) */
  if(__HAL_PWR_PVM2_EXTI_GET_FLAG() != RESET) 
 80013ca:	4c13      	ldr	r4, [pc, #76]	; (8001418 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 80013cc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80013ce:	06d9      	lsls	r1, r3, #27
 80013d0:	d411      	bmi.n	80013f6 <HAL_PWREx_PVD_PVM_IRQHandler+0x3e>
    HAL_PWREx_PVM2Callback();
   
    /* Clear PVM2 exti pending bit */
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
  }
  if(__HAL_PWR_PVM3_EXTI_GET_FLAG() != RESET) 
 80013d2:	4c11      	ldr	r4, [pc, #68]	; (8001418 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 80013d4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80013d6:	069a      	lsls	r2, r3, #26
 80013d8:	d408      	bmi.n	80013ec <HAL_PWREx_PVD_PVM_IRQHandler+0x34>
    HAL_PWREx_PVM3Callback();
   
    /* Clear PVM3 exti pending bit */
    __HAL_PWR_PVM3_EXTI_CLEAR_FLAG();
  }
  if(__HAL_PWR_PVM4_EXTI_GET_FLAG() != RESET) 
 80013da:	4c0f      	ldr	r4, [pc, #60]	; (8001418 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 80013dc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80013de:	065b      	lsls	r3, r3, #25
 80013e0:	d503      	bpl.n	80013ea <HAL_PWREx_PVD_PVM_IRQHandler+0x32>
  {
    /* PWR PVM4 interrupt user callback */
    HAL_PWREx_PVM4Callback();
 80013e2:	f7ff ffe7 	bl	80013b4 <HAL_PWREx_PVM4Callback>
   
    /* Clear PVM4 exti pending bit */
    __HAL_PWR_PVM4_EXTI_CLEAR_FLAG();
 80013e6:	2340      	movs	r3, #64	; 0x40
 80013e8:	6363      	str	r3, [r4, #52]	; 0x34
 80013ea:	bd10      	pop	{r4, pc}
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
  }
  if(__HAL_PWR_PVM3_EXTI_GET_FLAG() != RESET) 
  {
    /* PWR PVM3 interrupt user callback */
    HAL_PWREx_PVM3Callback();
 80013ec:	f7ff ffe0 	bl	80013b0 <HAL_PWREx_PVM3Callback>
   
    /* Clear PVM3 exti pending bit */
    __HAL_PWR_PVM3_EXTI_CLEAR_FLAG();
 80013f0:	2320      	movs	r3, #32
 80013f2:	6363      	str	r3, [r4, #52]	; 0x34
 80013f4:	e7f1      	b.n	80013da <HAL_PWREx_PVD_PVM_IRQHandler+0x22>
  }
#endif /* defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) */
  if(__HAL_PWR_PVM2_EXTI_GET_FLAG() != RESET) 
  {
    /* PWR PVM2 interrupt user callback */
    HAL_PWREx_PVM2Callback();
 80013f6:	f7ff ffd9 	bl	80013ac <HAL_PWREx_PVM2Callback>
   
    /* Clear PVM2 exti pending bit */
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
 80013fa:	2310      	movs	r3, #16
 80013fc:	6363      	str	r3, [r4, #52]	; 0x34
 80013fe:	e7e8      	b.n	80013d2 <HAL_PWREx_PVD_PVM_IRQHandler+0x1a>
  /* Next, successively check PVMx exti flags */
#if defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx)
  if(__HAL_PWR_PVM1_EXTI_GET_FLAG() != RESET) 
  {
    /* PWR PVM1 interrupt user callback */
    HAL_PWREx_PVM1Callback();
 8001400:	f7ff ffd2 	bl	80013a8 <HAL_PWREx_PVM1Callback>
   
    /* Clear PVM1 exti pending bit */
    __HAL_PWR_PVM1_EXTI_CLEAR_FLAG();
 8001404:	2308      	movs	r3, #8
 8001406:	6363      	str	r3, [r4, #52]	; 0x34
 8001408:	e7df      	b.n	80013ca <HAL_PWREx_PVD_PVM_IRQHandler+0x12>
{
  /* Check PWR exti flag */
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
  {
    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback();
 800140a:	f001 f859 	bl	80024c0 <HAL_PWR_PVDCallback>

    /* Clear PVD exti pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 800140e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001412:	6163      	str	r3, [r4, #20]
 8001414:	e7d5      	b.n	80013c2 <HAL_PWREx_PVD_PVM_IRQHandler+0xa>
 8001416:	bf00      	nop
 8001418:	40010400 	.word	0x40010400

0800141c <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 800141c:	b530      	push	{r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 800141e:	4c1f      	ldr	r4, [pc, #124]	; (800149c <RCC_SetFlashLatencyFromMSIRange+0x80>)
 8001420:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001422:	00da      	lsls	r2, r3, #3
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8001424:	b083      	sub	sp, #12
 8001426:	4605      	mov	r5, r0
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8001428:	d519      	bpl.n	800145e <RCC_SetFlashLatencyFromMSIRange+0x42>
  {
    vos = HAL_PWREx_GetVoltageRange();
 800142a:	f7ff fc23 	bl	8000c74 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 800142e:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8001432:	d026      	beq.n	8001482 <RCC_SetFlashLatencyFromMSIRange+0x66>
    }
    /* else MSI <= 16Mhz default FLASH_LATENCY_0 0WS */
  }
  else
  {
    if(msirange > RCC_MSIRANGE_8)
 8001434:	2d80      	cmp	r5, #128	; 0x80
 8001436:	d82b      	bhi.n	8001490 <RCC_SetFlashLatencyFromMSIRange+0x74>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 8001438:	d02e      	beq.n	8001498 <RCC_SetFlashLatencyFromMSIRange+0x7c>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else if(msirange == RCC_MSIRANGE_7) 
 800143a:	f1b5 0370 	subs.w	r3, r5, #112	; 0x70
 800143e:	4258      	negs	r0, r3
 8001440:	4158      	adcs	r0, r3
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
  }
       
  __HAL_FLASH_SET_LATENCY(latency);
 8001442:	4b17      	ldr	r3, [pc, #92]	; (80014a0 <RCC_SetFlashLatencyFromMSIRange+0x84>)
 8001444:	681a      	ldr	r2, [r3, #0]
 8001446:	f022 0207 	bic.w	r2, r2, #7
 800144a:	4302      	orrs	r2, r0
 800144c:	601a      	str	r2, [r3, #0]
  
  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 800144e:	681b      	ldr	r3, [r3, #0]
 8001450:	f003 0307 	and.w	r3, r3, #7
  {
    return HAL_ERROR;
  }
  
  return HAL_OK;
}
 8001454:	1ac0      	subs	r0, r0, r3
 8001456:	bf18      	it	ne
 8001458:	2001      	movne	r0, #1
 800145a:	b003      	add	sp, #12
 800145c:	bd30      	pop	{r4, r5, pc}
  {
    vos = HAL_PWREx_GetVoltageRange();
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 800145e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001460:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001464:	65a3      	str	r3, [r4, #88]	; 0x58
 8001466:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001468:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800146c:	9301      	str	r3, [sp, #4]
 800146e:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 8001470:	f7ff fc00 	bl	8000c74 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8001474:	6da3      	ldr	r3, [r4, #88]	; 0x58
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001476:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
 800147a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800147e:	65a3      	str	r3, [r4, #88]	; 0x58
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001480:	d1d8      	bne.n	8001434 <RCC_SetFlashLatencyFromMSIRange+0x18>
  {
    if(msirange > RCC_MSIRANGE_8)
 8001482:	2d80      	cmp	r5, #128	; 0x80
 8001484:	d906      	bls.n	8001494 <RCC_SetFlashLatencyFromMSIRange+0x78>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 8001486:	2da1      	cmp	r5, #161	; 0xa1
 8001488:	bf34      	ite	cc
 800148a:	2001      	movcc	r0, #1
 800148c:	2002      	movcs	r0, #2
 800148e:	e7d8      	b.n	8001442 <RCC_SetFlashLatencyFromMSIRange+0x26>
  else
  {
    if(msirange > RCC_MSIRANGE_8)
    {
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
 8001490:	2003      	movs	r0, #3
 8001492:	e7d6      	b.n	8001442 <RCC_SetFlashLatencyFromMSIRange+0x26>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8001494:	2000      	movs	r0, #0
 8001496:	e7d4      	b.n	8001442 <RCC_SetFlashLatencyFromMSIRange+0x26>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 8001498:	2002      	movs	r0, #2
 800149a:	e7d2      	b.n	8001442 <RCC_SetFlashLatencyFromMSIRange+0x26>
 800149c:	40021000 	.word	0x40021000
 80014a0:	40022000 	.word	0x40022000

080014a4 <HAL_RCC_DeInit>:
  * @retval None
  */
void HAL_RCC_DeInit(void)
{
  /* Set MSION bit */
  SET_BIT(RCC->CR, RCC_CR_MSION);
 80014a4:	4a16      	ldr	r2, [pc, #88]	; (8001500 <HAL_RCC_DeInit+0x5c>)
 80014a6:	6813      	ldr	r3, [r2, #0]
 80014a8:	f043 0301 	orr.w	r3, r3, #1
 80014ac:	6013      	str	r3, [r2, #0]

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET) { __NOP(); }
 80014ae:	6813      	ldr	r3, [r2, #0]
 80014b0:	0799      	lsls	r1, r3, #30
 80014b2:	d403      	bmi.n	80014bc <HAL_RCC_DeInit+0x18>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 80014b4:	bf00      	nop
 80014b6:	6813      	ldr	r3, [r2, #0]
 80014b8:	079b      	lsls	r3, r3, #30
 80014ba:	d5fb      	bpl.n	80014b4 <HAL_RCC_DeInit+0x10>
  
  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 80014bc:	4b10      	ldr	r3, [pc, #64]	; (8001500 <HAL_RCC_DeInit+0x5c>)
  
  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
 80014be:	4911      	ldr	r1, [pc, #68]	; (8001504 <HAL_RCC_DeInit+0x60>)

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET) { __NOP(); }
  
  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 80014c0:	6818      	ldr	r0, [r3, #0]
 80014c2:	f020 00f0 	bic.w	r0, r0, #240	; 0xf0
  
  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);
 80014c6:	2200      	movs	r2, #0

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET) { __NOP(); }
  
  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 80014c8:	f040 0060 	orr.w	r0, r0, #96	; 0x60
 80014cc:	6018      	str	r0, [r3, #0]
  
  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);
 80014ce:	609a      	str	r2, [r3, #8]

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
 80014d0:	6818      	ldr	r0, [r3, #0]
 80014d2:	4001      	ands	r1, r0
 80014d4:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  CLEAR_REG(RCC->PLLCFGR);
 80014d6:	60da      	str	r2, [r3, #12]
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN_4 );
 80014d8:	68d9      	ldr	r1, [r3, #12]
 80014da:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 80014de:	60d9      	str	r1, [r3, #12]

  /* Reset PLLSAI1CFGR register */
  CLEAR_REG(RCC->PLLSAI1CFGR);
 80014e0:	611a      	str	r2, [r3, #16]
  SET_BIT(RCC->PLLSAI1CFGR,  RCC_PLLSAI1CFGR_PLLSAI1N_4 );
 80014e2:	6919      	ldr	r1, [r3, #16]
 80014e4:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 80014e8:	6119      	str	r1, [r3, #16]

  /* Reset PLLSAI2CFGR register */
  CLEAR_REG(RCC->PLLSAI2CFGR);
 80014ea:	615a      	str	r2, [r3, #20]
  SET_BIT(RCC->PLLSAI2CFGR,  RCC_PLLSAI2CFGR_PLLSAI2N_4 );
 80014ec:	6959      	ldr	r1, [r3, #20]
 80014ee:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 80014f2:	6159      	str	r1, [r3, #20]

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 80014f4:	6819      	ldr	r1, [r3, #0]
 80014f6:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 80014fa:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
 80014fc:	619a      	str	r2, [r3, #24]
 80014fe:	4770      	bx	lr
 8001500:	40021000 	.word	0x40021000
 8001504:	eaf6f4ff 	.word	0xeaf6f4ff

08001508 <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001508:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800150c:	6803      	ldr	r3, [r0, #0]
 800150e:	06dc      	lsls	r4, r3, #27
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001510:	b083      	sub	sp, #12
 8001512:	4605      	mov	r5, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8001514:	d541      	bpl.n	800159a <HAL_RCC_OscConfig+0x92>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 8001516:	4ebf      	ldr	r6, [pc, #764]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
 8001518:	68b3      	ldr	r3, [r6, #8]
 800151a:	f013 0f0c 	tst.w	r3, #12
 800151e:	f040 817d 	bne.w	800181c <HAL_RCC_OscConfig+0x314>
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001522:	2302      	movs	r3, #2
 8001524:	fa93 f3a3 	rbit	r3, r3
 8001528:	2302      	movs	r3, #2
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800152a:	6832      	ldr	r2, [r6, #0]
 800152c:	fa93 f3a3 	rbit	r3, r3
 8001530:	fab3 f383 	clz	r3, r3
 8001534:	f003 031f 	and.w	r3, r3, #31
 8001538:	fa22 f303 	lsr.w	r3, r2, r3
 800153c:	07d8      	lsls	r0, r3, #31
 800153e:	d503      	bpl.n	8001548 <HAL_RCC_OscConfig+0x40>
 8001540:	69ab      	ldr	r3, [r5, #24]
 8001542:	2b00      	cmp	r3, #0
 8001544:	f000 81fc 	beq.w	8001940 <HAL_RCC_OscConfig+0x438>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8001548:	4bb2      	ldr	r3, [pc, #712]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
 800154a:	6a28      	ldr	r0, [r5, #32]
 800154c:	681a      	ldr	r2, [r3, #0]
 800154e:	0711      	lsls	r1, r2, #28
 8001550:	f100 823b 	bmi.w	80019ca <HAL_RCC_OscConfig+0x4c2>
 8001554:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8001558:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800155c:	091b      	lsrs	r3, r3, #4
 800155e:	4283      	cmp	r3, r0
 8001560:	f080 8239 	bcs.w	80019d6 <HAL_RCC_OscConfig+0x4ce>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8001564:	f7ff ff5a 	bl	800141c <RCC_SetFlashLatencyFromMSIRange>
 8001568:	2800      	cmp	r0, #0
 800156a:	f040 81e9 	bne.w	8001940 <HAL_RCC_OscConfig+0x438>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800156e:	4ba9      	ldr	r3, [pc, #676]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
 8001570:	681a      	ldr	r2, [r3, #0]
 8001572:	f042 0208 	orr.w	r2, r2, #8
 8001576:	601a      	str	r2, [r3, #0]
 8001578:	6819      	ldr	r1, [r3, #0]
 800157a:	6a2a      	ldr	r2, [r5, #32]
 800157c:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8001580:	430a      	orrs	r2, r1
 8001582:	601a      	str	r2, [r3, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8001584:	6859      	ldr	r1, [r3, #4]
 8001586:	69ea      	ldr	r2, [r5, #28]
 8001588:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
 800158c:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
 8001590:	605a      	str	r2, [r3, #4]
            return HAL_ERROR;
          }          
        }

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8001592:	2000      	movs	r0, #0
 8001594:	f7fe ff46 	bl	8000424 <HAL_InitTick>
 8001598:	682b      	ldr	r3, [r5, #0]
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800159a:	07d8      	lsls	r0, r3, #31
 800159c:	d565      	bpl.n	800166a <HAL_RCC_OscConfig+0x162>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
 800159e:	4a9d      	ldr	r2, [pc, #628]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
 80015a0:	6891      	ldr	r1, [r2, #8]
 80015a2:	f001 010c 	and.w	r1, r1, #12
 80015a6:	2908      	cmp	r1, #8
 80015a8:	f000 81b3 	beq.w	8001912 <HAL_RCC_OscConfig+0x40a>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80015ac:	6891      	ldr	r1, [r2, #8]
 80015ae:	f001 010c 	and.w	r1, r1, #12
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
 80015b2:	290c      	cmp	r1, #12
 80015b4:	f000 81a7 	beq.w	8001906 <HAL_RCC_OscConfig+0x3fe>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 80015b8:	4e96      	ldr	r6, [pc, #600]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
 80015ba:	6833      	ldr	r3, [r6, #0]
 80015bc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80015c0:	6033      	str	r3, [r6, #0]
 80015c2:	6833      	ldr	r3, [r6, #0]
 80015c4:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80015c8:	6033      	str	r3, [r6, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80015ca:	f7fe ff59 	bl	8000480 <HAL_GetTick>
 80015ce:	f44f 3400 	mov.w	r4, #131072	; 0x20000
 80015d2:	4680      	mov	r8, r0

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80015d4:	f241 3788 	movw	r7, #5000	; 0x1388

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80015d8:	e006      	b.n	80015e8 <HAL_RCC_OscConfig+0xe0>
      {
        if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80015da:	f7fe ff51 	bl	8000480 <HAL_GetTick>
 80015de:	ebc8 0000 	rsb	r0, r8, r0
 80015e2:	42b8      	cmp	r0, r7
 80015e4:	f200 814d 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 80015e8:	fa94 f3a4 	rbit	r3, r4

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80015ec:	6832      	ldr	r2, [r6, #0]
 80015ee:	fa94 f3a4 	rbit	r3, r4
 80015f2:	fab3 f383 	clz	r3, r3
 80015f6:	f003 031f 	and.w	r3, r3, #31
 80015fa:	fa22 f303 	lsr.w	r3, r2, r3
 80015fe:	07da      	lsls	r2, r3, #31
 8001600:	d4eb      	bmi.n	80015da <HAL_RCC_OscConfig+0xd2>
          return HAL_TIMEOUT;
        }
      }

      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001602:	686b      	ldr	r3, [r5, #4]
 8001604:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001608:	f000 82b4 	beq.w	8001b74 <HAL_RCC_OscConfig+0x66c>
 800160c:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001610:	f000 8341 	beq.w	8001c96 <HAL_RCC_OscConfig+0x78e>
 8001614:	4b7f      	ldr	r3, [pc, #508]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
 8001616:	681a      	ldr	r2, [r3, #0]
 8001618:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800161c:	601a      	str	r2, [r3, #0]
 800161e:	681a      	ldr	r2, [r3, #0]
 8001620:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001624:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001626:	686b      	ldr	r3, [r5, #4]
 8001628:	2b00      	cmp	r3, #0
 800162a:	f000 827a 	beq.w	8001b22 <HAL_RCC_OscConfig+0x61a>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800162e:	f7fe ff27 	bl	8000480 <HAL_GetTick>
 8001632:	f44f 3400 	mov.w	r4, #131072	; 0x20000
 8001636:	4680      	mov	r8, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001638:	4e76      	ldr	r6, [pc, #472]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800163a:	f241 3788 	movw	r7, #5000	; 0x1388
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800163e:	e006      	b.n	800164e <HAL_RCC_OscConfig+0x146>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001640:	f7fe ff1e 	bl	8000480 <HAL_GetTick>
 8001644:	ebc8 0000 	rsb	r0, r8, r0
 8001648:	42b8      	cmp	r0, r7
 800164a:	f200 811a 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 800164e:	fa94 f3a4 	rbit	r3, r4
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001652:	6832      	ldr	r2, [r6, #0]
 8001654:	fa94 f3a4 	rbit	r3, r4
 8001658:	fab3 f383 	clz	r3, r3
 800165c:	f003 031f 	and.w	r3, r3, #31
 8001660:	fa22 f303 	lsr.w	r3, r2, r3
 8001664:	07db      	lsls	r3, r3, #31
 8001666:	d5eb      	bpl.n	8001640 <HAL_RCC_OscConfig+0x138>
 8001668:	682b      	ldr	r3, [r5, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800166a:	0799      	lsls	r1, r3, #30
 800166c:	f100 8093 	bmi.w	8001796 <HAL_RCC_OscConfig+0x28e>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001670:	0719      	lsls	r1, r3, #28
 8001672:	d528      	bpl.n	80016c6 <HAL_RCC_OscConfig+0x1be>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001674:	696b      	ldr	r3, [r5, #20]
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001676:	4e67      	ldr	r6, [pc, #412]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001678:	2b00      	cmp	r3, #0
 800167a:	f000 8182 	beq.w	8001982 <HAL_RCC_OscConfig+0x47a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800167e:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8001682:	f043 0301 	orr.w	r3, r3, #1
 8001686:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800168a:	f7fe fef9 	bl	8000480 <HAL_GetTick>
 800168e:	2402      	movs	r4, #2
 8001690:	4607      	mov	r7, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001692:	e005      	b.n	80016a0 <HAL_RCC_OscConfig+0x198>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001694:	f7fe fef4 	bl	8000480 <HAL_GetTick>
 8001698:	1bc0      	subs	r0, r0, r7
 800169a:	2864      	cmp	r0, #100	; 0x64
 800169c:	f200 80f1 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 80016a0:	fa94 f3a4 	rbit	r3, r4
 80016a4:	fa94 f3a4 	rbit	r3, r4
 80016a8:	fa94 f3a4 	rbit	r3, r4

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80016ac:	f8d6 2094 	ldr.w	r2, [r6, #148]	; 0x94
 80016b0:	fa94 f3a4 	rbit	r3, r4
 80016b4:	fab3 f383 	clz	r3, r3
 80016b8:	f003 031f 	and.w	r3, r3, #31
 80016bc:	fa22 f303 	lsr.w	r3, r2, r3
 80016c0:	07da      	lsls	r2, r3, #31
 80016c2:	d5e7      	bpl.n	8001694 <HAL_RCC_OscConfig+0x18c>
 80016c4:	682b      	ldr	r3, [r5, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80016c6:	075e      	lsls	r6, r3, #29
 80016c8:	f140 80e7 	bpl.w	800189a <HAL_RCC_OscConfig+0x392>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 80016cc:	4b51      	ldr	r3, [pc, #324]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
 80016ce:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80016d0:	00d4      	lsls	r4, r2, #3
 80016d2:	f100 81d6 	bmi.w	8001a82 <HAL_RCC_OscConfig+0x57a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80016d6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80016d8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80016dc:	659a      	str	r2, [r3, #88]	; 0x58
 80016de:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80016e0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80016e4:	9301      	str	r3, [sp, #4]
 80016e6:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80016e8:	f04f 0901 	mov.w	r9, #1
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80016ec:	4c4a      	ldr	r4, [pc, #296]	; (8001818 <HAL_RCC_OscConfig+0x310>)
 80016ee:	6823      	ldr	r3, [r4, #0]
 80016f0:	05d8      	lsls	r0, r3, #23
 80016f2:	d410      	bmi.n	8001716 <HAL_RCC_OscConfig+0x20e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80016f4:	6823      	ldr	r3, [r4, #0]
 80016f6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80016fa:	6023      	str	r3, [r4, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80016fc:	f7fe fec0 	bl	8000480 <HAL_GetTick>
 8001700:	4606      	mov	r6, r0

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001702:	e005      	b.n	8001710 <HAL_RCC_OscConfig+0x208>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001704:	f7fe febc 	bl	8000480 <HAL_GetTick>
 8001708:	1b80      	subs	r0, r0, r6
 800170a:	2864      	cmp	r0, #100	; 0x64
 800170c:	f200 80b9 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001710:	6823      	ldr	r3, [r4, #0]
 8001712:	05d9      	lsls	r1, r3, #23
 8001714:	d5f6      	bpl.n	8001704 <HAL_RCC_OscConfig+0x1fc>
        }
      }
    }

    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8001716:	4e3f      	ldr	r6, [pc, #252]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
 8001718:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 800171c:	f023 0301 	bic.w	r3, r3, #1
 8001720:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
 8001724:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8001728:	f023 0304 	bic.w	r3, r3, #4
 800172c:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001730:	f7fe fea6 	bl	8000480 <HAL_GetTick>
 8001734:	2402      	movs	r4, #2
 8001736:	4680      	mov	r8, r0

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    {
      if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001738:	f241 3788 	movw	r7, #5000	; 0x1388

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800173c:	e01d      	b.n	800177a <HAL_RCC_OscConfig+0x272>
 800173e:	fa94 f3a4 	rbit	r3, r4
 8001742:	fab3 f383 	clz	r3, r3
 8001746:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800174a:	095b      	lsrs	r3, r3, #5
 800174c:	2b03      	cmp	r3, #3
 800174e:	bf0c      	ite	eq
 8001750:	f8d6 2094 	ldreq.w	r2, [r6, #148]	; 0x94
 8001754:	69f2      	ldrne	r2, [r6, #28]
 8001756:	fa94 f3a4 	rbit	r3, r4
 800175a:	fab3 f383 	clz	r3, r3
 800175e:	f003 031f 	and.w	r3, r3, #31
 8001762:	fa22 f303 	lsr.w	r3, r2, r3
 8001766:	07da      	lsls	r2, r3, #31
 8001768:	f140 818e 	bpl.w	8001a88 <HAL_RCC_OscConfig+0x580>
    {
      if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800176c:	f7fe fe88 	bl	8000480 <HAL_GetTick>
 8001770:	ebc8 0000 	rsb	r0, r8, r0
 8001774:	42b8      	cmp	r0, r7
 8001776:	f200 8084 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 800177a:	fa94 f3a4 	rbit	r3, r4
 800177e:	fa94 f3a4 	rbit	r3, r4

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001782:	fab3 f383 	clz	r3, r3
 8001786:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800178a:	095b      	lsrs	r3, r3, #5
 800178c:	2b02      	cmp	r3, #2
 800178e:	d1d6      	bne.n	800173e <HAL_RCC_OscConfig+0x236>
 8001790:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
 8001794:	e7df      	b.n	8001756 <HAL_RCC_OscConfig+0x24e>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 8001796:	4b1f      	ldr	r3, [pc, #124]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
 8001798:	689a      	ldr	r2, [r3, #8]
 800179a:	f002 020c 	and.w	r2, r2, #12
 800179e:	2a04      	cmp	r2, #4
 80017a0:	f000 8138 	beq.w	8001a14 <HAL_RCC_OscConfig+0x50c>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 80017a4:	689a      	ldr	r2, [r3, #8]
 80017a6:	f002 020c 	and.w	r2, r2, #12
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 80017aa:	2a0c      	cmp	r2, #12
 80017ac:	f000 812c 	beq.w	8001a08 <HAL_RCC_OscConfig+0x500>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80017b0:	68eb      	ldr	r3, [r5, #12]
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80017b2:	4e18      	ldr	r6, [pc, #96]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80017b4:	2b00      	cmp	r3, #0
 80017b6:	f000 8145 	beq.w	8001a44 <HAL_RCC_OscConfig+0x53c>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80017ba:	6833      	ldr	r3, [r6, #0]
 80017bc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80017c0:	6033      	str	r3, [r6, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80017c2:	f7fe fe5d 	bl	8000480 <HAL_GetTick>
 80017c6:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80017ca:	4607      	mov	r7, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80017cc:	e004      	b.n	80017d8 <HAL_RCC_OscConfig+0x2d0>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80017ce:	f7fe fe57 	bl	8000480 <HAL_GetTick>
 80017d2:	1bc0      	subs	r0, r0, r7
 80017d4:	2864      	cmp	r0, #100	; 0x64
 80017d6:	d854      	bhi.n	8001882 <HAL_RCC_OscConfig+0x37a>
 80017d8:	fa94 f3a4 	rbit	r3, r4

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80017dc:	6832      	ldr	r2, [r6, #0]
 80017de:	fa94 f3a4 	rbit	r3, r4
 80017e2:	fab3 f383 	clz	r3, r3
 80017e6:	f003 031f 	and.w	r3, r3, #31
 80017ea:	fa22 f303 	lsr.w	r3, r2, r3
 80017ee:	07db      	lsls	r3, r3, #31
 80017f0:	d5ed      	bpl.n	80017ce <HAL_RCC_OscConfig+0x2c6>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80017f2:	4b08      	ldr	r3, [pc, #32]	; (8001814 <HAL_RCC_OscConfig+0x30c>)
 80017f4:	f04f 50f8 	mov.w	r0, #520093696	; 0x1f000000
 80017f8:	6859      	ldr	r1, [r3, #4]
 80017fa:	fa90 f0a0 	rbit	r0, r0
 80017fe:	692a      	ldr	r2, [r5, #16]
 8001800:	fab0 f080 	clz	r0, r0
 8001804:	f021 51f8 	bic.w	r1, r1, #520093696	; 0x1f000000
 8001808:	4082      	lsls	r2, r0
 800180a:	430a      	orrs	r2, r1
 800180c:	605a      	str	r2, [r3, #4]
 800180e:	682b      	ldr	r3, [r5, #0]
 8001810:	e72e      	b.n	8001670 <HAL_RCC_OscConfig+0x168>
 8001812:	bf00      	nop
 8001814:	40021000 	.word	0x40021000
 8001818:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800181c:	6983      	ldr	r3, [r0, #24]
 800181e:	2b00      	cmp	r3, #0
 8001820:	f000 8092 	beq.w	8001948 <HAL_RCC_OscConfig+0x440>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8001824:	6833      	ldr	r3, [r6, #0]
 8001826:	f043 0301 	orr.w	r3, r3, #1
 800182a:	6033      	str	r3, [r6, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 800182c:	f7fe fe28 	bl	8000480 <HAL_GetTick>
 8001830:	2402      	movs	r4, #2
 8001832:	4607      	mov	r7, r0

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8001834:	e004      	b.n	8001840 <HAL_RCC_OscConfig+0x338>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8001836:	f7fe fe23 	bl	8000480 <HAL_GetTick>
 800183a:	1bc0      	subs	r0, r0, r7
 800183c:	2864      	cmp	r0, #100	; 0x64
 800183e:	d820      	bhi.n	8001882 <HAL_RCC_OscConfig+0x37a>
 8001840:	fa94 f3a4 	rbit	r3, r4

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8001844:	6832      	ldr	r2, [r6, #0]
 8001846:	fa94 f3a4 	rbit	r3, r4
 800184a:	fab3 f383 	clz	r3, r3
 800184e:	f003 031f 	and.w	r3, r3, #31
 8001852:	fa22 f303 	lsr.w	r3, r2, r3
 8001856:	07da      	lsls	r2, r3, #31
 8001858:	d5ed      	bpl.n	8001836 <HAL_RCC_OscConfig+0x32e>
          {
            return HAL_TIMEOUT;
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800185a:	4bc5      	ldr	r3, [pc, #788]	; (8001b70 <HAL_RCC_OscConfig+0x668>)
 800185c:	681a      	ldr	r2, [r3, #0]
 800185e:	f042 0208 	orr.w	r2, r2, #8
 8001862:	601a      	str	r2, [r3, #0]
 8001864:	6819      	ldr	r1, [r3, #0]
 8001866:	6a2a      	ldr	r2, [r5, #32]
 8001868:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 800186c:	430a      	orrs	r2, r1
 800186e:	601a      	str	r2, [r3, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8001870:	6859      	ldr	r1, [r3, #4]
 8001872:	69ea      	ldr	r2, [r5, #28]
 8001874:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
 8001878:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
 800187c:	605a      	str	r2, [r3, #4]
 800187e:	682b      	ldr	r3, [r5, #0]
 8001880:	e68b      	b.n	800159a <HAL_RCC_OscConfig+0x92>
        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8001882:	2003      	movs	r0, #3
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8001884:	b003      	add	sp, #12
 8001886:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 800188a:	f1b9 0f00 	cmp.w	r9, #0
 800188e:	d004      	beq.n	800189a <HAL_RCC_OscConfig+0x392>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001890:	4bb7      	ldr	r3, [pc, #732]	; (8001b70 <HAL_RCC_OscConfig+0x668>)
 8001892:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001894:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8001898:	659a      	str	r2, [r3, #88]	; 0x58
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 800189a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800189c:	b37a      	cbz	r2, 80018fe <HAL_RCC_OscConfig+0x3f6>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800189e:	4bb4      	ldr	r3, [pc, #720]	; (8001b70 <HAL_RCC_OscConfig+0x668>)
 80018a0:	6899      	ldr	r1, [r3, #8]
 80018a2:	f001 010c 	and.w	r1, r1, #12
 80018a6:	290c      	cmp	r1, #12
 80018a8:	d04a      	beq.n	8001940 <HAL_RCC_OscConfig+0x438>
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80018aa:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80018ac:	681a      	ldr	r2, [r3, #0]
 80018ae:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80018b2:	601a      	str	r2, [r3, #0]
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80018b4:	f000 819b 	beq.w	8001bee <HAL_RCC_OscConfig+0x6e6>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Disable all PLL outputs to save power */
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 80018b8:	68da      	ldr	r2, [r3, #12]
 80018ba:	f022 0203 	bic.w	r2, r2, #3
 80018be:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 80018c0:	68da      	ldr	r2, [r3, #12]
 80018c2:	f022 7288 	bic.w	r2, r2, #17825792	; 0x1100000
 80018c6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80018ca:	60da      	str	r2, [r3, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80018cc:	461d      	mov	r5, r3
        /* Disable all PLL outputs to save power */
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80018ce:	f7fe fdd7 	bl	8000480 <HAL_GetTick>
 80018d2:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 80018d6:	4606      	mov	r6, r0

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80018d8:	e004      	b.n	80018e4 <HAL_RCC_OscConfig+0x3dc>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80018da:	f7fe fdd1 	bl	8000480 <HAL_GetTick>
 80018de:	1b80      	subs	r0, r0, r6
 80018e0:	2864      	cmp	r0, #100	; 0x64
 80018e2:	d8ce      	bhi.n	8001882 <HAL_RCC_OscConfig+0x37a>
 80018e4:	fa94 f3a4 	rbit	r3, r4

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80018e8:	682a      	ldr	r2, [r5, #0]
 80018ea:	fa94 f3a4 	rbit	r3, r4
 80018ee:	fab3 f383 	clz	r3, r3
 80018f2:	f003 031f 	and.w	r3, r3, #31
 80018f6:	fa22 f303 	lsr.w	r3, r2, r3
 80018fa:	07db      	lsls	r3, r3, #31
 80018fc:	d4ed      	bmi.n	80018da <HAL_RCC_OscConfig+0x3d2>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80018fe:	2000      	movs	r0, #0
}
 8001900:	b003      	add	sp, #12
 8001902:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8001906:	68d2      	ldr	r2, [r2, #12]
 8001908:	f002 0203 	and.w	r2, r2, #3
 800190c:	2a03      	cmp	r2, #3
 800190e:	f47f ae53 	bne.w	80015b8 <HAL_RCC_OscConfig+0xb0>
 8001912:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8001916:	fa92 f2a2 	rbit	r2, r2
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800191a:	4995      	ldr	r1, [pc, #596]	; (8001b70 <HAL_RCC_OscConfig+0x668>)
 800191c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8001920:	6809      	ldr	r1, [r1, #0]
 8001922:	fa92 f2a2 	rbit	r2, r2
 8001926:	fab2 f282 	clz	r2, r2
 800192a:	f002 021f 	and.w	r2, r2, #31
 800192e:	fa21 f202 	lsr.w	r2, r1, r2
 8001932:	07d1      	lsls	r1, r2, #31
 8001934:	f57f ae99 	bpl.w	800166a <HAL_RCC_OscConfig+0x162>
 8001938:	686a      	ldr	r2, [r5, #4]
 800193a:	2a00      	cmp	r2, #0
 800193c:	f47f ae95 	bne.w	800166a <HAL_RCC_OscConfig+0x162>
    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
      {
        return HAL_ERROR;
 8001940:	2001      	movs	r0, #1
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8001942:	b003      	add	sp, #12
 8001944:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8001948:	6833      	ldr	r3, [r6, #0]
 800194a:	f023 0301 	bic.w	r3, r3, #1
 800194e:	6033      	str	r3, [r6, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 8001950:	f7fe fd96 	bl	8000480 <HAL_GetTick>
 8001954:	2402      	movs	r4, #2
 8001956:	4607      	mov	r7, r0

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 8001958:	e004      	b.n	8001964 <HAL_RCC_OscConfig+0x45c>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800195a:	f7fe fd91 	bl	8000480 <HAL_GetTick>
 800195e:	1bc0      	subs	r0, r0, r7
 8001960:	2864      	cmp	r0, #100	; 0x64
 8001962:	d88e      	bhi.n	8001882 <HAL_RCC_OscConfig+0x37a>
 8001964:	fa94 f3a4 	rbit	r3, r4

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 8001968:	6832      	ldr	r2, [r6, #0]
 800196a:	fa94 f3a4 	rbit	r3, r4
 800196e:	fab3 f383 	clz	r3, r3
 8001972:	f003 031f 	and.w	r3, r3, #31
 8001976:	fa22 f303 	lsr.w	r3, r2, r3
 800197a:	07db      	lsls	r3, r3, #31
 800197c:	d4ed      	bmi.n	800195a <HAL_RCC_OscConfig+0x452>
 800197e:	682b      	ldr	r3, [r5, #0]
 8001980:	e60b      	b.n	800159a <HAL_RCC_OscConfig+0x92>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001982:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8001986:	f023 0301 	bic.w	r3, r3, #1
 800198a:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800198e:	f7fe fd77 	bl	8000480 <HAL_GetTick>
 8001992:	2402      	movs	r4, #2
 8001994:	4607      	mov	r7, r0

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001996:	e005      	b.n	80019a4 <HAL_RCC_OscConfig+0x49c>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001998:	f7fe fd72 	bl	8000480 <HAL_GetTick>
 800199c:	1bc0      	subs	r0, r0, r7
 800199e:	2864      	cmp	r0, #100	; 0x64
 80019a0:	f63f af6f 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 80019a4:	fa94 f3a4 	rbit	r3, r4
 80019a8:	fa94 f3a4 	rbit	r3, r4
 80019ac:	fa94 f3a4 	rbit	r3, r4

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80019b0:	f8d6 2094 	ldr.w	r2, [r6, #148]	; 0x94
 80019b4:	fa94 f3a4 	rbit	r3, r4
 80019b8:	fab3 f383 	clz	r3, r3
 80019bc:	f003 031f 	and.w	r3, r3, #31
 80019c0:	fa22 f303 	lsr.w	r3, r2, r3
 80019c4:	07db      	lsls	r3, r3, #31
 80019c6:	d4e7      	bmi.n	8001998 <HAL_RCC_OscConfig+0x490>
 80019c8:	e67c      	b.n	80016c4 <HAL_RCC_OscConfig+0x1bc>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80019ca:	681b      	ldr	r3, [r3, #0]
 80019cc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80019d0:	4283      	cmp	r3, r0
 80019d2:	f4ff adc7 	bcc.w	8001564 <HAL_RCC_OscConfig+0x5c>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80019d6:	4b66      	ldr	r3, [pc, #408]	; (8001b70 <HAL_RCC_OscConfig+0x668>)
 80019d8:	681a      	ldr	r2, [r3, #0]
 80019da:	f042 0208 	orr.w	r2, r2, #8
 80019de:	601a      	str	r2, [r3, #0]
 80019e0:	6819      	ldr	r1, [r3, #0]
 80019e2:	6a2a      	ldr	r2, [r5, #32]
 80019e4:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 80019e8:	430a      	orrs	r2, r1
 80019ea:	601a      	str	r2, [r3, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80019ec:	6859      	ldr	r1, [r3, #4]
 80019ee:	69ea      	ldr	r2, [r5, #28]
 80019f0:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
 80019f4:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
 80019f8:	605a      	str	r2, [r3, #4]

          /* Decrease number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80019fa:	6a28      	ldr	r0, [r5, #32]
 80019fc:	f7ff fd0e 	bl	800141c <RCC_SetFlashLatencyFromMSIRange>
 8001a00:	2800      	cmp	r0, #0
 8001a02:	f43f adc6 	beq.w	8001592 <HAL_RCC_OscConfig+0x8a>
 8001a06:	e79b      	b.n	8001940 <HAL_RCC_OscConfig+0x438>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8001a08:	68db      	ldr	r3, [r3, #12]
 8001a0a:	f003 0303 	and.w	r3, r3, #3
 8001a0e:	2b02      	cmp	r3, #2
 8001a10:	f47f aece 	bne.w	80017b0 <HAL_RCC_OscConfig+0x2a8>
 8001a14:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001a18:	fa93 f3a3 	rbit	r3, r3
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8001a1c:	4a54      	ldr	r2, [pc, #336]	; (8001b70 <HAL_RCC_OscConfig+0x668>)
 8001a1e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001a22:	6812      	ldr	r2, [r2, #0]
 8001a24:	fa93 f3a3 	rbit	r3, r3
 8001a28:	fab3 f383 	clz	r3, r3
 8001a2c:	f003 031f 	and.w	r3, r3, #31
 8001a30:	fa22 f303 	lsr.w	r3, r2, r3
 8001a34:	07da      	lsls	r2, r3, #31
 8001a36:	f57f aedc 	bpl.w	80017f2 <HAL_RCC_OscConfig+0x2ea>
 8001a3a:	68eb      	ldr	r3, [r5, #12]
 8001a3c:	2b00      	cmp	r3, #0
 8001a3e:	f47f aed8 	bne.w	80017f2 <HAL_RCC_OscConfig+0x2ea>
 8001a42:	e77d      	b.n	8001940 <HAL_RCC_OscConfig+0x438>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8001a44:	6833      	ldr	r3, [r6, #0]
 8001a46:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001a4a:	6033      	str	r3, [r6, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001a4c:	f7fe fd18 	bl	8000480 <HAL_GetTick>
 8001a50:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8001a54:	4607      	mov	r7, r0

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001a56:	e005      	b.n	8001a64 <HAL_RCC_OscConfig+0x55c>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001a58:	f7fe fd12 	bl	8000480 <HAL_GetTick>
 8001a5c:	1bc0      	subs	r0, r0, r7
 8001a5e:	2864      	cmp	r0, #100	; 0x64
 8001a60:	f63f af0f 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 8001a64:	fa94 f3a4 	rbit	r3, r4

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001a68:	6832      	ldr	r2, [r6, #0]
 8001a6a:	fa94 f3a4 	rbit	r3, r4
 8001a6e:	fab3 f383 	clz	r3, r3
 8001a72:	f003 031f 	and.w	r3, r3, #31
 8001a76:	fa22 f303 	lsr.w	r3, r2, r3
 8001a7a:	07d8      	lsls	r0, r3, #31
 8001a7c:	d4ec      	bmi.n	8001a58 <HAL_RCC_OscConfig+0x550>
 8001a7e:	682b      	ldr	r3, [r5, #0]
 8001a80:	e5f6      	b.n	8001670 <HAL_RCC_OscConfig+0x168>
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 8001a82:	f04f 0900 	mov.w	r9, #0
 8001a86:	e631      	b.n	80016ec <HAL_RCC_OscConfig+0x1e4>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001a88:	68ab      	ldr	r3, [r5, #8]
 8001a8a:	2b01      	cmp	r3, #1
 8001a8c:	d067      	beq.n	8001b5e <HAL_RCC_OscConfig+0x656>
 8001a8e:	2b00      	cmp	r3, #0
 8001a90:	f040 8112 	bne.w	8001cb8 <HAL_RCC_OscConfig+0x7b0>
 8001a94:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001a98:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8001a9c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001aa0:	f022 0201 	bic.w	r2, r2, #1
 8001aa4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001aa8:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001aac:	f022 0204 	bic.w	r2, r2, #4
 8001ab0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8001ab4:	68ab      	ldr	r3, [r5, #8]
 8001ab6:	2b00      	cmp	r3, #0
 8001ab8:	d065      	beq.n	8001b86 <HAL_RCC_OscConfig+0x67e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001aba:	f7fe fce1 	bl	8000480 <HAL_GetTick>
 8001abe:	2402      	movs	r4, #2
 8001ac0:	4680      	mov	r8, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001ac2:	4e2b      	ldr	r6, [pc, #172]	; (8001b70 <HAL_RCC_OscConfig+0x668>)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001ac4:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001ac8:	e01d      	b.n	8001b06 <HAL_RCC_OscConfig+0x5fe>
 8001aca:	fa94 f3a4 	rbit	r3, r4
 8001ace:	fab3 f383 	clz	r3, r3
 8001ad2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001ad6:	095b      	lsrs	r3, r3, #5
 8001ad8:	2b03      	cmp	r3, #3
 8001ada:	bf0c      	ite	eq
 8001adc:	f8d6 2094 	ldreq.w	r2, [r6, #148]	; 0x94
 8001ae0:	69f2      	ldrne	r2, [r6, #28]
 8001ae2:	fa94 f3a4 	rbit	r3, r4
 8001ae6:	fab3 f383 	clz	r3, r3
 8001aea:	f003 031f 	and.w	r3, r3, #31
 8001aee:	fa22 f303 	lsr.w	r3, r2, r3
 8001af2:	07db      	lsls	r3, r3, #31
 8001af4:	f53f aec9 	bmi.w	800188a <HAL_RCC_OscConfig+0x382>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001af8:	f7fe fcc2 	bl	8000480 <HAL_GetTick>
 8001afc:	ebc8 0000 	rsb	r0, r8, r0
 8001b00:	42b8      	cmp	r0, r7
 8001b02:	f63f aebe 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 8001b06:	fa94 f3a4 	rbit	r3, r4
 8001b0a:	fa94 f3a4 	rbit	r3, r4
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001b0e:	fab3 f383 	clz	r3, r3
 8001b12:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001b16:	095b      	lsrs	r3, r3, #5
 8001b18:	2b02      	cmp	r3, #2
 8001b1a:	d1d6      	bne.n	8001aca <HAL_RCC_OscConfig+0x5c2>
 8001b1c:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
 8001b20:	e7df      	b.n	8001ae2 <HAL_RCC_OscConfig+0x5da>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001b22:	f7fe fcad 	bl	8000480 <HAL_GetTick>
 8001b26:	f44f 3400 	mov.w	r4, #131072	; 0x20000
 8001b2a:	4680      	mov	r8, r0

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001b2c:	4e10      	ldr	r6, [pc, #64]	; (8001b70 <HAL_RCC_OscConfig+0x668>)
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001b2e:	f241 3788 	movw	r7, #5000	; 0x1388
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001b32:	e006      	b.n	8001b42 <HAL_RCC_OscConfig+0x63a>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001b34:	f7fe fca4 	bl	8000480 <HAL_GetTick>
 8001b38:	ebc8 0000 	rsb	r0, r8, r0
 8001b3c:	42b8      	cmp	r0, r7
 8001b3e:	f63f aea0 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 8001b42:	fa94 f3a4 	rbit	r3, r4
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001b46:	6832      	ldr	r2, [r6, #0]
 8001b48:	fa94 f3a4 	rbit	r3, r4
 8001b4c:	fab3 f383 	clz	r3, r3
 8001b50:	f003 031f 	and.w	r3, r3, #31
 8001b54:	fa22 f303 	lsr.w	r3, r2, r3
 8001b58:	07d8      	lsls	r0, r3, #31
 8001b5a:	d4eb      	bmi.n	8001b34 <HAL_RCC_OscConfig+0x62c>
 8001b5c:	e584      	b.n	8001668 <HAL_RCC_OscConfig+0x160>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001b5e:	4b04      	ldr	r3, [pc, #16]	; (8001b70 <HAL_RCC_OscConfig+0x668>)
 8001b60:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001b64:	f042 0201 	orr.w	r2, r2, #1
 8001b68:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001b6c:	e7a2      	b.n	8001ab4 <HAL_RCC_OscConfig+0x5ac>
 8001b6e:	bf00      	nop
 8001b70:	40021000 	.word	0x40021000
          return HAL_TIMEOUT;
        }
      }

      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001b74:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001b78:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
 8001b7c:	681a      	ldr	r2, [r3, #0]
 8001b7e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001b82:	601a      	str	r2, [r3, #0]
 8001b84:	e54f      	b.n	8001626 <HAL_RCC_OscConfig+0x11e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001b86:	f7fe fc7b 	bl	8000480 <HAL_GetTick>
 8001b8a:	2402      	movs	r4, #2
 8001b8c:	4680      	mov	r8, r0

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001b8e:	4e58      	ldr	r6, [pc, #352]	; (8001cf0 <HAL_RCC_OscConfig+0x7e8>)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001b90:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001b94:	e01d      	b.n	8001bd2 <HAL_RCC_OscConfig+0x6ca>
 8001b96:	fa94 f3a4 	rbit	r3, r4
 8001b9a:	fab3 f383 	clz	r3, r3
 8001b9e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001ba2:	095b      	lsrs	r3, r3, #5
 8001ba4:	2b03      	cmp	r3, #3
 8001ba6:	bf0c      	ite	eq
 8001ba8:	f8d6 2094 	ldreq.w	r2, [r6, #148]	; 0x94
 8001bac:	69f2      	ldrne	r2, [r6, #28]
 8001bae:	fa94 f3a4 	rbit	r3, r4
 8001bb2:	fab3 f383 	clz	r3, r3
 8001bb6:	f003 031f 	and.w	r3, r3, #31
 8001bba:	fa22 f303 	lsr.w	r3, r2, r3
 8001bbe:	07d8      	lsls	r0, r3, #31
 8001bc0:	f57f ae63 	bpl.w	800188a <HAL_RCC_OscConfig+0x382>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001bc4:	f7fe fc5c 	bl	8000480 <HAL_GetTick>
 8001bc8:	ebc8 0000 	rsb	r0, r8, r0
 8001bcc:	42b8      	cmp	r0, r7
 8001bce:	f63f ae58 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 8001bd2:	fa94 f3a4 	rbit	r3, r4
 8001bd6:	fa94 f3a4 	rbit	r3, r4
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001bda:	fab3 f383 	clz	r3, r3
 8001bde:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001be2:	095b      	lsrs	r3, r3, #5
 8001be4:	2b02      	cmp	r3, #2
 8001be6:	d1d6      	bne.n	8001b96 <HAL_RCC_OscConfig+0x68e>
 8001be8:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
 8001bec:	e7df      	b.n	8001bae <HAL_RCC_OscConfig+0x6a6>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001bee:	461e      	mov	r6, r3

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001bf0:	f7fe fc46 	bl	8000480 <HAL_GetTick>
 8001bf4:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 8001bf8:	4607      	mov	r7, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001bfa:	e005      	b.n	8001c08 <HAL_RCC_OscConfig+0x700>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001bfc:	f7fe fc40 	bl	8000480 <HAL_GetTick>
 8001c00:	1bc0      	subs	r0, r0, r7
 8001c02:	2864      	cmp	r0, #100	; 0x64
 8001c04:	f63f ae3d 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 8001c08:	fa94 f3a4 	rbit	r3, r4

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001c0c:	6831      	ldr	r1, [r6, #0]
 8001c0e:	fa94 f2a4 	rbit	r2, r4
 8001c12:	fab2 f282 	clz	r2, r2
 8001c16:	f002 021f 	and.w	r2, r2, #31
 8001c1a:	fa21 f202 	lsr.w	r2, r1, r2
 8001c1e:	07d1      	lsls	r1, r2, #31
 8001c20:	d4ec      	bmi.n	8001bfc <HAL_RCC_OscConfig+0x6f4>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001c22:	f105 0328 	add.w	r3, r5, #40	; 0x28
 8001c26:	cb58      	ldmia	r3, {r3, r4, r6}
 8001c28:	f105 0034 	add.w	r0, r5, #52	; 0x34
 8001c2c:	c807      	ldmia	r0, {r0, r1, r2}
 8001c2e:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 8001c32:	3c01      	subs	r4, #1
 8001c34:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8001c38:	0900      	lsrs	r0, r0, #4
 8001c3a:	0849      	lsrs	r1, r1, #1
 8001c3c:	ea43 4340 	orr.w	r3, r3, r0, lsl #17
 8001c40:	3901      	subs	r1, #1
 8001c42:	0852      	lsrs	r2, r2, #1
 8001c44:	4d2a      	ldr	r5, [pc, #168]	; (8001cf0 <HAL_RCC_OscConfig+0x7e8>)
 8001c46:	ea43 5341 	orr.w	r3, r3, r1, lsl #21
 8001c4a:	3a01      	subs	r2, #1
 8001c4c:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8001c50:	60eb      	str	r3, [r5, #12]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8001c52:	682b      	ldr	r3, [r5, #0]
 8001c54:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001c58:	602b      	str	r3, [r5, #0]

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8001c5a:	68eb      	ldr	r3, [r5, #12]
 8001c5c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001c60:	60eb      	str	r3, [r5, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001c62:	f7fe fc0d 	bl	8000480 <HAL_GetTick>
 8001c66:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 8001c6a:	4606      	mov	r6, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001c6c:	e005      	b.n	8001c7a <HAL_RCC_OscConfig+0x772>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001c6e:	f7fe fc07 	bl	8000480 <HAL_GetTick>
 8001c72:	1b80      	subs	r0, r0, r6
 8001c74:	2864      	cmp	r0, #100	; 0x64
 8001c76:	f63f ae04 	bhi.w	8001882 <HAL_RCC_OscConfig+0x37a>
 8001c7a:	fa94 f3a4 	rbit	r3, r4

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001c7e:	682a      	ldr	r2, [r5, #0]
 8001c80:	fa94 f3a4 	rbit	r3, r4
 8001c84:	fab3 f383 	clz	r3, r3
 8001c88:	f003 031f 	and.w	r3, r3, #31
 8001c8c:	fa22 f303 	lsr.w	r3, r2, r3
 8001c90:	07da      	lsls	r2, r3, #31
 8001c92:	d5ec      	bpl.n	8001c6e <HAL_RCC_OscConfig+0x766>
 8001c94:	e633      	b.n	80018fe <HAL_RCC_OscConfig+0x3f6>
          return HAL_TIMEOUT;
        }
      }

      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001c96:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001c9a:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8001c9e:	681a      	ldr	r2, [r3, #0]
 8001ca0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001ca4:	601a      	str	r2, [r3, #0]
 8001ca6:	681a      	ldr	r2, [r3, #0]
 8001ca8:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8001cac:	601a      	str	r2, [r3, #0]
 8001cae:	681a      	ldr	r2, [r3, #0]
 8001cb0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001cb4:	601a      	str	r2, [r3, #0]
 8001cb6:	e4b6      	b.n	8001626 <HAL_RCC_OscConfig+0x11e>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001cb8:	2b05      	cmp	r3, #5
 8001cba:	4b0d      	ldr	r3, [pc, #52]	; (8001cf0 <HAL_RCC_OscConfig+0x7e8>)
 8001cbc:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001cc0:	f022 0201 	bic.w	r2, r2, #1
 8001cc4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001cc8:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001ccc:	d004      	beq.n	8001cd8 <HAL_RCC_OscConfig+0x7d0>
 8001cce:	f022 0204 	bic.w	r2, r2, #4
 8001cd2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001cd6:	e6ed      	b.n	8001ab4 <HAL_RCC_OscConfig+0x5ac>
 8001cd8:	f042 0204 	orr.w	r2, r2, #4
 8001cdc:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001ce0:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8001ce4:	f042 0201 	orr.w	r2, r2, #1
 8001ce8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8001cec:	e6e2      	b.n	8001ab4 <HAL_RCC_OscConfig+0x5ac>
 8001cee:	bf00      	nop
 8001cf0:	40021000 	.word	0x40021000

08001cf4 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001cf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001cf8:	4ba4      	ldr	r3, [pc, #656]	; (8001f8c <HAL_RCC_ClockConfig+0x298>)
 8001cfa:	681a      	ldr	r2, [r3, #0]
 8001cfc:	f002 0207 	and.w	r2, r2, #7
 8001d00:	428a      	cmp	r2, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001d02:	460c      	mov	r4, r1
 8001d04:	4605      	mov	r5, r0
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001d06:	d20f      	bcs.n	8001d28 <HAL_RCC_ClockConfig+0x34>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001d08:	681a      	ldr	r2, [r3, #0]
 8001d0a:	4ba0      	ldr	r3, [pc, #640]	; (8001f8c <HAL_RCC_ClockConfig+0x298>)
 8001d0c:	2904      	cmp	r1, #4
 8001d0e:	bf9c      	itt	ls
 8001d10:	f022 0207 	bicls.w	r2, r2, #7
 8001d14:	430a      	orrls	r2, r1
 8001d16:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001d18:	681b      	ldr	r3, [r3, #0]
 8001d1a:	f003 0307 	and.w	r3, r3, #7
 8001d1e:	428b      	cmp	r3, r1
 8001d20:	d06b      	beq.n	8001dfa <HAL_RCC_ClockConfig+0x106>
    {
      return HAL_ERROR;
 8001d22:	2001      	movs	r0, #1
 8001d24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001d28:	6803      	ldr	r3, [r0, #0]
 8001d2a:	079e      	lsls	r6, r3, #30
 8001d2c:	d507      	bpl.n	8001d3e <HAL_RCC_ClockConfig+0x4a>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001d2e:	4b98      	ldr	r3, [pc, #608]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001d30:	6882      	ldr	r2, [r0, #8]
 8001d32:	6899      	ldr	r1, [r3, #8]
 8001d34:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8001d38:	430a      	orrs	r2, r1
 8001d3a:	609a      	str	r2, [r3, #8]
 8001d3c:	6803      	ldr	r3, [r0, #0]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001d3e:	07d8      	lsls	r0, r3, #31
 8001d40:	d535      	bpl.n	8001dae <HAL_RCC_ClockConfig+0xba>
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001d42:	686b      	ldr	r3, [r5, #4]
 8001d44:	2b02      	cmp	r3, #2
 8001d46:	f000 80a3 	beq.w	8001e90 <HAL_RCC_ClockConfig+0x19c>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001d4a:	2b00      	cmp	r3, #0
 8001d4c:	f040 80a8 	bne.w	8001ea0 <HAL_RCC_ClockConfig+0x1ac>
 8001d50:	2202      	movs	r2, #2
 8001d52:	fa92 f2a2 	rbit	r2, r2
      {
        /* Check the MSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8001d56:	498e      	ldr	r1, [pc, #568]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001d58:	2202      	movs	r2, #2
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001d5a:	6809      	ldr	r1, [r1, #0]
 8001d5c:	fa92 f2a2 	rbit	r2, r2
 8001d60:	fab2 f282 	clz	r2, r2
 8001d64:	f002 021f 	and.w	r2, r2, #31
 8001d68:	fa21 f202 	lsr.w	r2, r1, r2
 8001d6c:	07d1      	lsls	r1, r2, #31
 8001d6e:	d5d8      	bpl.n	8001d22 <HAL_RCC_ClockConfig+0x2e>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8001d70:	4f87      	ldr	r7, [pc, #540]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001d72:	68ba      	ldr	r2, [r7, #8]
 8001d74:	f022 0203 	bic.w	r2, r2, #3
 8001d78:	4313      	orrs	r3, r2
 8001d7a:	60bb      	str	r3, [r7, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d7c:	f7fe fb80 	bl	8000480 <HAL_GetTick>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001d80:	686b      	ldr	r3, [r5, #4]
 8001d82:	2b02      	cmp	r3, #2
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d84:	4606      	mov	r6, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001d86:	f000 80cd 	beq.w	8001f24 <HAL_RCC_ClockConfig+0x230>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001d8a:	2b03      	cmp	r3, #3
 8001d8c:	f000 80d8 	beq.w	8001f40 <HAL_RCC_ClockConfig+0x24c>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001d90:	2b00      	cmp	r3, #0
 8001d92:	f040 80b1 	bne.w	8001ef8 <HAL_RCC_ClockConfig+0x204>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
        {
          if((HAL_GetTick() - tickstart) >= CLOCKSWITCH_TIMEOUT_VALUE)
 8001d96:	f241 3887 	movw	r8, #4999	; 0x1387
 8001d9a:	e004      	b.n	8001da6 <HAL_RCC_ClockConfig+0xb2>
 8001d9c:	f7fe fb70 	bl	8000480 <HAL_GetTick>
 8001da0:	1b80      	subs	r0, r0, r6
 8001da2:	4540      	cmp	r0, r8
 8001da4:	d86b      	bhi.n	8001e7e <HAL_RCC_ClockConfig+0x18a>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 8001da6:	68bb      	ldr	r3, [r7, #8]
 8001da8:	f013 0f0c 	tst.w	r3, #12
 8001dac:	d1f6      	bne.n	8001d9c <HAL_RCC_ClockConfig+0xa8>
        }
      }
    }

    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001dae:	2c04      	cmp	r4, #4
 8001db0:	d968      	bls.n	8001e84 <HAL_RCC_ClockConfig+0x190>
 8001db2:	4b76      	ldr	r3, [pc, #472]	; (8001f8c <HAL_RCC_ClockConfig+0x298>)
 8001db4:	681a      	ldr	r2, [r3, #0]
 8001db6:	4b75      	ldr	r3, [pc, #468]	; (8001f8c <HAL_RCC_ClockConfig+0x298>)
 8001db8:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001dba:	681b      	ldr	r3, [r3, #0]
 8001dbc:	f003 0307 	and.w	r3, r3, #7
 8001dc0:	42a3      	cmp	r3, r4
 8001dc2:	d1ae      	bne.n	8001d22 <HAL_RCC_ClockConfig+0x2e>
 8001dc4:	682b      	ldr	r3, [r5, #0]
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001dc6:	075a      	lsls	r2, r3, #29
 8001dc8:	d507      	bpl.n	8001dda <HAL_RCC_ClockConfig+0xe6>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001dca:	4b71      	ldr	r3, [pc, #452]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001dcc:	68ea      	ldr	r2, [r5, #12]
 8001dce:	6899      	ldr	r1, [r3, #8]
 8001dd0:	f421 61e0 	bic.w	r1, r1, #1792	; 0x700
 8001dd4:	430a      	orrs	r2, r1
 8001dd6:	609a      	str	r2, [r3, #8]
 8001dd8:	682b      	ldr	r3, [r5, #0]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001dda:	071b      	lsls	r3, r3, #28
 8001ddc:	d507      	bpl.n	8001dee <HAL_RCC_ClockConfig+0xfa>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001dde:	4b6c      	ldr	r3, [pc, #432]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001de0:	6929      	ldr	r1, [r5, #16]
 8001de2:	689a      	ldr	r2, [r3, #8]
 8001de4:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
 8001de8:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 8001dec:	609a      	str	r2, [r3, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8001dee:	2000      	movs	r0, #0
 8001df0:	f7fe fb18 	bl	8000424 <HAL_InitTick>

  return HAL_OK;
 8001df4:	2000      	movs	r0, #0
}
 8001df6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    {
      return HAL_ERROR;
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001dfa:	6803      	ldr	r3, [r0, #0]
 8001dfc:	0799      	lsls	r1, r3, #30
 8001dfe:	d507      	bpl.n	8001e10 <HAL_RCC_ClockConfig+0x11c>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001e00:	4b63      	ldr	r3, [pc, #396]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001e02:	6882      	ldr	r2, [r0, #8]
 8001e04:	6899      	ldr	r1, [r3, #8]
 8001e06:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8001e0a:	430a      	orrs	r2, r1
 8001e0c:	609a      	str	r2, [r3, #8]
 8001e0e:	6803      	ldr	r3, [r0, #0]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001e10:	07da      	lsls	r2, r3, #31
 8001e12:	d5d8      	bpl.n	8001dc6 <HAL_RCC_ClockConfig+0xd2>
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001e14:	686b      	ldr	r3, [r5, #4]
 8001e16:	2b02      	cmp	r3, #2
 8001e18:	f000 80a0 	beq.w	8001f5c <HAL_RCC_ClockConfig+0x268>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001e1c:	2b03      	cmp	r3, #3
 8001e1e:	d079      	beq.n	8001f14 <HAL_RCC_ClockConfig+0x220>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001e20:	2b00      	cmp	r3, #0
 8001e22:	f040 80ab 	bne.w	8001f7c <HAL_RCC_ClockConfig+0x288>
 8001e26:	2202      	movs	r2, #2
 8001e28:	fa92 f2a2 	rbit	r2, r2
      {
        /* Check the MSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8001e2c:	4958      	ldr	r1, [pc, #352]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001e2e:	2202      	movs	r2, #2
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001e30:	6809      	ldr	r1, [r1, #0]
 8001e32:	fa92 f2a2 	rbit	r2, r2
 8001e36:	fab2 f282 	clz	r2, r2
 8001e3a:	f002 021f 	and.w	r2, r2, #31
 8001e3e:	fa21 f202 	lsr.w	r2, r1, r2
 8001e42:	07d7      	lsls	r7, r2, #31
 8001e44:	f57f af6d 	bpl.w	8001d22 <HAL_RCC_ClockConfig+0x2e>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8001e48:	4e51      	ldr	r6, [pc, #324]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001e4a:	68b2      	ldr	r2, [r6, #8]
 8001e4c:	f022 0203 	bic.w	r2, r2, #3
 8001e50:	4313      	orrs	r3, r2
 8001e52:	60b3      	str	r3, [r6, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001e54:	f7fe fb14 	bl	8000480 <HAL_GetTick>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001e58:	686b      	ldr	r3, [r5, #4]
 8001e5a:	2b02      	cmp	r3, #2
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001e5c:	4604      	mov	r4, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001e5e:	f241 3788 	movw	r7, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001e62:	d027      	beq.n	8001eb4 <HAL_RCC_ClockConfig+0x1c0>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001e64:	2b03      	cmp	r3, #3
 8001e66:	d03b      	beq.n	8001ee0 <HAL_RCC_ClockConfig+0x1ec>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001e68:	b37b      	cbz	r3, 8001eca <HAL_RCC_ClockConfig+0x1d6>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 8001e6a:	68b3      	ldr	r3, [r6, #8]
 8001e6c:	f003 030c 	and.w	r3, r3, #12
 8001e70:	2b04      	cmp	r3, #4
 8001e72:	d0a7      	beq.n	8001dc4 <HAL_RCC_ClockConfig+0xd0>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001e74:	f7fe fb04 	bl	8000480 <HAL_GetTick>
 8001e78:	1b00      	subs	r0, r0, r4
 8001e7a:	42b8      	cmp	r0, r7
 8001e7c:	d9f5      	bls.n	8001e6a <HAL_RCC_ClockConfig+0x176>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8001e7e:	2003      	movs	r0, #3
 8001e80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }

    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001e84:	4b41      	ldr	r3, [pc, #260]	; (8001f8c <HAL_RCC_ClockConfig+0x298>)
 8001e86:	681a      	ldr	r2, [r3, #0]
 8001e88:	f022 0207 	bic.w	r2, r2, #7
 8001e8c:	4322      	orrs	r2, r4
 8001e8e:	e792      	b.n	8001db6 <HAL_RCC_ClockConfig+0xc2>
 8001e90:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8001e94:	fa92 f2a2 	rbit	r2, r2

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        /* Check the HSE ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001e98:	493d      	ldr	r1, [pc, #244]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001e9a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8001e9e:	e75c      	b.n	8001d5a <HAL_RCC_ClockConfig+0x66>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001ea0:	2b03      	cmp	r3, #3
 8001ea2:	d063      	beq.n	8001f6c <HAL_RCC_ClockConfig+0x278>
 8001ea4:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001ea8:	fa92 f2a2 	rbit	r2, r2
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001eac:	4938      	ldr	r1, [pc, #224]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001eae:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001eb2:	e752      	b.n	8001d5a <HAL_RCC_ClockConfig+0x66>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8001eb4:	68b3      	ldr	r3, [r6, #8]
 8001eb6:	f003 030c 	and.w	r3, r3, #12
 8001eba:	2b08      	cmp	r3, #8
 8001ebc:	d082      	beq.n	8001dc4 <HAL_RCC_ClockConfig+0xd0>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001ebe:	f7fe fadf 	bl	8000480 <HAL_GetTick>
 8001ec2:	1b00      	subs	r0, r0, r4
 8001ec4:	42b8      	cmp	r0, r7
 8001ec6:	d9f5      	bls.n	8001eb4 <HAL_RCC_ClockConfig+0x1c0>
 8001ec8:	e7d9      	b.n	8001e7e <HAL_RCC_ClockConfig+0x18a>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 8001eca:	68b3      	ldr	r3, [r6, #8]
 8001ecc:	f013 0f0c 	tst.w	r3, #12
 8001ed0:	f43f af78 	beq.w	8001dc4 <HAL_RCC_ClockConfig+0xd0>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001ed4:	f7fe fad4 	bl	8000480 <HAL_GetTick>
 8001ed8:	1b00      	subs	r0, r0, r4
 8001eda:	42b8      	cmp	r0, r7
 8001edc:	d9f5      	bls.n	8001eca <HAL_RCC_ClockConfig+0x1d6>
 8001ede:	e7ce      	b.n	8001e7e <HAL_RCC_ClockConfig+0x18a>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001ee0:	68b3      	ldr	r3, [r6, #8]
 8001ee2:	f003 030c 	and.w	r3, r3, #12
 8001ee6:	2b0c      	cmp	r3, #12
 8001ee8:	f43f af6c 	beq.w	8001dc4 <HAL_RCC_ClockConfig+0xd0>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001eec:	f7fe fac8 	bl	8000480 <HAL_GetTick>
 8001ef0:	1b00      	subs	r0, r0, r4
 8001ef2:	42b8      	cmp	r0, r7
 8001ef4:	d9f4      	bls.n	8001ee0 <HAL_RCC_ClockConfig+0x1ec>
 8001ef6:	e7c2      	b.n	8001e7e <HAL_RCC_ClockConfig+0x18a>
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001ef8:	f241 3888 	movw	r8, #5000	; 0x1388
 8001efc:	e004      	b.n	8001f08 <HAL_RCC_ClockConfig+0x214>
 8001efe:	f7fe fabf 	bl	8000480 <HAL_GetTick>
 8001f02:	1b80      	subs	r0, r0, r6
 8001f04:	4540      	cmp	r0, r8
 8001f06:	d8ba      	bhi.n	8001e7e <HAL_RCC_ClockConfig+0x18a>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 8001f08:	68bb      	ldr	r3, [r7, #8]
 8001f0a:	f003 030c 	and.w	r3, r3, #12
 8001f0e:	2b04      	cmp	r3, #4
 8001f10:	d1f5      	bne.n	8001efe <HAL_RCC_ClockConfig+0x20a>
 8001f12:	e74c      	b.n	8001dae <HAL_RCC_ClockConfig+0xba>
 8001f14:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8001f18:	fa92 f2a2 	rbit	r2, r2
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001f1c:	491c      	ldr	r1, [pc, #112]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001f1e:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8001f22:	e785      	b.n	8001e30 <HAL_RCC_ClockConfig+0x13c>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001f24:	f241 3888 	movw	r8, #5000	; 0x1388
 8001f28:	e004      	b.n	8001f34 <HAL_RCC_ClockConfig+0x240>
 8001f2a:	f7fe faa9 	bl	8000480 <HAL_GetTick>
 8001f2e:	1b80      	subs	r0, r0, r6
 8001f30:	4540      	cmp	r0, r8
 8001f32:	d8a4      	bhi.n	8001e7e <HAL_RCC_ClockConfig+0x18a>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8001f34:	68bb      	ldr	r3, [r7, #8]
 8001f36:	f003 030c 	and.w	r3, r3, #12
 8001f3a:	2b08      	cmp	r3, #8
 8001f3c:	d1f5      	bne.n	8001f2a <HAL_RCC_ClockConfig+0x236>
 8001f3e:	e736      	b.n	8001dae <HAL_RCC_ClockConfig+0xba>
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001f40:	f241 3888 	movw	r8, #5000	; 0x1388
 8001f44:	e004      	b.n	8001f50 <HAL_RCC_ClockConfig+0x25c>
 8001f46:	f7fe fa9b 	bl	8000480 <HAL_GetTick>
 8001f4a:	1b80      	subs	r0, r0, r6
 8001f4c:	4540      	cmp	r0, r8
 8001f4e:	d896      	bhi.n	8001e7e <HAL_RCC_ClockConfig+0x18a>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001f50:	68bb      	ldr	r3, [r7, #8]
 8001f52:	f003 030c 	and.w	r3, r3, #12
 8001f56:	2b0c      	cmp	r3, #12
 8001f58:	d1f5      	bne.n	8001f46 <HAL_RCC_ClockConfig+0x252>
 8001f5a:	e728      	b.n	8001dae <HAL_RCC_ClockConfig+0xba>
 8001f5c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8001f60:	fa92 f2a2 	rbit	r2, r2

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        /* Check the HSE ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001f64:	490a      	ldr	r1, [pc, #40]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001f66:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8001f6a:	e761      	b.n	8001e30 <HAL_RCC_ClockConfig+0x13c>
 8001f6c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8001f70:	fa92 f2a2 	rbit	r2, r2
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001f74:	4906      	ldr	r1, [pc, #24]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001f76:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8001f7a:	e6ee      	b.n	8001d5a <HAL_RCC_ClockConfig+0x66>
 8001f7c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001f80:	fa92 f2a2 	rbit	r2, r2
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001f84:	4902      	ldr	r1, [pc, #8]	; (8001f90 <HAL_RCC_ClockConfig+0x29c>)
 8001f86:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001f8a:	e751      	b.n	8001e30 <HAL_RCC_ClockConfig+0x13c>
 8001f8c:	40022000 	.word	0x40022000
 8001f90:	40021000 	.word	0x40021000

08001f94 <HAL_RCC_MCOConfig>:
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8001f94:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 8001f96:	4c12      	ldr	r4, [pc, #72]	; (8001fe0 <HAL_RCC_MCOConfig+0x4c>)
 8001f98:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001f9a:	f043 0301 	orr.w	r3, r3, #1
 8001f9e:	64e3      	str	r3, [r4, #76]	; 0x4c
 8001fa0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8001fa2:	b087      	sub	sp, #28
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 8001fa4:	f003 0301 	and.w	r3, r3, #1
 8001fa8:	9300      	str	r3, [sp, #0]

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
 8001faa:	f44f 7e80 	mov.w	lr, #256	; 0x100
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001fae:	2300      	movs	r3, #0
  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001fb0:	2502      	movs	r5, #2
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8001fb2:	460e      	mov	r6, r1
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8001fb4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001fb8:	a901      	add	r1, sp, #4

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001fba:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8001fbc:	9305      	str	r3, [sp, #20]
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8001fbe:	4617      	mov	r7, r2

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
 8001fc0:	f8cd e004 	str.w	lr, [sp, #4]
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 8001fc4:	9a00      	ldr	r2, [sp, #0]

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001fc6:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8001fc8:	9504      	str	r5, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8001fca:	f7fe fc5d 	bl	8000888 <HAL_GPIO_Init>

  /* Mask MCOSEL[] and MCOPRE[] bits then set MCO1 clock source and prescaler */
  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCO_PRE), (RCC_MCOSource | RCC_MCODiv ));
 8001fce:	68a3      	ldr	r3, [r4, #8]
 8001fd0:	f023 43ee 	bic.w	r3, r3, #1996488704	; 0x77000000
 8001fd4:	431f      	orrs	r7, r3
 8001fd6:	433e      	orrs	r6, r7
 8001fd8:	60a6      	str	r6, [r4, #8]
}
 8001fda:	b007      	add	sp, #28
 8001fdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001fde:	bf00      	nop
 8001fe0:	40021000 	.word	0x40021000

08001fe4 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8001fe4:	b410      	push	{r4}
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
  uint32_t sysclockfreq = 0;

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8001fe6:	4b3b      	ldr	r3, [pc, #236]	; (80020d4 <HAL_RCC_GetSysClockFreq+0xf0>)
 8001fe8:	689a      	ldr	r2, [r3, #8]
 8001fea:	f002 020c 	and.w	r2, r2, #12
 8001fee:	2a04      	cmp	r2, #4
 8001ff0:	d052      	beq.n	8002098 <HAL_RCC_GetSysClockFreq+0xb4>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8001ff2:	689a      	ldr	r2, [r3, #8]
 8001ff4:	f002 020c 	and.w	r2, r2, #12
 8001ff8:	2a08      	cmp	r2, #8
 8001ffa:	d050      	beq.n	800209e <HAL_RCC_GetSysClockFreq+0xba>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8001ffc:	689a      	ldr	r2, [r3, #8]
 8001ffe:	f012 0f0c 	tst.w	r2, #12
 8002002:	d11e      	bne.n	8002042 <HAL_RCC_GetSysClockFreq+0x5e>
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 8002004:	4b33      	ldr	r3, [pc, #204]	; (80020d4 <HAL_RCC_GetSysClockFreq+0xf0>)
 8002006:	681a      	ldr	r2, [r3, #0]
 8002008:	0712      	lsls	r2, r2, #28
    { /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 800200a:	bf54      	ite	pl
 800200c:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 8002010:	6819      	ldrmi	r1, [r3, #0]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 8002012:	4b30      	ldr	r3, [pc, #192]	; (80020d4 <HAL_RCC_GetSysClockFreq+0xf0>)
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8002014:	4a30      	ldr	r2, [pc, #192]	; (80020d8 <HAL_RCC_GetSysClockFreq+0xf4>)

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 8002016:	689b      	ldr	r3, [r3, #8]
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
    { /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 8002018:	bf54      	ite	pl
 800201a:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 800201e:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
  uint32_t sysclockfreq = 0;
 8002022:	f013 0f0c 	tst.w	r3, #12
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8002026:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
  uint32_t sysclockfreq = 0;
 800202a:	bf0c      	ite	eq
 800202c:	4608      	moveq	r0, r1
 800202e:	2000      	movne	r0, #0
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8002030:	4b28      	ldr	r3, [pc, #160]	; (80020d4 <HAL_RCC_GetSysClockFreq+0xf0>)
 8002032:	689a      	ldr	r2, [r3, #8]
 8002034:	f002 020c 	and.w	r2, r2, #12
 8002038:	2a0c      	cmp	r2, #12
 800203a:	d00f      	beq.n	800205c <HAL_RCC_GetSysClockFreq+0x78>
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>25) + 1 ) *2;
    sysclockfreq = pllvco/pllr;
  }

  return sysclockfreq;
}
 800203c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002040:	4770      	bx	lr
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8002042:	689a      	ldr	r2, [r3, #8]
 8002044:	f002 020c 	and.w	r2, r2, #12
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8002048:	2a0c      	cmp	r2, #12
 800204a:	d034      	beq.n	80020b6 <HAL_RCC_GetSysClockFreq+0xd2>
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 800204c:	4b21      	ldr	r3, [pc, #132]	; (80020d4 <HAL_RCC_GetSysClockFreq+0xf0>)
 800204e:	689a      	ldr	r2, [r3, #8]
 8002050:	f002 020c 	and.w	r2, r2, #12
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
  uint32_t sysclockfreq = 0;
 8002054:	2000      	movs	r0, #0
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8002056:	2a0c      	cmp	r2, #12
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
 8002058:	4601      	mov	r1, r0
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 800205a:	d1ef      	bne.n	800203c <HAL_RCC_GetSysClockFreq+0x58>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 800205c:	68da      	ldr	r2, [r3, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
 800205e:	68dc      	ldr	r4, [r3, #12]
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8002060:	f002 0203 	and.w	r2, r2, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
 8002064:	f3c4 1402 	ubfx	r4, r4, #4, #3

    switch (pllsource)
 8002068:	2a02      	cmp	r2, #2

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
 800206a:	f104 0401 	add.w	r4, r4, #1

    switch (pllsource)
 800206e:	d028      	beq.n	80020c2 <HAL_RCC_GetSysClockFreq+0xde>
 8002070:	2a03      	cmp	r2, #3
 8002072:	d017      	beq.n	80020a4 <HAL_RCC_GetSysClockFreq+0xc0>
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
      break;

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 8002074:	68d8      	ldr	r0, [r3, #12]
 8002076:	fbb1 f1f4 	udiv	r1, r1, r4
 800207a:	f3c0 2006 	ubfx	r0, r0, #8, #7
 800207e:	fb00 f001 	mul.w	r0, r0, r1
      break;
    }
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>25) + 1 ) *2;
 8002082:	4b14      	ldr	r3, [pc, #80]	; (80020d4 <HAL_RCC_GetSysClockFreq+0xf0>)
    sysclockfreq = pllvco/pllr;
  }

  return sysclockfreq;
}
 8002084:	f85d 4b04 	ldr.w	r4, [sp], #4
    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
      break;
    }
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>25) + 1 ) *2;
 8002088:	68db      	ldr	r3, [r3, #12]
 800208a:	f3c3 6341 	ubfx	r3, r3, #25, #2
 800208e:	3301      	adds	r3, #1
 8002090:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 8002092:	fbb0 f0f3 	udiv	r0, r0, r3
  }

  return sysclockfreq;
}
 8002096:	4770      	bx	lr
  uint32_t sysclockfreq = 0;

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8002098:	4810      	ldr	r0, [pc, #64]	; (80020dc <HAL_RCC_GetSysClockFreq+0xf8>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
 800209a:	2100      	movs	r1, #0
 800209c:	e7c8      	b.n	8002030 <HAL_RCC_GetSysClockFreq+0x4c>
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 800209e:	4810      	ldr	r0, [pc, #64]	; (80020e0 <HAL_RCC_GetSysClockFreq+0xfc>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
 80020a0:	2100      	movs	r1, #0
 80020a2:	e7c5      	b.n	8002030 <HAL_RCC_GetSysClockFreq+0x4c>
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80020a4:	68d8      	ldr	r0, [r3, #12]
 80020a6:	4b0e      	ldr	r3, [pc, #56]	; (80020e0 <HAL_RCC_GetSysClockFreq+0xfc>)
 80020a8:	f3c0 2006 	ubfx	r0, r0, #8, #7
 80020ac:	fbb3 f4f4 	udiv	r4, r3, r4
 80020b0:	fb00 f004 	mul.w	r0, r0, r4
      break;
 80020b4:	e7e5      	b.n	8002082 <HAL_RCC_GetSysClockFreq+0x9e>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 80020b6:	68db      	ldr	r3, [r3, #12]
 80020b8:	f003 0303 	and.w	r3, r3, #3
 80020bc:	2b01      	cmp	r3, #1
 80020be:	d1c5      	bne.n	800204c <HAL_RCC_GetSysClockFreq+0x68>
 80020c0:	e7a0      	b.n	8002004 <HAL_RCC_GetSysClockFreq+0x20>
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;

    switch (pllsource)
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80020c2:	68d8      	ldr	r0, [r3, #12]
 80020c4:	4b05      	ldr	r3, [pc, #20]	; (80020dc <HAL_RCC_GetSysClockFreq+0xf8>)
 80020c6:	f3c0 2006 	ubfx	r0, r0, #8, #7
 80020ca:	fbb3 f4f4 	udiv	r4, r3, r4
 80020ce:	fb00 f004 	mul.w	r0, r0, r4
      break;
 80020d2:	e7d6      	b.n	8002082 <HAL_RCC_GetSysClockFreq+0x9e>
 80020d4:	40021000 	.word	0x40021000
 80020d8:	08002850 	.word	0x08002850
 80020dc:	00f42400 	.word	0x00f42400
 80020e0:	007a1200 	.word	0x007a1200

080020e4 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80020e4:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 80020e6:	f7ff ff7d 	bl	8001fe4 <HAL_RCC_GetSysClockFreq>
 80020ea:	4a08      	ldr	r2, [pc, #32]	; (800210c <HAL_RCC_GetHCLKFreq+0x28>)
 80020ec:	23f0      	movs	r3, #240	; 0xf0
 80020ee:	6892      	ldr	r2, [r2, #8]
 80020f0:	fa93 f3a3 	rbit	r3, r3
 80020f4:	fab3 f383 	clz	r3, r3
 80020f8:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80020fc:	40da      	lsrs	r2, r3
 80020fe:	4904      	ldr	r1, [pc, #16]	; (8002110 <HAL_RCC_GetHCLKFreq+0x2c>)
 8002100:	4b04      	ldr	r3, [pc, #16]	; (8002114 <HAL_RCC_GetHCLKFreq+0x30>)
 8002102:	5c8a      	ldrb	r2, [r1, r2]
 8002104:	40d0      	lsrs	r0, r2
 8002106:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 8002108:	bd08      	pop	{r3, pc}
 800210a:	bf00      	nop
 800210c:	40021000 	.word	0x40021000
 8002110:	08002880 	.word	0x08002880
 8002114:	20000000 	.word	0x20000000

08002118 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8002118:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 800211a:	f7ff ffe3 	bl	80020e4 <HAL_RCC_GetHCLKFreq>
 800211e:	4b07      	ldr	r3, [pc, #28]	; (800213c <HAL_RCC_GetPCLK1Freq+0x24>)
 8002120:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 8002124:	689b      	ldr	r3, [r3, #8]
 8002126:	fa92 f2a2 	rbit	r2, r2
 800212a:	fab2 f282 	clz	r2, r2
 800212e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8002132:	40d3      	lsrs	r3, r2
 8002134:	4a02      	ldr	r2, [pc, #8]	; (8002140 <HAL_RCC_GetPCLK1Freq+0x28>)
 8002136:	5cd3      	ldrb	r3, [r2, r3]
}
 8002138:	40d8      	lsrs	r0, r3
 800213a:	bd08      	pop	{r3, pc}
 800213c:	40021000 	.word	0x40021000
 8002140:	08002890 	.word	0x08002890

08002144 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8002144:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8002146:	f7ff ffcd 	bl	80020e4 <HAL_RCC_GetHCLKFreq>
 800214a:	4b07      	ldr	r3, [pc, #28]	; (8002168 <HAL_RCC_GetPCLK2Freq+0x24>)
 800214c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002150:	689b      	ldr	r3, [r3, #8]
 8002152:	fa92 f2a2 	rbit	r2, r2
 8002156:	fab2 f282 	clz	r2, r2
 800215a:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 800215e:	40d3      	lsrs	r3, r2
 8002160:	4a02      	ldr	r2, [pc, #8]	; (800216c <HAL_RCC_GetPCLK2Freq+0x28>)
 8002162:	5cd3      	ldrb	r3, [r2, r3]
}
 8002164:	40d8      	lsrs	r0, r3
 8002166:	bd08      	pop	{r3, pc}
 8002168:	40021000 	.word	0x40021000
 800216c:	08002890 	.word	0x08002890

08002170 <HAL_RCC_GetOscConfig>:
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
 8002170:	221f      	movs	r2, #31
                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;

  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 8002172:	4b49      	ldr	r3, [pc, #292]	; (8002298 <HAL_RCC_GetOscConfig+0x128>)
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
 8002174:	6002      	str	r2, [r0, #0]
                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;

  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 8002176:	681a      	ldr	r2, [r3, #0]
 8002178:	0352      	lsls	r2, r2, #13
 800217a:	d57d      	bpl.n	8002278 <HAL_RCC_GetOscConfig+0x108>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
 800217c:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
 8002180:	6043      	str	r3, [r0, #4]
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }

   /* Get the MSI configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_MSION) == RCC_CR_MSION)
 8002182:	4b45      	ldr	r3, [pc, #276]	; (8002298 <HAL_RCC_GetOscConfig+0x128>)
 8002184:	681b      	ldr	r3, [r3, #0]
 8002186:	f013 0301 	ands.w	r3, r3, #1
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_ON;
 800218a:	bf18      	it	ne
 800218c:	2301      	movne	r3, #1
  }
  else
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
 800218e:	6183      	str	r3, [r0, #24]
  }

  RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->CR & RCC_ICSCR_MSITRIM) >> POSITION_VAL(RCC_ICSCR_MSITRIM));
 8002190:	4b41      	ldr	r3, [pc, #260]	; (8002298 <HAL_RCC_GetOscConfig+0x128>)
 8002192:	f44f 417f 	mov.w	r1, #65280	; 0xff00
 8002196:	681a      	ldr	r2, [r3, #0]
 8002198:	fa91 f1a1 	rbit	r1, r1
 800219c:	fab1 f181 	clz	r1, r1
 80021a0:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 80021a4:	40ca      	lsrs	r2, r1
 80021a6:	61c2      	str	r2, [r0, #28]
  RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->CR & RCC_CR_MSIRANGE) );
 80021a8:	681a      	ldr	r2, [r3, #0]
 80021aa:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80021ae:	6202      	str	r2, [r0, #32]

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSION) == RCC_CR_HSION)
 80021b0:	681b      	ldr	r3, [r3, #0]
 80021b2:	f413 7380 	ands.w	r3, r3, #256	; 0x100
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
 80021b6:	bf18      	it	ne
 80021b8:	f44f 7380 	movne.w	r3, #256	; 0x100
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
 80021bc:	60c3      	str	r3, [r0, #12]
  }

  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_HSITRIM) >> POSITION_VAL(RCC_ICSCR_HSITRIM));
 80021be:	4b36      	ldr	r3, [pc, #216]	; (8002298 <HAL_RCC_GetOscConfig+0x128>)
 80021c0:	f04f 51f8 	mov.w	r1, #520093696	; 0x1f000000
 80021c4:	685a      	ldr	r2, [r3, #4]
 80021c6:	fa91 f1a1 	rbit	r1, r1
 80021ca:	fab1 f181 	clz	r1, r1
 80021ce:	f002 52f8 	and.w	r2, r2, #520093696	; 0x1f000000
 80021d2:	40ca      	lsrs	r2, r1
 80021d4:	6102      	str	r2, [r0, #16]

  /* Get the LSE configuration -----------------------------------------------*/
  if((RCC->BDCR & RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
 80021d6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80021da:	0751      	lsls	r1, r2, #29
 80021dc:	d554      	bpl.n	8002288 <HAL_RCC_GetOscConfig+0x118>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
 80021de:	2305      	movs	r3, #5
 80021e0:	6083      	str	r3, [r0, #8]
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
  }

  /* Get the LSI configuration -----------------------------------------------*/
  if((RCC->CSR & RCC_CSR_LSION) == RCC_CSR_LSION)
 80021e2:	4b2d      	ldr	r3, [pc, #180]	; (8002298 <HAL_RCC_GetOscConfig+0x128>)
 80021e4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80021e8:	f013 0301 	ands.w	r3, r3, #1
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
 80021ec:	bf18      	it	ne
 80021ee:	2301      	movne	r3, #1
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
 80021f0:	6143      	str	r3, [r0, #20]
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_PLLON) == RCC_CR_PLLON)
 80021f2:	4b29      	ldr	r3, [pc, #164]	; (8002298 <HAL_RCC_GetOscConfig+0x128>)
 80021f4:	681b      	ldr	r3, [r3, #0]
 80021f6:	01da      	lsls	r2, r3, #7
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
 80021f8:	bf4c      	ite	mi
 80021fa:	2302      	movmi	r3, #2
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
 80021fc:	2301      	movpl	r3, #1
 80021fe:	6243      	str	r3, [r0, #36]	; 0x24
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8002200:	4b25      	ldr	r3, [pc, #148]	; (8002298 <HAL_RCC_GetOscConfig+0x128>)
 8002202:	68da      	ldr	r2, [r3, #12]
 8002204:	f002 0203 	and.w	r2, r2, #3
 8002208:	6282      	str	r2, [r0, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)(((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1);
 800220a:	68da      	ldr	r2, [r3, #12]
 800220c:	2170      	movs	r1, #112	; 0x70
 800220e:	fa91 f1a1 	rbit	r1, r1
 8002212:	fab1 f181 	clz	r1, r1
 8002216:	f002 0270 	and.w	r2, r2, #112	; 0x70
 800221a:	40ca      	lsrs	r2, r1
 800221c:	3201      	adds	r2, #1
 800221e:	62c2      	str	r2, [r0, #44]	; 0x2c
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 8002220:	68da      	ldr	r2, [r3, #12]
 8002222:	f44f 41fe 	mov.w	r1, #32512	; 0x7f00
 8002226:	fa91 f1a1 	rbit	r1, r1
 800222a:	fab1 f181 	clz	r1, r1
 800222e:	f402 42fe 	and.w	r2, r2, #32512	; 0x7f00
 8002232:	40ca      	lsrs	r2, r1
 8002234:	6302      	str	r2, [r0, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> POSITION_VAL(RCC_PLLCFGR_PLLQ)) + 1) << 1U);
 8002236:	68da      	ldr	r2, [r3, #12]
 8002238:	f44f 01c0 	mov.w	r1, #6291456	; 0x600000
 800223c:	fa91 f1a1 	rbit	r1, r1
 8002240:	fab1 f181 	clz	r1, r1
 8002244:	f402 02c0 	and.w	r2, r2, #6291456	; 0x600000
 8002248:	40ca      	lsrs	r2, r1
 800224a:	3201      	adds	r2, #1
 800224c:	0052      	lsls	r2, r2, #1
 800224e:	6382      	str	r2, [r0, #56]	; 0x38
  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> POSITION_VAL(RCC_PLLCFGR_PLLR)) + 1) << 1U);
 8002250:	68da      	ldr	r2, [r3, #12]
 8002252:	f04f 61c0 	mov.w	r1, #100663296	; 0x6000000
 8002256:	fa91 f1a1 	rbit	r1, r1
 800225a:	fab1 f181 	clz	r1, r1
 800225e:	f002 62c0 	and.w	r2, r2, #100663296	; 0x6000000
 8002262:	40ca      	lsrs	r2, r1
 8002264:	3201      	adds	r2, #1
 8002266:	0052      	lsls	r2, r2, #1
 8002268:	63c2      	str	r2, [r0, #60]	; 0x3c
  if((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) != RESET)
 800226a:	68db      	ldr	r3, [r3, #12]
 800226c:	039b      	lsls	r3, r3, #14
  {
    RCC_OscInitStruct->PLL.PLLP = RCC_PLLP_DIV17;
 800226e:	bf4c      	ite	mi
 8002270:	2311      	movmi	r3, #17
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLP = RCC_PLLP_DIV7;
 8002272:	2307      	movpl	r3, #7
 8002274:	6343      	str	r3, [r0, #52]	; 0x34
 8002276:	4770      	bx	lr
  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
  }
  else if((RCC->CR & RCC_CR_HSEON) == RCC_CR_HSEON)
 8002278:	681b      	ldr	r3, [r3, #0]
 800227a:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
 800227e:	bf18      	it	ne
 8002280:	f44f 3380 	movne.w	r3, #65536	; 0x10000
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
 8002284:	6043      	str	r3, [r0, #4]
 8002286:	e77c      	b.n	8002182 <HAL_RCC_GetOscConfig+0x12>
  /* Get the LSE configuration -----------------------------------------------*/
  if((RCC->BDCR & RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
  }
  else if((RCC->BDCR & RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
 8002288:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800228c:	f013 0301 	ands.w	r3, r3, #1
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
 8002290:	bf18      	it	ne
 8002292:	2301      	movne	r3, #1
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
 8002294:	6083      	str	r3, [r0, #8]
 8002296:	e7a4      	b.n	80021e2 <HAL_RCC_GetOscConfig+0x72>
 8002298:	40021000 	.word	0x40021000

0800229c <HAL_RCC_GetClockConfig>:
  *         will be configured.
  * @param  pFLatency  Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 800229c:	b410      	push	{r4}

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 800229e:	4b0e      	ldr	r3, [pc, #56]	; (80022d8 <HAL_RCC_GetClockConfig+0x3c>)
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != NULL);
  assert_param(pFLatency != NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 80022a0:	220f      	movs	r2, #15
 80022a2:	6002      	str	r2, [r0, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80022a4:	689c      	ldr	r4, [r3, #8]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 80022a6:	4a0d      	ldr	r2, [pc, #52]	; (80022dc <HAL_RCC_GetClockConfig+0x40>)

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80022a8:	f004 0403 	and.w	r4, r4, #3
 80022ac:	6044      	str	r4, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 80022ae:	689c      	ldr	r4, [r3, #8]
 80022b0:	f004 04f0 	and.w	r4, r4, #240	; 0xf0
 80022b4:	6084      	str	r4, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 80022b6:	689c      	ldr	r4, [r3, #8]
 80022b8:	f404 64e0 	and.w	r4, r4, #1792	; 0x700
 80022bc:	60c4      	str	r4, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 80022be:	689b      	ldr	r3, [r3, #8]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
}
 80022c0:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 80022c4:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 80022c8:	08db      	lsrs	r3, r3, #3
 80022ca:	6103      	str	r3, [r0, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 80022cc:	6813      	ldr	r3, [r2, #0]
 80022ce:	f003 0307 	and.w	r3, r3, #7
 80022d2:	600b      	str	r3, [r1, #0]
}
 80022d4:	4770      	bx	lr
 80022d6:	bf00      	nop
 80022d8:	40021000 	.word	0x40021000
 80022dc:	40022000 	.word	0x40022000

080022e0 <HAL_RCC_EnableCSS>:
  * @note   The Clock Security System can only be cleared by reset.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
  SET_BIT(RCC->CR, RCC_CR_CSSON) ;
 80022e0:	4b02      	ldr	r3, [pc, #8]	; (80022ec <HAL_RCC_EnableCSS+0xc>)
 80022e2:	681a      	ldr	r2, [r3, #0]
 80022e4:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 80022e8:	601a      	str	r2, [r3, #0]
 80022ea:	4770      	bx	lr
 80022ec:	40021000 	.word	0x40021000

080022f0 <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCC_CSSCallback(void)
{
 80022f0:	4770      	bx	lr
 80022f2:	bf00      	nop

080022f4 <HAL_RCC_NMI_IRQHandler>:
  * @brief Handle the RCC Clock Security System interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
 80022f4:	b510      	push	{r4, lr}
  /* Check RCC CSSF interrupt flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
 80022f6:	4c05      	ldr	r4, [pc, #20]	; (800230c <HAL_RCC_NMI_IRQHandler+0x18>)
 80022f8:	69e3      	ldr	r3, [r4, #28]
 80022fa:	05db      	lsls	r3, r3, #23
 80022fc:	d504      	bpl.n	8002308 <HAL_RCC_NMI_IRQHandler+0x14>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CSSCallback();
 80022fe:	f7ff fff7 	bl	80022f0 <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 8002302:	f44f 7380 	mov.w	r3, #256	; 0x100
 8002306:	6223      	str	r3, [r4, #32]
 8002308:	bd10      	pop	{r4, pc}
 800230a:	bf00      	nop
 800230c:	40021000 	.word	0x40021000

08002310 <HAL_PWR_DeInit>:
  * @brief Deinitialize the HAL PWR peripheral registers to their default reset values.
  * @retval None
  */
void HAL_PWR_DeInit(void)
{
  __HAL_RCC_PWR_FORCE_RESET();
 8002310:	4b04      	ldr	r3, [pc, #16]	; (8002324 <HAL_PWR_DeInit+0x14>)
 8002312:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002314:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002318:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_RCC_PWR_RELEASE_RESET();
 800231a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800231c:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8002320:	639a      	str	r2, [r3, #56]	; 0x38
 8002322:	4770      	bx	lr
 8002324:	40021000 	.word	0x40021000

08002328 <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.                
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);    
 8002328:	4b02      	ldr	r3, [pc, #8]	; (8002334 <HAL_PWR_EnableBkUpAccess+0xc>)
 800232a:	681a      	ldr	r2, [r3, #0]
 800232c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002330:	601a      	str	r2, [r3, #0]
 8002332:	4770      	bx	lr
 8002334:	40007000 	.word	0x40007000

08002338 <HAL_PWR_DisableBkUpAccess>:
  *        (RTC registers, RTC backup data registers).    
  * @retval None
  */
void HAL_PWR_DisableBkUpAccess(void)
{
  CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);   
 8002338:	4b02      	ldr	r3, [pc, #8]	; (8002344 <HAL_PWR_DisableBkUpAccess+0xc>)
 800233a:	681a      	ldr	r2, [r3, #0]
 800233c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8002340:	601a      	str	r2, [r3, #0]
 8002342:	4770      	bx	lr
 8002344:	40007000 	.word	0x40007000

08002348 <HAL_PWR_ConfigPVD>:
  *         more details about the voltage thresholds corresponding to each
  *         detection level.
  * @retval None
  */
HAL_StatusTypeDef HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
{
 8002348:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));

  /* Set PLS bits according to PVDLevel value */
  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, sConfigPVD->PVDLevel);
 800234a:	4a1d      	ldr	r2, [pc, #116]	; (80023c0 <HAL_PWR_ConfigPVD+0x78>)
  
  /* Clear any previous config. Keep it clear if no event or IT mode is selected */
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 800234c:	4b1d      	ldr	r3, [pc, #116]	; (80023c4 <HAL_PWR_ConfigPVD+0x7c>)
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));

  /* Set PLS bits according to PVDLevel value */
  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, sConfigPVD->PVDLevel);
 800234e:	6851      	ldr	r1, [r2, #4]
 8002350:	f021 040e 	bic.w	r4, r1, #14
 8002354:	6801      	ldr	r1, [r0, #0]
 8002356:	4321      	orrs	r1, r4
 8002358:	6051      	str	r1, [r2, #4]
  
  /* Clear any previous config. Keep it clear if no event or IT mode is selected */
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 800235a:	685a      	ldr	r2, [r3, #4]
 800235c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002360:	605a      	str	r2, [r3, #4]
  __HAL_PWR_PVD_EXTI_DISABLE_IT();
 8002362:	681a      	ldr	r2, [r3, #0]
 8002364:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002368:	601a      	str	r2, [r3, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
 800236a:	68da      	ldr	r2, [r3, #12]
 800236c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002370:	60da      	str	r2, [r3, #12]
  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
 8002372:	689a      	ldr	r2, [r3, #8]
 8002374:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002378:	609a      	str	r2, [r3, #8]

  /* Configure interrupt mode */
  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
 800237a:	6842      	ldr	r2, [r0, #4]
 800237c:	03d1      	lsls	r1, r2, #15
 800237e:	d504      	bpl.n	800238a <HAL_PWR_ConfigPVD+0x42>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT();
 8002380:	681a      	ldr	r2, [r3, #0]
 8002382:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002386:	601a      	str	r2, [r3, #0]
 8002388:	6842      	ldr	r2, [r0, #4]
  }
  
  /* Configure event mode */
  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 800238a:	0394      	lsls	r4, r2, #14
 800238c:	d505      	bpl.n	800239a <HAL_PWR_ConfigPVD+0x52>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
 800238e:	4b0d      	ldr	r3, [pc, #52]	; (80023c4 <HAL_PWR_ConfigPVD+0x7c>)
 8002390:	685a      	ldr	r2, [r3, #4]
 8002392:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002396:	605a      	str	r2, [r3, #4]
 8002398:	6842      	ldr	r2, [r0, #4]
  }
  
  /* Configure the edge */
  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 800239a:	07d1      	lsls	r1, r2, #31
 800239c:	d505      	bpl.n	80023aa <HAL_PWR_ConfigPVD+0x62>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 800239e:	4b09      	ldr	r3, [pc, #36]	; (80023c4 <HAL_PWR_ConfigPVD+0x7c>)
 80023a0:	689a      	ldr	r2, [r3, #8]
 80023a2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80023a6:	609a      	str	r2, [r3, #8]
 80023a8:	6842      	ldr	r2, [r0, #4]
  }
  
  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 80023aa:	0793      	lsls	r3, r2, #30
 80023ac:	d504      	bpl.n	80023b8 <HAL_PWR_ConfigPVD+0x70>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 80023ae:	4b05      	ldr	r3, [pc, #20]	; (80023c4 <HAL_PWR_ConfigPVD+0x7c>)
 80023b0:	68da      	ldr	r2, [r3, #12]
 80023b2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80023b6:	60da      	str	r2, [r3, #12]
  }
  
  return HAL_OK;
}
 80023b8:	2000      	movs	r0, #0
 80023ba:	f85d 4b04 	ldr.w	r4, [sp], #4
 80023be:	4770      	bx	lr
 80023c0:	40007000 	.word	0x40007000
 80023c4:	40010400 	.word	0x40010400

080023c8 <HAL_PWR_EnablePVD>:
  * @brief Enable the Power Voltage Detector (PVD).
  * @retval None
  */
void HAL_PWR_EnablePVD(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_PVDE);  
 80023c8:	4b02      	ldr	r3, [pc, #8]	; (80023d4 <HAL_PWR_EnablePVD+0xc>)
 80023ca:	685a      	ldr	r2, [r3, #4]
 80023cc:	f042 0201 	orr.w	r2, r2, #1
 80023d0:	605a      	str	r2, [r3, #4]
 80023d2:	4770      	bx	lr
 80023d4:	40007000 	.word	0x40007000

080023d8 <HAL_PWR_DisablePVD>:
  * @brief Disable the Power Voltage Detector (PVD).
  * @retval None
  */
void HAL_PWR_DisablePVD(void)
{
  CLEAR_BIT(PWR->CR2, PWR_CR2_PVDE);   
 80023d8:	4b02      	ldr	r3, [pc, #8]	; (80023e4 <HAL_PWR_DisablePVD+0xc>)
 80023da:	685a      	ldr	r2, [r3, #4]
 80023dc:	f022 0201 	bic.w	r2, r2, #1
 80023e0:	605a      	str	r2, [r3, #4]
 80023e2:	4770      	bx	lr
 80023e4:	40007000 	.word	0x40007000

080023e8 <HAL_PWR_EnableWakeUpPin>:
{
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinPolarity)); 
  
  /* Specifies the Wake-Up pin polarity for the event detection 
    (rising or falling edge) */
  MODIFY_REG(PWR->CR4, (PWR_CR3_EWUP & WakeUpPinPolarity), (WakeUpPinPolarity >> PWR_WUP_POLARITY_SHIFT)); 
 80023e8:	4b06      	ldr	r3, [pc, #24]	; (8002404 <HAL_PWR_EnableWakeUpPin+0x1c>)
 80023ea:	68d9      	ldr	r1, [r3, #12]
 80023ec:	f000 021f 	and.w	r2, r0, #31
 80023f0:	ea21 0102 	bic.w	r1, r1, r2
 80023f4:	ea41 1050 	orr.w	r0, r1, r0, lsr #5
 80023f8:	60d8      	str	r0, [r3, #12]
    
  /* Enable wake-up pin */
  SET_BIT(PWR->CR3, (PWR_CR3_EWUP & WakeUpPinPolarity));
 80023fa:	6899      	ldr	r1, [r3, #8]
 80023fc:	430a      	orrs	r2, r1
 80023fe:	609a      	str	r2, [r3, #8]
 8002400:	4770      	bx	lr
 8002402:	bf00      	nop
 8002404:	40007000 	.word	0x40007000

08002408 <HAL_PWR_DisableWakeUpPin>:
  */
void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
{
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));

  CLEAR_BIT(PWR->CR3, WakeUpPinx); 
 8002408:	4b02      	ldr	r3, [pc, #8]	; (8002414 <HAL_PWR_DisableWakeUpPin+0xc>)
 800240a:	689a      	ldr	r2, [r3, #8]
 800240c:	ea22 0000 	bic.w	r0, r2, r0
 8002410:	6098      	str	r0, [r3, #8]
 8002412:	4770      	bx	lr
 8002414:	40007000 	.word	0x40007000

08002418 <HAL_PWR_EnterSLEEPMode>:
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as 
  *        the interrupt wake up source.   
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
 8002418:	b510      	push	{r4, lr}

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 800241a:	4b0d      	ldr	r3, [pc, #52]	; (8002450 <HAL_PWR_EnterSLEEPMode+0x38>)
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as 
  *        the interrupt wake up source.   
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
 800241c:	460c      	mov	r4, r1

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 800241e:	695b      	ldr	r3, [r3, #20]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 8002420:	b960      	cbnz	r0, 800243c <HAL_PWR_EnterSLEEPMode+0x24>
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 8002422:	059a      	lsls	r2, r3, #22
 8002424:	d40f      	bmi.n	8002446 <HAL_PWR_EnterSLEEPMode+0x2e>
      HAL_PWREx_EnableLowPowerRunMode();  
    } 
  } 
    
  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8002426:	4b0b      	ldr	r3, [pc, #44]	; (8002454 <HAL_PWR_EnterSLEEPMode+0x3c>)
 8002428:	691a      	ldr	r2, [r3, #16]
  
  /* Select SLEEP mode entry -------------------------------------------------*/
  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 800242a:	2c01      	cmp	r4, #1
      HAL_PWREx_EnableLowPowerRunMode();  
    } 
  } 
    
  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800242c:	f022 0204 	bic.w	r2, r2, #4
 8002430:	611a      	str	r2, [r3, #16]
  
  /* Select SLEEP mode entry -------------------------------------------------*/
  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 8002432:	d00b      	beq.n	800244c <HAL_PWR_EnterSLEEPMode+0x34>

    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
{
  __ASM volatile ("sev");
 8002434:	bf40      	sev
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 8002436:	bf20      	wfe
 8002438:	bf20      	wfe
 800243a:	bd10      	pop	{r4, pc}
  }
  else
  {
    /* If in run mode, first move to low-power run mode.
       The system clock frequency must be below 2 MHz at this point. */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF) == RESET)
 800243c:	059b      	lsls	r3, r3, #22
 800243e:	d4f2      	bmi.n	8002426 <HAL_PWR_EnterSLEEPMode+0xe>
    {
      HAL_PWREx_EnableLowPowerRunMode();  
 8002440:	f7fe ff38 	bl	80012b4 <HAL_PWREx_EnableLowPowerRunMode>
 8002444:	e7ef      	b.n	8002426 <HAL_PWR_EnterSLEEPMode+0xe>
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
    {
      HAL_PWREx_DisableLowPowerRunMode();  
 8002446:	f7fe ff3d 	bl	80012c4 <HAL_PWREx_DisableLowPowerRunMode>
 800244a:	e7ec      	b.n	8002426 <HAL_PWR_EnterSLEEPMode+0xe>
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 800244c:	bf30      	wfi
 800244e:	bd10      	pop	{r4, pc}
 8002450:	40007000 	.word	0x40007000
 8002454:	e000ed00 	.word	0xe000ed00

08002458 <HAL_PWR_EnterSTOPMode>:
  *            @arg PWR_STOPENTRY_WFE: Enter Stop 1 mode with WFE instruction           
  * @retval None
  */
void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
{
  HAL_PWREx_EnterSTOP1Mode(Regulator, STOPEntry);
 8002458:	f7fe bf58 	b.w	800130c <HAL_PWREx_EnterSTOP1Mode>

0800245c <HAL_PWR_EnterSTANDBYMode>:
  * @retval None
  */
void HAL_PWR_EnterSTANDBYMode(void)
{
  /* Set Stand-by mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STANDBY);
 800245c:	4a06      	ldr	r2, [pc, #24]	; (8002478 <HAL_PWR_EnterSTANDBYMode+0x1c>)

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800245e:	4b07      	ldr	r3, [pc, #28]	; (800247c <HAL_PWR_EnterSTANDBYMode+0x20>)
  * @retval None
  */
void HAL_PWR_EnterSTANDBYMode(void)
{
  /* Set Stand-by mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STANDBY);
 8002460:	6811      	ldr	r1, [r2, #0]
 8002462:	f021 0107 	bic.w	r1, r1, #7
 8002466:	f041 0103 	orr.w	r1, r1, #3
 800246a:	6011      	str	r1, [r2, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800246c:	691a      	ldr	r2, [r3, #16]
 800246e:	f042 0204 	orr.w	r2, r2, #4
 8002472:	611a      	str	r2, [r3, #16]
 8002474:	bf30      	wfi
 8002476:	4770      	bx	lr
 8002478:	40007000 	.word	0x40007000
 800247c:	e000ed00 	.word	0xe000ed00

08002480 <HAL_PWR_EnableSleepOnExit>:
  * @retval None
  */
void HAL_PWR_EnableSleepOnExit(void)
{
  /* Set SLEEPONEXIT bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 8002480:	4b02      	ldr	r3, [pc, #8]	; (800248c <HAL_PWR_EnableSleepOnExit+0xc>)
 8002482:	691a      	ldr	r2, [r3, #16]
 8002484:	f042 0202 	orr.w	r2, r2, #2
 8002488:	611a      	str	r2, [r3, #16]
 800248a:	4770      	bx	lr
 800248c:	e000ed00 	.word	0xe000ed00

08002490 <HAL_PWR_DisableSleepOnExit>:
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit(void)
{
  /* Clear SLEEPONEXIT bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 8002490:	4b02      	ldr	r3, [pc, #8]	; (800249c <HAL_PWR_DisableSleepOnExit+0xc>)
 8002492:	691a      	ldr	r2, [r3, #16]
 8002494:	f022 0202 	bic.w	r2, r2, #2
 8002498:	611a      	str	r2, [r3, #16]
 800249a:	4770      	bx	lr
 800249c:	e000ed00 	.word	0xe000ed00

080024a0 <HAL_PWR_EnableSEVOnPend>:
  * @retval None
  */
void HAL_PWR_EnableSEVOnPend(void)
{
  /* Set SEVONPEND bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 80024a0:	4b02      	ldr	r3, [pc, #8]	; (80024ac <HAL_PWR_EnableSEVOnPend+0xc>)
 80024a2:	691a      	ldr	r2, [r3, #16]
 80024a4:	f042 0210 	orr.w	r2, r2, #16
 80024a8:	611a      	str	r2, [r3, #16]
 80024aa:	4770      	bx	lr
 80024ac:	e000ed00 	.word	0xe000ed00

080024b0 <HAL_PWR_DisableSEVOnPend>:
  * @retval None
  */
void HAL_PWR_DisableSEVOnPend(void)
{
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 80024b0:	4b02      	ldr	r3, [pc, #8]	; (80024bc <HAL_PWR_DisableSEVOnPend+0xc>)
 80024b2:	691a      	ldr	r2, [r3, #16]
 80024b4:	f022 0210 	bic.w	r2, r2, #16
 80024b8:	611a      	str	r2, [r3, #16]
 80024ba:	4770      	bx	lr
 80024bc:	e000ed00 	.word	0xe000ed00

080024c0 <HAL_PWR_PVDCallback>:
/**
  * @brief PWR PVD interrupt callback
  * @retval None
  */
__weak void HAL_PWR_PVDCallback(void)
{
 80024c0:	4770      	bx	lr
 80024c2:	bf00      	nop

080024c4 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80024c4:	f8df d040 	ldr.w	sp, [pc, #64]	; 8002508 <LoopForever+0x6>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 80024c8:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 80024ca:	f000 b804 	b.w	80024d6 <LoopCopyDataInit>

080024ce <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 80024ce:	4b0f      	ldr	r3, [pc, #60]	; (800250c <LoopForever+0xa>)
	ldr	r3, [r3, r1]
 80024d0:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 80024d2:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 80024d4:	3104      	adds	r1, #4

080024d6 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80024d6:	480e      	ldr	r0, [pc, #56]	; (8002510 <LoopForever+0xe>)
	ldr	r3, =_edata
 80024d8:	4b0e      	ldr	r3, [pc, #56]	; (8002514 <LoopForever+0x12>)
	adds	r2, r0, r1
 80024da:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80024dc:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80024de:	f4ff aff6 	bcc.w	80024ce <CopyDataInit>
	ldr	r2, =_sbss
 80024e2:	4a0d      	ldr	r2, [pc, #52]	; (8002518 <LoopForever+0x16>)
	b	LoopFillZerobss
 80024e4:	f000 b803 	b.w	80024ee <LoopFillZerobss>

080024e8 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 80024e8:	2300      	movs	r3, #0
	str	r3, [r2], #4
 80024ea:	f842 3b04 	str.w	r3, [r2], #4

080024ee <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 80024ee:	4b0b      	ldr	r3, [pc, #44]	; (800251c <LoopForever+0x1a>)
	cmp	r2, r3
 80024f0:	429a      	cmp	r2, r3
	bcc	FillZerobss
 80024f2:	f4ff aff9 	bcc.w	80024e8 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80024f6:	f7fd fe91 	bl	800021c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80024fa:	f000 f88d 	bl	8002618 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 80024fe:	f000 f811 	bl	8002524 <main>

08002502 <LoopForever>:

LoopForever:
    b LoopForever
 8002502:	f7ff bffe 	b.w	8002502 <LoopForever>
 8002506:	0000      	.short	0x0000

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8002508:	20018000 	.word	0x20018000
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 800250c:	080028b0 	.word	0x080028b0
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 8002510:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8002514:	20000430 	.word	0x20000430
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 8002518:	20000430 	.word	0x20000430
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 800251c:	20000450 	.word	0x20000450

08002520 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8002520:	f7ff bffe 	b.w	8002520 <ADC1_2_IRQHandler>

08002524 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 8002524:	b500      	push	{lr}
 8002526:	b08b      	sub	sp, #44	; 0x2c
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8002528:	f7fd ff90 	bl	800044c <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 800252c:	f7fd fef8 	bl	8000320 <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 8002530:	4b36      	ldr	r3, [pc, #216]	; (800260c <main+0xe8>)
  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);
 8002532:	4837      	ldr	r0, [pc, #220]	; (8002610 <main+0xec>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 8002534:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002536:	f042 0204 	orr.w	r2, r2, #4
 800253a:	64da      	str	r2, [r3, #76]	; 0x4c
 800253c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800253e:	f002 0204 	and.w	r2, r2, #4
 8002542:	9200      	str	r2, [sp, #0]
 8002544:	9a00      	ldr	r2, [sp, #0]
  __GPIOH_CLK_ENABLE();
 8002546:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002548:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800254c:	64da      	str	r2, [r3, #76]	; 0x4c
 800254e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002550:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8002554:	9201      	str	r2, [sp, #4]
 8002556:	9a01      	ldr	r2, [sp, #4]
  __GPIOB_CLK_ENABLE();
 8002558:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800255a:	f042 0202 	orr.w	r2, r2, #2
 800255e:	64da      	str	r2, [r3, #76]	; 0x4c
 8002560:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002562:	f002 0202 	and.w	r2, r2, #2
 8002566:	9202      	str	r2, [sp, #8]
 8002568:	9a02      	ldr	r2, [sp, #8]
  __GPIOE_CLK_ENABLE();
 800256a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800256c:	f042 0210 	orr.w	r2, r2, #16
 8002570:	64da      	str	r2, [r3, #76]	; 0x4c
 8002572:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002574:	f002 0210 	and.w	r2, r2, #16
 8002578:	9203      	str	r2, [sp, #12]
 800257a:	9a03      	ldr	r2, [sp, #12]
  __GPIOA_CLK_ENABLE();
 800257c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800257e:	f042 0201 	orr.w	r2, r2, #1
 8002582:	64da      	str	r2, [r3, #76]	; 0x4c
 8002584:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002586:	f003 0301 	and.w	r3, r3, #1

  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800258a:	2401      	movs	r4, #1
  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
  __GPIOH_CLK_ENABLE();
  __GPIOB_CLK_ENABLE();
  __GPIOE_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
 800258c:	9304      	str	r3, [sp, #16]
  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);
 800258e:	a905      	add	r1, sp, #20
  __GPIOB_CLK_ENABLE();
  __GPIOE_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();

  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
 8002590:	2304      	movs	r3, #4
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8002592:	2603      	movs	r6, #3
  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
  __GPIOH_CLK_ENABLE();
  __GPIOB_CLK_ENABLE();
  __GPIOE_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
 8002594:	9a04      	ldr	r2, [sp, #16]

  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
 8002596:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : GREEN_LED_Pin */
  GPIO_InitStruct.Pin = GREEN_LED_Pin;
 8002598:	f44f 7580 	mov.w	r5, #256	; 0x100
  __GPIOE_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();

  /*Configure GPIO pin : RED_LED_Pin */
  GPIO_InitStruct.Pin = RED_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800259c:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800259e:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80025a0:	9608      	str	r6, [sp, #32]
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);
 80025a2:	f7fe f971 	bl	8000888 <HAL_GPIO_Init>
  /*Configure GPIO pin : GREEN_LED_Pin */
  GPIO_InitStruct.Pin = GREEN_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GREEN_LED_GPIO_Port, &GPIO_InitStruct);
 80025a6:	a905      	add	r1, sp, #20
 80025a8:	481a      	ldr	r0, [pc, #104]	; (8002614 <main+0xf0>)
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : GREEN_LED_Pin */
  GPIO_InitStruct.Pin = GREEN_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80025aa:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80025ac:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80025ae:	9608      	str	r6, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(RED_LED_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : GREEN_LED_Pin */
  GPIO_InitStruct.Pin = GREEN_LED_Pin;
 80025b0:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GREEN_LED_GPIO_Port, &GPIO_InitStruct);
 80025b2:	f7fe f969 	bl	8000888 <HAL_GPIO_Init>

  /*Configure GPIO pin : PA8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80025b6:	2300      	movs	r3, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GREEN_LED_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PA8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80025b8:	2202      	movs	r2, #2
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80025ba:	a905      	add	r1, sp, #20
 80025bc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(GREEN_LED_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PA8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
 80025c0:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80025c2:	9206      	str	r2, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80025c4:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 80025c6:	9308      	str	r3, [sp, #32]
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 80025c8:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80025ca:	f7fe f95d 	bl	8000888 <HAL_GPIO_Init>
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
  /* USER CODE END WHILE */
    HAL_GPIO_WritePin(RED_LED_GPIO_Port, RED_LED_Pin, GPIO_PIN_SET);
 80025ce:	4810      	ldr	r0, [pc, #64]	; (8002610 <main+0xec>)
 80025d0:	2104      	movs	r1, #4
 80025d2:	2201      	movs	r2, #1
 80025d4:	f7fe fb20 	bl	8000c18 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GREEN_LED_GPIO_Port, GREEN_LED_Pin, GPIO_PIN_SET);
 80025d8:	f44f 7180 	mov.w	r1, #256	; 0x100
 80025dc:	2201      	movs	r2, #1
 80025de:	480d      	ldr	r0, [pc, #52]	; (8002614 <main+0xf0>)
 80025e0:	f7fe fb1a 	bl	8000c18 <HAL_GPIO_WritePin>

    HAL_Delay(500);
 80025e4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80025e8:	f7fd ff50 	bl	800048c <HAL_Delay>

    HAL_GPIO_WritePin(RED_LED_GPIO_Port, RED_LED_Pin, GPIO_PIN_RESET);
 80025ec:	4808      	ldr	r0, [pc, #32]	; (8002610 <main+0xec>)
 80025ee:	2104      	movs	r1, #4
 80025f0:	2200      	movs	r2, #0
 80025f2:	f7fe fb11 	bl	8000c18 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GREEN_LED_GPIO_Port, GREEN_LED_Pin, GPIO_PIN_RESET);
 80025f6:	4807      	ldr	r0, [pc, #28]	; (8002614 <main+0xf0>)
 80025f8:	f44f 7180 	mov.w	r1, #256	; 0x100
 80025fc:	2200      	movs	r2, #0
 80025fe:	f7fe fb0b 	bl	8000c18 <HAL_GPIO_WritePin>

    HAL_Delay(500);
 8002602:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002606:	f7fd ff41 	bl	800048c <HAL_Delay>
 800260a:	e7e0      	b.n	80025ce <main+0xaa>
 800260c:	40021000 	.word	0x40021000
 8002610:	48000400 	.word	0x48000400
 8002614:	48001000 	.word	0x48001000

08002618 <__libc_init_array>:
 8002618:	e92d4070 	push	{r4, r5, r6, lr}
 800261c:	e59f506c 	ldr	r5, [pc, #108]	; 8002690 <__libc_init_array+0x78>
 8002620:	e59f606c 	ldr	r6, [pc, #108]	; 8002694 <__libc_init_array+0x7c>
 8002624:	e0656006 	rsb	r6, r5, r6
 8002628:	e1b06146 	asrs	r6, r6, #2
 800262c:	12455004 	subne	r5, r5, #4
 8002630:	13a04000 	movne	r4, #0
 8002634:	0a000005 	beq	8002650 <__libc_init_array+0x38>
 8002638:	e2844001 	add	r4, r4, #1
 800263c:	e5b53004 	ldr	r3, [r5, #4]!
 8002640:	e1a0e00f 	mov	lr, pc
 8002644:	e12fff13 	bx	r3
 8002648:	e1560004 	cmp	r6, r4
 800264c:	1afffff9 	bne	8002638 <__libc_init_array+0x20>
 8002650:	e59f5040 	ldr	r5, [pc, #64]	; 8002698 <__libc_init_array+0x80>
 8002654:	e59f6040 	ldr	r6, [pc, #64]	; 800269c <__libc_init_array+0x84>
 8002658:	e0656006 	rsb	r6, r5, r6
 800265c:	eb00006e 	bl	800281c <_init>
 8002660:	e1b06146 	asrs	r6, r6, #2
 8002664:	12455004 	subne	r5, r5, #4
 8002668:	13a04000 	movne	r4, #0
 800266c:	0a000005 	beq	8002688 <__libc_init_array+0x70>
 8002670:	e2844001 	add	r4, r4, #1
 8002674:	e5b53004 	ldr	r3, [r5, #4]!
 8002678:	e1a0e00f 	mov	lr, pc
 800267c:	e12fff13 	bx	r3
 8002680:	e1560004 	cmp	r6, r4
 8002684:	1afffff9 	bne	8002670 <__libc_init_array+0x58>
 8002688:	e8bd4070 	pop	{r4, r5, r6, lr}
 800268c:	e12fff1e 	bx	lr
 8002690:	080028a0 	.word	0x080028a0
 8002694:	080028a0 	.word	0x080028a0
 8002698:	080028a0 	.word	0x080028a0
 800269c:	080028a8 	.word	0x080028a8

080026a0 <register_fini>:
 80026a0:	e92d4008 	push	{r3, lr}
 80026a4:	e59f3010 	ldr	r3, [pc, #16]	; 80026bc <register_fini+0x1c>
 80026a8:	e3530000 	cmp	r3, #0
 80026ac:	159f000c 	ldrne	r0, [pc, #12]	; 80026c0 <register_fini+0x20>
 80026b0:	1b000003 	blne	80026c4 <atexit>
 80026b4:	e8bd4008 	pop	{r3, lr}
 80026b8:	e12fff1e 	bx	lr
 80026bc:	00000000 	.word	0x00000000
 80026c0:	080026e4 	.word	0x080026e4

080026c4 <atexit>:
 80026c4:	e92d4008 	push	{r3, lr}
 80026c8:	e1a01000 	mov	r1, r0
 80026cc:	e3a00000 	mov	r0, #0
 80026d0:	e1a03000 	mov	r3, r0
 80026d4:	e1a02000 	mov	r2, r0
 80026d8:	eb000013 	bl	800272c <__register_exitproc>
 80026dc:	e8bd4008 	pop	{r3, lr}
 80026e0:	e12fff1e 	bx	lr

080026e4 <__libc_fini_array>:
 80026e4:	e92d4038 	push	{r3, r4, r5, lr}
 80026e8:	e59f5034 	ldr	r5, [pc, #52]	; 8002724 <__libc_fini_array+0x40>
 80026ec:	e59f4034 	ldr	r4, [pc, #52]	; 8002728 <__libc_fini_array+0x44>
 80026f0:	e0654004 	rsb	r4, r5, r4
 80026f4:	e1b04144 	asrs	r4, r4, #2
 80026f8:	10855104 	addne	r5, r5, r4, lsl #2
 80026fc:	0a000005 	beq	8002718 <__libc_fini_array+0x34>
 8002700:	e2444001 	sub	r4, r4, #1
 8002704:	e5353004 	ldr	r3, [r5, #-4]!
 8002708:	e1a0e00f 	mov	lr, pc
 800270c:	e12fff13 	bx	r3
 8002710:	e3540000 	cmp	r4, #0
 8002714:	1afffff9 	bne	8002700 <__libc_fini_array+0x1c>
 8002718:	eb000045 	bl	8002834 <_fini>
 800271c:	e8bd4038 	pop	{r3, r4, r5, lr}
 8002720:	e12fff1e 	bx	lr
 8002724:	080028a8 	.word	0x080028a8
 8002728:	080028ac 	.word	0x080028ac

0800272c <__register_exitproc>:
 800272c:	e59fc0e0 	ldr	ip, [pc, #224]	; 8002814 <__register_exitproc+0xe8>
 8002730:	e92d4070 	push	{r4, r5, r6, lr}
 8002734:	e59c5000 	ldr	r5, [ip]
 8002738:	e595c148 	ldr	ip, [r5, #328]	; 0x148
 800273c:	e35c0000 	cmp	ip, #0
 8002740:	0285cf53 	addeq	ip, r5, #332	; 0x14c
 8002744:	e59c4004 	ldr	r4, [ip, #4]
 8002748:	0585c148 	streq	ip, [r5, #328]	; 0x148
 800274c:	e354001f 	cmp	r4, #31
 8002750:	e24dd010 	sub	sp, sp, #16
 8002754:	e1a06000 	mov	r6, r0
 8002758:	da000016 	ble	80027b8 <__register_exitproc+0x8c>
 800275c:	e59f00b4 	ldr	r0, [pc, #180]	; 8002818 <__register_exitproc+0xec>
 8002760:	e3500000 	cmp	r0, #0
 8002764:	1a000003 	bne	8002778 <__register_exitproc+0x4c>
 8002768:	e3e00000 	mvn	r0, #0
 800276c:	e28dd010 	add	sp, sp, #16
 8002770:	e8bd4070 	pop	{r4, r5, r6, lr}
 8002774:	e12fff1e 	bx	lr
 8002778:	e3a00e19 	mov	r0, #400	; 0x190
 800277c:	e58d100c 	str	r1, [sp, #12]
 8002780:	e58d2008 	str	r2, [sp, #8]
 8002784:	e58d3004 	str	r3, [sp, #4]
 8002788:	e320f000 	nop	{0}
 800278c:	e250c000 	subs	ip, r0, #0
 8002790:	e59d100c 	ldr	r1, [sp, #12]
 8002794:	e59d2008 	ldr	r2, [sp, #8]
 8002798:	e59d3004 	ldr	r3, [sp, #4]
 800279c:	0afffff1 	beq	8002768 <__register_exitproc+0x3c>
 80027a0:	e5950148 	ldr	r0, [r5, #328]	; 0x148
 80027a4:	e3a04000 	mov	r4, #0
 80027a8:	e88c0011 	stm	ip, {r0, r4}
 80027ac:	e585c148 	str	ip, [r5, #328]	; 0x148
 80027b0:	e58c4188 	str	r4, [ip, #392]	; 0x188
 80027b4:	e58c418c 	str	r4, [ip, #396]	; 0x18c
 80027b8:	e3560000 	cmp	r6, #0
 80027bc:	1a000007 	bne	80027e0 <__register_exitproc+0xb4>
 80027c0:	e2843001 	add	r3, r4, #1
 80027c4:	e3a00000 	mov	r0, #0
 80027c8:	e2844002 	add	r4, r4, #2
 80027cc:	e58c3004 	str	r3, [ip, #4]
 80027d0:	e78c1104 	str	r1, [ip, r4, lsl #2]
 80027d4:	e28dd010 	add	sp, sp, #16
 80027d8:	e8bd4070 	pop	{r4, r5, r6, lr}
 80027dc:	e12fff1e 	bx	lr
 80027e0:	e3a05001 	mov	r5, #1
 80027e4:	e1a05415 	lsl	r5, r5, r4
 80027e8:	e08c0104 	add	r0, ip, r4, lsl #2
 80027ec:	e5802088 	str	r2, [r0, #136]	; 0x88
 80027f0:	e59c2188 	ldr	r2, [ip, #392]	; 0x188
 80027f4:	e1822005 	orr	r2, r2, r5
 80027f8:	e58c2188 	str	r2, [ip, #392]	; 0x188
 80027fc:	e5803108 	str	r3, [r0, #264]	; 0x108
 8002800:	e3560002 	cmp	r6, #2
 8002804:	059c318c 	ldreq	r3, [ip, #396]	; 0x18c
 8002808:	01835005 	orreq	r5, r3, r5
 800280c:	058c518c 	streq	r5, [ip, #396]	; 0x18c
 8002810:	eaffffea 	b	80027c0 <__register_exitproc+0x94>
 8002814:	0800289c 	.word	0x0800289c
 8002818:	00000000 	.word	0x00000000

0800281c <_init>:
 800281c:	e1a0c00d 	mov	ip, sp
 8002820:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 8002824:	e24cb004 	sub	fp, ip, #4
 8002828:	e24bd028 	sub	sp, fp, #40	; 0x28
 800282c:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
 8002830:	e12fff1e 	bx	lr

08002834 <_fini>:
 8002834:	e1a0c00d 	mov	ip, sp
 8002838:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 800283c:	e24cb004 	sub	fp, ip, #4
 8002840:	e24bd028 	sub	sp, fp, #40	; 0x28
 8002844:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
 8002848:	e12fff1e 	bx	lr
 800284c:	00000000 	andeq	r0, r0, r0
