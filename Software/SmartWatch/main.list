
main.out:     file format elf32-littlearm


Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	e92d4010 	push	{r4, lr}
 800018c:	e59f4028 	ldr	r4, [pc, #40]	; 80001bc <__do_global_dtors_aux+0x34>
 8000190:	e5d43000 	ldrb	r3, [r4]
 8000194:	e3530000 	cmp	r3, #0
 8000198:	1a000005 	bne	80001b4 <__do_global_dtors_aux+0x2c>
 800019c:	e59f301c 	ldr	r3, [pc, #28]	; 80001c0 <__do_global_dtors_aux+0x38>
 80001a0:	e3530000 	cmp	r3, #0
 80001a4:	159f0018 	ldrne	r0, [pc, #24]	; 80001c4 <__do_global_dtors_aux+0x3c>
 80001a8:	1320f000 	nopne	{0}
 80001ac:	e3a03001 	mov	r3, #1
 80001b0:	e5c43000 	strb	r3, [r4]
 80001b4:	e8bd4010 	pop	{r4, lr}
 80001b8:	e12fff1e 	bx	lr
 80001bc:	20000430 	.word	0x20000430
 80001c0:	00000000 	.word	0x00000000
 80001c4:	0800c434 	.word	0x0800c434

080001c8 <frame_dummy>:
 80001c8:	e59f303c 	ldr	r3, [pc, #60]	; 800020c <frame_dummy+0x44>
 80001cc:	e3530000 	cmp	r3, #0
 80001d0:	e92d4010 	push	{r4, lr}
 80001d4:	159f0034 	ldrne	r0, [pc, #52]	; 8000210 <frame_dummy+0x48>
 80001d8:	159f1034 	ldrne	r1, [pc, #52]	; 8000214 <frame_dummy+0x4c>
 80001dc:	1320f000 	nopne	{0}
 80001e0:	e59f0030 	ldr	r0, [pc, #48]	; 8000218 <frame_dummy+0x50>
 80001e4:	e5903000 	ldr	r3, [r0]
 80001e8:	e3530000 	cmp	r3, #0
 80001ec:	1a000001 	bne	80001f8 <frame_dummy+0x30>
 80001f0:	e8bd4010 	pop	{r4, lr}
 80001f4:	e12fff1e 	bx	lr
 80001f8:	e59f301c 	ldr	r3, [pc, #28]	; 800021c <frame_dummy+0x54>
 80001fc:	e3530000 	cmp	r3, #0
 8000200:	0afffffa 	beq	80001f0 <frame_dummy+0x28>
 8000204:	e8bd4010 	pop	{r4, lr}
 8000208:	e12fff13 	bx	r3
 800020c:	00000000 	.word	0x00000000
 8000210:	0800c434 	.word	0x0800c434
 8000214:	20000434 	.word	0x20000434
 8000218:	20000430 	.word	0x20000430
 800021c:	00000000 	.word	0x00000000

08000220 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 8000220:	b410      	push	{r4}
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000222:	4911      	ldr	r1, [pc, #68]	; (8000268 <SystemInit+0x48>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8000224:	4b11      	ldr	r3, [pc, #68]	; (800026c <SystemInit+0x4c>)

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000226:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800022a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800022e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8000232:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000234:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8000236:	f042 0201 	orr.w	r2, r2, #1
 800023a:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800023c:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 800023e:	681a      	ldr	r2, [r3, #0]
 8000240:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8000244:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000800;
 8000248:	f44f 6400 	mov.w	r4, #2048	; 0x800

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 800024c:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000800;
 800024e:	60dc      	str	r4, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000250:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000252:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000800;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000256:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800025a:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 800025c:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800025e:	608c      	str	r4, [r1, #8]
#endif
}
 8000260:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000264:	4770      	bx	lr
 8000266:	bf00      	nop
 8000268:	e000ed00 	.word	0xe000ed00
 800026c:	40021000 	.word	0x40021000

08000270 <SystemCoreClockUpdate>:
  *
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 8000270:	b410      	push	{r4}
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
 8000272:	4b27      	ldr	r3, [pc, #156]	; (8000310 <SystemCoreClockUpdate+0xa0>)
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000274:	4c26      	ldr	r4, [pc, #152]	; (8000310 <SystemCoreClockUpdate+0xa0>)
void SystemCoreClockUpdate(void)
{
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
 8000276:	681a      	ldr	r2, [r3, #0]
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 8000278:	4826      	ldr	r0, [pc, #152]	; (8000314 <SystemCoreClockUpdate+0xa4>)
void SystemCoreClockUpdate(void)
{
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
 800027a:	0712      	lsls	r2, r2, #28
  { /* MSISRANGE from RCC_CSR applies */
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 800027c:	bf54      	ite	pl
 800027e:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
  }
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 8000282:	6819      	ldrmi	r1, [r3, #0]
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000284:	68a3      	ldr	r3, [r4, #8]
  uint32_t tmp = 0, msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
  { /* MSISRANGE from RCC_CSR applies */
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 8000286:	bf54      	ite	pl
 8000288:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
  }
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 800028c:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000290:	f003 030c 	and.w	r3, r3, #12
 8000294:	2b08      	cmp	r3, #8
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 8000296:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800029a:	d013      	beq.n	80002c4 <SystemCoreClockUpdate+0x54>
 800029c:	2b0c      	cmp	r3, #12
 800029e:	d013      	beq.n	80002c8 <SystemCoreClockUpdate+0x58>
 80002a0:	491d      	ldr	r1, [pc, #116]	; (8000318 <SystemCoreClockUpdate+0xa8>)
 80002a2:	2b04      	cmp	r3, #4
 80002a4:	bf14      	ite	ne
 80002a6:	4613      	movne	r3, r2
 80002a8:	460b      	moveq	r3, r1
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80002aa:	4a19      	ldr	r2, [pc, #100]	; (8000310 <SystemCoreClockUpdate+0xa0>)
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 80002ac:	491b      	ldr	r1, [pc, #108]	; (800031c <SystemCoreClockUpdate+0xac>)
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80002ae:	6892      	ldr	r2, [r2, #8]
 80002b0:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80002b4:	4402      	add	r2, r0
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 80002b6:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
 80002ba:	40d3      	lsrs	r3, r2
 80002bc:	600b      	str	r3, [r1, #0]
}
 80002be:	f85d 4b04 	ldr.w	r4, [sp], #4
 80002c2:	4770      	bx	lr
      SystemCoreClock = HSI_VALUE;
      break;

    case 0x08:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
      break;
 80002c4:	4b16      	ldr	r3, [pc, #88]	; (8000320 <SystemCoreClockUpdate+0xb0>)
 80002c6:	e7f0      	b.n	80002aa <SystemCoreClockUpdate+0x3a>

    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80002c8:	68e1      	ldr	r1, [r4, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;
 80002ca:	68e3      	ldr	r3, [r4, #12]

    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80002cc:	f001 0103 	and.w	r1, r1, #3
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;
 80002d0:	f3c3 1302 	ubfx	r3, r3, #4, #3

      switch (pllsource)
 80002d4:	2902      	cmp	r1, #2
    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;
 80002d6:	f103 0301 	add.w	r3, r3, #1

      switch (pllsource)
 80002da:	d012      	beq.n	8000302 <SystemCoreClockUpdate+0x92>
 80002dc:	2903      	cmp	r1, #3
 80002de:	d114      	bne.n	800030a <SystemCoreClockUpdate+0x9a>
        case 0x02:  /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm);
          break;

        case 0x03:  /* HSE used as PLL clock source */
          pllvco = (HSE_VALUE / pllm);
 80002e0:	4a0f      	ldr	r2, [pc, #60]	; (8000320 <SystemCoreClockUpdate+0xb0>)
 80002e2:	fbb2 f3f3 	udiv	r3, r2, r3

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80002e6:	4a0a      	ldr	r2, [pc, #40]	; (8000310 <SystemCoreClockUpdate+0xa0>)
 80002e8:	68d1      	ldr	r1, [r2, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1) * 2;
 80002ea:	68d4      	ldr	r4, [r2, #12]
 80002ec:	f3c4 6441 	ubfx	r4, r4, #25, #2
 80002f0:	3401      	adds	r4, #1

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80002f2:	f3c1 2106 	ubfx	r1, r1, #8, #7
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1) * 2;
 80002f6:	0064      	lsls	r4, r4, #1

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80002f8:	fb01 f303 	mul.w	r3, r1, r3
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1) * 2;
      SystemCoreClock = pllvco/pllr;
 80002fc:	fbb3 f3f4 	udiv	r3, r3, r4
      break;
 8000300:	e7d3      	b.n	80002aa <SystemCoreClockUpdate+0x3a>
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1 ;

      switch (pllsource)
      {
        case 0x02:  /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm);
 8000302:	4a05      	ldr	r2, [pc, #20]	; (8000318 <SystemCoreClockUpdate+0xa8>)
 8000304:	fbb2 f3f3 	udiv	r3, r2, r3
          break;
 8000308:	e7ed      	b.n	80002e6 <SystemCoreClockUpdate+0x76>
        case 0x03:  /* HSE used as PLL clock source */
          pllvco = (HSE_VALUE / pllm);
          break;

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
 800030a:	fbb2 f3f3 	udiv	r3, r2, r3
          break;
 800030e:	e7ea      	b.n	80002e6 <SystemCoreClockUpdate+0x76>
 8000310:	40021000 	.word	0x40021000
 8000314:	0800c468 	.word	0x0800c468
 8000318:	00f42400 	.word	0x00f42400
 800031c:	20000000 	.word	0x20000000
 8000320:	007a1200 	.word	0x007a1200

08000324 <MX_DMA_Init>:

/** 
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
 8000324:	b500      	push	{lr}
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8000326:	4b17      	ldr	r3, [pc, #92]	; (8000384 <MX_DMA_Init+0x60>)
 8000328:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800032a:	f042 0202 	orr.w	r2, r2, #2
 800032e:	649a      	str	r2, [r3, #72]	; 0x48
 8000330:	6c9a      	ldr	r2, [r3, #72]	; 0x48

/** 
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
 8000332:	b083      	sub	sp, #12
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8000334:	f002 0202 	and.w	r2, r2, #2
 8000338:	9200      	str	r2, [sp, #0]
 800033a:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_DMA1_CLK_ENABLE();
 800033c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800033e:	f042 0201 	orr.w	r2, r2, #1
 8000342:	649a      	str	r2, [r3, #72]	; 0x48
 8000344:	6c9b      	ldr	r3, [r3, #72]	; 0x48

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
 8000346:	2100      	movs	r1, #0
  */
void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000348:	f003 0301 	and.w	r3, r3, #1

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
 800034c:	460a      	mov	r2, r1
  */
void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();
 800034e:	9301      	str	r3, [sp, #4]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
 8000350:	200c      	movs	r0, #12
  */
void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000352:	9b01      	ldr	r3, [sp, #4]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
 8000354:	f000 fca8 	bl	8000ca8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
 8000358:	200c      	movs	r0, #12
 800035a:	f000 fcdb 	bl	8000d14 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
 800035e:	2100      	movs	r1, #0
 8000360:	460a      	mov	r2, r1
 8000362:	200d      	movs	r0, #13
 8000364:	f000 fca0 	bl	8000ca8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);
 8000368:	200d      	movs	r0, #13
 800036a:	f000 fcd3 	bl	8000d14 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Channel2_IRQn, 0, 0);
 800036e:	2100      	movs	r1, #0
 8000370:	460a      	mov	r2, r1
 8000372:	2039      	movs	r0, #57	; 0x39
 8000374:	f000 fc98 	bl	8000ca8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Channel2_IRQn);
 8000378:	2039      	movs	r0, #57	; 0x39
 800037a:	f000 fccb 	bl	8000d14 <HAL_NVIC_EnableIRQ>

}
 800037e:	b003      	add	sp, #12
 8000380:	f85d fb04 	ldr.w	pc, [sp], #4
 8000384:	40021000 	.word	0x40021000

08000388 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8000388:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 800038a:	4b2d      	ldr	r3, [pc, #180]	; (8000440 <MX_GPIO_Init+0xb8>)

  /*Configure GPIO pins : PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = BTN_DN_Pin|BTN_SEL_Pin|BTN_UP_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800038c:	4d2d      	ldr	r5, [pc, #180]	; (8000444 <MX_GPIO_Init+0xbc>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 800038e:	6cda      	ldr	r2, [r3, #76]	; 0x4c

  /*Configure GPIO pins : PCPin PCPin PCPin */
  GPIO_InitStruct.Pin = BT_INT_Pin|G_INT_Pin|IMU_INT_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000390:	482d      	ldr	r0, [pc, #180]	; (8000448 <MX_GPIO_Init+0xc0>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 8000392:	f042 0204 	orr.w	r2, r2, #4
 8000396:	64da      	str	r2, [r3, #76]	; 0x4c
 8000398:	6cda      	ldr	r2, [r3, #76]	; 0x4c
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 800039a:	b08a      	sub	sp, #40	; 0x28

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 800039c:	f002 0204 	and.w	r2, r2, #4
 80003a0:	9201      	str	r2, [sp, #4]
 80003a2:	9a01      	ldr	r2, [sp, #4]
  __GPIOH_CLK_ENABLE();
 80003a4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80003a6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80003aa:	64da      	str	r2, [r3, #76]	; 0x4c
 80003ac:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80003ae:	f002 0280 	and.w	r2, r2, #128	; 0x80
 80003b2:	9202      	str	r2, [sp, #8]
 80003b4:	9a02      	ldr	r2, [sp, #8]
  __GPIOA_CLK_ENABLE();
 80003b6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80003b8:	f042 0201 	orr.w	r2, r2, #1
 80003bc:	64da      	str	r2, [r3, #76]	; 0x4c
 80003be:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80003c0:	f002 0201 	and.w	r2, r2, #1
 80003c4:	9203      	str	r2, [sp, #12]
 80003c6:	9a03      	ldr	r2, [sp, #12]
  __GPIOB_CLK_ENABLE();
 80003c8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80003ca:	f042 0202 	orr.w	r2, r2, #2
 80003ce:	64da      	str	r2, [r3, #76]	; 0x4c
 80003d0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80003d2:	f003 0302 	and.w	r3, r3, #2

  /*Configure GPIO pins : PCPin PCPin PCPin */
  GPIO_InitStruct.Pin = BT_INT_Pin|G_INT_Pin|IMU_INT_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80003d6:	2400      	movs	r4, #0

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
  __GPIOH_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
  __GPIOB_CLK_ENABLE();
 80003d8:	9304      	str	r3, [sp, #16]

  /*Configure GPIO pins : PCPin PCPin PCPin */
  GPIO_InitStruct.Pin = BT_INT_Pin|G_INT_Pin|IMU_INT_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80003da:	a905      	add	r1, sp, #20
  __GPIOH_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
  __GPIOB_CLK_ENABLE();

  /*Configure GPIO pins : PCPin PCPin PCPin */
  GPIO_InitStruct.Pin = BT_INT_Pin|G_INT_Pin|IMU_INT_Pin;
 80003dc:	f44f 7344 	mov.w	r3, #784	; 0x310

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
  __GPIOH_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
  __GPIOB_CLK_ENABLE();
 80003e0:	9a04      	ldr	r2, [sp, #16]

  /*Configure GPIO pins : PCPin PCPin PCPin */
  GPIO_InitStruct.Pin = BT_INT_Pin|G_INT_Pin|IMU_INT_Pin;
 80003e2:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80003e4:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80003e6:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80003e8:	f001 fdca 	bl	8001f80 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = BTN_DN_Pin|BTN_SEL_Pin|BTN_UP_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80003ec:	a905      	add	r1, sp, #20
 80003ee:	4628      	mov	r0, r5
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = BTN_DN_Pin|BTN_SEL_Pin|BTN_UP_Pin;
 80003f0:	2307      	movs	r3, #7
 80003f2:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = IMU_NRESET_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80003f4:	2601      	movs	r6, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = BTN_DN_Pin|BTN_SEL_Pin|BTN_UP_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80003f6:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80003f8:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80003fa:	f001 fdc1 	bl	8001f80 <HAL_GPIO_Init>
  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = IMU_NRESET_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(IMU_NRESET_GPIO_Port, &GPIO_InitStruct);
 80003fe:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = IMU_NRESET_Pin;
 8000400:	f44f 7380 	mov.w	r3, #256	; 0x100
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(IMU_NRESET_GPIO_Port, &GPIO_InitStruct);
 8000404:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = IMU_NRESET_Pin;
 8000408:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800040a:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 800040c:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = IMU_NRESET_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800040e:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(IMU_NRESET_GPIO_Port, &GPIO_InitStruct);
 8000410:	f001 fdb6 	bl	8001f80 <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin */
  GPIO_InitStruct.Pin = BTN_BACK_Pin|_ALRT_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000414:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(IMU_NRESET_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : PAPin PAPin */
  GPIO_InitStruct.Pin = BTN_BACK_Pin|_ALRT_Pin;
 8000416:	f44f 4304 	mov.w	r3, #33792	; 0x8400
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800041a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(IMU_NRESET_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : PAPin PAPin */
  GPIO_InitStruct.Pin = BTN_BACK_Pin|_ALRT_Pin;
 800041e:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000420:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000422:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000424:	f001 fdac 	bl	8001f80 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin PBPin PBPin 
                           PBPin */
  GPIO_InitStruct.Pin = RED_Pin|YELLOW_Pin|GREEN_Pin|OLED_RES_Pin 
 8000428:	f44f 734e 	mov.w	r3, #824	; 0x338
                          |OLED_DC_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800042c:	4628      	mov	r0, r5
 800042e:	a905      	add	r1, sp, #20

  /*Configure GPIO pins : PBPin PBPin PBPin PBPin 
                           PBPin */
  GPIO_InitStruct.Pin = RED_Pin|YELLOW_Pin|GREEN_Pin|OLED_RES_Pin 
                          |OLED_DC_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000430:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000432:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8000434:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pins : PBPin PBPin PBPin PBPin 
                           PBPin */
  GPIO_InitStruct.Pin = RED_Pin|YELLOW_Pin|GREEN_Pin|OLED_RES_Pin 
 8000436:	9305      	str	r3, [sp, #20]
                          |OLED_DC_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000438:	f001 fda2 	bl	8001f80 <HAL_GPIO_Init>

}
 800043c:	b00a      	add	sp, #40	; 0x28
 800043e:	bd70      	pop	{r4, r5, r6, pc}
 8000440:	40021000 	.word	0x40021000
 8000444:	48000400 	.word	0x48000400
 8000448:	48000800 	.word	0x48000800

0800044c <MX_I2C2_Init>:

I2C_HandleTypeDef hi2c2;

/* I2C2 init function */
void MX_I2C2_Init(void)
{
 800044c:	b538      	push	{r3, r4, r5, lr}

  hi2c2.Instance = I2C2;
 800044e:	4c0b      	ldr	r4, [pc, #44]	; (800047c <MX_I2C2_Init+0x30>)
 8000450:	4b0b      	ldr	r3, [pc, #44]	; (8000480 <MX_I2C2_Init+0x34>)
 8000452:	6023      	str	r3, [r4, #0]
  hi2c2.Init.Timing = 0x00000000;
 8000454:	2500      	movs	r5, #0
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8000456:	2301      	movs	r3, #1
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLED;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLED;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLED;
  HAL_I2C_Init(&hi2c2);
 8000458:	4620      	mov	r0, r4
{

  hi2c2.Instance = I2C2;
  hi2c2.Init.Timing = 0x00000000;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800045a:	60e3      	str	r3, [r4, #12]
/* I2C2 init function */
void MX_I2C2_Init(void)
{

  hi2c2.Instance = I2C2;
  hi2c2.Init.Timing = 0x00000000;
 800045c:	6065      	str	r5, [r4, #4]
  hi2c2.Init.OwnAddress1 = 0;
 800045e:	60a5      	str	r5, [r4, #8]
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLED;
 8000460:	6125      	str	r5, [r4, #16]
  hi2c2.Init.OwnAddress2 = 0;
 8000462:	6165      	str	r5, [r4, #20]
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8000464:	61a5      	str	r5, [r4, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLED;
 8000466:	61e5      	str	r5, [r4, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLED;
 8000468:	6225      	str	r5, [r4, #32]
  HAL_I2C_Init(&hi2c2);
 800046a:	f002 f8ad 	bl	80025c8 <HAL_I2C_Init>

    /**Configure Analogue filter 
    */
  HAL_I2CEx_AnalogFilter_Config(&hi2c2, I2C_ANALOGFILTER_ENABLED);
 800046e:	4620      	mov	r0, r4
 8000470:	4629      	mov	r1, r5

}
 8000472:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLED;
  HAL_I2C_Init(&hi2c2);

    /**Configure Analogue filter 
    */
  HAL_I2CEx_AnalogFilter_Config(&hi2c2, I2C_ANALOGFILTER_ENABLED);
 8000476:	f003 bff7 	b.w	8004468 <HAL_I2CEx_ConfigAnalogFilter>
 800047a:	bf00      	nop
 800047c:	2000044c 	.word	0x2000044c
 8000480:	40005800 	.word	0x40005800

08000484 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hi2c->Instance==I2C2)
 8000484:	6802      	ldr	r2, [r0, #0]
 8000486:	4b11      	ldr	r3, [pc, #68]	; (80004cc <HAL_I2C_MspInit+0x48>)
 8000488:	429a      	cmp	r2, r3
 800048a:	d000      	beq.n	800048e <HAL_I2C_MspInit+0xa>
 800048c:	4770      	bx	lr
  HAL_I2CEx_AnalogFilter_Config(&hi2c2, I2C_ANALOGFILTER_ENABLED);

}

void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 800048e:	b530      	push	{r4, r5, lr}
 8000490:	b087      	sub	sp, #28
    */
    GPIO_InitStruct.Pin = SCL_Pin|SDA_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 8000492:	2304      	movs	r3, #4
  
    /**I2C2 GPIO Configuration    
    PB13     ------> I2C2_SCL
    PB14     ------> I2C2_SDA 
    */
    GPIO_InitStruct.Pin = SCL_Pin|SDA_Pin;
 8000494:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8000498:	2203      	movs	r2, #3
  
    /**I2C2 GPIO Configuration    
    PB13     ------> I2C2_SCL
    PB14     ------> I2C2_SDA 
    */
    GPIO_InitStruct.Pin = SCL_Pin|SDA_Pin;
 800049a:	9101      	str	r1, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800049c:	2512      	movs	r5, #18
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800049e:	eb0d 0103 	add.w	r1, sp, r3
    PB13     ------> I2C2_SCL
    PB14     ------> I2C2_SDA 
    */
    GPIO_InitStruct.Pin = SCL_Pin|SDA_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80004a2:	2401      	movs	r4, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80004a4:	480a      	ldr	r0, [pc, #40]	; (80004d0 <HAL_I2C_MspInit+0x4c>)
    PB14     ------> I2C2_SDA 
    */
    GPIO_InitStruct.Pin = SCL_Pin|SDA_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80004a6:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 80004a8:	9305      	str	r3, [sp, #20]
    /**I2C2 GPIO Configuration    
    PB13     ------> I2C2_SCL
    PB14     ------> I2C2_SDA 
    */
    GPIO_InitStruct.Pin = SCL_Pin|SDA_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80004aa:	9502      	str	r5, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80004ac:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80004ae:	f001 fd67 	bl	8001f80 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __I2C2_CLK_ENABLE();
 80004b2:	4b08      	ldr	r3, [pc, #32]	; (80004d4 <HAL_I2C_MspInit+0x50>)
 80004b4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80004b6:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80004ba:	659a      	str	r2, [r3, #88]	; 0x58
 80004bc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80004be:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80004c2:	9300      	str	r3, [sp, #0]
 80004c4:	9b00      	ldr	r3, [sp, #0]
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
}
 80004c6:	b007      	add	sp, #28
 80004c8:	bd30      	pop	{r4, r5, pc}
 80004ca:	bf00      	nop
 80004cc:	40005800 	.word	0x40005800
 80004d0:	48000400 	.word	0x48000400
 80004d4:	40021000 	.word	0x40021000

080004d8 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* hi2c)
{

  if(hi2c->Instance==I2C2)
 80004d8:	6802      	ldr	r2, [r0, #0]
 80004da:	4b07      	ldr	r3, [pc, #28]	; (80004f8 <HAL_I2C_MspDeInit+0x20>)
 80004dc:	429a      	cmp	r2, r3
 80004de:	d000      	beq.n	80004e2 <HAL_I2C_MspDeInit+0xa>
 80004e0:	4770      	bx	lr
  {
  /* USER CODE BEGIN I2C2_MspDeInit 0 */

  /* USER CODE END I2C2_MspDeInit 0 */
    /* Peripheral clock disable */
    __I2C2_CLK_DISABLE();
 80004e2:	4a06      	ldr	r2, [pc, #24]	; (80004fc <HAL_I2C_MspDeInit+0x24>)
  
    /**I2C2 GPIO Configuration    
    PB13     ------> I2C2_SCL
    PB14     ------> I2C2_SDA 
    */
    HAL_GPIO_DeInit(GPIOB, SCL_Pin|SDA_Pin);
 80004e4:	4806      	ldr	r0, [pc, #24]	; (8000500 <HAL_I2C_MspDeInit+0x28>)
  {
  /* USER CODE BEGIN I2C2_MspDeInit 0 */

  /* USER CODE END I2C2_MspDeInit 0 */
    /* Peripheral clock disable */
    __I2C2_CLK_DISABLE();
 80004e6:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80004e8:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 80004ec:	6593      	str	r3, [r2, #88]	; 0x58
  
    /**I2C2 GPIO Configuration    
    PB13     ------> I2C2_SCL
    PB14     ------> I2C2_SDA 
    */
    HAL_GPIO_DeInit(GPIOB, SCL_Pin|SDA_Pin);
 80004ee:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
 80004f2:	f001 be43 	b.w	800217c <HAL_GPIO_DeInit>
 80004f6:	bf00      	nop
 80004f8:	40005800 	.word	0x40005800
 80004fc:	40021000 	.word	0x40021000
 8000500:	48000400 	.word	0x48000400

08000504 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 8000504:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000506:	b0b5      	sub	sp, #212	; 0xd4
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.LSEState = RCC_LSE_BYPASS;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000508:	2502      	movs	r5, #2

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
 800050a:	2305      	movs	r3, #5
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.LSEState = RCC_LSE_BYPASS;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 20;
 800050c:	2214      	movs	r2, #20

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.LSEState = RCC_LSE_BYPASS;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800050e:	2703      	movs	r7, #3
  RCC_OscInitStruct.PLL.PLLM = 1;
 8000510:	2101      	movs	r1, #1
  RCC_OscInitStruct.PLL.PLLN = 20;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 8000512:	2607      	movs	r6, #7
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 8000514:	f44f 24a0 	mov.w	r4, #327680	; 0x50000
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 20;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8000518:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.LSEState = RCC_LSE_BYPASS;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 20;
 800051a:	9212      	str	r2, [sp, #72]	; 0x48

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
 800051c:	9306      	str	r3, [sp, #24]
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.LSEState = RCC_LSE_BYPASS;
 800051e:	9308      	str	r3, [sp, #32]
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 8000520:	9407      	str	r4, [sp, #28]
  RCC_OscInitStruct.LSEState = RCC_LSE_BYPASS;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000522:	9710      	str	r7, [sp, #64]	; 0x40
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000524:	2400      	movs	r4, #0
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.LSEState = RCC_LSE_BYPASS;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 1;
 8000526:	9111      	str	r1, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLN = 20;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 8000528:	9613      	str	r6, [sp, #76]	; 0x4c
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.LSEState = RCC_LSE_BYPASS;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800052a:	950f      	str	r5, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 20;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 800052c:	9514      	str	r5, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 800052e:	9515      	str	r5, [sp, #84]	; 0x54
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8000530:	f005 fafe 	bl	8005b30 <HAL_RCC_OscConfig>

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000534:	230f      	movs	r3, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 8000536:	a801      	add	r0, sp, #4
 8000538:	2104      	movs	r1, #4
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800053a:	9702      	str	r7, [sp, #8]
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800053c:	9301      	str	r3, [sp, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800053e:	9403      	str	r4, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000540:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000542:	9405      	str	r4, [sp, #20]
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_I2C2
 8000544:	4f1b      	ldr	r7, [pc, #108]	; (80005b4 <SystemClock_Config+0xb0>)
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 8000546:	f005 fedd 	bl	8006304 <HAL_RCC_ClockConfig>

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_I2C2
                              |RCC_PERIPHCLK_USB;
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 800054a:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
  PeriphClkInit.PLLSAI1.PLLSAI1N = 12;
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
 800054e:	9618      	str	r6, [sp, #96]	; 0x60
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_I2C2
                              |RCC_PERIPHCLK_USB;
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
  PeriphClkInit.PLLSAI1.PLLSAI1N = 12;
 8000550:	220c      	movs	r2, #12
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
 8000552:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_I2C2
                              |RCC_PERIPHCLK_USB;
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 8000556:	f44f 7680 	mov.w	r6, #256	; 0x100
  PeriphClkInit.PLLSAI1.PLLSAI1N = 12;
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 800055a:	a816      	add	r0, sp, #88	; 0x58

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_I2C2
                              |RCC_PERIPHCLK_USB;
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 800055c:	912d      	str	r1, [sp, #180]	; 0xb4
  PeriphClkInit.PLLSAI1.PLLSAI1N = 12;
 800055e:	9217      	str	r2, [sp, #92]	; 0x5c
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
 8000560:	931b      	str	r3, [sp, #108]	; 0x6c
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_I2C2
                              |RCC_PERIPHCLK_USB;
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
 8000562:	9427      	str	r4, [sp, #156]	; 0x9c
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
  PeriphClkInit.PLLSAI1.PLLSAI1N = 12;
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
 8000564:	9519      	str	r5, [sp, #100]	; 0x64
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
 8000566:	951a      	str	r5, [sp, #104]	; 0x68
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_I2C2
 8000568:	9716      	str	r7, [sp, #88]	; 0x58
                              |RCC_PERIPHCLK_USB;
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 800056a:	9633      	str	r6, [sp, #204]	; 0xcc
  PeriphClkInit.PLLSAI1.PLLSAI1N = 12;
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 800056c:	f006 fac0 	bl	8006af0 <HAL_RCCEx_PeriphCLKConfig>

  __PWR_CLK_ENABLE();
 8000570:	4b11      	ldr	r3, [pc, #68]	; (80005b8 <SystemClock_Config+0xb4>)
 8000572:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000574:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000578:	659a      	str	r2, [r3, #88]	; 0x58
 800057a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800057c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000580:	9300      	str	r3, [sp, #0]

  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000582:	f44f 7000 	mov.w	r0, #512	; 0x200
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);

  __PWR_CLK_ENABLE();
 8000586:	9b00      	ldr	r3, [sp, #0]

  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000588:	f004 fe8e 	bl	80052a8 <HAL_PWREx_ControlVoltageScaling>

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 800058c:	f006 f88c 	bl	80066a8 <HAL_RCC_GetHCLKFreq>
 8000590:	4b0a      	ldr	r3, [pc, #40]	; (80005bc <SystemClock_Config+0xb8>)
 8000592:	fba3 3000 	umull	r3, r0, r3, r0
 8000596:	0980      	lsrs	r0, r0, #6
 8000598:	f000 fbe6 	bl	8000d68 <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 800059c:	2004      	movs	r0, #4
 800059e:	f000 fc69 	bl	8000e74 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80005a2:	4621      	mov	r1, r4
 80005a4:	4622      	mov	r2, r4
 80005a6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80005aa:	f000 fb7d 	bl	8000ca8 <HAL_NVIC_SetPriority>
}
 80005ae:	b035      	add	sp, #212	; 0xd4
 80005b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80005b2:	bf00      	nop
 80005b4:	00022080 	.word	0x00022080
 80005b8:	40021000 	.word	0x40021000
 80005bc:	10624dd3 	.word	0x10624dd3

080005c0 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 80005c0:	b570      	push	{r4, r5, r6, lr}
  RTC_DateTypeDef sDate;
  RTC_AlarmTypeDef sAlarm;

    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
 80005c2:	4d23      	ldr	r5, [pc, #140]	; (8000650 <MX_RTC_Init+0x90>)
 80005c4:	4b23      	ldr	r3, [pc, #140]	; (8000654 <MX_RTC_Init+0x94>)
 80005c6:	602b      	str	r3, [r5, #0]

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 80005c8:	b090      	sub	sp, #64	; 0x40
  RTC_AlarmTypeDef sAlarm;

    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 80005ca:	2400      	movs	r4, #0
  sTime.TimeFormat = RTC_HOURFORMAT12_AM;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);

  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 80005cc:	2601      	movs	r6, #1
    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
 80005ce:	23ff      	movs	r3, #255	; 0xff

    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
 80005d0:	227f      	movs	r2, #127	; 0x7f
  hrtc.Init.SynchPrediv = 255;
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  HAL_RTC_Init(&hrtc);
 80005d2:	4628      	mov	r0, r5
    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
 80005d4:	60eb      	str	r3, [r5, #12]

    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
 80005d6:	60aa      	str	r2, [r5, #8]
  RTC_AlarmTypeDef sAlarm;

    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 80005d8:	606c      	str	r4, [r5, #4]
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 80005da:	612c      	str	r4, [r5, #16]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 80005dc:	616c      	str	r4, [r5, #20]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 80005de:	61ac      	str	r4, [r5, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 80005e0:	61ec      	str	r4, [r5, #28]
  HAL_RTC_Init(&hrtc);
 80005e2:	f007 fe03 	bl	80081ec <HAL_RTC_Init>
  sTime.Minutes = 0x0;
  sTime.Seconds = 0x0;
  sTime.TimeFormat = RTC_HOURFORMAT12_AM;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);
 80005e6:	a901      	add	r1, sp, #4
 80005e8:	4632      	mov	r2, r6
 80005ea:	4628      	mov	r0, r5
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  HAL_RTC_Init(&hrtc);

  sTime.Hours = 0x0;
 80005ec:	f88d 4004 	strb.w	r4, [sp, #4]
  sTime.Minutes = 0x0;
 80005f0:	f88d 4005 	strb.w	r4, [sp, #5]
  sTime.Seconds = 0x0;
 80005f4:	f88d 4006 	strb.w	r4, [sp, #6]
  sTime.TimeFormat = RTC_HOURFORMAT12_AM;
 80005f8:	f88d 4007 	strb.w	r4, [sp, #7]
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 80005fc:	9404      	str	r4, [sp, #16]
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 80005fe:	9405      	str	r4, [sp, #20]
  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);
 8000600:	f007 feba 	bl	8008378 <HAL_RTC_SetTime>
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
  sDate.Month = RTC_MONTH_JANUARY;
  sDate.Date = 0x1;
  sDate.Year = 0x0;

  HAL_RTC_SetDate(&hrtc, &sDate, FORMAT_BCD);
 8000604:	4632      	mov	r2, r6
 8000606:	4669      	mov	r1, sp
 8000608:	4628      	mov	r0, r5
  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);

  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
  sDate.Month = RTC_MONTH_JANUARY;
  sDate.Date = 0x1;
  sDate.Year = 0x0;
 800060a:	f88d 4003 	strb.w	r4, [sp, #3]
  sTime.TimeFormat = RTC_HOURFORMAT12_AM;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);

  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 800060e:	f88d 6000 	strb.w	r6, [sp]
  sDate.Month = RTC_MONTH_JANUARY;
 8000612:	f88d 6001 	strb.w	r6, [sp, #1]
  sDate.Date = 0x1;
 8000616:	f88d 6002 	strb.w	r6, [sp, #2]
  sDate.Year = 0x0;

  HAL_RTC_SetDate(&hrtc, &sDate, FORMAT_BCD);
 800061a:	f007 ff5f 	bl	80084dc <HAL_RTC_SetDate>
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
  sAlarm.AlarmDateWeekDay = 0x1;
  sAlarm.Alarm = RTC_ALARM_A;
 800061e:	f44f 7380 	mov.w	r3, #256	; 0x100
  HAL_RTC_SetAlarm(&hrtc, &sAlarm, FORMAT_BCD);
 8000622:	4628      	mov	r0, r5
 8000624:	4632      	mov	r2, r6
 8000626:	a906      	add	r1, sp, #24

  HAL_RTC_SetDate(&hrtc, &sDate, FORMAT_BCD);

    /**Enable the Alarm A 
    */
  sAlarm.AlarmTime.Hours = 0x0;
 8000628:	f88d 4018 	strb.w	r4, [sp, #24]
  sAlarm.AlarmTime.Minutes = 0x0;
 800062c:	f88d 4019 	strb.w	r4, [sp, #25]
  sAlarm.AlarmTime.Seconds = 0x0;
 8000630:	f88d 401a 	strb.w	r4, [sp, #26]
  sAlarm.AlarmTime.TimeFormat = RTC_HOURFORMAT12_AM;
 8000634:	f88d 401b 	strb.w	r4, [sp, #27]
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 8000638:	9409      	str	r4, [sp, #36]	; 0x24
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 800063a:	940a      	str	r4, [sp, #40]	; 0x28
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 800063c:	940b      	str	r4, [sp, #44]	; 0x2c
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 800063e:	940c      	str	r4, [sp, #48]	; 0x30
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 8000640:	940d      	str	r4, [sp, #52]	; 0x34
  sAlarm.AlarmDateWeekDay = 0x1;
 8000642:	f88d 6038 	strb.w	r6, [sp, #56]	; 0x38
  sAlarm.Alarm = RTC_ALARM_A;
 8000646:	930f      	str	r3, [sp, #60]	; 0x3c
  HAL_RTC_SetAlarm(&hrtc, &sAlarm, FORMAT_BCD);
 8000648:	f007 fa8a 	bl	8007b60 <HAL_RTC_SetAlarm>

}
 800064c:	b010      	add	sp, #64	; 0x40
 800064e:	bd70      	pop	{r4, r5, r6, pc}
 8000650:	20000488 	.word	0x20000488
 8000654:	40002800 	.word	0x40002800

08000658 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{

  if(hrtc->Instance==RTC)
 8000658:	6802      	ldr	r2, [r0, #0]
 800065a:	4b06      	ldr	r3, [pc, #24]	; (8000674 <HAL_RTC_MspInit+0x1c>)
 800065c:	429a      	cmp	r2, r3
 800065e:	d000      	beq.n	8000662 <HAL_RTC_MspInit+0xa>
 8000660:	4770      	bx	lr
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 8000662:	4a05      	ldr	r2, [pc, #20]	; (8000678 <HAL_RTC_MspInit+0x20>)
 8000664:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8000668:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800066c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8000670:	4770      	bx	lr
 8000672:	bf00      	nop
 8000674:	40002800 	.word	0x40002800
 8000678:	40021000 	.word	0x40021000

0800067c <HAL_RTC_MspDeInit>:
}

void HAL_RTC_MspDeInit(RTC_HandleTypeDef* hrtc)
{

  if(hrtc->Instance==RTC)
 800067c:	6802      	ldr	r2, [r0, #0]
 800067e:	4b06      	ldr	r3, [pc, #24]	; (8000698 <HAL_RTC_MspDeInit+0x1c>)
 8000680:	429a      	cmp	r2, r3
 8000682:	d000      	beq.n	8000686 <HAL_RTC_MspDeInit+0xa>
 8000684:	4770      	bx	lr
  {
  /* USER CODE BEGIN RTC_MspDeInit 0 */

  /* USER CODE END RTC_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_RTC_DISABLE();
 8000686:	4a05      	ldr	r2, [pc, #20]	; (800069c <HAL_RTC_MspDeInit+0x20>)
 8000688:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 800068c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8000690:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8000694:	4770      	bx	lr
 8000696:	bf00      	nop
 8000698:	40002800 	.word	0x40002800
 800069c:	40021000 	.word	0x40021000

080006a0 <MX_SPI1_Init>:
DMA_HandleTypeDef hdma_spi1_rx;
DMA_HandleTypeDef hdma_spi3_tx;

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 80006a0:	b5f0      	push	{r4, r5, r6, r7, lr}

  hspi1.Instance = SPI1;
 80006a2:	4b10      	ldr	r3, [pc, #64]	; (80006e4 <MX_SPI1_Init+0x44>)
 80006a4:	4a10      	ldr	r2, [pc, #64]	; (80006e8 <MX_SPI1_Init+0x48>)
 80006a6:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80006a8:	f44f 7e82 	mov.w	lr, #260	; 0x104
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 80006ac:	2200      	movs	r2, #0
  hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
 80006ae:	f44f 7740 	mov.w	r7, #768	; 0x300
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80006b2:	f44f 7600 	mov.w	r6, #512	; 0x200
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 80006b6:	2510      	movs	r5, #16
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLED;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
  hspi1.Init.CRCPolynomial = 7;
 80006b8:	2407      	movs	r4, #7
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLED;
 80006ba:	2108      	movs	r1, #8
/* SPI1 init function */
void MX_SPI1_Init(void)
{

  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80006bc:	f8c3 e004 	str.w	lr, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
 80006c0:	60df      	str	r7, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80006c2:	619e      	str	r6, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 80006c4:	61dd      	str	r5, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLED;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
  hspi1.Init.CRCPolynomial = 7;
 80006c6:	62dc      	str	r4, [r3, #44]	; 0x2c
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLED;
 80006c8:	6359      	str	r1, [r3, #52]	; 0x34
void MX_SPI1_Init(void)
{

  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 80006ca:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 80006cc:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 80006ce:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80006d0:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLED;
 80006d2:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
 80006d4:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 80006d6:	631a      	str	r2, [r3, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLED;
  HAL_SPI_Init(&hspi1);
 80006d8:	4618      	mov	r0, r3

}
 80006da:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  hspi1.Init.TIMode = SPI_TIMODE_DISABLED;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
  hspi1.Init.CRCPolynomial = 7;
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLED;
  HAL_SPI_Init(&hspi1);
 80006de:	f009 b8c3 	b.w	8009868 <HAL_SPI_Init>
 80006e2:	bf00      	nop
 80006e4:	200004ac 	.word	0x200004ac
 80006e8:	40013000 	.word	0x40013000

080006ec <MX_SPI3_Init>:

}
/* SPI3 init function */
void MX_SPI3_Init(void)
{
 80006ec:	b5f0      	push	{r4, r5, r6, r7, lr}

  hspi3.Instance = SPI3;
 80006ee:	4b14      	ldr	r3, [pc, #80]	; (8000740 <MX_SPI3_Init+0x54>)
 80006f0:	4a14      	ldr	r2, [pc, #80]	; (8000744 <MX_SPI3_Init+0x58>)
 80006f2:	665a      	str	r2, [r3, #100]	; 0x64
  hspi3.Init.Mode = SPI_MODE_MASTER;
 80006f4:	f44f 7e82 	mov.w	lr, #260	; 0x104
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
 80006f8:	2200      	movs	r2, #0
  hspi3.Init.DataSize = SPI_DATASIZE_4BIT;
 80006fa:	f44f 7740 	mov.w	r7, #768	; 0x300
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi3.Init.NSS = SPI_NSS_SOFT;
 80006fe:	f44f 7600 	mov.w	r6, #512	; 0x200
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 8000702:	2510      	movs	r5, #16
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi3.Init.TIMode = SPI_TIMODE_DISABLED;
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
  hspi3.Init.CRCPolynomial = 7;
 8000704:	2407      	movs	r4, #7
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLED;
 8000706:	2108      	movs	r1, #8
/* SPI3 init function */
void MX_SPI3_Init(void)
{

  hspi3.Instance = SPI3;
  hspi3.Init.Mode = SPI_MODE_MASTER;
 8000708:	f8c3 e068 	str.w	lr, [r3, #104]	; 0x68
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
  hspi3.Init.DataSize = SPI_DATASIZE_4BIT;
 800070c:	671f      	str	r7, [r3, #112]	; 0x70
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi3.Init.NSS = SPI_NSS_SOFT;
 800070e:	67de      	str	r6, [r3, #124]	; 0x7c
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 8000710:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi3.Init.TIMode = SPI_TIMODE_DISABLED;
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
  hspi3.Init.CRCPolynomial = 7;
 8000714:	f8c3 4090 	str.w	r4, [r3, #144]	; 0x90
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLED;
 8000718:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
void MX_SPI3_Init(void)
{

  hspi3.Instance = SPI3;
  hspi3.Init.Mode = SPI_MODE_MASTER;
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
 800071c:	66da      	str	r2, [r3, #108]	; 0x6c
  hspi3.Init.DataSize = SPI_DATASIZE_4BIT;
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
 800071e:	675a      	str	r2, [r3, #116]	; 0x74
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000720:	679a      	str	r2, [r3, #120]	; 0x78
  hspi3.Init.NSS = SPI_NSS_SOFT;
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000722:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  hspi3.Init.TIMode = SPI_TIMODE_DISABLED;
 8000726:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
 800072a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  hspi3.Init.CRCPolynomial = 7;
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 800072e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLED;
  HAL_SPI_Init(&hspi3);
 8000732:	f103 0064 	add.w	r0, r3, #100	; 0x64
  //HAL_SPI_MspInit(&hspi3);

}
 8000736:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  hspi3.Init.TIMode = SPI_TIMODE_DISABLED;
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
  hspi3.Init.CRCPolynomial = 7;
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLED;
  HAL_SPI_Init(&hspi3);
 800073a:	f009 b895 	b.w	8009868 <HAL_SPI_Init>
 800073e:	bf00      	nop
 8000740:	200004ac 	.word	0x200004ac
 8000744:	40003c00 	.word	0x40003c00

08000748 <HAL_SPI_MspInit>:
  //HAL_SPI_MspInit(&hspi3);

}

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8000748:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==SPI1)
 800074c:	4a4f      	ldr	r2, [pc, #316]	; (800088c <HAL_SPI_MspInit+0x144>)
 800074e:	6803      	ldr	r3, [r0, #0]
 8000750:	4293      	cmp	r3, r2
  //HAL_SPI_MspInit(&hspi3);

}

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8000752:	b089      	sub	sp, #36	; 0x24
 8000754:	4604      	mov	r4, r0

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==SPI1)
 8000756:	d040      	beq.n	80007da <HAL_SPI_MspInit+0x92>

  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }
  else if(hspi->Instance==SPI3)
 8000758:	4a4d      	ldr	r2, [pc, #308]	; (8000890 <HAL_SPI_MspInit+0x148>)
 800075a:	4293      	cmp	r3, r2
 800075c:	d002      	beq.n	8000764 <HAL_SPI_MspInit+0x1c>

  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }
}
 800075e:	b009      	add	sp, #36	; 0x24
 8000760:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  {
  /* USER CODE BEGIN SPI3_MspInit 0 */

  /* USER CODE END SPI3_MspInit 0 */
    /* Peripheral clock enable */
    __SPI3_CLK_ENABLE();
 8000764:	4b4b      	ldr	r3, [pc, #300]	; (8000894 <HAL_SPI_MspInit+0x14c>)
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    /* Peripheral DMA init*/
  
    hdma_spi3_tx.Instance = DMA2_Channel2;
 8000766:	4d4c      	ldr	r5, [pc, #304]	; (8000898 <HAL_SPI_MspInit+0x150>)
  {
  /* USER CODE BEGIN SPI3_MspInit 0 */

  /* USER CODE END SPI3_MspInit 0 */
    /* Peripheral clock enable */
    __SPI3_CLK_ENABLE();
 8000768:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    GPIO_InitStruct.Pin = OLED_SCK_Pin|OLED_MOSI_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800076a:	484c      	ldr	r0, [pc, #304]	; (800089c <HAL_SPI_MspInit+0x154>)
  {
  /* USER CODE BEGIN SPI3_MspInit 0 */

  /* USER CODE END SPI3_MspInit 0 */
    /* Peripheral clock enable */
    __SPI3_CLK_ENABLE();
 800076c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000770:	659a      	str	r2, [r3, #88]	; 0x58
 8000772:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000774:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    PC10     ------> SPI3_SCK
    PC12     ------> SPI3_MOSI 
    */
    GPIO_InitStruct.Pin = OLED_SCK_Pin|OLED_MOSI_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000778:	2600      	movs	r6, #0
  {
  /* USER CODE BEGIN SPI3_MspInit 0 */

  /* USER CODE END SPI3_MspInit 0 */
    /* Peripheral clock enable */
    __SPI3_CLK_ENABLE();
 800077a:	9302      	str	r3, [sp, #8]
  
    /**SPI3 GPIO Configuration    
    PC10     ------> SPI3_SCK
    PC12     ------> SPI3_MOSI 
    */
    GPIO_InitStruct.Pin = OLED_SCK_Pin|OLED_MOSI_Pin;
 800077c:	f44f 5ea0 	mov.w	lr, #5120	; 0x1400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000780:	2202      	movs	r2, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8000782:	2306      	movs	r3, #6
    PC12     ------> SPI3_MOSI 
    */
    GPIO_InitStruct.Pin = OLED_SCK_Pin|OLED_MOSI_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8000784:	f04f 0803 	mov.w	r8, #3
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000788:	a903      	add	r1, sp, #12
    hdma_spi3_tx.Init.MemInc = DMA_MINC_DISABLE;
    hdma_spi3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi3_tx.Init.Mode = DMA_NORMAL;
    hdma_spi3_tx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi3_tx);
 800078a:	f505 77a0 	add.w	r7, r5, #320	; 0x140
  {
  /* USER CODE BEGIN SPI3_MspInit 0 */

  /* USER CODE END SPI3_MspInit 0 */
    /* Peripheral clock enable */
    __SPI3_CLK_ENABLE();
 800078e:	f8dd c008 	ldr.w	ip, [sp, #8]
  
    /**SPI3 GPIO Configuration    
    PC10     ------> SPI3_SCK
    PC12     ------> SPI3_MOSI 
    */
    GPIO_InitStruct.Pin = OLED_SCK_Pin|OLED_MOSI_Pin;
 8000792:	f8cd e00c 	str.w	lr, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000796:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8000798:	9307      	str	r3, [sp, #28]
    PC10     ------> SPI3_SCK
    PC12     ------> SPI3_MOSI 
    */
    GPIO_InitStruct.Pin = OLED_SCK_Pin|OLED_MOSI_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800079a:	9605      	str	r6, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800079c:	f8cd 8018 	str.w	r8, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80007a0:	f001 fbee 	bl	8001f80 <HAL_GPIO_Init>

    /* Peripheral DMA init*/
  
    hdma_spi3_tx.Instance = DMA2_Channel2;
 80007a4:	4a3e      	ldr	r2, [pc, #248]	; (80008a0 <HAL_SPI_MspInit+0x158>)
    hdma_spi3_tx.Init.Request = DMA_REQUEST_3;
 80007a6:	f8c5 8144 	str.w	r8, [r5, #324]	; 0x144
    hdma_spi3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80007aa:	2310      	movs	r3, #16
    hdma_spi3_tx.Init.MemInc = DMA_MINC_DISABLE;
    hdma_spi3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi3_tx.Init.Mode = DMA_NORMAL;
    hdma_spi3_tx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi3_tx);
 80007ac:	4638      	mov	r0, r7
    /* Peripheral DMA init*/
  
    hdma_spi3_tx.Instance = DMA2_Channel2;
    hdma_spi3_tx.Init.Request = DMA_REQUEST_3;
    hdma_spi3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_spi3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80007ae:	f8c5 614c 	str.w	r6, [r5, #332]	; 0x14c
    hdma_spi3_tx.Init.MemInc = DMA_MINC_DISABLE;
 80007b2:	f8c5 6150 	str.w	r6, [r5, #336]	; 0x150
    hdma_spi3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80007b6:	f8c5 6154 	str.w	r6, [r5, #340]	; 0x154
    hdma_spi3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80007ba:	f8c5 6158 	str.w	r6, [r5, #344]	; 0x158
    hdma_spi3_tx.Init.Mode = DMA_NORMAL;
 80007be:	f8c5 615c 	str.w	r6, [r5, #348]	; 0x15c
    hdma_spi3_tx.Init.Priority = DMA_PRIORITY_LOW;
 80007c2:	f8c5 6160 	str.w	r6, [r5, #352]	; 0x160
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    /* Peripheral DMA init*/
  
    hdma_spi3_tx.Instance = DMA2_Channel2;
 80007c6:	f8c5 2140 	str.w	r2, [r5, #320]	; 0x140
    hdma_spi3_tx.Init.Request = DMA_REQUEST_3;
    hdma_spi3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80007ca:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
    hdma_spi3_tx.Init.MemInc = DMA_MINC_DISABLE;
    hdma_spi3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi3_tx.Init.Mode = DMA_NORMAL;
    hdma_spi3_tx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi3_tx);
 80007ce:	f000 fb91 	bl	8000ef4 <HAL_DMA_Init>

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi3_tx);
 80007d2:	f8c5 4168 	str.w	r4, [r5, #360]	; 0x168
 80007d6:	6567      	str	r7, [r4, #84]	; 0x54
 80007d8:	e7c1      	b.n	800075e <HAL_SPI_MspInit+0x16>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __SPI1_CLK_ENABLE();
 80007da:	4b2e      	ldr	r3, [pc, #184]	; (8000894 <HAL_SPI_MspInit+0x14c>)
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral DMA init*/
  
    hdma_spi1_tx.Instance = DMA1_Channel3;
 80007dc:	4d2e      	ldr	r5, [pc, #184]	; (8000898 <HAL_SPI_MspInit+0x150>)
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __SPI1_CLK_ENABLE();
 80007de:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80007e0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80007e4:	661a      	str	r2, [r3, #96]	; 0x60
 80007e6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80007e8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = BT_SCK_Pin|BT_MISO_Pin|BT_MOSI_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80007ec:	2600      	movs	r6, #0
    /**SPI1 GPIO Configuration    
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = BT_SCK_Pin|BT_MISO_Pin|BT_MOSI_Pin;
 80007ee:	f04f 0ee0 	mov.w	lr, #224	; 0xe0
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __SPI1_CLK_ENABLE();
 80007f2:	9301      	str	r3, [sp, #4]
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = BT_SCK_Pin|BT_MISO_Pin|BT_MOSI_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80007f4:	2203      	movs	r2, #3
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80007f6:	2305      	movs	r3, #5
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80007f8:	a903      	add	r1, sp, #12
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = BT_SCK_Pin|BT_MISO_Pin|BT_MOSI_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80007fa:	2702      	movs	r7, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80007fc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    hdma_spi1_tx.Init.MemInc = DMA_MINC_DISABLE;
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi1_tx);
 8000800:	f105 09c8 	add.w	r9, r5, #200	; 0xc8
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __SPI1_CLK_ENABLE();
 8000804:	f8dd c004 	ldr.w	ip, [sp, #4]
    /**SPI1 GPIO Configuration    
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = BT_SCK_Pin|BT_MISO_Pin|BT_MOSI_Pin;
 8000808:	f8cd e00c 	str.w	lr, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800080c:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800080e:	9206      	str	r2, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8000810:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral DMA init*/
  
    hdma_spi1_tx.Instance = DMA1_Channel3;
    hdma_spi1_tx.Init.Request = DMA_REQUEST_1;
 8000812:	f04f 0801 	mov.w	r8, #1
    hdma_spi1_rx.Init.MemInc = DMA_MINC_DISABLE;
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi1_rx);
 8000816:	f505 7782 	add.w	r7, r5, #260	; 0x104
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = BT_SCK_Pin|BT_MISO_Pin|BT_MOSI_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800081a:	9605      	str	r6, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800081c:	f001 fbb0 	bl	8001f80 <HAL_GPIO_Init>

    /* Peripheral DMA init*/
  
    hdma_spi1_tx.Instance = DMA1_Channel3;
 8000820:	4a20      	ldr	r2, [pc, #128]	; (80008a4 <HAL_SPI_MspInit+0x15c>)
 8000822:	f8c5 20c8 	str.w	r2, [r5, #200]	; 0xc8
    hdma_spi1_tx.Init.Request = DMA_REQUEST_1;
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8000826:	2310      	movs	r3, #16
    hdma_spi1_tx.Init.MemInc = DMA_MINC_DISABLE;
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi1_tx);
 8000828:	4648      	mov	r0, r9

    /* Peripheral DMA init*/
  
    hdma_spi1_tx.Instance = DMA1_Channel3;
    hdma_spi1_tx.Init.Request = DMA_REQUEST_1;
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800082a:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 800082e:	f8c5 60d4 	str.w	r6, [r5, #212]	; 0xd4
    hdma_spi1_tx.Init.MemInc = DMA_MINC_DISABLE;
 8000832:	f8c5 60d8 	str.w	r6, [r5, #216]	; 0xd8
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8000836:	f8c5 60dc 	str.w	r6, [r5, #220]	; 0xdc
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800083a:	f8c5 60e0 	str.w	r6, [r5, #224]	; 0xe0
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
 800083e:	f8c5 60e4 	str.w	r6, [r5, #228]	; 0xe4
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
 8000842:	f8c5 60e8 	str.w	r6, [r5, #232]	; 0xe8
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral DMA init*/
  
    hdma_spi1_tx.Instance = DMA1_Channel3;
    hdma_spi1_tx.Init.Request = DMA_REQUEST_1;
 8000846:	f8c5 80cc 	str.w	r8, [r5, #204]	; 0xcc
    hdma_spi1_tx.Init.MemInc = DMA_MINC_DISABLE;
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi1_tx);
 800084a:	f000 fb53 	bl	8000ef4 <HAL_DMA_Init>

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);

    hdma_spi1_rx.Instance = DMA1_Channel2;
 800084e:	4b16      	ldr	r3, [pc, #88]	; (80008a8 <HAL_SPI_MspInit+0x160>)
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi1_tx);

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);
 8000850:	f8c4 9054 	str.w	r9, [r4, #84]	; 0x54
    hdma_spi1_rx.Init.MemInc = DMA_MINC_DISABLE;
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi1_rx);
 8000854:	4638      	mov	r0, r7
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi1_tx);

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);
 8000856:	f8c5 40f0 	str.w	r4, [r5, #240]	; 0xf0

    hdma_spi1_rx.Instance = DMA1_Channel2;
    hdma_spi1_rx.Init.Request = DMA_REQUEST_1;
 800085a:	f8c5 8108 	str.w	r8, [r5, #264]	; 0x108
    hdma_spi1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800085e:	f8c5 610c 	str.w	r6, [r5, #268]	; 0x10c
    hdma_spi1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000862:	f8c5 6110 	str.w	r6, [r5, #272]	; 0x110
    hdma_spi1_rx.Init.MemInc = DMA_MINC_DISABLE;
 8000866:	f8c5 6114 	str.w	r6, [r5, #276]	; 0x114
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800086a:	f8c5 6118 	str.w	r6, [r5, #280]	; 0x118
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800086e:	f8c5 611c 	str.w	r6, [r5, #284]	; 0x11c
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
 8000872:	f8c5 6120 	str.w	r6, [r5, #288]	; 0x120
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_LOW;
 8000876:	f8c5 6124 	str.w	r6, [r5, #292]	; 0x124
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi1_tx);

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);

    hdma_spi1_rx.Instance = DMA1_Channel2;
 800087a:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
    hdma_spi1_rx.Init.MemInc = DMA_MINC_DISABLE;
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_spi1_rx);
 800087e:	f000 fb39 	bl	8000ef4 <HAL_DMA_Init>

    __HAL_LINKDMA(hspi,hdmarx,hdma_spi1_rx);
 8000882:	65a7      	str	r7, [r4, #88]	; 0x58
 8000884:	f8c5 412c 	str.w	r4, [r5, #300]	; 0x12c
 8000888:	e769      	b.n	800075e <HAL_SPI_MspInit+0x16>
 800088a:	bf00      	nop
 800088c:	40013000 	.word	0x40013000
 8000890:	40003c00 	.word	0x40003c00
 8000894:	40021000 	.word	0x40021000
 8000898:	200004ac 	.word	0x200004ac
 800089c:	48000800 	.word	0x48000800
 80008a0:	4002041c 	.word	0x4002041c
 80008a4:	40020030 	.word	0x40020030
 80008a8:	4002001c 	.word	0x4002001c

080008ac <HAL_SPI_MspDeInit>:
  /* USER CODE END SPI3_MspInit 1 */
  }
}

void HAL_SPI_MspDeInit(SPI_HandleTypeDef* hspi)
{
 80008ac:	b510      	push	{r4, lr}

  if(hspi->Instance==SPI1)
 80008ae:	4a16      	ldr	r2, [pc, #88]	; (8000908 <HAL_SPI_MspDeInit+0x5c>)
 80008b0:	6803      	ldr	r3, [r0, #0]
 80008b2:	4293      	cmp	r3, r2
  /* USER CODE END SPI3_MspInit 1 */
  }
}

void HAL_SPI_MspDeInit(SPI_HandleTypeDef* hspi)
{
 80008b4:	4604      	mov	r4, r0

  if(hspi->Instance==SPI1)
 80008b6:	d013      	beq.n	80008e0 <HAL_SPI_MspDeInit+0x34>
    HAL_DMA_DeInit(hspi->hdmarx);
  /* USER CODE BEGIN SPI1_MspDeInit 1 */

  /* USER CODE END SPI1_MspDeInit 1 */
  }
  else if(hspi->Instance==SPI3)
 80008b8:	4a14      	ldr	r2, [pc, #80]	; (800090c <HAL_SPI_MspDeInit+0x60>)
 80008ba:	4293      	cmp	r3, r2
 80008bc:	d000      	beq.n	80008c0 <HAL_SPI_MspDeInit+0x14>
 80008be:	bd10      	pop	{r4, pc}
  {
  /* USER CODE BEGIN SPI3_MspDeInit 0 */

  /* USER CODE END SPI3_MspDeInit 0 */
    /* Peripheral clock disable */
    __SPI3_CLK_DISABLE();
 80008c0:	f502 32ea 	add.w	r2, r2, #119808	; 0x1d400
  
    /**SPI3 GPIO Configuration    
    PC10     ------> SPI3_SCK
    PC12     ------> SPI3_MOSI 
    */
    HAL_GPIO_DeInit(GPIOC, OLED_SCK_Pin|OLED_MOSI_Pin);
 80008c4:	4812      	ldr	r0, [pc, #72]	; (8000910 <HAL_SPI_MspDeInit+0x64>)
  {
  /* USER CODE BEGIN SPI3_MspDeInit 0 */

  /* USER CODE END SPI3_MspDeInit 0 */
    /* Peripheral clock disable */
    __SPI3_CLK_DISABLE();
 80008c6:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80008c8:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80008cc:	6593      	str	r3, [r2, #88]	; 0x58
  
    /**SPI3 GPIO Configuration    
    PC10     ------> SPI3_SCK
    PC12     ------> SPI3_MOSI 
    */
    HAL_GPIO_DeInit(GPIOC, OLED_SCK_Pin|OLED_MOSI_Pin);
 80008ce:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
 80008d2:	f001 fc53 	bl	800217c <HAL_GPIO_DeInit>

    /* Peripheral DMA DeInit*/
    HAL_DMA_DeInit(hspi->hdmatx);
 80008d6:	6d60      	ldr	r0, [r4, #84]	; 0x54
  /* USER CODE BEGIN SPI3_MspDeInit 1 */

  /* USER CODE END SPI3_MspDeInit 1 */
  }
} 
 80008d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    PC12     ------> SPI3_MOSI 
    */
    HAL_GPIO_DeInit(GPIOC, OLED_SCK_Pin|OLED_MOSI_Pin);

    /* Peripheral DMA DeInit*/
    HAL_DMA_DeInit(hspi->hdmatx);
 80008dc:	f000 bbe4 	b.w	80010a8 <HAL_DMA_DeInit>
  {
  /* USER CODE BEGIN SPI1_MspDeInit 0 */

  /* USER CODE END SPI1_MspDeInit 0 */
    /* Peripheral clock disable */
    __SPI1_CLK_DISABLE();
 80008e0:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
    /**SPI1 GPIO Configuration    
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    HAL_GPIO_DeInit(GPIOA, BT_SCK_Pin|BT_MISO_Pin|BT_MOSI_Pin);
 80008e4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  {
  /* USER CODE BEGIN SPI1_MspDeInit 0 */

  /* USER CODE END SPI1_MspDeInit 0 */
    /* Peripheral clock disable */
    __SPI1_CLK_DISABLE();
 80008e8:	6e13      	ldr	r3, [r2, #96]	; 0x60
 80008ea:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80008ee:	6613      	str	r3, [r2, #96]	; 0x60
    /**SPI1 GPIO Configuration    
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    HAL_GPIO_DeInit(GPIOA, BT_SCK_Pin|BT_MISO_Pin|BT_MOSI_Pin);
 80008f0:	21e0      	movs	r1, #224	; 0xe0
 80008f2:	f001 fc43 	bl	800217c <HAL_GPIO_DeInit>

    /* Peripheral DMA DeInit*/
    HAL_DMA_DeInit(hspi->hdmatx);
 80008f6:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80008f8:	f000 fbd6 	bl	80010a8 <HAL_DMA_DeInit>
    HAL_DMA_DeInit(hspi->hdmarx);
 80008fc:	6da0      	ldr	r0, [r4, #88]	; 0x58
    HAL_DMA_DeInit(hspi->hdmatx);
  /* USER CODE BEGIN SPI3_MspDeInit 1 */

  /* USER CODE END SPI3_MspDeInit 1 */
  }
} 
 80008fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    */
    HAL_GPIO_DeInit(GPIOA, BT_SCK_Pin|BT_MISO_Pin|BT_MOSI_Pin);

    /* Peripheral DMA DeInit*/
    HAL_DMA_DeInit(hspi->hdmatx);
    HAL_DMA_DeInit(hspi->hdmarx);
 8000902:	f000 bbd1 	b.w	80010a8 <HAL_DMA_DeInit>
 8000906:	bf00      	nop
 8000908:	40013000 	.word	0x40013000
 800090c:	40003c00 	.word	0x40003c00
 8000910:	48000800 	.word	0x48000800

08000914 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000914:	b500      	push	{lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __SYSCFG_CLK_ENABLE();
 8000916:	4b0b      	ldr	r3, [pc, #44]	; (8000944 <HAL_MspInit+0x30>)
 8000918:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800091a:	f042 0201 	orr.w	r2, r2, #1
 800091e:	661a      	str	r2, [r3, #96]	; 0x60
 8000920:	6e1b      	ldr	r3, [r3, #96]	; 0x60

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000922:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __SYSCFG_CLK_ENABLE();
 8000924:	f003 0301 	and.w	r3, r3, #1
 8000928:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800092a:	2003      	movs	r0, #3
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __SYSCFG_CLK_ENABLE();
 800092c:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800092e:	f000 f9a9 	bl	8000c84 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8000932:	2100      	movs	r1, #0
 8000934:	460a      	mov	r2, r1
 8000936:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800093a:	f000 f9b5 	bl	8000ca8 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800093e:	b003      	add	sp, #12
 8000940:	f85d fb04 	ldr.w	pc, [sp], #4
 8000944:	40021000 	.word	0x40021000

08000948 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 8000948:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800094a:	f000 f8d5 	bl	8000af8 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800094e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 8000952:	f000 ba9d 	b.w	8000e90 <HAL_SYSTICK_IRQHandler>
 8000956:	bf00      	nop

08000958 <DMA1_Channel2_IRQHandler>:
void DMA1_Channel2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel2_IRQn 0 */

  /* USER CODE END DMA1_Channel2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_rx);
 8000958:	4801      	ldr	r0, [pc, #4]	; (8000960 <DMA1_Channel2_IRQHandler+0x8>)
 800095a:	f001 b85d 	b.w	8001a18 <HAL_DMA_IRQHandler>
 800095e:	bf00      	nop
 8000960:	200005b0 	.word	0x200005b0

08000964 <DMA1_Channel3_IRQHandler>:
void DMA1_Channel3_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel3_IRQn 0 */

  /* USER CODE END DMA1_Channel3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
 8000964:	4801      	ldr	r0, [pc, #4]	; (800096c <DMA1_Channel3_IRQHandler+0x8>)
 8000966:	f001 b857 	b.w	8001a18 <HAL_DMA_IRQHandler>
 800096a:	bf00      	nop
 800096c:	20000574 	.word	0x20000574

08000970 <DMA2_Channel2_IRQHandler>:
void DMA2_Channel2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Channel2_IRQn 0 */

  /* USER CODE END DMA2_Channel2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi3_tx);
 8000970:	4801      	ldr	r0, [pc, #4]	; (8000978 <DMA2_Channel2_IRQHandler+0x8>)
 8000972:	f001 b851 	b.w	8001a18 <HAL_DMA_IRQHandler>
 8000976:	bf00      	nop
 8000978:	200005ec 	.word	0x200005ec

0800097c <MX_USB_OTG_FS_PCD_Init>:
PCD_HandleTypeDef hpcd_USB_OTG_FS;

/* USB_OTG_FS init function */

void MX_USB_OTG_FS_PCD_Init(void)
{
 800097c:	b430      	push	{r4, r5}

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 800097e:	4b0a      	ldr	r3, [pc, #40]	; (80009a8 <MX_USB_OTG_FS_PCD_Init+0x2c>)
  hpcd_USB_OTG_FS.Init.dev_endpoints = 7;
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8000980:	2200      	movs	r2, #0
void MX_USB_OTG_FS_PCD_Init(void)
{

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 7;
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8000982:	2101      	movs	r1, #1
/* USB_OTG_FS init function */

void MX_USB_OTG_FS_PCD_Init(void)
{

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8000984:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
  hpcd_USB_OTG_FS.Init.dev_endpoints = 7;
 8000988:	2407      	movs	r4, #7
/* USB_OTG_FS init function */

void MX_USB_OTG_FS_PCD_Init(void)
{

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 800098a:	601d      	str	r5, [r3, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 7;
 800098c:	605c      	str	r4, [r3, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 800098e:	60d9      	str	r1, [r3, #12]
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8000990:	6199      	str	r1, [r3, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.battery_charging_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 8000992:	62d9      	str	r1, [r3, #44]	; 0x2c
{

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 7;
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8000994:	615a      	str	r2, [r3, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 8000996:	61da      	str	r2, [r3, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8000998:	621a      	str	r2, [r3, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 800099a:	625a      	str	r2, [r3, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.battery_charging_enable = DISABLE;
 800099c:	629a      	str	r2, [r3, #40]	; 0x28
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
  HAL_PCD_Init(&hpcd_USB_OTG_FS);
 800099e:	4618      	mov	r0, r3

}
 80009a0:	bc30      	pop	{r4, r5}
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.battery_charging_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
  HAL_PCD_Init(&hpcd_USB_OTG_FS);
 80009a2:	f003 be7d 	b.w	80046a0 <HAL_PCD_Init>
 80009a6:	bf00      	nop
 80009a8:	20000628 	.word	0x20000628

080009ac <HAL_PCD_MspInit>:

void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hpcd->Instance==USB_OTG_FS)
 80009ac:	6803      	ldr	r3, [r0, #0]
 80009ae:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80009b2:	d000      	beq.n	80009b6 <HAL_PCD_MspInit+0xa>
 80009b4:	4770      	bx	lr
  HAL_PCD_Init(&hpcd_USB_OTG_FS);

}

void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{
 80009b6:	b5f0      	push	{r4, r5, r6, r7, lr}
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __USB_OTG_FS_CLK_ENABLE();
 80009b8:	4c18      	ldr	r4, [pc, #96]	; (8000a1c <HAL_PCD_MspInit+0x70>)
  HAL_PCD_Init(&hpcd_USB_OTG_FS);

}

void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{
 80009ba:	b089      	sub	sp, #36	; 0x24
    */
    GPIO_InitStruct.Pin = USB_D__Pin|USB_D_A12_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80009bc:	230a      	movs	r3, #10
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = USB_D__Pin|USB_D_A12_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80009be:	2203      	movs	r2, #3
  
    /**USB_OTG_FS GPIO Configuration    
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = USB_D__Pin|USB_D_A12_Pin;
 80009c0:	f44f 57c0 	mov.w	r7, #6144	; 0x1800
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80009c4:	2602      	movs	r6, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80009c6:	2500      	movs	r5, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009c8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80009cc:	a903      	add	r1, sp, #12
    */
    GPIO_InitStruct.Pin = USB_D__Pin|USB_D_A12_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80009ce:	9307      	str	r3, [sp, #28]
  
    /**USB_OTG_FS GPIO Configuration    
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = USB_D__Pin|USB_D_A12_Pin;
 80009d0:	9703      	str	r7, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80009d2:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80009d4:	9505      	str	r5, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80009d6:	9206      	str	r2, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009d8:	f001 fad2 	bl	8001f80 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __USB_OTG_FS_CLK_ENABLE();
 80009dc:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80009de:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80009e2:	64e3      	str	r3, [r4, #76]	; 0x4c
 80009e4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80009e6:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80009ea:	9301      	str	r3, [sp, #4]
 80009ec:	9b01      	ldr	r3, [sp, #4]

    /* Enable VDDUSB */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80009ee:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80009f0:	00db      	lsls	r3, r3, #3
 80009f2:	d503      	bpl.n	80009fc <HAL_PCD_MspInit+0x50>
      HAL_PWREx_EnableVddUSB();
      __HAL_RCC_PWR_CLK_DISABLE();
    }
    else
    {
      HAL_PWREx_EnableVddUSB();
 80009f4:	f004 fcae 	bl	8005354 <HAL_PWREx_EnableVddUSB>
    }
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 80009f8:	b009      	add	sp, #36	; 0x24
 80009fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __USB_OTG_FS_CLK_ENABLE();

    /* Enable VDDUSB */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80009fc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80009fe:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000a02:	65a3      	str	r3, [r4, #88]	; 0x58
 8000a04:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000a06:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000a0a:	9302      	str	r3, [sp, #8]
 8000a0c:	9b02      	ldr	r3, [sp, #8]
      HAL_PWREx_EnableVddUSB();
 8000a0e:	f004 fca1 	bl	8005354 <HAL_PWREx_EnableVddUSB>
      __HAL_RCC_PWR_CLK_DISABLE();
 8000a12:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000a14:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000a18:	65a3      	str	r3, [r4, #88]	; 0x58
 8000a1a:	e7ed      	b.n	80009f8 <HAL_PCD_MspInit+0x4c>
 8000a1c:	40021000 	.word	0x40021000

08000a20 <HAL_PCD_MspDeInit>:
}

void HAL_PCD_MspDeInit(PCD_HandleTypeDef* hpcd)
{

  if(hpcd->Instance==USB_OTG_FS)
 8000a20:	6803      	ldr	r3, [r0, #0]
 8000a22:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000a26:	d000      	beq.n	8000a2a <HAL_PCD_MspDeInit+0xa>
 8000a28:	4770      	bx	lr
  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}

void HAL_PCD_MspDeInit(PCD_HandleTypeDef* hpcd)
{
 8000a2a:	b510      	push	{r4, lr}
  {
  /* USER CODE BEGIN USB_OTG_FS_MspDeInit 0 */

  /* USER CODE END USB_OTG_FS_MspDeInit 0 */
    /* Peripheral clock disable */
    __USB_OTG_FS_CLK_DISABLE();
 8000a2c:	4c11      	ldr	r4, [pc, #68]	; (8000a74 <HAL_PCD_MspDeInit+0x54>)
 8000a2e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8000a30:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000a34:	64e3      	str	r3, [r4, #76]	; 0x4c
  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}

void HAL_PCD_MspDeInit(PCD_HandleTypeDef* hpcd)
{
 8000a36:	b082      	sub	sp, #8
  
    /**USB_OTG_FS GPIO Configuration    
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    HAL_GPIO_DeInit(GPIOA, USB_D__Pin|USB_D_A12_Pin);
 8000a38:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000a3c:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
 8000a40:	f001 fb9c 	bl	800217c <HAL_GPIO_DeInit>

    /* Disable VDDUSB */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000a44:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000a46:	00db      	lsls	r3, r3, #3
 8000a48:	d503      	bpl.n	8000a52 <HAL_PCD_MspDeInit+0x32>
      HAL_PWREx_DisableVddUSB();
      __HAL_RCC_PWR_CLK_DISABLE();
    }
    else
    {
      HAL_PWREx_DisableVddUSB();
 8000a4a:	f004 fc8b 	bl	8005364 <HAL_PWREx_DisableVddUSB>
    }
  }
  /* USER CODE BEGIN USB_OTG_FS_MspDeInit 1 */

  /* USER CODE END USB_OTG_FS_MspDeInit 1 */
} 
 8000a4e:	b002      	add	sp, #8
 8000a50:	bd10      	pop	{r4, pc}
    HAL_GPIO_DeInit(GPIOA, USB_D__Pin|USB_D_A12_Pin);

    /* Disable VDDUSB */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000a52:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000a54:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000a58:	65a3      	str	r3, [r4, #88]	; 0x58
 8000a5a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000a5c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000a60:	9301      	str	r3, [sp, #4]
 8000a62:	9b01      	ldr	r3, [sp, #4]
      HAL_PWREx_DisableVddUSB();
 8000a64:	f004 fc7e 	bl	8005364 <HAL_PWREx_DisableVddUSB>
      __HAL_RCC_PWR_CLK_DISABLE();
 8000a68:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000a6a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000a6e:	65a3      	str	r3, [r4, #88]	; 0x58
 8000a70:	e7ed      	b.n	8000a4e <HAL_PCD_MspDeInit+0x2e>
 8000a72:	bf00      	nop
 8000a74:	40021000 	.word	0x40021000
/**
  * @brief  Initialize the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
 8000a78:	4770      	bx	lr
 8000a7a:	bf00      	nop

08000a7c <HAL_MspDeInit>:
/**
  * @brief  DeInitialize the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
 8000a7c:	4770      	bx	lr
 8000a7e:	bf00      	nop

08000a80 <HAL_DeInit>:
  * @brief De-initialize common part of the HAL and stop the source of time base.
  * @note This function is optional.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
 8000a80:	b510      	push	{r4, lr}
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
 8000a82:	4b09      	ldr	r3, [pc, #36]	; (8000aa8 <HAL_DeInit+0x28>)
 8000a84:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  __HAL_RCC_APB1_RELEASE_RESET();
 8000a88:	2400      	movs	r4, #0
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
 8000a8a:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_RCC_APB1_RELEASE_RESET();
 8000a8c:	639c      	str	r4, [r3, #56]	; 0x38

  __HAL_RCC_APB2_FORCE_RESET();
 8000a8e:	641a      	str	r2, [r3, #64]	; 0x40
  __HAL_RCC_APB2_RELEASE_RESET();
 8000a90:	641c      	str	r4, [r3, #64]	; 0x40

  __HAL_RCC_AHB1_FORCE_RESET();
 8000a92:	629a      	str	r2, [r3, #40]	; 0x28
  __HAL_RCC_AHB1_RELEASE_RESET();
 8000a94:	629c      	str	r4, [r3, #40]	; 0x28

  __HAL_RCC_AHB2_FORCE_RESET();
 8000a96:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_RCC_AHB2_RELEASE_RESET();
 8000a98:	62dc      	str	r4, [r3, #44]	; 0x2c

  __HAL_RCC_AHB3_FORCE_RESET();
 8000a9a:	631a      	str	r2, [r3, #48]	; 0x30
  __HAL_RCC_AHB3_RELEASE_RESET();
 8000a9c:	631c      	str	r4, [r3, #48]	; 0x30

  /* De-Init the low level hardware */
  HAL_MspDeInit();
 8000a9e:	f7ff ffed 	bl	8000a7c <HAL_MspDeInit>

  /* Return function status */
  return HAL_OK;
}
 8000aa2:	4620      	mov	r0, r4
 8000aa4:	bd10      	pop	{r4, pc}
 8000aa6:	bf00      	nop
 8000aa8:	40021000 	.word	0x40021000

08000aac <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000aac:	b510      	push	{r4, lr}
 8000aae:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8000ab0:	f005 fdfa 	bl	80066a8 <HAL_RCC_GetHCLKFreq>
 8000ab4:	4b06      	ldr	r3, [pc, #24]	; (8000ad0 <HAL_InitTick+0x24>)
 8000ab6:	fba3 3000 	umull	r3, r0, r3, r0
 8000aba:	0980      	lsrs	r0, r0, #6
 8000abc:	f000 f954 	bl	8000d68 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8000ac0:	4621      	mov	r1, r4
 8000ac2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000ac6:	2200      	movs	r2, #0
 8000ac8:	f000 f8ee 	bl	8000ca8 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8000acc:	2000      	movs	r0, #0
 8000ace:	bd10      	pop	{r4, pc}
 8000ad0:	10624dd3 	.word	0x10624dd3

08000ad4 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000ad4:	b508      	push	{r3, lr}
#if (DATA_CACHE_ENABLE == 0)
   __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000ad6:	4a07      	ldr	r2, [pc, #28]	; (8000af4 <HAL_Init+0x20>)
 8000ad8:	6813      	ldr	r3, [r2, #0]
 8000ada:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000ade:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000ae0:	2003      	movs	r0, #3
 8000ae2:	f000 f8cf 	bl	8000c84 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000ae6:	2000      	movs	r0, #0
 8000ae8:	f7ff ffe0 	bl	8000aac <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000aec:	f7ff ff12 	bl	8000914 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8000af0:	2000      	movs	r0, #0
 8000af2:	bd08      	pop	{r3, pc}
 8000af4:	40022000 	.word	0x40022000

08000af8 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000af8:	4a02      	ldr	r2, [pc, #8]	; (8000b04 <HAL_IncTick+0xc>)
 8000afa:	6813      	ldr	r3, [r2, #0]
 8000afc:	3301      	adds	r3, #1
 8000afe:	6013      	str	r3, [r2, #0]
 8000b00:	4770      	bx	lr
 8000b02:	bf00      	nop
 8000b04:	200009f0 	.word	0x200009f0

08000b08 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000b08:	4b01      	ldr	r3, [pc, #4]	; (8000b10 <HAL_GetTick+0x8>)
 8000b0a:	6818      	ldr	r0, [r3, #0]
}
 8000b0c:	4770      	bx	lr
 8000b0e:	bf00      	nop
 8000b10:	200009f0 	.word	0x200009f0

08000b14 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000b14:	b538      	push	{r3, r4, r5, lr}
 8000b16:	4605      	mov	r5, r0
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 8000b18:	f7ff fff6 	bl	8000b08 <HAL_GetTick>
 8000b1c:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8000b1e:	f7ff fff3 	bl	8000b08 <HAL_GetTick>
 8000b22:	1b00      	subs	r0, r0, r4
 8000b24:	42a8      	cmp	r0, r5
 8000b26:	d3fa      	bcc.n	8000b1e <HAL_Delay+0xa>
  {
  }
}
 8000b28:	bd38      	pop	{r3, r4, r5, pc}
 8000b2a:	bf00      	nop

08000b2c <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
 8000b2c:	4a02      	ldr	r2, [pc, #8]	; (8000b38 <HAL_SuspendTick+0xc>)
 8000b2e:	6813      	ldr	r3, [r2, #0]
 8000b30:	f023 0302 	bic.w	r3, r3, #2
 8000b34:	6013      	str	r3, [r2, #0]
 8000b36:	4770      	bx	lr
 8000b38:	e000e010 	.word	0xe000e010

08000b3c <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
 8000b3c:	4a02      	ldr	r2, [pc, #8]	; (8000b48 <HAL_ResumeTick+0xc>)
 8000b3e:	6813      	ldr	r3, [r2, #0]
 8000b40:	f043 0302 	orr.w	r3, r3, #2
 8000b44:	6013      	str	r3, [r2, #0]
 8000b46:	4770      	bx	lr
 8000b48:	e000e010 	.word	0xe000e010

08000b4c <HAL_GetHalVersion>:
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
 return __STM32L4xx_HAL_VERSION;
}
 8000b4c:	4800      	ldr	r0, [pc, #0]	; (8000b50 <HAL_GetHalVersion+0x4>)
 8000b4e:	4770      	bx	lr
 8000b50:	01010100 	.word	0x01010100

08000b54 <HAL_GetREVID>:
  * @brief  Return the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE & DBGMCU_IDCODE_REV_ID) >> 16);
 8000b54:	4b01      	ldr	r3, [pc, #4]	; (8000b5c <HAL_GetREVID+0x8>)
 8000b56:	6818      	ldr	r0, [r3, #0]
}
 8000b58:	0c00      	lsrs	r0, r0, #16
 8000b5a:	4770      	bx	lr
 8000b5c:	e0042000 	.word	0xe0042000

08000b60 <HAL_GetDEVID>:
  * @brief  Return the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
   return(DBGMCU->IDCODE & DBGMCU_IDCODE_DEV_ID);
 8000b60:	4b02      	ldr	r3, [pc, #8]	; (8000b6c <HAL_GetDEVID+0xc>)
 8000b62:	6818      	ldr	r0, [r3, #0]
}
 8000b64:	f3c0 000b 	ubfx	r0, r0, #0, #12
 8000b68:	4770      	bx	lr
 8000b6a:	bf00      	nop
 8000b6c:	e0042000 	.word	0xe0042000

08000b70 <HAL_DBGMCU_EnableDBGSleepMode>:
  * @brief  Enable the Debug Module during SLEEP mode.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8000b70:	4a02      	ldr	r2, [pc, #8]	; (8000b7c <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 8000b72:	6853      	ldr	r3, [r2, #4]
 8000b74:	f043 0301 	orr.w	r3, r3, #1
 8000b78:	6053      	str	r3, [r2, #4]
 8000b7a:	4770      	bx	lr
 8000b7c:	e0042000 	.word	0xe0042000

08000b80 <HAL_DBGMCU_DisableDBGSleepMode>:
  * @brief  Disable the Debug Module during SLEEP mode.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8000b80:	4a02      	ldr	r2, [pc, #8]	; (8000b8c <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
 8000b82:	6853      	ldr	r3, [r2, #4]
 8000b84:	f023 0301 	bic.w	r3, r3, #1
 8000b88:	6053      	str	r3, [r2, #4]
 8000b8a:	4770      	bx	lr
 8000b8c:	e0042000 	.word	0xe0042000

08000b90 <HAL_DBGMCU_EnableDBGStopMode>:
  * @brief  Enable the Debug Module during STOP1/STOP2 modes.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8000b90:	4a02      	ldr	r2, [pc, #8]	; (8000b9c <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 8000b92:	6853      	ldr	r3, [r2, #4]
 8000b94:	f043 0302 	orr.w	r3, r3, #2
 8000b98:	6053      	str	r3, [r2, #4]
 8000b9a:	4770      	bx	lr
 8000b9c:	e0042000 	.word	0xe0042000

08000ba0 <HAL_DBGMCU_DisableDBGStopMode>:
  * @brief  Disable the Debug Module during STOP1/STOP2 modes.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8000ba0:	4a02      	ldr	r2, [pc, #8]	; (8000bac <HAL_DBGMCU_DisableDBGStopMode+0xc>)
 8000ba2:	6853      	ldr	r3, [r2, #4]
 8000ba4:	f023 0302 	bic.w	r3, r3, #2
 8000ba8:	6053      	str	r3, [r2, #4]
 8000baa:	4770      	bx	lr
 8000bac:	e0042000 	.word	0xe0042000

08000bb0 <HAL_DBGMCU_EnableDBGStandbyMode>:
  * @brief  Enable the Debug Module during STANDBY mode.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 8000bb0:	4a02      	ldr	r2, [pc, #8]	; (8000bbc <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 8000bb2:	6853      	ldr	r3, [r2, #4]
 8000bb4:	f043 0304 	orr.w	r3, r3, #4
 8000bb8:	6053      	str	r3, [r2, #4]
 8000bba:	4770      	bx	lr
 8000bbc:	e0042000 	.word	0xe0042000

08000bc0 <HAL_DBGMCU_DisableDBGStandbyMode>:
  * @brief  Disable the Debug Module during STANDBY mode.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 8000bc0:	4a02      	ldr	r2, [pc, #8]	; (8000bcc <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
 8000bc2:	6853      	ldr	r3, [r2, #4]
 8000bc4:	f023 0304 	bic.w	r3, r3, #4
 8000bc8:	6053      	str	r3, [r2, #4]
 8000bca:	4770      	bx	lr
 8000bcc:	e0042000 	.word	0xe0042000

08000bd0 <HAL_SYSCFG_SRAM2Erase>:
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
 8000bd0:	4b05      	ldr	r3, [pc, #20]	; (8000be8 <HAL_SYSCFG_SRAM2Erase+0x18>)
  SYSCFG->SKR = 0x53;
  /* Starts a hardware SRAM2 erase operation*/
  *(__IO uint32_t *) SCSR_SRAM2ER_BB = (uint8_t)0x00000001;
 8000bd2:	4a06      	ldr	r2, [pc, #24]	; (8000bec <HAL_SYSCFG_SRAM2Erase+0x1c>)
  * @note   As long as SRAM2 is not erased the SRAM2ER bit will be set.
  *         This bit is automatically reset at the end of the SRAM2 erase operation.
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
 8000bd4:	b410      	push	{r4}
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
  SYSCFG->SKR = 0x53;
 8000bd6:	2053      	movs	r0, #83	; 0x53
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
 8000bd8:	24ca      	movs	r4, #202	; 0xca
  SYSCFG->SKR = 0x53;
  /* Starts a hardware SRAM2 erase operation*/
  *(__IO uint32_t *) SCSR_SRAM2ER_BB = (uint8_t)0x00000001;
 8000bda:	2101      	movs	r1, #1
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
{
  /* unlock the write protection of the SRAM2ER bit */
  SYSCFG->SKR = 0xCA;
 8000bdc:	625c      	str	r4, [r3, #36]	; 0x24
  SYSCFG->SKR = 0x53;
 8000bde:	6258      	str	r0, [r3, #36]	; 0x24
  /* Starts a hardware SRAM2 erase operation*/
  *(__IO uint32_t *) SCSR_SRAM2ER_BB = (uint8_t)0x00000001;
 8000be0:	6011      	str	r1, [r2, #0]
}
 8000be2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000be6:	4770      	bx	lr
 8000be8:	40010000 	.word	0x40010000
 8000bec:	42200300 	.word	0x42200300

08000bf0 <HAL_SYSCFG_EnableMemorySwappingBank>:
  *
  * @retval None
  */
void HAL_SYSCFG_EnableMemorySwappingBank(void)
{
  *(__IO uint32_t *)FB_MODE_BB = (uint32_t)ENABLE;
 8000bf0:	4b01      	ldr	r3, [pc, #4]	; (8000bf8 <HAL_SYSCFG_EnableMemorySwappingBank+0x8>)
 8000bf2:	2201      	movs	r2, #1
 8000bf4:	601a      	str	r2, [r3, #0]
 8000bf6:	4770      	bx	lr
 8000bf8:	42200020 	.word	0x42200020

08000bfc <HAL_SYSCFG_DisableMemorySwappingBank>:
  * @retval None
  */
void HAL_SYSCFG_DisableMemorySwappingBank(void)
{

  *(__IO uint32_t *)FB_MODE_BB = (uint32_t)DISABLE;
 8000bfc:	4b01      	ldr	r3, [pc, #4]	; (8000c04 <HAL_SYSCFG_DisableMemorySwappingBank+0x8>)
 8000bfe:	2200      	movs	r2, #0
 8000c00:	601a      	str	r2, [r3, #0]
 8000c02:	4770      	bx	lr
 8000c04:	42200020 	.word	0x42200020

08000c08 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig>:
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));
  
  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
 8000c08:	4a03      	ldr	r2, [pc, #12]	; (8000c18 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x10>)
 8000c0a:	6813      	ldr	r3, [r2, #0]
 8000c0c:	f023 0304 	bic.w	r3, r3, #4
 8000c10:	4318      	orrs	r0, r3
 8000c12:	6010      	str	r0, [r2, #0]
 8000c14:	4770      	bx	lr
 8000c16:	bf00      	nop
 8000c18:	40010030 	.word	0x40010030

08000c1c <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));
  
  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
 8000c1c:	4a03      	ldr	r2, [pc, #12]	; (8000c2c <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x10>)
 8000c1e:	6813      	ldr	r3, [r2, #0]
 8000c20:	f023 0302 	bic.w	r3, r3, #2
 8000c24:	4318      	orrs	r0, r3
 8000c26:	6010      	str	r0, [r2, #0]
 8000c28:	4770      	bx	lr
 8000c2a:	bf00      	nop
 8000c2c:	40010030 	.word	0x40010030

08000c30 <HAL_SYSCFG_VREFBUF_TrimmingConfig>:
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));
  
  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
 8000c30:	4a03      	ldr	r2, [pc, #12]	; (8000c40 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x10>)
 8000c32:	6853      	ldr	r3, [r2, #4]
 8000c34:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8000c38:	4318      	orrs	r0, r3
 8000c3a:	6050      	str	r0, [r2, #4]
 8000c3c:	4770      	bx	lr
 8000c3e:	bf00      	nop
 8000c40:	40010030 	.word	0x40010030

08000c44 <HAL_SYSCFG_EnableVREFBUF>:
/**
  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
  * @retval HAL_OK/HAL_TIMEOUT
  */
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
{
 8000c44:	b538      	push	{r3, r4, r5, lr}
  uint32_t  tickstart = 0;
  
  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
 8000c46:	4c0a      	ldr	r4, [pc, #40]	; (8000c70 <HAL_SYSCFG_EnableVREFBUF+0x2c>)
 8000c48:	6823      	ldr	r3, [r4, #0]
 8000c4a:	f043 0301 	orr.w	r3, r3, #1
 8000c4e:	6023      	str	r3, [r4, #0]
  
  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8000c50:	f7ff ff5a 	bl	8000b08 <HAL_GetTick>
 8000c54:	4605      	mov	r5, r0

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == RESET)
 8000c56:	e004      	b.n	8000c62 <HAL_SYSCFG_EnableVREFBUF+0x1e>
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
 8000c58:	f7ff ff56 	bl	8000b08 <HAL_GetTick>
 8000c5c:	1b40      	subs	r0, r0, r5
 8000c5e:	280a      	cmp	r0, #10
 8000c60:	d804      	bhi.n	8000c6c <HAL_SYSCFG_EnableVREFBUF+0x28>
  
  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == RESET)
 8000c62:	6823      	ldr	r3, [r4, #0]
 8000c64:	071b      	lsls	r3, r3, #28
 8000c66:	d5f7      	bpl.n	8000c58 <HAL_SYSCFG_EnableVREFBUF+0x14>
    {
      return HAL_TIMEOUT;
    }
  }
  
  return HAL_OK;
 8000c68:	2000      	movs	r0, #0
 8000c6a:	bd38      	pop	{r3, r4, r5, pc}
  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == RESET)
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
 8000c6c:	2003      	movs	r0, #3
    }
  }
  
  return HAL_OK;
}
 8000c6e:	bd38      	pop	{r3, r4, r5, pc}
 8000c70:	40010030 	.word	0x40010030

08000c74 <HAL_SYSCFG_DisableVREFBUF>:
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
 8000c74:	4a02      	ldr	r2, [pc, #8]	; (8000c80 <HAL_SYSCFG_DisableVREFBUF+0xc>)
 8000c76:	6813      	ldr	r3, [r2, #0]
 8000c78:	f023 0301 	bic.w	r3, r3, #1
 8000c7c:	6013      	str	r3, [r2, #0]
 8000c7e:	4770      	bx	lr
 8000c80:	40010030 	.word	0x40010030

08000c84 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000c84:	4a07      	ldr	r2, [pc, #28]	; (8000ca4 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000c86:	68d1      	ldr	r1, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8000c88:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8000c8c:	400b      	ands	r3, r1
 8000c8e:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8000c92:	f000 0007 	and.w	r0, r0, #7
 8000c96:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000c9a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000c9e:	60d3      	str	r3, [r2, #12]
 8000ca0:	4770      	bx	lr
 8000ca2:	bf00      	nop
 8000ca4:	e000ed00 	.word	0xe000ed00

08000ca8 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000ca8:	b430      	push	{r4, r5}

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000caa:	4b18      	ldr	r3, [pc, #96]	; (8000d0c <HAL_NVIC_SetPriority+0x64>)
 8000cac:	68db      	ldr	r3, [r3, #12]
 8000cae:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000cb2:	f1c3 0507 	rsb	r5, r3, #7
 8000cb6:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000cb8:	f103 0404 	add.w	r4, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000cbc:	bf28      	it	cs
 8000cbe:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000cc0:	2c06      	cmp	r4, #6
 8000cc2:	d917      	bls.n	8000cf4 <HAL_NVIC_SetPriority+0x4c>
 8000cc4:	3b03      	subs	r3, #3
 8000cc6:	2401      	movs	r4, #1
 8000cc8:	409c      	lsls	r4, r3
 8000cca:	3c01      	subs	r4, #1
 8000ccc:	4022      	ands	r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000cce:	2401      	movs	r4, #1
 8000cd0:	40ac      	lsls	r4, r5
 8000cd2:	3c01      	subs	r4, #1
 8000cd4:	4021      	ands	r1, r4
 8000cd6:	4099      	lsls	r1, r3
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
 8000cd8:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000cda:	ea42 0201 	orr.w	r2, r2, r1
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
 8000cde:	db0c      	blt.n	8000cfa <HAL_NVIC_SetPriority+0x52>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ce0:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000ce4:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000ce8:	0112      	lsls	r2, r2, #4
 8000cea:	b2d2      	uxtb	r2, r2
 8000cec:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000cf0:	bc30      	pop	{r4, r5}
 8000cf2:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000cf4:	2200      	movs	r2, #0
 8000cf6:	4613      	mov	r3, r2
 8000cf8:	e7e9      	b.n	8000cce <HAL_NVIC_SetPriority+0x26>
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000cfa:	4b05      	ldr	r3, [pc, #20]	; (8000d10 <HAL_NVIC_SetPriority+0x68>)
 8000cfc:	f000 000f 	and.w	r0, r0, #15
 8000d00:	0112      	lsls	r2, r2, #4
 8000d02:	4403      	add	r3, r0
 8000d04:	b2d2      	uxtb	r2, r2
 8000d06:	761a      	strb	r2, [r3, #24]
 8000d08:	bc30      	pop	{r4, r5}
 8000d0a:	4770      	bx	lr
 8000d0c:	e000ed00 	.word	0xe000ed00
 8000d10:	e000ecfc 	.word	0xe000ecfc

08000d14 <HAL_NVIC_EnableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000d14:	f000 011f 	and.w	r1, r0, #31
 8000d18:	2301      	movs	r3, #1
 8000d1a:	0940      	lsrs	r0, r0, #5
 8000d1c:	4a02      	ldr	r2, [pc, #8]	; (8000d28 <HAL_NVIC_EnableIRQ+0x14>)
 8000d1e:	408b      	lsls	r3, r1
 8000d20:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 8000d24:	4770      	bx	lr
 8000d26:	bf00      	nop
 8000d28:	e000e100 	.word	0xe000e100

08000d2c <HAL_NVIC_DisableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000d2c:	0943      	lsrs	r3, r0, #5
 8000d2e:	3320      	adds	r3, #32
 8000d30:	f000 001f 	and.w	r0, r0, #31
 8000d34:	2201      	movs	r2, #1
 8000d36:	4902      	ldr	r1, [pc, #8]	; (8000d40 <HAL_NVIC_DisableIRQ+0x14>)
 8000d38:	4082      	lsls	r2, r0
 8000d3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8000d3e:	4770      	bx	lr
 8000d40:	e000e100 	.word	0xe000e100

08000d44 <HAL_NVIC_SystemReset>:
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000d44:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8000d48:	4905      	ldr	r1, [pc, #20]	; (8000d60 <HAL_NVIC_SystemReset+0x1c>)
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8000d4a:	4b06      	ldr	r3, [pc, #24]	; (8000d64 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8000d4c:	68ca      	ldr	r2, [r1, #12]
 8000d4e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8000d52:	4313      	orrs	r3, r2
 8000d54:	60cb      	str	r3, [r1, #12]
 8000d56:	f3bf 8f4f 	dsb	sy

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 8000d5a:	bf00      	nop
 8000d5c:	e7fd      	b.n	8000d5a <HAL_NVIC_SystemReset+0x16>
 8000d5e:	bf00      	nop
 8000d60:	e000ed00 	.word	0xe000ed00
 8000d64:	05fa0004 	.word	0x05fa0004

08000d68 <HAL_SYSTICK_Config>:
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 8000d68:	3801      	subs	r0, #1
 8000d6a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000d6e:	d20e      	bcs.n	8000d8e <HAL_SYSTICK_Config+0x26>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000d70:	4b08      	ldr	r3, [pc, #32]	; (8000d94 <HAL_SYSTICK_Config+0x2c>)
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8000d72:	b410      	push	{r4}
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d74:	4c08      	ldr	r4, [pc, #32]	; (8000d98 <HAL_SYSTICK_Config+0x30>)
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000d76:	6058      	str	r0, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000d78:	2200      	movs	r2, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d7a:	20f0      	movs	r0, #240	; 0xf0
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000d7c:	2107      	movs	r1, #7
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d7e:	f884 0023 	strb.w	r0, [r4, #35]	; 0x23
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000d82:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000d84:	6019      	str	r1, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8000d86:	4610      	mov	r0, r2
   return SysTick_Config(TicksNumb);
}
 8000d88:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000d8c:	4770      	bx	lr
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 8000d8e:	2001      	movs	r0, #1
 8000d90:	4770      	bx	lr
 8000d92:	bf00      	nop
 8000d94:	e000e010 	.word	0xe000e010
 8000d98:	e000ed00 	.word	0xe000ed00

08000d9c <HAL_NVIC_GetPriorityGrouping>:

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000d9c:	4b02      	ldr	r3, [pc, #8]	; (8000da8 <HAL_NVIC_GetPriorityGrouping+0xc>)
 8000d9e:	68d8      	ldr	r0, [r3, #12]
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
}
 8000da0:	f3c0 2002 	ubfx	r0, r0, #8, #3
 8000da4:	4770      	bx	lr
 8000da6:	bf00      	nop
 8000da8:	e000ed00 	.word	0xe000ed00

08000dac <HAL_NVIC_GetPriority>:
                        priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if((int32_t)IRQn < 0) {
 8000dac:	2800      	cmp	r0, #0
  * @param  pPreemptPriority: Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority: Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
 8000dae:	b470      	push	{r4, r5, r6}
 8000db0:	db23      	blt.n	8000dfa <HAL_NVIC_GetPriority+0x4e>
    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
  }
  else {
    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - __NVIC_PRIO_BITS)));
 8000db2:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000db6:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000dba:	f890 4300 	ldrb.w	r4, [r0, #768]	; 0x300
 8000dbe:	0924      	lsrs	r4, r4, #4
    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
    \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000dc0:	f001 0107 	and.w	r1, r1, #7
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000dc4:	f1c1 0607 	rsb	r6, r1, #7
 8000dc8:	2e04      	cmp	r6, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000dca:	f101 0004 	add.w	r0, r1, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000dce:	bf28      	it	cs
 8000dd0:	2604      	movcs	r6, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000dd2:	2806      	cmp	r0, #6
 8000dd4:	d90e      	bls.n	8000df4 <HAL_NVIC_GetPriority+0x48>
 8000dd6:	3903      	subs	r1, #3
 8000dd8:	2501      	movs	r5, #1
 8000dda:	408d      	lsls	r5, r1
 8000ddc:	3d01      	subs	r5, #1
 8000dde:	4025      	ands	r5, r4

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
 8000de0:	2001      	movs	r0, #1
 8000de2:	40b0      	lsls	r0, r6
 8000de4:	40cc      	lsrs	r4, r1
 8000de6:	3801      	subs	r0, #1
 8000de8:	ea04 0100 	and.w	r1, r4, r0
 8000dec:	6011      	str	r1, [r2, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
 8000dee:	601d      	str	r5, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
}
 8000df0:	bc70      	pop	{r4, r5, r6}
 8000df2:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000df4:	2500      	movs	r5, #0
 8000df6:	4629      	mov	r1, r5
 8000df8:	e7f2      	b.n	8000de0 <HAL_NVIC_GetPriority+0x34>
 */
__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if((int32_t)IRQn < 0) {
    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
 8000dfa:	4c03      	ldr	r4, [pc, #12]	; (8000e08 <HAL_NVIC_GetPriority+0x5c>)
 8000dfc:	f000 000f 	and.w	r0, r0, #15
 8000e00:	4404      	add	r4, r0
 8000e02:	7e24      	ldrb	r4, [r4, #24]
 8000e04:	0924      	lsrs	r4, r4, #4
 8000e06:	e7db      	b.n	8000dc0 <HAL_NVIC_GetPriority+0x14>
 8000e08:	e000ecfc 	.word	0xe000ecfc

08000e0c <HAL_NVIC_SetPendingIRQ>:

    \param [in]      IRQn  Interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000e0c:	0943      	lsrs	r3, r0, #5
 8000e0e:	3340      	adds	r3, #64	; 0x40
 8000e10:	f000 001f 	and.w	r0, r0, #31
 8000e14:	2201      	movs	r2, #1
 8000e16:	4902      	ldr	r1, [pc, #8]	; (8000e20 <HAL_NVIC_SetPendingIRQ+0x14>)
 8000e18:	4082      	lsls	r2, r0
 8000e1a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8000e1e:	4770      	bx	lr
 8000e20:	e000e100 	.word	0xe000e100

08000e24 <HAL_NVIC_GetPendingIRQ>:
    \return             0  Interrupt status is not pending.
    \return             1  Interrupt status is pending.
 */
__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 8000e24:	0943      	lsrs	r3, r0, #5
 8000e26:	3340      	adds	r3, #64	; 0x40
 8000e28:	4a04      	ldr	r2, [pc, #16]	; (8000e3c <HAL_NVIC_GetPendingIRQ+0x18>)
 8000e2a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8000e2e:	f000 031f 	and.w	r3, r0, #31
 8000e32:	fa22 f003 	lsr.w	r0, r2, r3
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
}
 8000e36:	f000 0001 	and.w	r0, r0, #1
 8000e3a:	4770      	bx	lr
 8000e3c:	e000e100 	.word	0xe000e100

08000e40 <HAL_NVIC_ClearPendingIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000e40:	0943      	lsrs	r3, r0, #5
 8000e42:	3360      	adds	r3, #96	; 0x60
 8000e44:	f000 001f 	and.w	r0, r0, #31
 8000e48:	2201      	movs	r2, #1
 8000e4a:	4902      	ldr	r1, [pc, #8]	; (8000e54 <HAL_NVIC_ClearPendingIRQ+0x14>)
 8000e4c:	4082      	lsls	r2, r0
 8000e4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8000e52:	4770      	bx	lr
 8000e54:	e000e100 	.word	0xe000e100

08000e58 <HAL_NVIC_GetActive>:
    \return             0  Interrupt status is not active.
    \return             1  Interrupt status is active.
 */
__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
{
  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 8000e58:	0943      	lsrs	r3, r0, #5
 8000e5a:	3380      	adds	r3, #128	; 0x80
 8000e5c:	4a04      	ldr	r2, [pc, #16]	; (8000e70 <HAL_NVIC_GetActive+0x18>)
 8000e5e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8000e62:	f000 031f 	and.w	r3, r0, #31
 8000e66:	fa22 f003 	lsr.w	r0, r2, r3
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
}
 8000e6a:	f000 0001 	and.w	r0, r0, #1
 8000e6e:	4770      	bx	lr
 8000e70:	e000e100 	.word	0xe000e100

08000e74 <HAL_SYSTICK_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000e74:	4a04      	ldr	r2, [pc, #16]	; (8000e88 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 8000e76:	6813      	ldr	r3, [r2, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000e78:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000e7a:	bf0c      	ite	eq
 8000e7c:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000e80:	f023 0304 	bicne.w	r3, r3, #4
 8000e84:	6013      	str	r3, [r2, #0]
 8000e86:	4770      	bx	lr
 8000e88:	e000e010 	.word	0xe000e010

08000e8c <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000e8c:	4770      	bx	lr
 8000e8e:	bf00      	nop

08000e90 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  Handle SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8000e90:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8000e92:	f7ff fffb 	bl	8000e8c <HAL_SYSTICK_Callback>
 8000e96:	bd08      	pop	{r3, pc}

08000e98 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init: Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 8000e98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 8000e9c:	4d14      	ldr	r5, [pc, #80]	; (8000ef0 <HAL_MPU_ConfigRegion+0x58>)
 8000e9e:	7843      	ldrb	r3, [r0, #1]
 8000ea0:	60ab      	str	r3, [r5, #8]

  if ((MPU_Init->Enable) != RESET)
 8000ea2:	7803      	ldrb	r3, [r0, #0]
 8000ea4:	b91b      	cbnz	r3, 8000eae <HAL_MPU_ConfigRegion+0x16>
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable             << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00;
 8000ea6:	60eb      	str	r3, [r5, #12]
    MPU->RASR = 0x00;
 8000ea8:	612b      	str	r3, [r5, #16]
 8000eaa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
 8000eae:	6843      	ldr	r3, [r0, #4]
 8000eb0:	60eb      	str	r3, [r5, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
 8000eb2:	7ac6      	ldrb	r6, [r0, #11]
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
 8000eb4:	f890 800c 	ldrb.w	r8, [r0, #12]
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
 8000eb8:	7b42      	ldrb	r2, [r0, #13]
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
 8000eba:	7bc3      	ldrb	r3, [r0, #15]
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable             << MPU_RASR_ENABLE_Pos);
 8000ebc:	7804      	ldrb	r4, [r0, #0]
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
 8000ebe:	7a81      	ldrb	r1, [r0, #10]
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
 8000ec0:	f890 c00e 	ldrb.w	ip, [r0, #14]
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
 8000ec4:	f890 e009 	ldrb.w	lr, [r0, #9]
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
 8000ec8:	7a07      	ldrb	r7, [r0, #8]
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
 8000eca:	0630      	lsls	r0, r6, #24
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
 8000ecc:	ea40 7008 	orr.w	r0, r0, r8, lsl #28
 8000ed0:	4320      	orrs	r0, r4
 8000ed2:	ea40 41c1 	orr.w	r1, r0, r1, lsl #19
 8000ed6:	ea41 4182 	orr.w	r1, r1, r2, lsl #18
 8000eda:	ea41 424c 	orr.w	r2, r1, ip, lsl #17
 8000ede:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 8000ee2:	ea42 230e 	orr.w	r3, r2, lr, lsl #8
                ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
 8000ee6:	ea43 0347 	orr.w	r3, r3, r7, lsl #1
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
 8000eea:	612b      	str	r3, [r5, #16]
 8000eec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000ef0:	e000ed90 	.word	0xe000ed90

08000ef4 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp = 0;

  /* Check the DMA handle allocation */
  if(hdma == NULL)
 8000ef4:	4603      	mov	r3, r0
 8000ef6:	2800      	cmp	r0, #0
 8000ef8:	d064      	beq.n	8000fc4 <HAL_DMA_Init+0xd0>
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8000efa:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
  {
    assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));
  }
  
  if(hdma->State == HAL_DMA_STATE_RESET)
 8000efc:	f890 2025 	ldrb.w	r2, [r0, #37]	; 0x25
 8000f00:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 8000f04:	2a00      	cmp	r2, #0
 8000f06:	d04f      	beq.n	8000fa8 <HAL_DMA_Init+0xb4>
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8000f08:	68df      	ldr	r7, [r3, #12]
 8000f0a:	689e      	ldr	r6, [r3, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000f0c:	691d      	ldr	r5, [r3, #16]
 8000f0e:	6959      	ldr	r1, [r3, #20]

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 8000f10:	f8d3 e000 	ldr.w	lr, [r3]
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000f14:	699a      	ldr	r2, [r3, #24]
 8000f16:	69dc      	ldr	r4, [r3, #28]
          hdma->Init.Mode                | hdma->Init.Priority;
 8000f18:	6a18      	ldr	r0, [r3, #32]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8000f1a:	433e      	orrs	r6, r7
    /* Allocate lock resource and initialize it */
    hdma->Lock = HAL_UNLOCKED;
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8000f1c:	2702      	movs	r7, #2
 8000f1e:	f883 7025 	strb.w	r7, [r3, #37]	; 0x25
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000f22:	4335      	orrs	r5, r6
 8000f24:	430d      	orrs	r5, r1

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 8000f26:	f8de 1000 	ldr.w	r1, [lr]
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000f2a:	432a      	orrs	r2, r5
 8000f2c:	4314      	orrs	r4, r2

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;

  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8000f2e:	f421 527f 	bic.w	r2, r1, #16320	; 0x3fc0

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;
 8000f32:	4320      	orrs	r0, r4

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;

  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8000f34:	f022 0230 	bic.w	r2, r2, #48	; 0x30
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8000f38:	4302      	orrs	r2, r0
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;
 8000f3a:	f8ce 2000 	str.w	r2, [lr]

  /* Set request selection */
  if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
 8000f3e:	689a      	ldr	r2, [r3, #8]
 8000f40:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 8000f44:	d02a      	beq.n	8000f9c <HAL_DMA_Init+0xa8>
  {
    /* Write to DMA channel selection register */
    if (hdma->Instance == DMA1_Channel1)
 8000f46:	681a      	ldr	r2, [r3, #0]
 8000f48:	4947      	ldr	r1, [pc, #284]	; (8001068 <HAL_DMA_Init+0x174>)
 8000f4a:	428a      	cmp	r2, r1
 8000f4c:	d03c      	beq.n	8000fc8 <HAL_DMA_Init+0xd4>
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C1S;

      /* Configure request selection for DMA1 Channel1 */
      DMA1_CSELR->CSELR |= hdma->Init.Request;
    }
    else if (hdma->Instance == DMA1_Channel2)
 8000f4e:	4947      	ldr	r1, [pc, #284]	; (800106c <HAL_DMA_Init+0x178>)
 8000f50:	428a      	cmp	r2, r1
 8000f52:	d02c      	beq.n	8000fae <HAL_DMA_Init+0xba>
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C2S;

      /* Configure request selection for DMA1 Channel2 */
      DMA1_CSELR->CSELR |= (uint32_t)(hdma->Init.Request << 4);
    }
    else if (hdma->Instance == DMA1_Channel3)
 8000f54:	4946      	ldr	r1, [pc, #280]	; (8001070 <HAL_DMA_Init+0x17c>)
 8000f56:	428a      	cmp	r2, r1
 8000f58:	d040      	beq.n	8000fdc <HAL_DMA_Init+0xe8>
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C3S;

      /* Configure request selection for DMA1 Channel3 */
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 8);
    }
    else if (hdma->Instance == DMA1_Channel4)
 8000f5a:	4946      	ldr	r1, [pc, #280]	; (8001074 <HAL_DMA_Init+0x180>)
 8000f5c:	428a      	cmp	r2, r1
 8000f5e:	d048      	beq.n	8000ff2 <HAL_DMA_Init+0xfe>
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C4S;

      /* Configure request selection for DMA1 Channel4 */
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 12);
    }
    else if (hdma->Instance == DMA1_Channel5)
 8000f60:	4945      	ldr	r1, [pc, #276]	; (8001078 <HAL_DMA_Init+0x184>)
 8000f62:	428a      	cmp	r2, r1
 8000f64:	d050      	beq.n	8001008 <HAL_DMA_Init+0x114>
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C5S;

      /* Configure request selection for DMA1 Channel5 */
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 16);
    }
    else if (hdma->Instance == DMA1_Channel6)
 8000f66:	4945      	ldr	r1, [pc, #276]	; (800107c <HAL_DMA_Init+0x188>)
 8000f68:	428a      	cmp	r2, r1
 8000f6a:	d065      	beq.n	8001038 <HAL_DMA_Init+0x144>
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C6S;

      /* Configure request selection for DMA1 Channel6 */
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 20);
    }
    else if (hdma->Instance == DMA1_Channel7)
 8000f6c:	4944      	ldr	r1, [pc, #272]	; (8001080 <HAL_DMA_Init+0x18c>)
 8000f6e:	428a      	cmp	r2, r1
 8000f70:	d06d      	beq.n	800104e <HAL_DMA_Init+0x15a>
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C7S;

      /* Configure request selection for DMA1 Channel7 */
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 24);
    }
    else if (hdma->Instance == DMA2_Channel1)
 8000f72:	4944      	ldr	r1, [pc, #272]	; (8001084 <HAL_DMA_Init+0x190>)
 8000f74:	428a      	cmp	r2, r1
 8000f76:	d052      	beq.n	800101e <HAL_DMA_Init+0x12a>
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C1S;

      /* Configure request selection for DMA2 Channel1 */
      DMA2_CSELR->CSELR |= hdma->Init.Request;
    }
    else if (hdma->Instance == DMA2_Channel2)
 8000f78:	4943      	ldr	r1, [pc, #268]	; (8001088 <HAL_DMA_Init+0x194>)
 8000f7a:	428a      	cmp	r2, r1
 8000f7c:	d069      	beq.n	8001052 <HAL_DMA_Init+0x15e>
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C2S;

      /* Configure request selection for DMA2 Channel2 */
      DMA2_CSELR->CSELR |= (uint32_t)(hdma->Init.Request << 4);
    }
    else if (hdma->Instance == DMA2_Channel3)
 8000f7e:	4943      	ldr	r1, [pc, #268]	; (800108c <HAL_DMA_Init+0x198>)
 8000f80:	428a      	cmp	r2, r1
 8000f82:	d068      	beq.n	8001056 <HAL_DMA_Init+0x162>
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C3S;

      /* Configure request selection for DMA2 Channel3 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 8);
    }
    else if (hdma->Instance == DMA2_Channel4)
 8000f84:	4942      	ldr	r1, [pc, #264]	; (8001090 <HAL_DMA_Init+0x19c>)
 8000f86:	428a      	cmp	r2, r1
 8000f88:	d067      	beq.n	800105a <HAL_DMA_Init+0x166>
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C4S;

      /* Configure request selection for DMA2 Channel4 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 12);
    }
    else if (hdma->Instance == DMA2_Channel5)
 8000f8a:	4942      	ldr	r1, [pc, #264]	; (8001094 <HAL_DMA_Init+0x1a0>)
 8000f8c:	428a      	cmp	r2, r1
 8000f8e:	d066      	beq.n	800105e <HAL_DMA_Init+0x16a>
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C5S;

      /* Configure request selection for DMA2 Channel5 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 16);
    }
    else if (hdma->Instance == DMA2_Channel6)
 8000f90:	4941      	ldr	r1, [pc, #260]	; (8001098 <HAL_DMA_Init+0x1a4>)
 8000f92:	428a      	cmp	r2, r1
 8000f94:	d065      	beq.n	8001062 <HAL_DMA_Init+0x16e>
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C6S;

      /* Configure request selection for DMA2 Channel6 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 20);
    }
    else if (hdma->Instance == DMA2_Channel7)
 8000f96:	4941      	ldr	r1, [pc, #260]	; (800109c <HAL_DMA_Init+0x1a8>)
 8000f98:	428a      	cmp	r2, r1
 8000f9a:	d042      	beq.n	8001022 <HAL_DMA_Init+0x12e>
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 24);
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000f9c:	2000      	movs	r0, #0

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
 8000f9e:	2201      	movs	r2, #1
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 24);
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000fa0:	6398      	str	r0, [r3, #56]	; 0x38

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
 8000fa2:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  return HAL_OK;
 8000fa6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }
  
  if(hdma->State == HAL_DMA_STATE_RESET)
  {  
    /* Allocate lock resource and initialize it */
    hdma->Lock = HAL_UNLOCKED;
 8000fa8:	f880 1024 	strb.w	r1, [r0, #36]	; 0x24
 8000fac:	e7ac      	b.n	8000f08 <HAL_DMA_Init+0x14>
      DMA1_CSELR->CSELR |= hdma->Init.Request;
    }
    else if (hdma->Instance == DMA1_Channel2)
    {
      /*Reset request selection for DMA1 Channel2*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C2S;
 8000fae:	4a3c      	ldr	r2, [pc, #240]	; (80010a0 <HAL_DMA_Init+0x1ac>)
      DMA2_CSELR->CSELR |= hdma->Init.Request;
    }
    else if (hdma->Instance == DMA2_Channel2)
    {
      /*Reset request selection for DMA2 Channel2*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C2S;
 8000fb0:	6811      	ldr	r1, [r2, #0]
 8000fb2:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8000fb6:	6011      	str	r1, [r2, #0]

      /* Configure request selection for DMA2 Channel2 */
      DMA2_CSELR->CSELR |= (uint32_t)(hdma->Init.Request << 4);
 8000fb8:	6811      	ldr	r1, [r2, #0]
 8000fba:	6858      	ldr	r0, [r3, #4]
 8000fbc:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8000fc0:	6011      	str	r1, [r2, #0]
 8000fc2:	e7eb      	b.n	8000f9c <HAL_DMA_Init+0xa8>
  uint32_t tmp = 0;

  /* Check the DMA handle allocation */
  if(hdma == NULL)
  {
    return HAL_ERROR;
 8000fc4:	2001      	movs	r0, #1
 8000fc6:	4770      	bx	lr
  {
    /* Write to DMA channel selection register */
    if (hdma->Instance == DMA1_Channel1)
    {
      /*Reset request selection for DMA1 Channel1*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C1S;
 8000fc8:	4a35      	ldr	r2, [pc, #212]	; (80010a0 <HAL_DMA_Init+0x1ac>)
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 24);
    }
    else if (hdma->Instance == DMA2_Channel1)
    {
      /*Reset request selection for DMA2 Channel1*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C1S;
 8000fca:	6811      	ldr	r1, [r2, #0]
 8000fcc:	f021 010f 	bic.w	r1, r1, #15
 8000fd0:	6011      	str	r1, [r2, #0]

      /* Configure request selection for DMA2 Channel1 */
      DMA2_CSELR->CSELR |= hdma->Init.Request;
 8000fd2:	6810      	ldr	r0, [r2, #0]
 8000fd4:	6859      	ldr	r1, [r3, #4]
 8000fd6:	4301      	orrs	r1, r0
 8000fd8:	6011      	str	r1, [r2, #0]
 8000fda:	e7df      	b.n	8000f9c <HAL_DMA_Init+0xa8>
      DMA1_CSELR->CSELR |= (uint32_t)(hdma->Init.Request << 4);
    }
    else if (hdma->Instance == DMA1_Channel3)
    {
      /*Reset request selection for DMA1 Channel3*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C3S;
 8000fdc:	4a30      	ldr	r2, [pc, #192]	; (80010a0 <HAL_DMA_Init+0x1ac>)
      DMA2_CSELR->CSELR |= (uint32_t)(hdma->Init.Request << 4);
    }
    else if (hdma->Instance == DMA2_Channel3)
    {
      /*Reset request selection for DMA2 Channel3*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C3S;
 8000fde:	6811      	ldr	r1, [r2, #0]
 8000fe0:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00
 8000fe4:	6011      	str	r1, [r2, #0]

      /* Configure request selection for DMA2 Channel3 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 8);
 8000fe6:	6811      	ldr	r1, [r2, #0]
 8000fe8:	6858      	ldr	r0, [r3, #4]
 8000fea:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8000fee:	6011      	str	r1, [r2, #0]
 8000ff0:	e7d4      	b.n	8000f9c <HAL_DMA_Init+0xa8>
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 8);
    }
    else if (hdma->Instance == DMA1_Channel4)
    {
      /*Reset request selection for DMA1 Channel4*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C4S;
 8000ff2:	4a2b      	ldr	r2, [pc, #172]	; (80010a0 <HAL_DMA_Init+0x1ac>)
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 8);
    }
    else if (hdma->Instance == DMA2_Channel4)
    {
      /*Reset request selection for DMA2 Channel4*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C4S;
 8000ff4:	6811      	ldr	r1, [r2, #0]
 8000ff6:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
 8000ffa:	6011      	str	r1, [r2, #0]

      /* Configure request selection for DMA2 Channel4 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 12);
 8000ffc:	6811      	ldr	r1, [r2, #0]
 8000ffe:	6858      	ldr	r0, [r3, #4]
 8001000:	ea41 3100 	orr.w	r1, r1, r0, lsl #12
 8001004:	6011      	str	r1, [r2, #0]
 8001006:	e7c9      	b.n	8000f9c <HAL_DMA_Init+0xa8>
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 12);
    }
    else if (hdma->Instance == DMA1_Channel5)
    {
      /*Reset request selection for DMA1 Channel5*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C5S;
 8001008:	4a25      	ldr	r2, [pc, #148]	; (80010a0 <HAL_DMA_Init+0x1ac>)
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 12);
    }
    else if (hdma->Instance == DMA2_Channel5)
    {
      /*Reset request selection for DMA2 Channel5*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C5S;
 800100a:	6811      	ldr	r1, [r2, #0]
 800100c:	f421 2170 	bic.w	r1, r1, #983040	; 0xf0000
 8001010:	6011      	str	r1, [r2, #0]

      /* Configure request selection for DMA2 Channel5 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 16);
 8001012:	6811      	ldr	r1, [r2, #0]
 8001014:	6858      	ldr	r0, [r3, #4]
 8001016:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 800101a:	6011      	str	r1, [r2, #0]
 800101c:	e7be      	b.n	8000f9c <HAL_DMA_Init+0xa8>
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 24);
    }
    else if (hdma->Instance == DMA2_Channel1)
    {
      /*Reset request selection for DMA2 Channel1*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C1S;
 800101e:	4a21      	ldr	r2, [pc, #132]	; (80010a4 <HAL_DMA_Init+0x1b0>)
 8001020:	e7d3      	b.n	8000fca <HAL_DMA_Init+0xd6>
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 20);
    }
    else if (hdma->Instance == DMA2_Channel7)
    {
      /*Reset request selection for DMA2 Channel7*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C7S;
 8001022:	4a20      	ldr	r2, [pc, #128]	; (80010a4 <HAL_DMA_Init+0x1b0>)
 8001024:	6811      	ldr	r1, [r2, #0]
 8001026:	f021 6170 	bic.w	r1, r1, #251658240	; 0xf000000
 800102a:	6011      	str	r1, [r2, #0]

      /* Configure request selection for DMA2 Channel7 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 24);
 800102c:	6811      	ldr	r1, [r2, #0]
 800102e:	6858      	ldr	r0, [r3, #4]
 8001030:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
 8001034:	6011      	str	r1, [r2, #0]
 8001036:	e7b1      	b.n	8000f9c <HAL_DMA_Init+0xa8>
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 16);
    }
    else if (hdma->Instance == DMA1_Channel6)
    {
      /*Reset request selection for DMA1 Channel6*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C6S;
 8001038:	4a19      	ldr	r2, [pc, #100]	; (80010a0 <HAL_DMA_Init+0x1ac>)
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 16);
    }
    else if (hdma->Instance == DMA2_Channel6)
    {
      /*Reset request selection for DMA2 Channel6*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C6S;
 800103a:	6811      	ldr	r1, [r2, #0]
 800103c:	f421 0170 	bic.w	r1, r1, #15728640	; 0xf00000
 8001040:	6011      	str	r1, [r2, #0]

      /* Configure request selection for DMA2 Channel6 */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 20);
 8001042:	6811      	ldr	r1, [r2, #0]
 8001044:	6858      	ldr	r0, [r3, #4]
 8001046:	ea41 5100 	orr.w	r1, r1, r0, lsl #20
 800104a:	6011      	str	r1, [r2, #0]
 800104c:	e7a6      	b.n	8000f9c <HAL_DMA_Init+0xa8>
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 20);
    }
    else if (hdma->Instance == DMA1_Channel7)
    {
      /*Reset request selection for DMA1 Channel7*/
      DMA1_CSELR->CSELR &= ~DMA_CSELR_C7S;
 800104e:	4a14      	ldr	r2, [pc, #80]	; (80010a0 <HAL_DMA_Init+0x1ac>)
 8001050:	e7e8      	b.n	8001024 <HAL_DMA_Init+0x130>
      DMA2_CSELR->CSELR |= hdma->Init.Request;
    }
    else if (hdma->Instance == DMA2_Channel2)
    {
      /*Reset request selection for DMA2 Channel2*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C2S;
 8001052:	4a14      	ldr	r2, [pc, #80]	; (80010a4 <HAL_DMA_Init+0x1b0>)
 8001054:	e7ac      	b.n	8000fb0 <HAL_DMA_Init+0xbc>
      DMA2_CSELR->CSELR |= (uint32_t)(hdma->Init.Request << 4);
    }
    else if (hdma->Instance == DMA2_Channel3)
    {
      /*Reset request selection for DMA2 Channel3*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C3S;
 8001056:	4a13      	ldr	r2, [pc, #76]	; (80010a4 <HAL_DMA_Init+0x1b0>)
 8001058:	e7c1      	b.n	8000fde <HAL_DMA_Init+0xea>
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 8);
    }
    else if (hdma->Instance == DMA2_Channel4)
    {
      /*Reset request selection for DMA2 Channel4*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C4S;
 800105a:	4a12      	ldr	r2, [pc, #72]	; (80010a4 <HAL_DMA_Init+0x1b0>)
 800105c:	e7ca      	b.n	8000ff4 <HAL_DMA_Init+0x100>
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 12);
    }
    else if (hdma->Instance == DMA2_Channel5)
    {
      /*Reset request selection for DMA2 Channel5*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C5S;
 800105e:	4a11      	ldr	r2, [pc, #68]	; (80010a4 <HAL_DMA_Init+0x1b0>)
 8001060:	e7d3      	b.n	800100a <HAL_DMA_Init+0x116>
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 16);
    }
    else if (hdma->Instance == DMA2_Channel6)
    {
      /*Reset request selection for DMA2 Channel6*/
      DMA2_CSELR->CSELR &= ~DMA_CSELR_C6S;
 8001062:	4a10      	ldr	r2, [pc, #64]	; (80010a4 <HAL_DMA_Init+0x1b0>)
 8001064:	e7e9      	b.n	800103a <HAL_DMA_Init+0x146>
 8001066:	bf00      	nop
 8001068:	40020008 	.word	0x40020008
 800106c:	4002001c 	.word	0x4002001c
 8001070:	40020030 	.word	0x40020030
 8001074:	40020044 	.word	0x40020044
 8001078:	40020058 	.word	0x40020058
 800107c:	4002006c 	.word	0x4002006c
 8001080:	40020080 	.word	0x40020080
 8001084:	40020408 	.word	0x40020408
 8001088:	4002041c 	.word	0x4002041c
 800108c:	40020430 	.word	0x40020430
 8001090:	40020444 	.word	0x40020444
 8001094:	40020458 	.word	0x40020458
 8001098:	4002046c 	.word	0x4002046c
 800109c:	40020480 	.word	0x40020480
 80010a0:	400200a8 	.word	0x400200a8
 80010a4:	400204a8 	.word	0x400204a8

080010a8 <HAL_DMA_DeInit>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
  /* Check the DMA handle allocation */
  if(hdma == NULL)
 80010a8:	2800      	cmp	r0, #0
 80010aa:	d052      	beq.n	8001152 <HAL_DMA_DeInit+0xaa>
  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
 80010ac:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 80010b0:	2b02      	cmp	r3, #2
 80010b2:	d04e      	beq.n	8001152 <HAL_DMA_DeInit+0xaa>
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
 80010b4:	b410      	push	{r4}
  {
     return HAL_ERROR;
  }

  /* Disable the selected DMA Channelx */
  __HAL_DMA_DISABLE(hdma);
 80010b6:	6802      	ldr	r2, [r0, #0]

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 80010b8:	49bc      	ldr	r1, [pc, #752]	; (80013ac <HAL_DMA_DeInit+0x304>)
  {
     return HAL_ERROR;
  }

  /* Disable the selected DMA Channelx */
  __HAL_DMA_DISABLE(hdma);
 80010ba:	6813      	ldr	r3, [r2, #0]
 80010bc:	f023 0301 	bic.w	r3, r3, #1
 80010c0:	6013      	str	r3, [r2, #0]

  /* Reset DMA Channel control register */
  hdma->Instance->CCR  = 0;
 80010c2:	6802      	ldr	r2, [r0, #0]
 80010c4:	2300      	movs	r3, #0
 80010c6:	6013      	str	r3, [r2, #0]

  /* Reset DMA Channel Number of Data to Transfer register */
  hdma->Instance->CNDTR = 0;
 80010c8:	6802      	ldr	r2, [r0, #0]
 80010ca:	6053      	str	r3, [r2, #4]

  /* Reset DMA Channel peripheral address register */
  hdma->Instance->CPAR  = 0;
 80010cc:	6802      	ldr	r2, [r0, #0]
 80010ce:	6093      	str	r3, [r2, #8]

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;
 80010d0:	6802      	ldr	r2, [r0, #0]
 80010d2:	60d3      	str	r3, [r2, #12]

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 80010d4:	6803      	ldr	r3, [r0, #0]
 80010d6:	428b      	cmp	r3, r1
 80010d8:	d91e      	bls.n	8001118 <HAL_DMA_DeInit+0x70>
 80010da:	4ab5      	ldr	r2, [pc, #724]	; (80013b0 <HAL_DMA_DeInit+0x308>)
 80010dc:	f501 7162 	add.w	r1, r1, #904	; 0x388
 80010e0:	428b      	cmp	r3, r1
 80010e2:	6852      	ldr	r2, [r2, #4]
 80010e4:	f000 80e8 	beq.w	80012b8 <HAL_DMA_DeInit+0x210>
 80010e8:	3114      	adds	r1, #20
 80010ea:	428b      	cmp	r3, r1
 80010ec:	f000 819d 	beq.w	800142a <HAL_DMA_DeInit+0x382>
 80010f0:	3114      	adds	r1, #20
 80010f2:	428b      	cmp	r3, r1
 80010f4:	f000 81c8 	beq.w	8001488 <HAL_DMA_DeInit+0x3e0>
 80010f8:	3114      	adds	r1, #20
 80010fa:	428b      	cmp	r3, r1
 80010fc:	f000 81a9 	beq.w	8001452 <HAL_DMA_DeInit+0x3aa>
 8001100:	3114      	adds	r1, #20
 8001102:	428b      	cmp	r3, r1
 8001104:	f000 81de 	beq.w	80014c4 <HAL_DMA_DeInit+0x41c>
 8001108:	3114      	adds	r1, #20
 800110a:	428b      	cmp	r3, r1
 800110c:	bf0c      	ite	eq
 800110e:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8001112:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8001116:	e0d0      	b.n	80012ba <HAL_DMA_DeInit+0x212>
 8001118:	4aa6      	ldr	r2, [pc, #664]	; (80013b4 <HAL_DMA_DeInit+0x30c>)
 800111a:	49a7      	ldr	r1, [pc, #668]	; (80013b8 <HAL_DMA_DeInit+0x310>)
 800111c:	4293      	cmp	r3, r2
 800111e:	6849      	ldr	r1, [r1, #4]
 8001120:	f000 80cf 	beq.w	80012c2 <HAL_DMA_DeInit+0x21a>
 8001124:	3214      	adds	r2, #20
 8001126:	4293      	cmp	r3, r2
 8001128:	d015      	beq.n	8001156 <HAL_DMA_DeInit+0xae>
 800112a:	3214      	adds	r2, #20
 800112c:	4293      	cmp	r3, r2
 800112e:	f000 819f 	beq.w	8001470 <HAL_DMA_DeInit+0x3c8>
 8001132:	3214      	adds	r2, #20
 8001134:	4293      	cmp	r3, r2
 8001136:	f000 817a 	beq.w	800142e <HAL_DMA_DeInit+0x386>
 800113a:	3214      	adds	r2, #20
 800113c:	4293      	cmp	r3, r2
 800113e:	f000 81af 	beq.w	80014a0 <HAL_DMA_DeInit+0x3f8>
 8001142:	3214      	adds	r2, #20
 8001144:	4293      	cmp	r3, r2
 8001146:	bf0c      	ite	eq
 8001148:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
 800114c:	f04f 7280 	movne.w	r2, #16777216	; 0x1000000
 8001150:	e002      	b.n	8001158 <HAL_DMA_DeInit+0xb0>
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
  /* Check the DMA handle allocation */
  if(hdma == NULL)
  {
    return HAL_ERROR;
 8001152:	2001      	movs	r0, #1
 8001154:	4770      	bx	lr

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8001156:	2210      	movs	r2, #16
 8001158:	4c97      	ldr	r4, [pc, #604]	; (80013b8 <HAL_DMA_DeInit+0x310>)
 800115a:	ea42 0301 	orr.w	r3, r2, r1
 800115e:	6063      	str	r3, [r4, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001160:	6803      	ldr	r3, [r0, #0]
 8001162:	4a92      	ldr	r2, [pc, #584]	; (80013ac <HAL_DMA_DeInit+0x304>)
 8001164:	4293      	cmp	r3, r2
 8001166:	d941      	bls.n	80011ec <HAL_DMA_DeInit+0x144>
 8001168:	4994      	ldr	r1, [pc, #592]	; (80013bc <HAL_DMA_DeInit+0x314>)
 800116a:	4a91      	ldr	r2, [pc, #580]	; (80013b0 <HAL_DMA_DeInit+0x308>)
 800116c:	428b      	cmp	r3, r1
 800116e:	6852      	ldr	r2, [r2, #4]
 8001170:	f000 81ad 	beq.w	80014ce <HAL_DMA_DeInit+0x426>
 8001174:	4992      	ldr	r1, [pc, #584]	; (80013c0 <HAL_DMA_DeInit+0x318>)
 8001176:	428b      	cmp	r3, r1
 8001178:	f000 8175 	beq.w	8001466 <HAL_DMA_DeInit+0x3be>
 800117c:	3114      	adds	r1, #20
 800117e:	428b      	cmp	r3, r1
 8001180:	f000 8185 	beq.w	800148e <HAL_DMA_DeInit+0x3e6>
 8001184:	3114      	adds	r1, #20
 8001186:	428b      	cmp	r3, r1
 8001188:	f000 8160 	beq.w	800144c <HAL_DMA_DeInit+0x3a4>
 800118c:	3114      	adds	r1, #20
 800118e:	428b      	cmp	r3, r1
 8001190:	f000 818f 	beq.w	80014b2 <HAL_DMA_DeInit+0x40a>
 8001194:	3114      	adds	r1, #20
 8001196:	428b      	cmp	r3, r1
 8001198:	bf0c      	ite	eq
 800119a:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 800119e:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 80011a2:	4983      	ldr	r1, [pc, #524]	; (80013b0 <HAL_DMA_DeInit+0x308>)
 80011a4:	4313      	orrs	r3, r2
 80011a6:	604b      	str	r3, [r1, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80011a8:	6803      	ldr	r3, [r0, #0]
 80011aa:	4a80      	ldr	r2, [pc, #512]	; (80013ac <HAL_DMA_DeInit+0x304>)
 80011ac:	4293      	cmp	r3, r2
 80011ae:	d842      	bhi.n	8001236 <HAL_DMA_DeInit+0x18e>
 80011b0:	4980      	ldr	r1, [pc, #512]	; (80013b4 <HAL_DMA_DeInit+0x30c>)
 80011b2:	4a81      	ldr	r2, [pc, #516]	; (80013b8 <HAL_DMA_DeInit+0x310>)
 80011b4:	428b      	cmp	r3, r1
 80011b6:	6852      	ldr	r2, [r2, #4]
 80011b8:	f000 8085 	beq.w	80012c6 <HAL_DMA_DeInit+0x21e>
 80011bc:	3114      	adds	r1, #20
 80011be:	428b      	cmp	r3, r1
 80011c0:	f000 8131 	beq.w	8001426 <HAL_DMA_DeInit+0x37e>
 80011c4:	3114      	adds	r1, #20
 80011c6:	428b      	cmp	r3, r1
 80011c8:	f000 8158 	beq.w	800147c <HAL_DMA_DeInit+0x3d4>
 80011cc:	3114      	adds	r1, #20
 80011ce:	428b      	cmp	r3, r1
 80011d0:	f000 8133 	beq.w	800143a <HAL_DMA_DeInit+0x392>
 80011d4:	3114      	adds	r1, #20
 80011d6:	428b      	cmp	r3, r1
 80011d8:	f000 8168 	beq.w	80014ac <HAL_DMA_DeInit+0x404>
 80011dc:	3114      	adds	r1, #20
 80011de:	428b      	cmp	r3, r1
 80011e0:	bf0c      	ite	eq
 80011e2:	f44f 0300 	moveq.w	r3, #8388608	; 0x800000
 80011e6:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 80011ea:	e06d      	b.n	80012c8 <HAL_DMA_DeInit+0x220>
  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80011ec:	4971      	ldr	r1, [pc, #452]	; (80013b4 <HAL_DMA_DeInit+0x30c>)
 80011ee:	4a72      	ldr	r2, [pc, #456]	; (80013b8 <HAL_DMA_DeInit+0x310>)
 80011f0:	428b      	cmp	r3, r1
 80011f2:	6852      	ldr	r2, [r2, #4]
 80011f4:	d017      	beq.n	8001226 <HAL_DMA_DeInit+0x17e>
 80011f6:	3114      	adds	r1, #20
 80011f8:	428b      	cmp	r3, r1
 80011fa:	f000 8112 	beq.w	8001422 <HAL_DMA_DeInit+0x37a>
 80011fe:	3114      	adds	r1, #20
 8001200:	428b      	cmp	r3, r1
 8001202:	f000 8132 	beq.w	800146a <HAL_DMA_DeInit+0x3c2>
 8001206:	3114      	adds	r1, #20
 8001208:	428b      	cmp	r3, r1
 800120a:	f000 8119 	beq.w	8001440 <HAL_DMA_DeInit+0x398>
 800120e:	3114      	adds	r1, #20
 8001210:	428b      	cmp	r3, r1
 8001212:	f000 8148 	beq.w	80014a6 <HAL_DMA_DeInit+0x3fe>
 8001216:	3114      	adds	r1, #20
 8001218:	428b      	cmp	r3, r1
 800121a:	bf0c      	ite	eq
 800121c:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001220:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8001224:	e000      	b.n	8001228 <HAL_DMA_DeInit+0x180>
 8001226:	2302      	movs	r3, #2
 8001228:	4963      	ldr	r1, [pc, #396]	; (80013b8 <HAL_DMA_DeInit+0x310>)
 800122a:	4313      	orrs	r3, r2
 800122c:	604b      	str	r3, [r1, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800122e:	6803      	ldr	r3, [r0, #0]
 8001230:	4a5e      	ldr	r2, [pc, #376]	; (80013ac <HAL_DMA_DeInit+0x304>)
 8001232:	4293      	cmp	r3, r2
 8001234:	d9bc      	bls.n	80011b0 <HAL_DMA_DeInit+0x108>
 8001236:	4961      	ldr	r1, [pc, #388]	; (80013bc <HAL_DMA_DeInit+0x314>)
 8001238:	4a5d      	ldr	r2, [pc, #372]	; (80013b0 <HAL_DMA_DeInit+0x308>)
 800123a:	428b      	cmp	r3, r1
 800123c:	6852      	ldr	r2, [r2, #4]
 800123e:	f000 8144 	beq.w	80014ca <HAL_DMA_DeInit+0x422>
 8001242:	495f      	ldr	r1, [pc, #380]	; (80013c0 <HAL_DMA_DeInit+0x318>)
 8001244:	428b      	cmp	r3, r1
 8001246:	f000 810c 	beq.w	8001462 <HAL_DMA_DeInit+0x3ba>
 800124a:	3114      	adds	r1, #20
 800124c:	428b      	cmp	r3, r1
 800124e:	f000 8121 	beq.w	8001494 <HAL_DMA_DeInit+0x3ec>
 8001252:	3114      	adds	r1, #20
 8001254:	428b      	cmp	r3, r1
 8001256:	f000 80ff 	beq.w	8001458 <HAL_DMA_DeInit+0x3b0>
 800125a:	3114      	adds	r1, #20
 800125c:	428b      	cmp	r3, r1
 800125e:	f000 812b 	beq.w	80014b8 <HAL_DMA_DeInit+0x410>
 8001262:	3114      	adds	r1, #20
 8001264:	428b      	cmp	r3, r1
 8001266:	bf0c      	ite	eq
 8001268:	f44f 0300 	moveq.w	r3, #8388608	; 0x800000
 800126c:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8001270:	494f      	ldr	r1, [pc, #316]	; (80013b0 <HAL_DMA_DeInit+0x308>)
 8001272:	4313      	orrs	r3, r2
 8001274:	604b      	str	r3, [r1, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001276:	6803      	ldr	r3, [r0, #0]
 8001278:	4a4c      	ldr	r2, [pc, #304]	; (80013ac <HAL_DMA_DeInit+0x304>)
 800127a:	4293      	cmp	r3, r2
 800127c:	d82b      	bhi.n	80012d6 <HAL_DMA_DeInit+0x22e>
 800127e:	494d      	ldr	r1, [pc, #308]	; (80013b4 <HAL_DMA_DeInit+0x30c>)
 8001280:	4a4d      	ldr	r2, [pc, #308]	; (80013b8 <HAL_DMA_DeInit+0x310>)
 8001282:	428b      	cmp	r3, r1
 8001284:	6852      	ldr	r2, [r2, #4]
 8001286:	d051      	beq.n	800132c <HAL_DMA_DeInit+0x284>
 8001288:	3114      	adds	r1, #20
 800128a:	428b      	cmp	r3, r1
 800128c:	f000 80c7 	beq.w	800141e <HAL_DMA_DeInit+0x376>
 8001290:	3114      	adds	r1, #20
 8001292:	428b      	cmp	r3, r1
 8001294:	f000 80ef 	beq.w	8001476 <HAL_DMA_DeInit+0x3ce>
 8001298:	3114      	adds	r1, #20
 800129a:	428b      	cmp	r3, r1
 800129c:	f000 80ca 	beq.w	8001434 <HAL_DMA_DeInit+0x38c>
 80012a0:	3114      	adds	r1, #20
 80012a2:	428b      	cmp	r3, r1
 80012a4:	f000 80f9 	beq.w	800149a <HAL_DMA_DeInit+0x3f2>
 80012a8:	3114      	adds	r1, #20
 80012aa:	428b      	cmp	r3, r1
 80012ac:	bf0c      	ite	eq
 80012ae:	f44f 0380 	moveq.w	r3, #4194304	; 0x400000
 80012b2:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 80012b6:	e03a      	b.n	800132e <HAL_DMA_DeInit+0x286>

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 80012b8:	2301      	movs	r3, #1
 80012ba:	493d      	ldr	r1, [pc, #244]	; (80013b0 <HAL_DMA_DeInit+0x308>)
 80012bc:	4313      	orrs	r3, r2
 80012be:	604b      	str	r3, [r1, #4]
 80012c0:	e74e      	b.n	8001160 <HAL_DMA_DeInit+0xb8>
 80012c2:	2201      	movs	r2, #1
 80012c4:	e748      	b.n	8001158 <HAL_DMA_DeInit+0xb0>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80012c6:	2308      	movs	r3, #8
 80012c8:	493b      	ldr	r1, [pc, #236]	; (80013b8 <HAL_DMA_DeInit+0x310>)
 80012ca:	4313      	orrs	r3, r2
 80012cc:	604b      	str	r3, [r1, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80012ce:	6803      	ldr	r3, [r0, #0]
 80012d0:	4a36      	ldr	r2, [pc, #216]	; (80013ac <HAL_DMA_DeInit+0x304>)
 80012d2:	4293      	cmp	r3, r2
 80012d4:	d9d3      	bls.n	800127e <HAL_DMA_DeInit+0x1d6>
 80012d6:	4939      	ldr	r1, [pc, #228]	; (80013bc <HAL_DMA_DeInit+0x314>)
 80012d8:	4a35      	ldr	r2, [pc, #212]	; (80013b0 <HAL_DMA_DeInit+0x308>)
 80012da:	428b      	cmp	r3, r1
 80012dc:	6852      	ldr	r2, [r2, #4]
 80012de:	f000 80f8 	beq.w	80014d2 <HAL_DMA_DeInit+0x42a>
 80012e2:	4937      	ldr	r1, [pc, #220]	; (80013c0 <HAL_DMA_DeInit+0x318>)
 80012e4:	428b      	cmp	r3, r1
 80012e6:	f000 80ba 	beq.w	800145e <HAL_DMA_DeInit+0x3b6>
 80012ea:	3114      	adds	r1, #20
 80012ec:	428b      	cmp	r3, r1
 80012ee:	f000 80c8 	beq.w	8001482 <HAL_DMA_DeInit+0x3da>
 80012f2:	3114      	adds	r1, #20
 80012f4:	428b      	cmp	r3, r1
 80012f6:	f000 80a6 	beq.w	8001446 <HAL_DMA_DeInit+0x39e>
 80012fa:	3114      	adds	r1, #20
 80012fc:	428b      	cmp	r3, r1
 80012fe:	f000 80de 	beq.w	80014be <HAL_DMA_DeInit+0x416>
 8001302:	3114      	adds	r1, #20
 8001304:	428b      	cmp	r3, r1
 8001306:	bf0c      	ite	eq
 8001308:	f44f 0380 	moveq.w	r3, #4194304	; 0x400000
 800130c:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8001310:	4927      	ldr	r1, [pc, #156]	; (80013b0 <HAL_DMA_DeInit+0x308>)
 8001312:	4313      	orrs	r3, r2
 8001314:	604b      	str	r3, [r1, #4]

  /* Reset DMA channel selection register */
  if (hdma->Instance == DMA1_Channel1)
 8001316:	6803      	ldr	r3, [r0, #0]
 8001318:	4a26      	ldr	r2, [pc, #152]	; (80013b4 <HAL_DMA_DeInit+0x30c>)
 800131a:	4293      	cmp	r3, r2
 800131c:	d10e      	bne.n	800133c <HAL_DMA_DeInit+0x294>
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C7S;
  }
  else if (hdma->Instance == DMA2_Channel1)
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C1S;
 800131e:	f8d2 30a0 	ldr.w	r3, [r2, #160]	; 0xa0
 8001322:	f023 030f 	bic.w	r3, r3, #15
 8001326:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
 800132a:	e02e      	b.n	800138a <HAL_DMA_DeInit+0x2e2>

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800132c:	2304      	movs	r3, #4
 800132e:	4922      	ldr	r1, [pc, #136]	; (80013b8 <HAL_DMA_DeInit+0x310>)
 8001330:	4313      	orrs	r3, r2
 8001332:	604b      	str	r3, [r1, #4]

  /* Reset DMA channel selection register */
  if (hdma->Instance == DMA1_Channel1)
 8001334:	6803      	ldr	r3, [r0, #0]
 8001336:	4a1f      	ldr	r2, [pc, #124]	; (80013b4 <HAL_DMA_DeInit+0x30c>)
 8001338:	4293      	cmp	r3, r2
 800133a:	d0f0      	beq.n	800131e <HAL_DMA_DeInit+0x276>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C1S;
  }
  else if (hdma->Instance == DMA1_Channel2)
 800133c:	4a21      	ldr	r2, [pc, #132]	; (80013c4 <HAL_DMA_DeInit+0x31c>)
 800133e:	4293      	cmp	r3, r2
 8001340:	d02d      	beq.n	800139e <HAL_DMA_DeInit+0x2f6>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C2S;
  }
  else if (hdma->Instance == DMA1_Channel3)
 8001342:	4a21      	ldr	r2, [pc, #132]	; (80013c8 <HAL_DMA_DeInit+0x320>)
 8001344:	4293      	cmp	r3, r2
 8001346:	d051      	beq.n	80013ec <HAL_DMA_DeInit+0x344>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C3S;
  }
  else if (hdma->Instance == DMA1_Channel4)
 8001348:	4a20      	ldr	r2, [pc, #128]	; (80013cc <HAL_DMA_DeInit+0x324>)
 800134a:	4293      	cmp	r3, r2
 800134c:	d053      	beq.n	80013f6 <HAL_DMA_DeInit+0x34e>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C4S;
  }
  else if (hdma->Instance == DMA1_Channel5)
 800134e:	4a20      	ldr	r2, [pc, #128]	; (80013d0 <HAL_DMA_DeInit+0x328>)
 8001350:	4293      	cmp	r3, r2
 8001352:	d055      	beq.n	8001400 <HAL_DMA_DeInit+0x358>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C5S;
  }
  else if (hdma->Instance == DMA1_Channel6)
 8001354:	4a1f      	ldr	r2, [pc, #124]	; (80013d4 <HAL_DMA_DeInit+0x32c>)
 8001356:	4293      	cmp	r3, r2
 8001358:	d057      	beq.n	800140a <HAL_DMA_DeInit+0x362>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C6S;
  }
  else if (hdma->Instance == DMA1_Channel7)
 800135a:	4a14      	ldr	r2, [pc, #80]	; (80013ac <HAL_DMA_DeInit+0x304>)
 800135c:	4293      	cmp	r3, r2
 800135e:	d059      	beq.n	8001414 <HAL_DMA_DeInit+0x36c>
  {
    /*Reset DMA request*/
    DMA1_CSELR->CSELR &= ~DMA_CSELR_C7S;
  }
  else if (hdma->Instance == DMA2_Channel1)
 8001360:	4a16      	ldr	r2, [pc, #88]	; (80013bc <HAL_DMA_DeInit+0x314>)
 8001362:	4293      	cmp	r3, r2
 8001364:	d0db      	beq.n	800131e <HAL_DMA_DeInit+0x276>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C1S;
  }
  else if (hdma->Instance == DMA2_Channel2)
 8001366:	4a16      	ldr	r2, [pc, #88]	; (80013c0 <HAL_DMA_DeInit+0x318>)
 8001368:	4293      	cmp	r3, r2
 800136a:	d018      	beq.n	800139e <HAL_DMA_DeInit+0x2f6>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C2S;
  }
  else if (hdma->Instance == DMA2_Channel3)
 800136c:	4a1a      	ldr	r2, [pc, #104]	; (80013d8 <HAL_DMA_DeInit+0x330>)
 800136e:	4293      	cmp	r3, r2
 8001370:	d03c      	beq.n	80013ec <HAL_DMA_DeInit+0x344>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C3S;
  }
  else if (hdma->Instance == DMA2_Channel4)
 8001372:	4a1a      	ldr	r2, [pc, #104]	; (80013dc <HAL_DMA_DeInit+0x334>)
 8001374:	4293      	cmp	r3, r2
 8001376:	d03e      	beq.n	80013f6 <HAL_DMA_DeInit+0x34e>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C4S;
  }
  else if (hdma->Instance == DMA2_Channel5)
 8001378:	4a19      	ldr	r2, [pc, #100]	; (80013e0 <HAL_DMA_DeInit+0x338>)
 800137a:	4293      	cmp	r3, r2
 800137c:	d040      	beq.n	8001400 <HAL_DMA_DeInit+0x358>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C5S;
  }
  else if (hdma->Instance == DMA2_Channel6)
 800137e:	4a19      	ldr	r2, [pc, #100]	; (80013e4 <HAL_DMA_DeInit+0x33c>)
 8001380:	4293      	cmp	r3, r2
 8001382:	d042      	beq.n	800140a <HAL_DMA_DeInit+0x362>
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C6S;
  }
  else if (hdma->Instance == DMA2_Channel7)
 8001384:	4a18      	ldr	r2, [pc, #96]	; (80013e8 <HAL_DMA_DeInit+0x340>)
 8001386:	4293      	cmp	r3, r2
 8001388:	d044      	beq.n	8001414 <HAL_DMA_DeInit+0x36c>
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C7S;
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800138a:	2300      	movs	r3, #0
 800138c:	6383      	str	r3, [r0, #56]	; 0x38

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 800138e:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
 8001392:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25

  /* Release Lock */
  __HAL_UNLOCK(hdma);

  return HAL_OK;
}
 8001396:	f85d 4b04 	ldr.w	r4, [sp], #4
  hdma->State = HAL_DMA_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdma);

  return HAL_OK;
 800139a:	4618      	mov	r0, r3
}
 800139c:	4770      	bx	lr
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C1S;
  }
  else if (hdma->Instance == DMA2_Channel2)
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C2S;
 800139e:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 80013a2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80013a6:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 80013aa:	e7ee      	b.n	800138a <HAL_DMA_DeInit+0x2e2>
 80013ac:	40020080 	.word	0x40020080
 80013b0:	40020400 	.word	0x40020400
 80013b4:	40020008 	.word	0x40020008
 80013b8:	40020000 	.word	0x40020000
 80013bc:	40020408 	.word	0x40020408
 80013c0:	4002041c 	.word	0x4002041c
 80013c4:	4002001c 	.word	0x4002001c
 80013c8:	40020030 	.word	0x40020030
 80013cc:	40020044 	.word	0x40020044
 80013d0:	40020058 	.word	0x40020058
 80013d4:	4002006c 	.word	0x4002006c
 80013d8:	40020430 	.word	0x40020430
 80013dc:	40020444 	.word	0x40020444
 80013e0:	40020458 	.word	0x40020458
 80013e4:	4002046c 	.word	0x4002046c
 80013e8:	40020480 	.word	0x40020480
  }
  else if (hdma->Instance == DMA2_Channel3)
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C3S;
 80013ec:	6f93      	ldr	r3, [r2, #120]	; 0x78
 80013ee:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80013f2:	6793      	str	r3, [r2, #120]	; 0x78
 80013f4:	e7c9      	b.n	800138a <HAL_DMA_DeInit+0x2e2>
  }
  else if (hdma->Instance == DMA2_Channel4)
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C4S;
 80013f6:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80013f8:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 80013fc:	6653      	str	r3, [r2, #100]	; 0x64
 80013fe:	e7c4      	b.n	800138a <HAL_DMA_DeInit+0x2e2>
  }
  else if (hdma->Instance == DMA2_Channel5)
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C5S;
 8001400:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8001402:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8001406:	6513      	str	r3, [r2, #80]	; 0x50
 8001408:	e7bf      	b.n	800138a <HAL_DMA_DeInit+0x2e2>
  }
  else if (hdma->Instance == DMA2_Channel6)
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C6S;
 800140a:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800140c:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8001410:	63d3      	str	r3, [r2, #60]	; 0x3c
 8001412:	e7ba      	b.n	800138a <HAL_DMA_DeInit+0x2e2>
  }
  else if (hdma->Instance == DMA2_Channel7)
  {
    /*Reset DMA request*/
    DMA2_CSELR->CSELR &= ~DMA_CSELR_C7S;
 8001414:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8001416:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 800141a:	6293      	str	r3, [r2, #40]	; 0x28
 800141c:	e7b5      	b.n	800138a <HAL_DMA_DeInit+0x2e2>

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800141e:	2340      	movs	r3, #64	; 0x40
 8001420:	e785      	b.n	800132e <HAL_DMA_DeInit+0x286>
  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001422:	2320      	movs	r3, #32
 8001424:	e700      	b.n	8001228 <HAL_DMA_DeInit+0x180>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001426:	2380      	movs	r3, #128	; 0x80
 8001428:	e74e      	b.n	80012c8 <HAL_DMA_DeInit+0x220>

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 800142a:	2310      	movs	r3, #16
 800142c:	e745      	b.n	80012ba <HAL_DMA_DeInit+0x212>
 800142e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001432:	e691      	b.n	8001158 <HAL_DMA_DeInit+0xb0>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001434:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8001438:	e779      	b.n	800132e <HAL_DMA_DeInit+0x286>
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800143a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800143e:	e743      	b.n	80012c8 <HAL_DMA_DeInit+0x220>
  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001440:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001444:	e6f0      	b.n	8001228 <HAL_DMA_DeInit+0x180>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001446:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800144a:	e761      	b.n	8001310 <HAL_DMA_DeInit+0x268>
  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800144c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001450:	e6a7      	b.n	80011a2 <HAL_DMA_DeInit+0xfa>

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8001452:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001456:	e730      	b.n	80012ba <HAL_DMA_DeInit+0x212>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001458:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800145c:	e708      	b.n	8001270 <HAL_DMA_DeInit+0x1c8>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800145e:	2340      	movs	r3, #64	; 0x40
 8001460:	e756      	b.n	8001310 <HAL_DMA_DeInit+0x268>
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001462:	2380      	movs	r3, #128	; 0x80
 8001464:	e704      	b.n	8001270 <HAL_DMA_DeInit+0x1c8>
  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001466:	2320      	movs	r3, #32
 8001468:	e69b      	b.n	80011a2 <HAL_DMA_DeInit+0xfa>
 800146a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800146e:	e6db      	b.n	8001228 <HAL_DMA_DeInit+0x180>

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8001470:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001474:	e670      	b.n	8001158 <HAL_DMA_DeInit+0xb0>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001476:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800147a:	e758      	b.n	800132e <HAL_DMA_DeInit+0x286>
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800147c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001480:	e722      	b.n	80012c8 <HAL_DMA_DeInit+0x220>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001482:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001486:	e743      	b.n	8001310 <HAL_DMA_DeInit+0x268>

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8001488:	f44f 7380 	mov.w	r3, #256	; 0x100
 800148c:	e715      	b.n	80012ba <HAL_DMA_DeInit+0x212>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800148e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001492:	e686      	b.n	80011a2 <HAL_DMA_DeInit+0xfa>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001494:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001498:	e6ea      	b.n	8001270 <HAL_DMA_DeInit+0x1c8>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800149a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800149e:	e746      	b.n	800132e <HAL_DMA_DeInit+0x286>

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 80014a0:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80014a4:	e658      	b.n	8001158 <HAL_DMA_DeInit+0xb0>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80014a6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80014aa:	e6bd      	b.n	8001228 <HAL_DMA_DeInit+0x180>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80014ac:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80014b0:	e70a      	b.n	80012c8 <HAL_DMA_DeInit+0x220>
  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80014b2:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80014b6:	e674      	b.n	80011a2 <HAL_DMA_DeInit+0xfa>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80014b8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80014bc:	e6d8      	b.n	8001270 <HAL_DMA_DeInit+0x1c8>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80014be:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80014c2:	e725      	b.n	8001310 <HAL_DMA_DeInit+0x268>

  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 80014c4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80014c8:	e6f7      	b.n	80012ba <HAL_DMA_DeInit+0x212>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80014ca:	2308      	movs	r3, #8
 80014cc:	e6d0      	b.n	8001270 <HAL_DMA_DeInit+0x1c8>
  /* Reset DMA Channel memory address register */
  hdma->Instance->CMAR = 0;

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80014ce:	2302      	movs	r3, #2
 80014d0:	e667      	b.n	80011a2 <HAL_DMA_DeInit+0xfa>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80014d2:	2304      	movs	r3, #4
 80014d4:	e71c      	b.n	8001310 <HAL_DMA_DeInit+0x268>
 80014d6:	bf00      	nop

080014d8 <HAL_DMA_Start>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80014d8:	b470      	push	{r4, r5, r6}
  /* Process locked */
  __HAL_LOCK(hdma);
 80014da:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
 80014de:	2c01      	cmp	r4, #1
 80014e0:	d01b      	beq.n	800151a <HAL_DMA_Start+0x42>

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80014e2:	6805      	ldr	r5, [r0, #0]
{
  /* Process locked */
  __HAL_LOCK(hdma);

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80014e4:	2402      	movs	r4, #2
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Process locked */
  __HAL_LOCK(hdma);
 80014e6:	2601      	movs	r6, #1
 80014e8:	f880 6024 	strb.w	r6, [r0, #36]	; 0x24

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80014ec:	f880 4025 	strb.w	r4, [r0, #37]	; 0x25

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80014f0:	682c      	ldr	r4, [r5, #0]
 80014f2:	f024 0401 	bic.w	r4, r4, #1
 80014f6:	602c      	str	r4, [r5, #0]
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 80014f8:	6804      	ldr	r4, [r0, #0]
 80014fa:	6063      	str	r3, [r4, #4]

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80014fc:	6883      	ldr	r3, [r0, #8]
 80014fe:	2b10      	cmp	r3, #16
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 8001500:	6803      	ldr	r3, [r0, #0]
{
  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001502:	d00d      	beq.n	8001520 <HAL_DMA_Start+0x48>
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 8001504:	6099      	str	r1, [r3, #8]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 8001506:	6803      	ldr	r3, [r0, #0]
 8001508:	60da      	str	r2, [r3, #12]

  /* Configure the source, destination address and the data length */
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);

  /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
 800150a:	6802      	ldr	r2, [r0, #0]
 800150c:	6813      	ldr	r3, [r2, #0]
 800150e:	f043 0301 	orr.w	r3, r3, #1
 8001512:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 8001514:	2000      	movs	r0, #0
}
 8001516:	bc70      	pop	{r4, r5, r6}
 8001518:	4770      	bx	lr
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Process locked */
  __HAL_LOCK(hdma);
 800151a:	2002      	movs	r0, #2

  /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);

  return HAL_OK;
}
 800151c:	bc70      	pop	{r4, r5, r6}
 800151e:	4770      	bx	lr

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 8001520:	609a      	str	r2, [r3, #8]

    /* Configure DMA Channel source address */
    hdma->Instance->CMAR = SrcAddress;
 8001522:	6803      	ldr	r3, [r0, #0]
 8001524:	60d9      	str	r1, [r3, #12]
 8001526:	e7f0      	b.n	800150a <HAL_DMA_Start+0x32>

08001528 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8001528:	b470      	push	{r4, r5, r6}
  /* Process locked */
  __HAL_LOCK(hdma);
 800152a:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
 800152e:	2c01      	cmp	r4, #1
 8001530:	d020      	beq.n	8001574 <HAL_DMA_Start_IT+0x4c>

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8001532:	6805      	ldr	r5, [r0, #0]
{
  /* Process locked */
  __HAL_LOCK(hdma);

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8001534:	2402      	movs	r4, #2
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Process locked */
  __HAL_LOCK(hdma);
 8001536:	2601      	movs	r6, #1
 8001538:	f880 6024 	strb.w	r6, [r0, #36]	; 0x24

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 800153c:	f880 4025 	strb.w	r4, [r0, #37]	; 0x25

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8001540:	682c      	ldr	r4, [r5, #0]
 8001542:	f024 0401 	bic.w	r4, r4, #1
 8001546:	602c      	str	r4, [r5, #0]
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 8001548:	6804      	ldr	r4, [r0, #0]
 800154a:	6063      	str	r3, [r4, #4]

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800154c:	6883      	ldr	r3, [r0, #8]
 800154e:	2b10      	cmp	r3, #16
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 8001550:	6803      	ldr	r3, [r0, #0]
{
  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001552:	d012      	beq.n	800157a <HAL_DMA_Start_IT+0x52>
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 8001554:	6099      	str	r1, [r3, #8]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 8001556:	6803      	ldr	r3, [r0, #0]
 8001558:	60da      	str	r2, [r3, #12]
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);

  /* Enable the transfer complete interrupt */
  /* Enable the Half transfer complete interrupt */
  /* Enable the transfer Error interrupt */
  __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800155a:	6802      	ldr	r2, [r0, #0]
 800155c:	6813      	ldr	r3, [r2, #0]
 800155e:	f043 030e 	orr.w	r3, r3, #14
 8001562:	6013      	str	r3, [r2, #0]

   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
 8001564:	6802      	ldr	r2, [r0, #0]
 8001566:	6813      	ldr	r3, [r2, #0]
 8001568:	f043 0301 	orr.w	r3, r3, #1
 800156c:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 800156e:	2000      	movs	r0, #0
}
 8001570:	bc70      	pop	{r4, r5, r6}
 8001572:	4770      	bx	lr
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Process locked */
  __HAL_LOCK(hdma);
 8001574:	2002      	movs	r0, #2

   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);

  return HAL_OK;
}
 8001576:	bc70      	pop	{r4, r5, r6}
 8001578:	4770      	bx	lr

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 800157a:	609a      	str	r2, [r3, #8]

    /* Configure DMA Channel source address */
    hdma->Instance->CMAR = SrcAddress;
 800157c:	6803      	ldr	r3, [r0, #0]
 800157e:	60d9      	str	r1, [r3, #12]
 8001580:	e7eb      	b.n	800155a <HAL_DMA_Start_IT+0x32>
 8001582:	bf00      	nop

08001584 <HAL_DMA_Abort>:
  *        and the Channel will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 8001584:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0;

  /* Disable the channel */
  __HAL_DMA_DISABLE(hdma);
 8001586:	6802      	ldr	r2, [r0, #0]
 8001588:	6813      	ldr	r3, [r2, #0]
 800158a:	f023 0301 	bic.w	r3, r3, #1
 800158e:	6013      	str	r3, [r2, #0]
  *        and the Channel will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 8001590:	4604      	mov	r4, r0

  /* Disable the channel */
  __HAL_DMA_DISABLE(hdma);

  /* Get tick */
  tickstart = HAL_GetTick();
 8001592:	f7ff fab9 	bl	8000b08 <HAL_GetTick>
 8001596:	4605      	mov	r5, r0

  /* Check if the DMA Channel is effectively disabled */
  while((hdma->Instance->CCR & DMA_CCR_EN) != 0)
 8001598:	e005      	b.n	80015a6 <HAL_DMA_Abort+0x22>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
 800159a:	f7ff fab5 	bl	8000b08 <HAL_GetTick>
 800159e:	1b40      	subs	r0, r0, r5
 80015a0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80015a4:	d80a      	bhi.n	80015bc <HAL_DMA_Abort+0x38>

  /* Get tick */
  tickstart = HAL_GetTick();

  /* Check if the DMA Channel is effectively disabled */
  while((hdma->Instance->CCR & DMA_CCR_EN) != 0)
 80015a6:	6823      	ldr	r3, [r4, #0]
 80015a8:	6818      	ldr	r0, [r3, #0]
 80015aa:	f010 0001 	ands.w	r0, r0, #1
 80015ae:	d1f4      	bne.n	800159a <HAL_DMA_Abort+0x16>

      return HAL_TIMEOUT;
    }
  }
  /* Change the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 80015b0:	2301      	movs	r3, #1
  
  /* Process Unlocked */
  __HAL_UNLOCK(hdma);
 80015b2:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24

      return HAL_TIMEOUT;
    }
  }
  /* Change the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 80015b6:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
  
  /* Process Unlocked */
  __HAL_UNLOCK(hdma);
  
  return HAL_OK; 
}
 80015ba:	bd38      	pop	{r3, r4, r5, pc}
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 80015bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80015be:	2203      	movs	r2, #3
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 80015c0:	f043 0320 	orr.w	r3, r3, #32

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 80015c4:	2100      	movs	r1, #0
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 80015c6:	63a3      	str	r3, [r4, #56]	; 0x38

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 80015c8:	f884 1024 	strb.w	r1, [r4, #36]	; 0x24
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80015cc:	f884 2025 	strb.w	r2, [r4, #37]	; 0x25

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);

      return HAL_TIMEOUT;
 80015d0:	4610      	mov	r0, r2
 80015d2:	bd38      	pop	{r3, r4, r5, pc}

080015d4 <HAL_DMA_PollForTransfer>:
  * @param  CompleteLevel: Specifies the DMA level complete.
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, uint32_t CompleteLevel, uint32_t Timeout)
{
 80015d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80015d8:	b083      	sub	sp, #12
 80015da:	4616      	mov	r6, r2
 80015dc:	4681      	mov	r9, r0
  uint32_t temp;
  uint32_t tickstart = 0;

  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
 80015de:	9100      	str	r1, [sp, #0]
  {
    /* Transfer Complete flag */
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 80015e0:	6804      	ldr	r4, [r0, #0]
 80015e2:	4ac5      	ldr	r2, [pc, #788]	; (80018f8 <HAL_DMA_PollForTransfer+0x324>)
{
  uint32_t temp;
  uint32_t tickstart = 0;

  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
 80015e4:	b9e1      	cbnz	r1, 8001620 <HAL_DMA_PollForTransfer+0x4c>
  {
    /* Transfer Complete flag */
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 80015e6:	f424 6380 	bic.w	r3, r4, #1024	; 0x400
 80015ea:	4293      	cmp	r3, r2
 80015ec:	f000 8082 	beq.w	80016f4 <HAL_DMA_PollForTransfer+0x120>
 80015f0:	3214      	adds	r2, #20
 80015f2:	4293      	cmp	r3, r2
 80015f4:	f000 8082 	beq.w	80016fc <HAL_DMA_PollForTransfer+0x128>
 80015f8:	3214      	adds	r2, #20
 80015fa:	4293      	cmp	r3, r2
 80015fc:	f000 81c2 	beq.w	8001984 <HAL_DMA_PollForTransfer+0x3b0>
 8001600:	3214      	adds	r2, #20
 8001602:	4293      	cmp	r3, r2
 8001604:	f000 81d0 	beq.w	80019a8 <HAL_DMA_PollForTransfer+0x3d4>
 8001608:	3214      	adds	r2, #20
 800160a:	4293      	cmp	r3, r2
 800160c:	f000 81b4 	beq.w	8001978 <HAL_DMA_PollForTransfer+0x3a4>
 8001610:	4cba      	ldr	r4, [pc, #744]	; (80018fc <HAL_DMA_PollForTransfer+0x328>)
 8001612:	42a3      	cmp	r3, r4
 8001614:	bf0c      	ite	eq
 8001616:	f44f 1400 	moveq.w	r4, #2097152	; 0x200000
 800161a:	f04f 7400 	movne.w	r4, #33554432	; 0x2000000
 800161e:	e01b      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>
  }
  else
  {
    /* Half Transfer Complete flag */
    temp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);
 8001620:	f424 6380 	bic.w	r3, r4, #1024	; 0x400
 8001624:	4293      	cmp	r3, r2
 8001626:	d016      	beq.n	8001656 <HAL_DMA_PollForTransfer+0x82>
 8001628:	3214      	adds	r2, #20
 800162a:	4293      	cmp	r3, r2
 800162c:	d064      	beq.n	80016f8 <HAL_DMA_PollForTransfer+0x124>
 800162e:	3214      	adds	r2, #20
 8001630:	4293      	cmp	r3, r2
 8001632:	f000 81a4 	beq.w	800197e <HAL_DMA_PollForTransfer+0x3aa>
 8001636:	3214      	adds	r2, #20
 8001638:	4293      	cmp	r3, r2
 800163a:	f000 81b2 	beq.w	80019a2 <HAL_DMA_PollForTransfer+0x3ce>
 800163e:	3214      	adds	r2, #20
 8001640:	4293      	cmp	r3, r2
 8001642:	f000 8196 	beq.w	8001972 <HAL_DMA_PollForTransfer+0x39e>
 8001646:	4cad      	ldr	r4, [pc, #692]	; (80018fc <HAL_DMA_PollForTransfer+0x328>)
 8001648:	42a3      	cmp	r3, r4
 800164a:	bf0c      	ite	eq
 800164c:	f44f 0480 	moveq.w	r4, #4194304	; 0x400000
 8001650:	f04f 6480 	movne.w	r4, #67108864	; 0x4000000
 8001654:	e000      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>
 8001656:	2404      	movs	r4, #4
  }

  /* Get tick */
  tickstart = HAL_GetTick();
 8001658:	f7ff fa56 	bl	8000b08 <HAL_GetTick>

  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
 800165c:	4da8      	ldr	r5, [pc, #672]	; (8001900 <HAL_DMA_PollForTransfer+0x32c>)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
 800165e:	f8df 8298 	ldr.w	r8, [pc, #664]	; 80018f8 <HAL_DMA_PollForTransfer+0x324>
 8001662:	f8df a2b0 	ldr.w	sl, [pc, #688]	; 8001914 <HAL_DMA_PollForTransfer+0x340>
 8001666:	f8df b2b0 	ldr.w	fp, [pc, #688]	; 8001918 <HAL_DMA_PollForTransfer+0x344>
    /* Half Transfer Complete flag */
    temp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);
  }

  /* Get tick */
  tickstart = HAL_GetTick();
 800166a:	9001      	str	r0, [sp, #4]
 800166c:	f8d9 3000 	ldr.w	r3, [r9]

  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
 8001670:	f8df e2a8 	ldr.w	lr, [pc, #680]	; 800191c <HAL_DMA_PollForTransfer+0x348>
 8001674:	f8df c2a8 	ldr.w	ip, [pc, #680]	; 8001920 <HAL_DMA_PollForTransfer+0x34c>
  }

  /* Get tick */
  tickstart = HAL_GetTick();

  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
 8001678:	4aa2      	ldr	r2, [pc, #648]	; (8001904 <HAL_DMA_PollForTransfer+0x330>)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
 800167a:	4fa3      	ldr	r7, [pc, #652]	; (8001908 <HAL_DMA_PollForTransfer+0x334>)
 800167c:	e021      	b.n	80016c2 <HAL_DMA_PollForTransfer+0xee>
  }

  /* Get tick */
  tickstart = HAL_GetTick();

  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
 800167e:	6810      	ldr	r0, [r2, #0]
 8001680:	49a0      	ldr	r1, [pc, #640]	; (8001904 <HAL_DMA_PollForTransfer+0x330>)
 8001682:	4204      	tst	r4, r0
 8001684:	f040 80a9 	bne.w	80017da <HAL_DMA_PollForTransfer+0x206>
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
 8001688:	42bb      	cmp	r3, r7
 800168a:	6811      	ldr	r1, [r2, #0]
 800168c:	d038      	beq.n	8001700 <HAL_DMA_PollForTransfer+0x12c>
 800168e:	489f      	ldr	r0, [pc, #636]	; (800190c <HAL_DMA_PollForTransfer+0x338>)
 8001690:	4283      	cmp	r3, r0
 8001692:	d037      	beq.n	8001704 <HAL_DMA_PollForTransfer+0x130>
 8001694:	3014      	adds	r0, #20
 8001696:	4283      	cmp	r3, r0
 8001698:	d036      	beq.n	8001708 <HAL_DMA_PollForTransfer+0x134>
 800169a:	3014      	adds	r0, #20
 800169c:	4283      	cmp	r3, r0
 800169e:	d036      	beq.n	800170e <HAL_DMA_PollForTransfer+0x13a>
 80016a0:	3014      	adds	r0, #20
 80016a2:	4283      	cmp	r3, r0
 80016a4:	d071      	beq.n	800178a <HAL_DMA_PollForTransfer+0x1b6>
 80016a6:	3014      	adds	r0, #20
 80016a8:	4283      	cmp	r3, r0
 80016aa:	bf0c      	ite	eq
 80016ac:	f44f 0000 	moveq.w	r0, #8388608	; 0x800000
 80016b0:	f04f 6000 	movne.w	r0, #134217728	; 0x8000000
 80016b4:	4208      	tst	r0, r1
 80016b6:	bf14      	ite	ne
 80016b8:	2101      	movne	r1, #1
 80016ba:	2100      	moveq	r1, #0
 80016bc:	bb51      	cbnz	r1, 8001714 <HAL_DMA_PollForTransfer+0x140>
      __HAL_UNLOCK(hdma);

      return HAL_ERROR;
    }
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 80016be:	1c71      	adds	r1, r6, #1
 80016c0:	d14d      	bne.n	800175e <HAL_DMA_PollForTransfer+0x18a>
  }

  /* Get tick */
  tickstart = HAL_GetTick();

  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
 80016c2:	42ab      	cmp	r3, r5
 80016c4:	d8db      	bhi.n	800167e <HAL_DMA_PollForTransfer+0xaa>
 80016c6:	4992      	ldr	r1, [pc, #584]	; (8001910 <HAL_DMA_PollForTransfer+0x33c>)
 80016c8:	6808      	ldr	r0, [r1, #0]
 80016ca:	4204      	tst	r4, r0
 80016cc:	d160      	bne.n	8001790 <HAL_DMA_PollForTransfer+0x1bc>
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
 80016ce:	4543      	cmp	r3, r8
 80016d0:	6809      	ldr	r1, [r1, #0]
 80016d2:	d015      	beq.n	8001700 <HAL_DMA_PollForTransfer+0x12c>
 80016d4:	4553      	cmp	r3, sl
 80016d6:	d015      	beq.n	8001704 <HAL_DMA_PollForTransfer+0x130>
 80016d8:	455b      	cmp	r3, fp
 80016da:	d015      	beq.n	8001708 <HAL_DMA_PollForTransfer+0x134>
 80016dc:	4573      	cmp	r3, lr
 80016de:	d016      	beq.n	800170e <HAL_DMA_PollForTransfer+0x13a>
 80016e0:	4563      	cmp	r3, ip
 80016e2:	d052      	beq.n	800178a <HAL_DMA_PollForTransfer+0x1b6>
 80016e4:	4885      	ldr	r0, [pc, #532]	; (80018fc <HAL_DMA_PollForTransfer+0x328>)
 80016e6:	4283      	cmp	r3, r0
 80016e8:	bf0c      	ite	eq
 80016ea:	f44f 0000 	moveq.w	r0, #8388608	; 0x800000
 80016ee:	f04f 6000 	movne.w	r0, #134217728	; 0x8000000
 80016f2:	e7df      	b.n	80016b4 <HAL_DMA_PollForTransfer+0xe0>

  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Transfer Complete flag */
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 80016f4:	2402      	movs	r4, #2
 80016f6:	e7af      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>
  }
  else
  {
    /* Half Transfer Complete flag */
    temp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);
 80016f8:	2440      	movs	r4, #64	; 0x40
 80016fa:	e7ad      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>

  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Transfer Complete flag */
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 80016fc:	2420      	movs	r4, #32
 80016fe:	e7ab      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>
  /* Get tick */
  tickstart = HAL_GetTick();

  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
 8001700:	2008      	movs	r0, #8
 8001702:	e7d7      	b.n	80016b4 <HAL_DMA_PollForTransfer+0xe0>
 8001704:	2080      	movs	r0, #128	; 0x80
 8001706:	e7d5      	b.n	80016b4 <HAL_DMA_PollForTransfer+0xe0>
 8001708:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800170c:	e7d2      	b.n	80016b4 <HAL_DMA_PollForTransfer+0xe0>
 800170e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8001712:	e7cf      	b.n	80016b4 <HAL_DMA_PollForTransfer+0xe0>
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001714:	4a7a      	ldr	r2, [pc, #488]	; (8001900 <HAL_DMA_PollForTransfer+0x32c>)
 8001716:	4293      	cmp	r3, r2
 8001718:	f240 8087 	bls.w	800182a <HAL_DMA_PollForTransfer+0x256>
 800171c:	4976      	ldr	r1, [pc, #472]	; (80018f8 <HAL_DMA_PollForTransfer+0x324>)
 800171e:	f502 7260 	add.w	r2, r2, #896	; 0x380
 8001722:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001726:	428b      	cmp	r3, r1
 8001728:	6852      	ldr	r2, [r2, #4]
 800172a:	f000 810f 	beq.w	800194c <HAL_DMA_PollForTransfer+0x378>
 800172e:	3114      	adds	r1, #20
 8001730:	428b      	cmp	r3, r1
 8001732:	f000 8130 	beq.w	8001996 <HAL_DMA_PollForTransfer+0x3c2>
 8001736:	3114      	adds	r1, #20
 8001738:	428b      	cmp	r3, r1
 800173a:	f000 8110 	beq.w	800195e <HAL_DMA_PollForTransfer+0x38a>
 800173e:	3114      	adds	r1, #20
 8001740:	428b      	cmp	r3, r1
 8001742:	f000 813a 	beq.w	80019ba <HAL_DMA_PollForTransfer+0x3e6>
 8001746:	3114      	adds	r1, #20
 8001748:	428b      	cmp	r3, r1
 800174a:	f000 814e 	beq.w	80019ea <HAL_DMA_PollForTransfer+0x416>
 800174e:	3114      	adds	r1, #20
 8001750:	428b      	cmp	r3, r1
 8001752:	bf0c      	ite	eq
 8001754:	f44f 0300 	moveq.w	r3, #8388608	; 0x800000
 8001758:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 800175c:	e0f7      	b.n	800194e <HAL_DMA_PollForTransfer+0x37a>
      return HAL_ERROR;
    }
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
 800175e:	b136      	cbz	r6, 800176e <HAL_DMA_PollForTransfer+0x19a>
 8001760:	f7ff f9d2 	bl	8000b08 <HAL_GetTick>
 8001764:	9b01      	ldr	r3, [sp, #4]
 8001766:	1ac0      	subs	r0, r0, r3
 8001768:	4286      	cmp	r6, r0
 800176a:	f4bf af7f 	bcs.w	800166c <HAL_DMA_PollForTransfer+0x98>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 800176e:	f8d9 3038 	ldr.w	r3, [r9, #56]	; 0x38

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8001772:	2203      	movs	r2, #3
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 8001774:	f043 0320 	orr.w	r3, r3, #32

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_TIMEOUT;

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 8001778:	2100      	movs	r1, #0
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 800177a:	f8c9 3038 	str.w	r3, [r9, #56]	; 0x38
        hdma->State = HAL_DMA_STATE_TIMEOUT;

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);

        return HAL_TIMEOUT;
 800177e:	4610      	mov	r0, r2
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8001780:	f889 2025 	strb.w	r2, [r9, #37]	; 0x25

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 8001784:	f889 1024 	strb.w	r1, [r9, #36]	; 0x24

        return HAL_TIMEOUT;
 8001788:	e0dd      	b.n	8001946 <HAL_DMA_PollForTransfer+0x372>
  /* Get tick */
  tickstart = HAL_GetTick();

  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
 800178a:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800178e:	e791      	b.n	80016b4 <HAL_DMA_PollForTransfer+0xe0>
        return HAL_TIMEOUT;
      }
    }
  }

  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
 8001790:	9a00      	ldr	r2, [sp, #0]
 8001792:	2a00      	cmp	r2, #0
 8001794:	d168      	bne.n	8001868 <HAL_DMA_PollForTransfer+0x294>
  {
    /* Clear the transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001796:	4858      	ldr	r0, [pc, #352]	; (80018f8 <HAL_DMA_PollForTransfer+0x324>)
 8001798:	684a      	ldr	r2, [r1, #4]
 800179a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800179e:	4283      	cmp	r3, r0
 80017a0:	f000 80f5 	beq.w	800198e <HAL_DMA_PollForTransfer+0x3ba>
 80017a4:	495b      	ldr	r1, [pc, #364]	; (8001914 <HAL_DMA_PollForTransfer+0x340>)
 80017a6:	428b      	cmp	r3, r1
 80017a8:	f000 80d7 	beq.w	800195a <HAL_DMA_PollForTransfer+0x386>
 80017ac:	3114      	adds	r1, #20
 80017ae:	428b      	cmp	r3, r1
 80017b0:	f000 8100 	beq.w	80019b4 <HAL_DMA_PollForTransfer+0x3e0>
 80017b4:	3114      	adds	r1, #20
 80017b6:	428b      	cmp	r3, r1
 80017b8:	f000 8114 	beq.w	80019e4 <HAL_DMA_PollForTransfer+0x410>
 80017bc:	3114      	adds	r1, #20
 80017be:	428b      	cmp	r3, r1
 80017c0:	f000 811c 	beq.w	80019fc <HAL_DMA_PollForTransfer+0x428>
 80017c4:	3114      	adds	r1, #20
 80017c6:	428b      	cmp	r3, r1
 80017c8:	bf0c      	ite	eq
 80017ca:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 80017ce:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 80017d2:	494f      	ldr	r1, [pc, #316]	; (8001910 <HAL_DMA_PollForTransfer+0x33c>)
 80017d4:	4313      	orrs	r3, r2
 80017d6:	604b      	str	r3, [r1, #4]
 80017d8:	e023      	b.n	8001822 <HAL_DMA_PollForTransfer+0x24e>
        return HAL_TIMEOUT;
      }
    }
  }

  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
 80017da:	9a00      	ldr	r2, [sp, #0]
 80017dc:	2a00      	cmp	r2, #0
 80017de:	d164      	bne.n	80018aa <HAL_DMA_PollForTransfer+0x2d6>
  {
    /* Clear the transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80017e0:	4845      	ldr	r0, [pc, #276]	; (80018f8 <HAL_DMA_PollForTransfer+0x324>)
 80017e2:	684a      	ldr	r2, [r1, #4]
 80017e4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80017e8:	4283      	cmp	r3, r0
 80017ea:	f000 80d6 	beq.w	800199a <HAL_DMA_PollForTransfer+0x3c6>
 80017ee:	4949      	ldr	r1, [pc, #292]	; (8001914 <HAL_DMA_PollForTransfer+0x340>)
 80017f0:	428b      	cmp	r3, r1
 80017f2:	f000 80b7 	beq.w	8001964 <HAL_DMA_PollForTransfer+0x390>
 80017f6:	3114      	adds	r1, #20
 80017f8:	428b      	cmp	r3, r1
 80017fa:	f000 80d8 	beq.w	80019ae <HAL_DMA_PollForTransfer+0x3da>
 80017fe:	3114      	adds	r1, #20
 8001800:	428b      	cmp	r3, r1
 8001802:	f000 80ec 	beq.w	80019de <HAL_DMA_PollForTransfer+0x40a>
 8001806:	3114      	adds	r1, #20
 8001808:	428b      	cmp	r3, r1
 800180a:	f000 80f4 	beq.w	80019f6 <HAL_DMA_PollForTransfer+0x422>
 800180e:	3114      	adds	r1, #20
 8001810:	428b      	cmp	r3, r1
 8001812:	bf0c      	ite	eq
 8001814:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001818:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 800181c:	4939      	ldr	r1, [pc, #228]	; (8001904 <HAL_DMA_PollForTransfer+0x330>)
 800181e:	4313      	orrs	r3, r2
 8001820:	604b      	str	r3, [r1, #4]

    /* The selected Channelx EN bit is cleared (DMA is disabled and
    all transfers are complete) */
    hdma->State = HAL_DMA_STATE_READY;
 8001822:	2301      	movs	r3, #1
 8001824:	f889 3025 	strb.w	r3, [r9, #37]	; 0x25
 8001828:	e060      	b.n	80018ec <HAL_DMA_PollForTransfer+0x318>
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800182a:	4933      	ldr	r1, [pc, #204]	; (80018f8 <HAL_DMA_PollForTransfer+0x324>)
 800182c:	4a38      	ldr	r2, [pc, #224]	; (8001910 <HAL_DMA_PollForTransfer+0x33c>)
 800182e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001832:	428b      	cmp	r3, r1
 8001834:	6852      	ldr	r2, [r2, #4]
 8001836:	d075      	beq.n	8001924 <HAL_DMA_PollForTransfer+0x350>
 8001838:	3114      	adds	r1, #20
 800183a:	428b      	cmp	r3, r1
 800183c:	f000 80a9 	beq.w	8001992 <HAL_DMA_PollForTransfer+0x3be>
 8001840:	3114      	adds	r1, #20
 8001842:	428b      	cmp	r3, r1
 8001844:	f000 8090 	beq.w	8001968 <HAL_DMA_PollForTransfer+0x394>
 8001848:	3114      	adds	r1, #20
 800184a:	428b      	cmp	r3, r1
 800184c:	f000 80bb 	beq.w	80019c6 <HAL_DMA_PollForTransfer+0x3f2>
 8001850:	3114      	adds	r1, #20
 8001852:	428b      	cmp	r3, r1
 8001854:	f000 80bd 	beq.w	80019d2 <HAL_DMA_PollForTransfer+0x3fe>
 8001858:	3114      	adds	r1, #20
 800185a:	428b      	cmp	r3, r1
 800185c:	bf0c      	ite	eq
 800185e:	f44f 0300 	moveq.w	r3, #8388608	; 0x800000
 8001862:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8001866:	e05e      	b.n	8001926 <HAL_DMA_PollForTransfer+0x352>

  }
  else
  {
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001868:	4823      	ldr	r0, [pc, #140]	; (80018f8 <HAL_DMA_PollForTransfer+0x324>)
 800186a:	684a      	ldr	r2, [r1, #4]
 800186c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001870:	4283      	cmp	r3, r0
 8001872:	f000 8094 	beq.w	800199e <HAL_DMA_PollForTransfer+0x3ca>
 8001876:	4927      	ldr	r1, [pc, #156]	; (8001914 <HAL_DMA_PollForTransfer+0x340>)
 8001878:	428b      	cmp	r3, r1
 800187a:	d078      	beq.n	800196e <HAL_DMA_PollForTransfer+0x39a>
 800187c:	3114      	adds	r1, #20
 800187e:	428b      	cmp	r3, r1
 8001880:	f000 80a4 	beq.w	80019cc <HAL_DMA_PollForTransfer+0x3f8>
 8001884:	3114      	adds	r1, #20
 8001886:	428b      	cmp	r3, r1
 8001888:	f000 80a6 	beq.w	80019d8 <HAL_DMA_PollForTransfer+0x404>
 800188c:	3114      	adds	r1, #20
 800188e:	428b      	cmp	r3, r1
 8001890:	f000 80ba 	beq.w	8001a08 <HAL_DMA_PollForTransfer+0x434>
 8001894:	3114      	adds	r1, #20
 8001896:	428b      	cmp	r3, r1
 8001898:	bf0c      	ite	eq
 800189a:	f44f 0380 	moveq.w	r3, #4194304	; 0x400000
 800189e:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 80018a2:	491b      	ldr	r1, [pc, #108]	; (8001910 <HAL_DMA_PollForTransfer+0x33c>)
 80018a4:	4313      	orrs	r3, r2
 80018a6:	604b      	str	r3, [r1, #4]
 80018a8:	e01d      	b.n	80018e6 <HAL_DMA_PollForTransfer+0x312>
 80018aa:	4813      	ldr	r0, [pc, #76]	; (80018f8 <HAL_DMA_PollForTransfer+0x324>)
 80018ac:	684a      	ldr	r2, [r1, #4]
 80018ae:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80018b2:	4283      	cmp	r3, r0
 80018b4:	d069      	beq.n	800198a <HAL_DMA_PollForTransfer+0x3b6>
 80018b6:	4917      	ldr	r1, [pc, #92]	; (8001914 <HAL_DMA_PollForTransfer+0x340>)
 80018b8:	428b      	cmp	r3, r1
 80018ba:	d04c      	beq.n	8001956 <HAL_DMA_PollForTransfer+0x382>
 80018bc:	3114      	adds	r1, #20
 80018be:	428b      	cmp	r3, r1
 80018c0:	d07e      	beq.n	80019c0 <HAL_DMA_PollForTransfer+0x3ec>
 80018c2:	3114      	adds	r1, #20
 80018c4:	428b      	cmp	r3, r1
 80018c6:	f000 8093 	beq.w	80019f0 <HAL_DMA_PollForTransfer+0x41c>
 80018ca:	3114      	adds	r1, #20
 80018cc:	428b      	cmp	r3, r1
 80018ce:	f000 8098 	beq.w	8001a02 <HAL_DMA_PollForTransfer+0x42e>
 80018d2:	3114      	adds	r1, #20
 80018d4:	428b      	cmp	r3, r1
 80018d6:	bf0c      	ite	eq
 80018d8:	f44f 0380 	moveq.w	r3, #4194304	; 0x400000
 80018dc:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 80018e0:	4908      	ldr	r1, [pc, #32]	; (8001904 <HAL_DMA_PollForTransfer+0x330>)
 80018e2:	4313      	orrs	r3, r2
 80018e4:	604b      	str	r3, [r1, #4]

    hdma->State = HAL_DMA_STATE_READY_HALF;
 80018e6:	2311      	movs	r3, #17
 80018e8:	f889 3025 	strb.w	r3, [r9, #37]	; 0x25
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hdma);  
 80018ec:	2000      	movs	r0, #0
 80018ee:	f889 0024 	strb.w	r0, [r9, #36]	; 0x24

  return HAL_OK;
}
 80018f2:	b003      	add	sp, #12
 80018f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80018f8:	40020008 	.word	0x40020008
 80018fc:	4002006c 	.word	0x4002006c
 8001900:	40020080 	.word	0x40020080
 8001904:	40020400 	.word	0x40020400
 8001908:	40020408 	.word	0x40020408
 800190c:	4002041c 	.word	0x4002041c
 8001910:	40020000 	.word	0x40020000
 8001914:	4002001c 	.word	0x4002001c
 8001918:	40020030 	.word	0x40020030
 800191c:	40020044 	.word	0x40020044
 8001920:	40020058 	.word	0x40020058
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001924:	2308      	movs	r3, #8
 8001926:	493a      	ldr	r1, [pc, #232]	; (8001a10 <HAL_DMA_PollForTransfer+0x43c>)
 8001928:	4313      	orrs	r3, r2
 800192a:	604b      	str	r3, [r1, #4]

      /* Update error code */
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
 800192c:	f8d9 3038 	ldr.w	r3, [r9, #56]	; 0x38

      /* Change the DMA state */
      hdma->State= HAL_DMA_STATE_ERROR;
 8001930:	2204      	movs	r2, #4
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));

      /* Update error code */
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
 8001932:	f043 0301 	orr.w	r3, r3, #1

      /* Change the DMA state */
      hdma->State= HAL_DMA_STATE_ERROR;

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8001936:	2100      	movs	r1, #0
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));

      /* Update error code */
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
 8001938:	f8c9 3038 	str.w	r3, [r9, #56]	; 0x38

      /* Change the DMA state */
      hdma->State= HAL_DMA_STATE_ERROR;

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800193c:	f889 1024 	strb.w	r1, [r9, #36]	; 0x24

      /* Update error code */
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);

      /* Change the DMA state */
      hdma->State= HAL_DMA_STATE_ERROR;
 8001940:	f889 2025 	strb.w	r2, [r9, #37]	; 0x25

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);

      return HAL_ERROR;
 8001944:	2001      	movs	r0, #1
  
  /* Process unlocked */
  __HAL_UNLOCK(hdma);  

  return HAL_OK;
}
 8001946:	b003      	add	sp, #12
 8001948:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800194c:	2308      	movs	r3, #8
 800194e:	4931      	ldr	r1, [pc, #196]	; (8001a14 <HAL_DMA_PollForTransfer+0x440>)
 8001950:	4313      	orrs	r3, r2
 8001952:	604b      	str	r3, [r1, #4]
 8001954:	e7ea      	b.n	800192c <HAL_DMA_PollForTransfer+0x358>

  }
  else
  {
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001956:	2340      	movs	r3, #64	; 0x40
 8001958:	e7c2      	b.n	80018e0 <HAL_DMA_PollForTransfer+0x30c>
  }

  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Clear the transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800195a:	2320      	movs	r3, #32
 800195c:	e739      	b.n	80017d2 <HAL_DMA_PollForTransfer+0x1fe>
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800195e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001962:	e7f4      	b.n	800194e <HAL_DMA_PollForTransfer+0x37a>
  }

  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Clear the transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001964:	2320      	movs	r3, #32
 8001966:	e759      	b.n	800181c <HAL_DMA_PollForTransfer+0x248>
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001968:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800196c:	e7db      	b.n	8001926 <HAL_DMA_PollForTransfer+0x352>

  }
  else
  {
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800196e:	2340      	movs	r3, #64	; 0x40
 8001970:	e797      	b.n	80018a2 <HAL_DMA_PollForTransfer+0x2ce>
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
  }
  else
  {
    /* Half Transfer Complete flag */
    temp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);
 8001972:	f44f 2480 	mov.w	r4, #262144	; 0x40000
 8001976:	e66f      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>

  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Transfer Complete flag */
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 8001978:	f44f 3400 	mov.w	r4, #131072	; 0x20000
 800197c:	e66c      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>
  }
  else
  {
    /* Half Transfer Complete flag */
    temp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);
 800197e:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8001982:	e669      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>

  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Transfer Complete flag */
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 8001984:	f44f 7400 	mov.w	r4, #512	; 0x200
 8001988:	e666      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>

  }
  else
  {
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800198a:	2304      	movs	r3, #4
 800198c:	e7a8      	b.n	80018e0 <HAL_DMA_PollForTransfer+0x30c>
  }

  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Clear the transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800198e:	2302      	movs	r3, #2
 8001990:	e71f      	b.n	80017d2 <HAL_DMA_PollForTransfer+0x1fe>
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001992:	2380      	movs	r3, #128	; 0x80
 8001994:	e7c7      	b.n	8001926 <HAL_DMA_PollForTransfer+0x352>
 8001996:	2380      	movs	r3, #128	; 0x80
 8001998:	e7d9      	b.n	800194e <HAL_DMA_PollForTransfer+0x37a>
  }

  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Clear the transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800199a:	2302      	movs	r3, #2
 800199c:	e73e      	b.n	800181c <HAL_DMA_PollForTransfer+0x248>

  }
  else
  {
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800199e:	2304      	movs	r3, #4
 80019a0:	e77f      	b.n	80018a2 <HAL_DMA_PollForTransfer+0x2ce>
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
  }
  else
  {
    /* Half Transfer Complete flag */
    temp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);
 80019a2:	f44f 4480 	mov.w	r4, #16384	; 0x4000
 80019a6:	e657      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>

  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Transfer Complete flag */
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 80019a8:	f44f 5400 	mov.w	r4, #8192	; 0x2000
 80019ac:	e654      	b.n	8001658 <HAL_DMA_PollForTransfer+0x84>
  }

  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Clear the transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80019ae:	f44f 7300 	mov.w	r3, #512	; 0x200
 80019b2:	e733      	b.n	800181c <HAL_DMA_PollForTransfer+0x248>
 80019b4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80019b8:	e70b      	b.n	80017d2 <HAL_DMA_PollForTransfer+0x1fe>
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80019ba:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80019be:	e7c6      	b.n	800194e <HAL_DMA_PollForTransfer+0x37a>

  }
  else
  {
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80019c0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80019c4:	e78c      	b.n	80018e0 <HAL_DMA_PollForTransfer+0x30c>
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80019c6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80019ca:	e7ac      	b.n	8001926 <HAL_DMA_PollForTransfer+0x352>

  }
  else
  {
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80019cc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80019d0:	e767      	b.n	80018a2 <HAL_DMA_PollForTransfer+0x2ce>
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80019d2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80019d6:	e7a6      	b.n	8001926 <HAL_DMA_PollForTransfer+0x352>

  }
  else
  {
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80019d8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80019dc:	e761      	b.n	80018a2 <HAL_DMA_PollForTransfer+0x2ce>
  }

  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Clear the transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80019de:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80019e2:	e71b      	b.n	800181c <HAL_DMA_PollForTransfer+0x248>
 80019e4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80019e8:	e6f3      	b.n	80017d2 <HAL_DMA_PollForTransfer+0x1fe>
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
  {
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    {
      /* Clear the transfer error flags */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80019ea:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80019ee:	e7ae      	b.n	800194e <HAL_DMA_PollForTransfer+0x37a>

  }
  else
  {
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80019f0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80019f4:	e774      	b.n	80018e0 <HAL_DMA_PollForTransfer+0x30c>
  }

  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
  {
    /* Clear the transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80019f6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80019fa:	e70f      	b.n	800181c <HAL_DMA_PollForTransfer+0x248>
 80019fc:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001a00:	e6e7      	b.n	80017d2 <HAL_DMA_PollForTransfer+0x1fe>

  }
  else
  {
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001a02:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001a06:	e76b      	b.n	80018e0 <HAL_DMA_PollForTransfer+0x30c>
 8001a08:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001a0c:	e749      	b.n	80018a2 <HAL_DMA_PollForTransfer+0x2ce>
 8001a0e:	bf00      	nop
 8001a10:	40020000 	.word	0x40020000
 8001a14:	40020400 	.word	0x40020400

08001a18 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8001a18:	b510      	push	{r4, lr}
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001a1a:	4ac1      	ldr	r2, [pc, #772]	; (8001d20 <HAL_DMA_IRQHandler+0x308>)
 8001a1c:	6803      	ldr	r3, [r0, #0]
 8001a1e:	4293      	cmp	r3, r2
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8001a20:	4604      	mov	r4, r0
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001a22:	d920      	bls.n	8001a66 <HAL_DMA_IRQHandler+0x4e>
 8001a24:	49bf      	ldr	r1, [pc, #764]	; (8001d24 <HAL_DMA_IRQHandler+0x30c>)
 8001a26:	f8d2 0380 	ldr.w	r0, [r2, #896]	; 0x380
 8001a2a:	f502 7260 	add.w	r2, r2, #896	; 0x380
 8001a2e:	428b      	cmp	r3, r1
 8001a30:	d06f      	beq.n	8001b12 <HAL_DMA_IRQHandler+0xfa>
 8001a32:	3114      	adds	r1, #20
 8001a34:	428b      	cmp	r3, r1
 8001a36:	f000 81d6 	beq.w	8001de6 <HAL_DMA_IRQHandler+0x3ce>
 8001a3a:	3114      	adds	r1, #20
 8001a3c:	428b      	cmp	r3, r1
 8001a3e:	f000 8221 	beq.w	8001e84 <HAL_DMA_IRQHandler+0x46c>
 8001a42:	3114      	adds	r1, #20
 8001a44:	428b      	cmp	r3, r1
 8001a46:	f000 81ee 	beq.w	8001e26 <HAL_DMA_IRQHandler+0x40e>
 8001a4a:	3114      	adds	r1, #20
 8001a4c:	428b      	cmp	r3, r1
 8001a4e:	f000 823f 	beq.w	8001ed0 <HAL_DMA_IRQHandler+0x4b8>
 8001a52:	3114      	adds	r1, #20
 8001a54:	428b      	cmp	r3, r1
 8001a56:	f000 825b 	beq.w	8001f10 <HAL_DMA_IRQHandler+0x4f8>
 8001a5a:	0101      	lsls	r1, r0, #4
 8001a5c:	d461      	bmi.n	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001a5e:	6811      	ldr	r1, [r2, #0]
 8001a60:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8001a64:	e1c4      	b.n	8001df0 <HAL_DMA_IRQHandler+0x3d8>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001a66:	49b0      	ldr	r1, [pc, #704]	; (8001d28 <HAL_DMA_IRQHandler+0x310>)
 8001a68:	4ab0      	ldr	r2, [pc, #704]	; (8001d2c <HAL_DMA_IRQHandler+0x314>)
 8001a6a:	428b      	cmp	r3, r1
 8001a6c:	6810      	ldr	r0, [r2, #0]
 8001a6e:	d018      	beq.n	8001aa2 <HAL_DMA_IRQHandler+0x8a>
 8001a70:	3114      	adds	r1, #20
 8001a72:	428b      	cmp	r3, r1
 8001a74:	d052      	beq.n	8001b1c <HAL_DMA_IRQHandler+0x104>
 8001a76:	3114      	adds	r1, #20
 8001a78:	428b      	cmp	r3, r1
 8001a7a:	f000 81f6 	beq.w	8001e6a <HAL_DMA_IRQHandler+0x452>
 8001a7e:	3114      	adds	r1, #20
 8001a80:	428b      	cmp	r3, r1
 8001a82:	f000 820b 	beq.w	8001e9c <HAL_DMA_IRQHandler+0x484>
 8001a86:	3114      	adds	r1, #20
 8001a88:	428b      	cmp	r3, r1
 8001a8a:	f000 81db 	beq.w	8001e44 <HAL_DMA_IRQHandler+0x42c>
 8001a8e:	3114      	adds	r1, #20
 8001a90:	428b      	cmp	r3, r1
 8001a92:	f000 8230 	beq.w	8001ef6 <HAL_DMA_IRQHandler+0x4de>
 8001a96:	0100      	lsls	r0, r0, #4
 8001a98:	d443      	bmi.n	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001a9a:	6812      	ldr	r2, [r2, #0]
 8001a9c:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
 8001aa0:	e003      	b.n	8001aaa <HAL_DMA_IRQHandler+0x92>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001aa2:	0701      	lsls	r1, r0, #28
 8001aa4:	d43d      	bmi.n	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001aa6:	6812      	ldr	r2, [r2, #0]
 8001aa8:	2104      	movs	r1, #4
 8001aaa:	4211      	tst	r1, r2
 8001aac:	f000 811c 	beq.w	8001ce8 <HAL_DMA_IRQHandler+0x2d0>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8001ab0:	681a      	ldr	r2, [r3, #0]
 8001ab2:	0752      	lsls	r2, r2, #29
 8001ab4:	f140 80f7 	bpl.w	8001ca6 <HAL_DMA_IRQHandler+0x28e>
    {
      /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 8001ab8:	681a      	ldr	r2, [r3, #0]
 8001aba:	0690      	lsls	r0, r2, #26
 8001abc:	d404      	bmi.n	8001ac8 <HAL_DMA_IRQHandler+0xb0>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8001abe:	681a      	ldr	r2, [r3, #0]
 8001ac0:	f022 0204 	bic.w	r2, r2, #4
 8001ac4:	601a      	str	r2, [r3, #0]
 8001ac6:	6823      	ldr	r3, [r4, #0]
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001ac8:	4a95      	ldr	r2, [pc, #596]	; (8001d20 <HAL_DMA_IRQHandler+0x308>)
 8001aca:	4293      	cmp	r3, r2
 8001acc:	f240 80c3 	bls.w	8001c56 <HAL_DMA_IRQHandler+0x23e>
 8001ad0:	4994      	ldr	r1, [pc, #592]	; (8001d24 <HAL_DMA_IRQHandler+0x30c>)
 8001ad2:	4a97      	ldr	r2, [pc, #604]	; (8001d30 <HAL_DMA_IRQHandler+0x318>)
 8001ad4:	428b      	cmp	r3, r1
 8001ad6:	6852      	ldr	r2, [r2, #4]
 8001ad8:	f000 823b 	beq.w	8001f52 <HAL_DMA_IRQHandler+0x53a>
 8001adc:	4995      	ldr	r1, [pc, #596]	; (8001d34 <HAL_DMA_IRQHandler+0x31c>)
 8001ade:	428b      	cmp	r3, r1
 8001ae0:	f000 81e8 	beq.w	8001eb4 <HAL_DMA_IRQHandler+0x49c>
 8001ae4:	3114      	adds	r1, #20
 8001ae6:	428b      	cmp	r3, r1
 8001ae8:	f000 81ff 	beq.w	8001eea <HAL_DMA_IRQHandler+0x4d2>
 8001aec:	3114      	adds	r1, #20
 8001aee:	428b      	cmp	r3, r1
 8001af0:	f000 821b 	beq.w	8001f2a <HAL_DMA_IRQHandler+0x512>
 8001af4:	3114      	adds	r1, #20
 8001af6:	428b      	cmp	r3, r1
 8001af8:	f000 8226 	beq.w	8001f48 <HAL_DMA_IRQHandler+0x530>
 8001afc:	3114      	adds	r1, #20
 8001afe:	428b      	cmp	r3, r1
 8001b00:	bf0c      	ite	eq
 8001b02:	f44f 0380 	moveq.w	r3, #4194304	; 0x400000
 8001b06:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8001b0a:	4989      	ldr	r1, [pc, #548]	; (8001d30 <HAL_DMA_IRQHandler+0x318>)
 8001b0c:	4313      	orrs	r3, r2
 8001b0e:	604b      	str	r3, [r1, #4]
 8001b10:	e0c1      	b.n	8001c96 <HAL_DMA_IRQHandler+0x27e>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001b12:	0701      	lsls	r1, r0, #28
 8001b14:	d405      	bmi.n	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001b16:	6811      	ldr	r1, [r2, #0]
 8001b18:	2204      	movs	r2, #4
 8001b1a:	e169      	b.n	8001df0 <HAL_DMA_IRQHandler+0x3d8>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001b1c:	0600      	lsls	r0, r0, #24
 8001b1e:	f140 815b 	bpl.w	8001dd8 <HAL_DMA_IRQHandler+0x3c0>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8001b22:	681a      	ldr	r2, [r3, #0]
 8001b24:	0711      	lsls	r1, r2, #28
 8001b26:	d558      	bpl.n	8001bda <HAL_DMA_IRQHandler+0x1c2>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 8001b28:	681a      	ldr	r2, [r3, #0]

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001b2a:	497d      	ldr	r1, [pc, #500]	; (8001d20 <HAL_DMA_IRQHandler+0x308>)
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 8001b2c:	f022 0208 	bic.w	r2, r2, #8
 8001b30:	601a      	str	r2, [r3, #0]

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001b32:	6823      	ldr	r3, [r4, #0]
 8001b34:	428b      	cmp	r3, r1
 8001b36:	d921      	bls.n	8001b7c <HAL_DMA_IRQHandler+0x164>
 8001b38:	4a7d      	ldr	r2, [pc, #500]	; (8001d30 <HAL_DMA_IRQHandler+0x318>)
 8001b3a:	f501 7162 	add.w	r1, r1, #904	; 0x388
 8001b3e:	428b      	cmp	r3, r1
 8001b40:	6852      	ldr	r2, [r2, #4]
 8001b42:	f000 8199 	beq.w	8001e78 <HAL_DMA_IRQHandler+0x460>
 8001b46:	3114      	adds	r1, #20
 8001b48:	428b      	cmp	r3, r1
 8001b4a:	f000 8179 	beq.w	8001e40 <HAL_DMA_IRQHandler+0x428>
 8001b4e:	3114      	adds	r1, #20
 8001b50:	428b      	cmp	r3, r1
 8001b52:	f000 81c7 	beq.w	8001ee4 <HAL_DMA_IRQHandler+0x4cc>
 8001b56:	3114      	adds	r1, #20
 8001b58:	428b      	cmp	r3, r1
 8001b5a:	f000 81e3 	beq.w	8001f24 <HAL_DMA_IRQHandler+0x50c>
 8001b5e:	3114      	adds	r1, #20
 8001b60:	428b      	cmp	r3, r1
 8001b62:	f000 81ee 	beq.w	8001f42 <HAL_DMA_IRQHandler+0x52a>
 8001b66:	3114      	adds	r1, #20
 8001b68:	428b      	cmp	r3, r1
 8001b6a:	bf0c      	ite	eq
 8001b6c:	f44f 0300 	moveq.w	r3, #8388608	; 0x800000
 8001b70:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8001b74:	496e      	ldr	r1, [pc, #440]	; (8001d30 <HAL_DMA_IRQHandler+0x318>)
 8001b76:	4313      	orrs	r3, r2
 8001b78:	604b      	str	r3, [r1, #4]
 8001b7a:	e01f      	b.n	8001bbc <HAL_DMA_IRQHandler+0x1a4>
 8001b7c:	496a      	ldr	r1, [pc, #424]	; (8001d28 <HAL_DMA_IRQHandler+0x310>)
 8001b7e:	4a6b      	ldr	r2, [pc, #428]	; (8001d2c <HAL_DMA_IRQHandler+0x314>)
 8001b80:	428b      	cmp	r3, r1
 8001b82:	6852      	ldr	r2, [r2, #4]
 8001b84:	f000 817a 	beq.w	8001e7c <HAL_DMA_IRQHandler+0x464>
 8001b88:	3114      	adds	r1, #20
 8001b8a:	428b      	cmp	r3, r1
 8001b8c:	f000 8147 	beq.w	8001e1e <HAL_DMA_IRQHandler+0x406>
 8001b90:	3114      	adds	r1, #20
 8001b92:	428b      	cmp	r3, r1
 8001b94:	f000 8190 	beq.w	8001eb8 <HAL_DMA_IRQHandler+0x4a0>
 8001b98:	3114      	adds	r1, #20
 8001b9a:	428b      	cmp	r3, r1
 8001b9c:	f000 81b2 	beq.w	8001f04 <HAL_DMA_IRQHandler+0x4ec>
 8001ba0:	3114      	adds	r1, #20
 8001ba2:	428b      	cmp	r3, r1
 8001ba4:	f000 81c7 	beq.w	8001f36 <HAL_DMA_IRQHandler+0x51e>
 8001ba8:	3114      	adds	r1, #20
 8001baa:	428b      	cmp	r3, r1
 8001bac:	bf0c      	ite	eq
 8001bae:	f44f 0300 	moveq.w	r3, #8388608	; 0x800000
 8001bb2:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8001bb6:	495d      	ldr	r1, [pc, #372]	; (8001d2c <HAL_DMA_IRQHandler+0x314>)
 8001bb8:	4313      	orrs	r3, r2
 8001bba:	604b      	str	r3, [r1, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8001bbc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hdma->State = HAL_DMA_STATE_ERROR;

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);

      if (hdma->XferErrorCallback != NULL)
 8001bbe:	6b62      	ldr	r2, [r4, #52]	; 0x34

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8001bc0:	f043 0301 	orr.w	r3, r3, #1

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8001bc4:	2104      	movs	r1, #4

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8001bc6:	2000      	movs	r0, #0

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8001bc8:	63a3      	str	r3, [r4, #56]	; 0x38

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8001bca:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8001bce:	f884 1025 	strb.w	r1, [r4, #37]	; 0x25

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);

      if (hdma->XferErrorCallback != NULL)
 8001bd2:	b10a      	cbz	r2, 8001bd8 <HAL_DMA_IRQHandler+0x1c0>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8001bd4:	4620      	mov	r0, r4
 8001bd6:	4790      	blx	r2
 8001bd8:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001bda:	4a51      	ldr	r2, [pc, #324]	; (8001d20 <HAL_DMA_IRQHandler+0x308>)
 8001bdc:	4293      	cmp	r3, r2
 8001bde:	d91c      	bls.n	8001c1a <HAL_DMA_IRQHandler+0x202>
 8001be0:	4a50      	ldr	r2, [pc, #320]	; (8001d24 <HAL_DMA_IRQHandler+0x30c>)
 8001be2:	4953      	ldr	r1, [pc, #332]	; (8001d30 <HAL_DMA_IRQHandler+0x318>)
 8001be4:	4293      	cmp	r3, r2
 8001be6:	6809      	ldr	r1, [r1, #0]
 8001be8:	d096      	beq.n	8001b18 <HAL_DMA_IRQHandler+0x100>
 8001bea:	4a52      	ldr	r2, [pc, #328]	; (8001d34 <HAL_DMA_IRQHandler+0x31c>)
 8001bec:	4293      	cmp	r3, r2
 8001bee:	f000 80fe 	beq.w	8001dee <HAL_DMA_IRQHandler+0x3d6>
 8001bf2:	3214      	adds	r2, #20
 8001bf4:	4293      	cmp	r3, r2
 8001bf6:	f000 8149 	beq.w	8001e8c <HAL_DMA_IRQHandler+0x474>
 8001bfa:	3214      	adds	r2, #20
 8001bfc:	4293      	cmp	r3, r2
 8001bfe:	f000 8116 	beq.w	8001e2e <HAL_DMA_IRQHandler+0x416>
 8001c02:	3214      	adds	r2, #20
 8001c04:	4293      	cmp	r3, r2
 8001c06:	f000 815d 	beq.w	8001ec4 <HAL_DMA_IRQHandler+0x4ac>
 8001c0a:	3214      	adds	r2, #20
 8001c0c:	4293      	cmp	r3, r2
 8001c0e:	bf0c      	ite	eq
 8001c10:	f44f 0280 	moveq.w	r2, #4194304	; 0x400000
 8001c14:	f04f 6280 	movne.w	r2, #67108864	; 0x4000000
 8001c18:	e0ea      	b.n	8001df0 <HAL_DMA_IRQHandler+0x3d8>
 8001c1a:	4943      	ldr	r1, [pc, #268]	; (8001d28 <HAL_DMA_IRQHandler+0x310>)
 8001c1c:	4a43      	ldr	r2, [pc, #268]	; (8001d2c <HAL_DMA_IRQHandler+0x314>)
 8001c1e:	428b      	cmp	r3, r1
 8001c20:	6812      	ldr	r2, [r2, #0]
 8001c22:	f43f af41 	beq.w	8001aa8 <HAL_DMA_IRQHandler+0x90>
 8001c26:	3114      	adds	r1, #20
 8001c28:	428b      	cmp	r3, r1
 8001c2a:	f000 80d6 	beq.w	8001dda <HAL_DMA_IRQHandler+0x3c2>
 8001c2e:	3114      	adds	r1, #20
 8001c30:	428b      	cmp	r3, r1
 8001c32:	f000 811e 	beq.w	8001e72 <HAL_DMA_IRQHandler+0x45a>
 8001c36:	3114      	adds	r1, #20
 8001c38:	428b      	cmp	r3, r1
 8001c3a:	f000 8133 	beq.w	8001ea4 <HAL_DMA_IRQHandler+0x48c>
 8001c3e:	3114      	adds	r1, #20
 8001c40:	428b      	cmp	r3, r1
 8001c42:	f000 8106 	beq.w	8001e52 <HAL_DMA_IRQHandler+0x43a>
 8001c46:	3114      	adds	r1, #20
 8001c48:	428b      	cmp	r3, r1
 8001c4a:	bf0c      	ite	eq
 8001c4c:	f44f 0180 	moveq.w	r1, #4194304	; 0x400000
 8001c50:	f04f 6180 	movne.w	r1, #67108864	; 0x4000000
 8001c54:	e729      	b.n	8001aaa <HAL_DMA_IRQHandler+0x92>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001c56:	4934      	ldr	r1, [pc, #208]	; (8001d28 <HAL_DMA_IRQHandler+0x310>)
 8001c58:	4a34      	ldr	r2, [pc, #208]	; (8001d2c <HAL_DMA_IRQHandler+0x314>)
 8001c5a:	428b      	cmp	r3, r1
 8001c5c:	6852      	ldr	r2, [r2, #4]
 8001c5e:	f000 810f 	beq.w	8001e80 <HAL_DMA_IRQHandler+0x468>
 8001c62:	3114      	adds	r1, #20
 8001c64:	428b      	cmp	r3, r1
 8001c66:	f000 80dc 	beq.w	8001e22 <HAL_DMA_IRQHandler+0x40a>
 8001c6a:	3114      	adds	r1, #20
 8001c6c:	428b      	cmp	r3, r1
 8001c6e:	f000 8126 	beq.w	8001ebe <HAL_DMA_IRQHandler+0x4a6>
 8001c72:	3114      	adds	r1, #20
 8001c74:	428b      	cmp	r3, r1
 8001c76:	f000 8148 	beq.w	8001f0a <HAL_DMA_IRQHandler+0x4f2>
 8001c7a:	3114      	adds	r1, #20
 8001c7c:	428b      	cmp	r3, r1
 8001c7e:	f000 815d 	beq.w	8001f3c <HAL_DMA_IRQHandler+0x524>
 8001c82:	3114      	adds	r1, #20
 8001c84:	428b      	cmp	r3, r1
 8001c86:	bf0c      	ite	eq
 8001c88:	f44f 0380 	moveq.w	r3, #4194304	; 0x400000
 8001c8c:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8001c90:	4926      	ldr	r1, [pc, #152]	; (8001d2c <HAL_DMA_IRQHandler+0x314>)
 8001c92:	4313      	orrs	r3, r2
 8001c94:	604b      	str	r3, [r1, #4]

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;

      if(hdma->XferHalfCpltCallback != NULL)
 8001c96:	6b23      	ldr	r3, [r4, #48]	; 0x30
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8001c98:	2211      	movs	r2, #17
 8001c9a:	f884 2025 	strb.w	r2, [r4, #37]	; 0x25

      if(hdma->XferHalfCpltCallback != NULL)
 8001c9e:	b10b      	cbz	r3, 8001ca4 <HAL_DMA_IRQHandler+0x28c>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
 8001ca0:	4620      	mov	r0, r4
 8001ca2:	4798      	blx	r3
 8001ca4:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001ca6:	4a1e      	ldr	r2, [pc, #120]	; (8001d20 <HAL_DMA_IRQHandler+0x308>)
 8001ca8:	4293      	cmp	r3, r2
 8001caa:	d91d      	bls.n	8001ce8 <HAL_DMA_IRQHandler+0x2d0>
 8001cac:	4a1d      	ldr	r2, [pc, #116]	; (8001d24 <HAL_DMA_IRQHandler+0x30c>)
 8001cae:	4920      	ldr	r1, [pc, #128]	; (8001d30 <HAL_DMA_IRQHandler+0x318>)
 8001cb0:	4293      	cmp	r3, r2
 8001cb2:	6809      	ldr	r1, [r1, #0]
 8001cb4:	f000 814b 	beq.w	8001f4e <HAL_DMA_IRQHandler+0x536>
 8001cb8:	4a1e      	ldr	r2, [pc, #120]	; (8001d34 <HAL_DMA_IRQHandler+0x31c>)
 8001cba:	4293      	cmp	r3, r2
 8001cbc:	f000 8091 	beq.w	8001de2 <HAL_DMA_IRQHandler+0x3ca>
 8001cc0:	3214      	adds	r2, #20
 8001cc2:	4293      	cmp	r3, r2
 8001cc4:	f000 80e5 	beq.w	8001e92 <HAL_DMA_IRQHandler+0x47a>
 8001cc8:	3214      	adds	r2, #20
 8001cca:	4293      	cmp	r3, r2
 8001ccc:	f000 80b2 	beq.w	8001e34 <HAL_DMA_IRQHandler+0x41c>
 8001cd0:	3214      	adds	r2, #20
 8001cd2:	4293      	cmp	r3, r2
 8001cd4:	f000 80f9 	beq.w	8001eca <HAL_DMA_IRQHandler+0x4b2>
 8001cd8:	3214      	adds	r2, #20
 8001cda:	4293      	cmp	r3, r2
 8001cdc:	bf0c      	ite	eq
 8001cde:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8001ce2:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
 8001ce6:	e028      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
 8001ce8:	490f      	ldr	r1, [pc, #60]	; (8001d28 <HAL_DMA_IRQHandler+0x310>)
 8001cea:	4a10      	ldr	r2, [pc, #64]	; (8001d2c <HAL_DMA_IRQHandler+0x314>)
 8001cec:	428b      	cmp	r3, r1
 8001cee:	6812      	ldr	r2, [r2, #0]
 8001cf0:	d022      	beq.n	8001d38 <HAL_DMA_IRQHandler+0x320>
 8001cf2:	3114      	adds	r1, #20
 8001cf4:	428b      	cmp	r3, r1
 8001cf6:	d072      	beq.n	8001dde <HAL_DMA_IRQHandler+0x3c6>
 8001cf8:	3114      	adds	r1, #20
 8001cfa:	428b      	cmp	r3, r1
 8001cfc:	f000 80b2 	beq.w	8001e64 <HAL_DMA_IRQHandler+0x44c>
 8001d00:	3114      	adds	r1, #20
 8001d02:	428b      	cmp	r3, r1
 8001d04:	f000 80d1 	beq.w	8001eaa <HAL_DMA_IRQHandler+0x492>
 8001d08:	3114      	adds	r1, #20
 8001d0a:	428b      	cmp	r3, r1
 8001d0c:	f000 80a7 	beq.w	8001e5e <HAL_DMA_IRQHandler+0x446>
 8001d10:	3114      	adds	r1, #20
 8001d12:	428b      	cmp	r3, r1
 8001d14:	bf0c      	ite	eq
 8001d16:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8001d1a:	f04f 7100 	movne.w	r1, #33554432	; 0x2000000
 8001d1e:	e00c      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
 8001d20:	40020080 	.word	0x40020080
 8001d24:	40020408 	.word	0x40020408
 8001d28:	40020008 	.word	0x40020008
 8001d2c:	40020000 	.word	0x40020000
 8001d30:	40020400 	.word	0x40020400
 8001d34:	4002041c 	.word	0x4002041c
 8001d38:	2102      	movs	r1, #2
 8001d3a:	4211      	tst	r1, r2
 8001d3c:	bf14      	ite	ne
 8001d3e:	2201      	movne	r2, #1
 8001d40:	2200      	moveq	r2, #0
 8001d42:	b36a      	cbz	r2, 8001da0 <HAL_DMA_IRQHandler+0x388>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8001d44:	681a      	ldr	r2, [r3, #0]
 8001d46:	0791      	lsls	r1, r2, #30
 8001d48:	d52a      	bpl.n	8001da0 <HAL_DMA_IRQHandler+0x388>
    {
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 8001d4a:	681a      	ldr	r2, [r3, #0]
 8001d4c:	0692      	lsls	r2, r2, #26
 8001d4e:	d404      	bmi.n	8001d5a <HAL_DMA_IRQHandler+0x342>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
 8001d50:	681a      	ldr	r2, [r3, #0]
 8001d52:	f022 0202 	bic.w	r2, r2, #2
 8001d56:	601a      	str	r2, [r3, #0]
 8001d58:	6823      	ldr	r3, [r4, #0]
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001d5a:	4a80      	ldr	r2, [pc, #512]	; (8001f5c <HAL_DMA_IRQHandler+0x544>)
 8001d5c:	4293      	cmp	r3, r2
 8001d5e:	d920      	bls.n	8001da2 <HAL_DMA_IRQHandler+0x38a>
 8001d60:	497f      	ldr	r1, [pc, #508]	; (8001f60 <HAL_DMA_IRQHandler+0x548>)
 8001d62:	4a80      	ldr	r2, [pc, #512]	; (8001f64 <HAL_DMA_IRQHandler+0x54c>)
 8001d64:	428b      	cmp	r3, r1
 8001d66:	6852      	ldr	r2, [r2, #4]
 8001d68:	f000 80f5 	beq.w	8001f56 <HAL_DMA_IRQHandler+0x53e>
 8001d6c:	497e      	ldr	r1, [pc, #504]	; (8001f68 <HAL_DMA_IRQHandler+0x550>)
 8001d6e:	428b      	cmp	r3, r1
 8001d70:	f000 809e 	beq.w	8001eb0 <HAL_DMA_IRQHandler+0x498>
 8001d74:	3114      	adds	r1, #20
 8001d76:	428b      	cmp	r3, r1
 8001d78:	d06e      	beq.n	8001e58 <HAL_DMA_IRQHandler+0x440>
 8001d7a:	3114      	adds	r1, #20
 8001d7c:	428b      	cmp	r3, r1
 8001d7e:	f000 80b7 	beq.w	8001ef0 <HAL_DMA_IRQHandler+0x4d8>
 8001d82:	3114      	adds	r1, #20
 8001d84:	428b      	cmp	r3, r1
 8001d86:	f000 80d3 	beq.w	8001f30 <HAL_DMA_IRQHandler+0x518>
 8001d8a:	3114      	adds	r1, #20
 8001d8c:	428b      	cmp	r3, r1
 8001d8e:	bf0c      	ite	eq
 8001d90:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001d94:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8001d98:	4972      	ldr	r1, [pc, #456]	; (8001f64 <HAL_DMA_IRQHandler+0x54c>)
 8001d9a:	4313      	orrs	r3, r2
 8001d9c:	604b      	str	r3, [r1, #4]
 8001d9e:	e02f      	b.n	8001e00 <HAL_DMA_IRQHandler+0x3e8>
 8001da0:	bd10      	pop	{r4, pc}
 8001da2:	4972      	ldr	r1, [pc, #456]	; (8001f6c <HAL_DMA_IRQHandler+0x554>)
 8001da4:	4a72      	ldr	r2, [pc, #456]	; (8001f70 <HAL_DMA_IRQHandler+0x558>)
 8001da6:	428b      	cmp	r3, r1
 8001da8:	6852      	ldr	r2, [r2, #4]
 8001daa:	d025      	beq.n	8001df8 <HAL_DMA_IRQHandler+0x3e0>
 8001dac:	3114      	adds	r1, #20
 8001dae:	428b      	cmp	r3, r1
 8001db0:	d072      	beq.n	8001e98 <HAL_DMA_IRQHandler+0x480>
 8001db2:	3114      	adds	r1, #20
 8001db4:	428b      	cmp	r3, r1
 8001db6:	d040      	beq.n	8001e3a <HAL_DMA_IRQHandler+0x422>
 8001db8:	3114      	adds	r1, #20
 8001dba:	428b      	cmp	r3, r1
 8001dbc:	f000 808f 	beq.w	8001ede <HAL_DMA_IRQHandler+0x4c6>
 8001dc0:	3114      	adds	r1, #20
 8001dc2:	428b      	cmp	r3, r1
 8001dc4:	f000 80ab 	beq.w	8001f1e <HAL_DMA_IRQHandler+0x506>
 8001dc8:	3114      	adds	r1, #20
 8001dca:	428b      	cmp	r3, r1
 8001dcc:	bf0c      	ite	eq
 8001dce:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001dd2:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8001dd6:	e010      	b.n	8001dfa <HAL_DMA_IRQHandler+0x3e2>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001dd8:	6812      	ldr	r2, [r2, #0]
 8001dda:	2140      	movs	r1, #64	; 0x40
 8001ddc:	e665      	b.n	8001aaa <HAL_DMA_IRQHandler+0x92>
      }
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001dde:	2120      	movs	r1, #32
 8001de0:	e7ab      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
 8001de2:	2220      	movs	r2, #32
 8001de4:	e7a9      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001de6:	0600      	lsls	r0, r0, #24
 8001de8:	f53f ae9b 	bmi.w	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001dec:	6811      	ldr	r1, [r2, #0]
 8001dee:	2240      	movs	r2, #64	; 0x40
 8001df0:	420a      	tst	r2, r1
 8001df2:	f47f ae5d 	bne.w	8001ab0 <HAL_DMA_IRQHandler+0x98>
 8001df6:	e759      	b.n	8001cac <HAL_DMA_IRQHandler+0x294>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001df8:	2302      	movs	r3, #2
 8001dfa:	495d      	ldr	r1, [pc, #372]	; (8001f70 <HAL_DMA_IRQHandler+0x558>)
 8001dfc:	4313      	orrs	r3, r2
 8001dfe:	604b      	str	r3, [r1, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
 8001e00:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      hdma->State = HAL_DMA_STATE_READY;

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);

      if(hdma->XferCpltCallback != NULL)
 8001e02:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
 8001e04:	63a2      	str	r2, [r4, #56]	; 0x38

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8001e06:	2101      	movs	r1, #1

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8001e08:	2200      	movs	r2, #0

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_NONE;

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8001e0a:	f884 1025 	strb.w	r1, [r4, #37]	; 0x25

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8001e0e:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24

      if(hdma->XferCpltCallback != NULL)
 8001e12:	2b00      	cmp	r3, #0
 8001e14:	d0c4      	beq.n	8001da0 <HAL_DMA_IRQHandler+0x388>
      {
        /* Transfer complete callback */
        hdma->XferCpltCallback(hdma);
 8001e16:	4620      	mov	r0, r4
      }
    }
  }
}
 8001e18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      __HAL_UNLOCK(hdma);

      if(hdma->XferCpltCallback != NULL)
      {
        /* Transfer complete callback */
        hdma->XferCpltCallback(hdma);
 8001e1c:	4718      	bx	r3
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001e1e:	2380      	movs	r3, #128	; 0x80
 8001e20:	e6c9      	b.n	8001bb6 <HAL_DMA_IRQHandler+0x19e>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001e22:	2340      	movs	r3, #64	; 0x40
 8001e24:	e734      	b.n	8001c90 <HAL_DMA_IRQHandler+0x278>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001e26:	0400      	lsls	r0, r0, #16
 8001e28:	f53f ae7b 	bmi.w	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001e2c:	6811      	ldr	r1, [r2, #0]
 8001e2e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8001e32:	e7dd      	b.n	8001df0 <HAL_DMA_IRQHandler+0x3d8>
      }
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001e34:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001e38:	e77f      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001e3a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001e3e:	e7dc      	b.n	8001dfa <HAL_DMA_IRQHandler+0x3e2>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001e40:	2380      	movs	r3, #128	; 0x80
 8001e42:	e697      	b.n	8001b74 <HAL_DMA_IRQHandler+0x15c>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001e44:	0301      	lsls	r1, r0, #12
 8001e46:	f53f ae6c 	bmi.w	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001e4a:	6812      	ldr	r2, [r2, #0]
 8001e4c:	f44f 2180 	mov.w	r1, #262144	; 0x40000
 8001e50:	e62b      	b.n	8001aaa <HAL_DMA_IRQHandler+0x92>
 8001e52:	f44f 2180 	mov.w	r1, #262144	; 0x40000
 8001e56:	e628      	b.n	8001aaa <HAL_DMA_IRQHandler+0x92>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001e58:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001e5c:	e79c      	b.n	8001d98 <HAL_DMA_IRQHandler+0x380>
      }
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001e5e:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8001e62:	e76a      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
 8001e64:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001e68:	e767      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001e6a:	0500      	lsls	r0, r0, #20
 8001e6c:	f53f ae59 	bmi.w	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001e70:	6812      	ldr	r2, [r2, #0]
 8001e72:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001e76:	e618      	b.n	8001aaa <HAL_DMA_IRQHandler+0x92>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001e78:	2308      	movs	r3, #8
 8001e7a:	e67b      	b.n	8001b74 <HAL_DMA_IRQHandler+0x15c>
 8001e7c:	2308      	movs	r3, #8
 8001e7e:	e69a      	b.n	8001bb6 <HAL_DMA_IRQHandler+0x19e>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001e80:	2304      	movs	r3, #4
 8001e82:	e705      	b.n	8001c90 <HAL_DMA_IRQHandler+0x278>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001e84:	0501      	lsls	r1, r0, #20
 8001e86:	f53f ae4c 	bmi.w	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001e8a:	6811      	ldr	r1, [r2, #0]
 8001e8c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001e90:	e7ae      	b.n	8001df0 <HAL_DMA_IRQHandler+0x3d8>
      }
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001e92:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001e96:	e750      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001e98:	2320      	movs	r3, #32
 8001e9a:	e7ae      	b.n	8001dfa <HAL_DMA_IRQHandler+0x3e2>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001e9c:	0401      	lsls	r1, r0, #16
 8001e9e:	f53f ae40 	bmi.w	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001ea2:	6812      	ldr	r2, [r2, #0]
 8001ea4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8001ea8:	e5ff      	b.n	8001aaa <HAL_DMA_IRQHandler+0x92>
      }
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001eaa:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8001eae:	e744      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001eb0:	2320      	movs	r3, #32
 8001eb2:	e771      	b.n	8001d98 <HAL_DMA_IRQHandler+0x380>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001eb4:	2340      	movs	r3, #64	; 0x40
 8001eb6:	e628      	b.n	8001b0a <HAL_DMA_IRQHandler+0xf2>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001eb8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001ebc:	e67b      	b.n	8001bb6 <HAL_DMA_IRQHandler+0x19e>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001ebe:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001ec2:	e6e5      	b.n	8001c90 <HAL_DMA_IRQHandler+0x278>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001ec4:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8001ec8:	e792      	b.n	8001df0 <HAL_DMA_IRQHandler+0x3d8>
      }
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001eca:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8001ece:	e734      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001ed0:	0300      	lsls	r0, r0, #12
 8001ed2:	f53f ae26 	bmi.w	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001ed6:	6811      	ldr	r1, [r2, #0]
 8001ed8:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8001edc:	e788      	b.n	8001df0 <HAL_DMA_IRQHandler+0x3d8>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001ede:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001ee2:	e78a      	b.n	8001dfa <HAL_DMA_IRQHandler+0x3e2>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001ee4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001ee8:	e644      	b.n	8001b74 <HAL_DMA_IRQHandler+0x15c>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001eea:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001eee:	e60c      	b.n	8001b0a <HAL_DMA_IRQHandler+0xf2>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001ef0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001ef4:	e750      	b.n	8001d98 <HAL_DMA_IRQHandler+0x380>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001ef6:	0201      	lsls	r1, r0, #8
 8001ef8:	f53f ae13 	bmi.w	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001efc:	6812      	ldr	r2, [r2, #0]
 8001efe:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8001f02:	e5d2      	b.n	8001aaa <HAL_DMA_IRQHandler+0x92>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001f04:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001f08:	e655      	b.n	8001bb6 <HAL_DMA_IRQHandler+0x19e>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001f0a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8001f0e:	e6bf      	b.n	8001c90 <HAL_DMA_IRQHandler+0x278>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8001f10:	0200      	lsls	r0, r0, #8
 8001f12:	f53f ae06 	bmi.w	8001b22 <HAL_DMA_IRQHandler+0x10a>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001f16:	6811      	ldr	r1, [r2, #0]
 8001f18:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8001f1c:	e768      	b.n	8001df0 <HAL_DMA_IRQHandler+0x3d8>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001f1e:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001f22:	e76a      	b.n	8001dfa <HAL_DMA_IRQHandler+0x3e2>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001f24:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001f28:	e624      	b.n	8001b74 <HAL_DMA_IRQHandler+0x15c>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001f2a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8001f2e:	e5ec      	b.n	8001b0a <HAL_DMA_IRQHandler+0xf2>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001f30:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001f34:	e730      	b.n	8001d98 <HAL_DMA_IRQHandler+0x380>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001f36:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8001f3a:	e63c      	b.n	8001bb6 <HAL_DMA_IRQHandler+0x19e>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001f3c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001f40:	e6a6      	b.n	8001c90 <HAL_DMA_IRQHandler+0x278>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);

      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8001f42:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8001f46:	e615      	b.n	8001b74 <HAL_DMA_IRQHandler+0x15c>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001f48:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001f4c:	e5dd      	b.n	8001b0a <HAL_DMA_IRQHandler+0xf2>
      }
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001f4e:	2202      	movs	r2, #2
 8001f50:	e6f3      	b.n	8001d3a <HAL_DMA_IRQHandler+0x322>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001f52:	2304      	movs	r3, #4
 8001f54:	e5d9      	b.n	8001b0a <HAL_DMA_IRQHandler+0xf2>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001f56:	2302      	movs	r3, #2
 8001f58:	e71e      	b.n	8001d98 <HAL_DMA_IRQHandler+0x380>
 8001f5a:	bf00      	nop
 8001f5c:	40020080 	.word	0x40020080
 8001f60:	40020408 	.word	0x40020408
 8001f64:	40020400 	.word	0x40020400
 8001f68:	4002041c 	.word	0x4002041c
 8001f6c:	40020008 	.word	0x40020008
 8001f70:	40020000 	.word	0x40020000

08001f74 <HAL_DMA_GetState>:
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
  /* Return DMA handle state */
  return hdma->State;
 8001f74:	f890 0025 	ldrb.w	r0, [r0, #37]	; 0x25
}
 8001f78:	4770      	bx	lr
 8001f7a:	bf00      	nop

08001f7c <HAL_DMA_GetError>:
  *              the configuration information for the specified DMA Channel.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
  return hdma->ErrorCode;
 8001f7c:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 8001f7e:	4770      	bx	lr

08001f80 <HAL_GPIO_Init>:
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8001f80:	680b      	ldr	r3, [r1, #0]
 8001f82:	2b00      	cmp	r3, #0
 8001f84:	f000 80e9 	beq.w	800215a <HAL_GPIO_Init+0x1da>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001f88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8001f8c:	f04f 0800 	mov.w	r8, #0
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001f90:	b082      	sub	sp, #8
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001f92:	f8df c1e4 	ldr.w	ip, [pc, #484]	; 8002178 <HAL_GPIO_Init+0x1f8>
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8001f96:	4f71      	ldr	r7, [pc, #452]	; (800215c <HAL_GPIO_Init+0x1dc>)
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8001f98:	4644      	mov	r4, r8
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8001f9a:	f04f 0e01 	mov.w	lr, #1
 8001f9e:	e06b      	b.n	8002078 <HAL_GPIO_Init+0xf8>
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
        GPIOx->ASCR = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8001fa0:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001fa2:	688a      	ldr	r2, [r1, #8]
        GPIOx->ASCR = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8001fa4:	402b      	ands	r3, r5
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001fa6:	40b2      	lsls	r2, r6
 8001fa8:	431a      	orrs	r2, r3
      GPIOx->PUPDR = temp;
 8001faa:	60c2      	str	r2, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001fac:	684b      	ldr	r3, [r1, #4]
 8001fae:	00db      	lsls	r3, r3, #3
 8001fb0:	d55c      	bpl.n	800206c <HAL_GPIO_Init+0xec>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fb2:	f8dc 3060 	ldr.w	r3, [ip, #96]	; 0x60
 8001fb6:	f043 0301 	orr.w	r3, r3, #1
 8001fba:	f8cc 3060 	str.w	r3, [ip, #96]	; 0x60
 8001fbe:	f8dc 2060 	ldr.w	r2, [ip, #96]	; 0x60
 8001fc2:	f024 0303 	bic.w	r3, r4, #3
 8001fc6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001fca:	f002 0201 	and.w	r2, r2, #1
 8001fce:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8001fd2:	9201      	str	r2, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001fd4:	f004 0203 	and.w	r2, r4, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fd8:	9d01      	ldr	r5, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2];
 8001fda:	689e      	ldr	r6, [r3, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001fdc:	0092      	lsls	r2, r2, #2
 8001fde:	250f      	movs	r5, #15
 8001fe0:	4095      	lsls	r5, r2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 8001fe2:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001fe6:	ea26 0505 	bic.w	r5, r6, r5
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 8001fea:	f000 80a1 	beq.w	8002130 <HAL_GPIO_Init+0x1b0>
 8001fee:	4e5c      	ldr	r6, [pc, #368]	; (8002160 <HAL_GPIO_Init+0x1e0>)
 8001ff0:	42b0      	cmp	r0, r6
 8001ff2:	f000 809f 	beq.w	8002134 <HAL_GPIO_Init+0x1b4>
 8001ff6:	4e5b      	ldr	r6, [pc, #364]	; (8002164 <HAL_GPIO_Init+0x1e4>)
 8001ff8:	42b0      	cmp	r0, r6
 8001ffa:	f000 809e 	beq.w	800213a <HAL_GPIO_Init+0x1ba>
 8001ffe:	4e5a      	ldr	r6, [pc, #360]	; (8002168 <HAL_GPIO_Init+0x1e8>)
 8002000:	42b0      	cmp	r0, r6
 8002002:	f000 809e 	beq.w	8002142 <HAL_GPIO_Init+0x1c2>
 8002006:	4e59      	ldr	r6, [pc, #356]	; (800216c <HAL_GPIO_Init+0x1ec>)
 8002008:	42b0      	cmp	r0, r6
 800200a:	f000 809e 	beq.w	800214a <HAL_GPIO_Init+0x1ca>
 800200e:	4e58      	ldr	r6, [pc, #352]	; (8002170 <HAL_GPIO_Init+0x1f0>)
 8002010:	42b0      	cmp	r0, r6
 8002012:	f000 809e 	beq.w	8002152 <HAL_GPIO_Init+0x1d2>
 8002016:	4e57      	ldr	r6, [pc, #348]	; (8002174 <HAL_GPIO_Init+0x1f4>)
 8002018:	42b0      	cmp	r0, r6
 800201a:	bf0c      	ite	eq
 800201c:	2606      	moveq	r6, #6
 800201e:	2607      	movne	r6, #7
 8002020:	fa06 f202 	lsl.w	r2, r6, r2
 8002024:	432a      	orrs	r2, r5
        SYSCFG->EXTICR[position >> 2] = temp;
 8002026:	609a      	str	r2, [r3, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8002028:	684b      	ldr	r3, [r1, #4]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 800202a:	683a      	ldr	r2, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 800202c:	ea6f 0509 	mvn.w	r5, r9
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8002030:	03de      	lsls	r6, r3, #15
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
 8002032:	bf54      	ite	pl
 8002034:	402a      	andpl	r2, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8002036:	ea49 0202 	orrmi.w	r2, r9, r2
        }
        EXTI->IMR1 = temp;
 800203a:	603a      	str	r2, [r7, #0]

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800203c:	684b      	ldr	r3, [r1, #4]
        {
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
 800203e:	687a      	ldr	r2, [r7, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8002040:	039b      	lsls	r3, r3, #14
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
 8002042:	bf54      	ite	pl
 8002044:	402a      	andpl	r2, r5
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8002046:	ea49 0202 	orrmi.w	r2, r9, r2
        }
        EXTI->EMR1 = temp;
 800204a:	607a      	str	r2, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800204c:	684b      	ldr	r3, [r1, #4]
          temp |= iocurrent;
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 800204e:	68ba      	ldr	r2, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8002050:	02de      	lsls	r6, r3, #11
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
 8002052:	bf54      	ite	pl
 8002054:	402a      	andpl	r2, r5
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8002056:	ea49 0202 	orrmi.w	r2, r9, r2
        }
        EXTI->RTSR1 = temp;
 800205a:	60ba      	str	r2, [r7, #8]

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800205c:	684a      	ldr	r2, [r1, #4]
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
 800205e:	68fb      	ldr	r3, [r7, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8002060:	0292      	lsls	r2, r2, #10
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
 8002062:	bf54      	ite	pl
 8002064:	402b      	andpl	r3, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8002066:	ea49 0303 	orrmi.w	r3, r9, r3
        }
        EXTI->FTSR1 = temp;
 800206a:	60fb      	str	r3, [r7, #12]
 800206c:	680b      	ldr	r3, [r1, #0]
      }
    }
    
    position++;
 800206e:	3401      	adds	r4, #1
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8002070:	fa33 f204 	lsrs.w	r2, r3, r4
 8002074:	46a0      	mov	r8, r4
 8002076:	d058      	beq.n	800212a <HAL_GPIO_Init+0x1aa>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8002078:	fa0e f508 	lsl.w	r5, lr, r8

    if(iocurrent)
 800207c:	ea13 0905 	ands.w	r9, r3, r5
 8002080:	d0f5      	beq.n	800206e <HAL_GPIO_Init+0xee>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8002082:	684a      	ldr	r2, [r1, #4]
 8002084:	f022 0310 	bic.w	r3, r2, #16
 8002088:	2b02      	cmp	r3, #2
 800208a:	d112      	bne.n	80020b2 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 800208c:	08e6      	lsrs	r6, r4, #3
 800208e:	eb00 0686 	add.w	r6, r0, r6, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8002092:	f004 0207 	and.w	r2, r4, #7
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8002096:	6a33      	ldr	r3, [r6, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8002098:	0092      	lsls	r2, r2, #2
 800209a:	f04f 0a0f 	mov.w	sl, #15
 800209e:	fa0a fa02 	lsl.w	sl, sl, r2
 80020a2:	ea23 0a0a 	bic.w	sl, r3, sl
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 80020a6:	690b      	ldr	r3, [r1, #16]
 80020a8:	4093      	lsls	r3, r2
 80020aa:	ea4a 0303 	orr.w	r3, sl, r3
        GPIOx->AFR[position >> 3] = temp;
 80020ae:	6233      	str	r3, [r6, #32]
 80020b0:	684a      	ldr	r2, [r1, #4]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80020b2:	f8d0 a000 	ldr.w	sl, [r0]
 80020b6:	0066      	lsls	r6, r4, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80020b8:	2303      	movs	r3, #3
 80020ba:	40b3      	lsls	r3, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80020bc:	f002 0203 	and.w	r2, r2, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80020c0:	43db      	mvns	r3, r3
 80020c2:	ea03 0a0a 	and.w	sl, r3, sl
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80020c6:	40b2      	lsls	r2, r6
 80020c8:	ea42 020a 	orr.w	r2, r2, sl
      GPIOx->MODER = temp;
 80020cc:	6002      	str	r2, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80020ce:	684a      	ldr	r2, [r1, #4]
 80020d0:	f022 0a10 	bic.w	sl, r2, #16
 80020d4:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 80020d8:	f1ba 0f01 	cmp.w	sl, #1
 80020dc:	d814      	bhi.n	8002108 <HAL_GPIO_Init+0x188>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 80020de:	6882      	ldr	r2, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80020e0:	ea03 0a02 	and.w	sl, r3, r2
        temp |= (GPIO_Init->Speed << (position * 2));
 80020e4:	68ca      	ldr	r2, [r1, #12]
 80020e6:	40b2      	lsls	r2, r6
 80020e8:	ea4a 0202 	orr.w	r2, sl, r2
        GPIOx->OSPEEDR = temp;
 80020ec:	6082      	str	r2, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 80020ee:	684a      	ldr	r2, [r1, #4]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
        temp |= (GPIO_Init->Speed << (position * 2));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80020f0:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 80020f4:	f3c2 1200 	ubfx	r2, r2, #4, #1
 80020f8:	fa02 f208 	lsl.w	r2, r2, r8
        temp |= (GPIO_Init->Speed << (position * 2));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80020fc:	ea2a 0a05 	bic.w	sl, sl, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8002100:	ea4a 0202 	orr.w	r2, sl, r2
        GPIOx->OTYPER = temp;
 8002104:	6042      	str	r2, [r0, #4]
 8002106:	684a      	ldr	r2, [r1, #4]
      }

      /* In case of Analog mode, check if ADC control mode is selected */
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
 8002108:	f002 0a03 	and.w	sl, r2, #3
 800210c:	f1ba 0f03 	cmp.w	sl, #3
 8002110:	f47f af46 	bne.w	8001fa0 <HAL_GPIO_Init+0x20>
      {
        /* Configure the IO Output Type */
        temp = GPIOx->ASCR;
 8002114:	f8d0 a02c 	ldr.w	sl, [r0, #44]	; 0x2c
        temp &= ~(GPIO_ASCR_EN_0 << position) ;
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 8002118:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 800211c:	fa02 f208 	lsl.w	r2, r2, r8
      /* In case of Analog mode, check if ADC control mode is selected */
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
      {
        /* Configure the IO Output Type */
        temp = GPIOx->ASCR;
        temp &= ~(GPIO_ASCR_EN_0 << position) ;
 8002120:	ea2a 0505 	bic.w	r5, sl, r5
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 8002124:	432a      	orrs	r2, r5
        GPIOx->ASCR = temp;
 8002126:	62c2      	str	r2, [r0, #44]	; 0x2c
 8002128:	e73a      	b.n	8001fa0 <HAL_GPIO_Init+0x20>
      }
    }
    
    position++;
  }
}
 800212a:	b002      	add	sp, #8
 800212c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002130:	2200      	movs	r2, #0
 8002132:	e777      	b.n	8002024 <HAL_GPIO_Init+0xa4>
 8002134:	fa0e f202 	lsl.w	r2, lr, r2
 8002138:	e774      	b.n	8002024 <HAL_GPIO_Init+0xa4>
 800213a:	2602      	movs	r6, #2
 800213c:	fa06 f202 	lsl.w	r2, r6, r2
 8002140:	e770      	b.n	8002024 <HAL_GPIO_Init+0xa4>
 8002142:	2603      	movs	r6, #3
 8002144:	fa06 f202 	lsl.w	r2, r6, r2
 8002148:	e76c      	b.n	8002024 <HAL_GPIO_Init+0xa4>
 800214a:	2604      	movs	r6, #4
 800214c:	fa06 f202 	lsl.w	r2, r6, r2
 8002150:	e768      	b.n	8002024 <HAL_GPIO_Init+0xa4>
 8002152:	2605      	movs	r6, #5
 8002154:	fa06 f202 	lsl.w	r2, r6, r2
 8002158:	e764      	b.n	8002024 <HAL_GPIO_Init+0xa4>
 800215a:	4770      	bx	lr
 800215c:	40010400 	.word	0x40010400
 8002160:	48000400 	.word	0x48000400
 8002164:	48000800 	.word	0x48000800
 8002168:	48000c00 	.word	0x48000c00
 800216c:	48001000 	.word	0x48001000
 8002170:	48001400 	.word	0x48001400
 8002174:	48001800 	.word	0x48001800
 8002178:	40021000 	.word	0x40021000

0800217c <HAL_GPIO_DeInit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 800217c:	2900      	cmp	r1, #0
 800217e:	f000 8099 	beq.w	80022b4 <HAL_GPIO_DeInit+0x138>
 8002182:	2300      	movs	r3, #0
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8002184:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8002188:	461a      	mov	r2, r3
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 800218a:	f8df 8140 	ldr.w	r8, [pc, #320]	; 80022cc <HAL_GPIO_DeInit+0x150>
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 800218e:	f8df b140 	ldr.w	fp, [pc, #320]	; 80022d0 <HAL_GPIO_DeInit+0x154>

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
 8002192:	f04f 0901 	mov.w	r9, #1

    if (iocurrent)
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
 8002196:	f04f 0a03 	mov.w	sl, #3
 800219a:	e004      	b.n	80021a6 <HAL_GPIO_DeInit+0x2a>
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
      }
    }
    
    position++;
 800219c:	3201      	adds	r2, #1
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 800219e:	fa31 f402 	lsrs.w	r4, r1, r2
 80021a2:	4613      	mov	r3, r2
 80021a4:	d070      	beq.n	8002288 <HAL_GPIO_DeInit+0x10c>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
 80021a6:	fa09 f303 	lsl.w	r3, r9, r3

    if (iocurrent)
 80021aa:	ea11 0e03 	ands.w	lr, r1, r3
 80021ae:	d0f5      	beq.n	800219c <HAL_GPIO_DeInit+0x20>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
 80021b0:	6806      	ldr	r6, [r0, #0]
 80021b2:	0054      	lsls	r4, r2, #1
 80021b4:	fa0a f504 	lsl.w	r5, sl, r4

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80021b8:	08d4      	lsrs	r4, r2, #3

    if (iocurrent)
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
 80021ba:	432e      	orrs	r6, r5
 80021bc:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 80021c0:	6006      	str	r6, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80021c2:	f002 0607 	and.w	r6, r2, #7
 80021c6:	f8d4 c020 	ldr.w	ip, [r4, #32]
 80021ca:	270f      	movs	r7, #15
 80021cc:	00b6      	lsls	r6, r6, #2
 80021ce:	fa07 f606 	lsl.w	r6, r7, r6
 80021d2:	ea2c 0606 	bic.w	r6, ip, r6
 80021d6:	6226      	str	r6, [r4, #32]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80021d8:	6884      	ldr	r4, [r0, #8]
 80021da:	43ed      	mvns	r5, r5
 80021dc:	402c      	ands	r4, r5
 80021de:	6084      	str	r4, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 80021e0:	6844      	ldr	r4, [r0, #4]
 80021e2:	43db      	mvns	r3, r3
 80021e4:	401c      	ands	r4, r3
 80021e6:	6044      	str	r4, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 80021e8:	68c4      	ldr	r4, [r0, #12]
 80021ea:	4025      	ands	r5, r4
 80021ec:	60c5      	str	r5, [r0, #12]

      /* Deactivate the Control bit of Analog mode for the current IO */
      GPIOx->ASCR &= ~(GPIO_ASCR_EN_0<< position);
 80021ee:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80021f0:	f022 0403 	bic.w	r4, r2, #3
 80021f4:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 80021f8:	402b      	ands	r3, r5
 80021fa:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
 80021fe:	62c3      	str	r3, [r0, #44]	; 0x2c

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8002200:	f002 0303 	and.w	r3, r2, #3
      GPIOx->ASCR &= ~(GPIO_ASCR_EN_0<< position);

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
 8002204:	68a5      	ldr	r5, [r4, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8002206:	009b      	lsls	r3, r3, #2
 8002208:	409f      	lsls	r7, r3
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 800220a:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 800220e:	ea05 0507 	and.w	r5, r5, r7
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8002212:	d03b      	beq.n	800228c <HAL_GPIO_DeInit+0x110>
 8002214:	4558      	cmp	r0, fp
 8002216:	d03b      	beq.n	8002290 <HAL_GPIO_DeInit+0x114>
 8002218:	4e27      	ldr	r6, [pc, #156]	; (80022b8 <HAL_GPIO_DeInit+0x13c>)
 800221a:	42b0      	cmp	r0, r6
 800221c:	d03b      	beq.n	8002296 <HAL_GPIO_DeInit+0x11a>
 800221e:	4e27      	ldr	r6, [pc, #156]	; (80022bc <HAL_GPIO_DeInit+0x140>)
 8002220:	42b0      	cmp	r0, r6
 8002222:	d03c      	beq.n	800229e <HAL_GPIO_DeInit+0x122>
 8002224:	4e26      	ldr	r6, [pc, #152]	; (80022c0 <HAL_GPIO_DeInit+0x144>)
 8002226:	42b0      	cmp	r0, r6
 8002228:	d03c      	beq.n	80022a4 <HAL_GPIO_DeInit+0x128>
 800222a:	4e26      	ldr	r6, [pc, #152]	; (80022c4 <HAL_GPIO_DeInit+0x148>)
 800222c:	42b0      	cmp	r0, r6
 800222e:	d03d      	beq.n	80022ac <HAL_GPIO_DeInit+0x130>
 8002230:	4e25      	ldr	r6, [pc, #148]	; (80022c8 <HAL_GPIO_DeInit+0x14c>)
 8002232:	42b0      	cmp	r0, r6
 8002234:	bf0c      	ite	eq
 8002236:	2606      	moveq	r6, #6
 8002238:	2607      	movne	r6, #7
 800223a:	fa06 f303 	lsl.w	r3, r6, r3
 800223e:	429d      	cmp	r5, r3
 8002240:	d1ac      	bne.n	800219c <HAL_GPIO_DeInit+0x20>
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 8002242:	68a3      	ldr	r3, [r4, #8]
 8002244:	ea23 0707 	bic.w	r7, r3, r7
 8002248:	60a7      	str	r7, [r4, #8]

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 800224a:	f8d8 3000 	ldr.w	r3, [r8]
 800224e:	ea6f 0e0e 	mvn.w	lr, lr
 8002252:	ea0e 0303 	and.w	r3, lr, r3
 8002256:	f8c8 3000 	str.w	r3, [r8]
        EXTI->EMR1 &= ~((uint32_t)iocurrent);
 800225a:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800225e:	ea0e 0303 	and.w	r3, lr, r3
 8002262:	f8c8 3004 	str.w	r3, [r8, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
 8002266:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800226a:	ea0e 0303 	and.w	r3, lr, r3
 800226e:	f8c8 3008 	str.w	r3, [r8, #8]
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 8002272:	f8d8 300c 	ldr.w	r3, [r8, #12]
      }
    }
    
    position++;
 8002276:	3201      	adds	r2, #1
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
        EXTI->EMR1 &= ~((uint32_t)iocurrent);

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 8002278:	ea0e 0303 	and.w	r3, lr, r3
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 800227c:	fa31 f402 	lsrs.w	r4, r1, r2
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
        EXTI->EMR1 &= ~((uint32_t)iocurrent);

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 8002280:	f8c8 300c 	str.w	r3, [r8, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 8002284:	4613      	mov	r3, r2
 8002286:	d18e      	bne.n	80021a6 <HAL_GPIO_DeInit+0x2a>
 8002288:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800228c:	2300      	movs	r3, #0
 800228e:	e7d6      	b.n	800223e <HAL_GPIO_DeInit+0xc2>
 8002290:	fa09 f303 	lsl.w	r3, r9, r3
 8002294:	e7d3      	b.n	800223e <HAL_GPIO_DeInit+0xc2>
 8002296:	2602      	movs	r6, #2
 8002298:	fa06 f303 	lsl.w	r3, r6, r3
 800229c:	e7cf      	b.n	800223e <HAL_GPIO_DeInit+0xc2>
 800229e:	fa0a f303 	lsl.w	r3, sl, r3
 80022a2:	e7cc      	b.n	800223e <HAL_GPIO_DeInit+0xc2>
 80022a4:	2604      	movs	r6, #4
 80022a6:	fa06 f303 	lsl.w	r3, r6, r3
 80022aa:	e7c8      	b.n	800223e <HAL_GPIO_DeInit+0xc2>
 80022ac:	2605      	movs	r6, #5
 80022ae:	fa06 f303 	lsl.w	r3, r6, r3
 80022b2:	e7c4      	b.n	800223e <HAL_GPIO_DeInit+0xc2>
 80022b4:	4770      	bx	lr
 80022b6:	bf00      	nop
 80022b8:	48000800 	.word	0x48000800
 80022bc:	48000c00 	.word	0x48000c00
 80022c0:	48001000 	.word	0x48001000
 80022c4:	48001400 	.word	0x48001400
 80022c8:	48001800 	.word	0x48001800
 80022cc:	40010400 	.word	0x40010400
 80022d0:	48000400 	.word	0x48000400

080022d4 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 80022d4:	6903      	ldr	r3, [r0, #16]
 80022d6:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 80022d8:	bf14      	ite	ne
 80022da:	2001      	movne	r0, #1
 80022dc:	2000      	moveq	r0, #0
 80022de:	4770      	bx	lr

080022e0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80022e0:	b90a      	cbnz	r2, 80022e6 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80022e2:	6281      	str	r1, [r0, #40]	; 0x28
 80022e4:	4770      	bx	lr
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80022e6:	6181      	str	r1, [r0, #24]
 80022e8:	4770      	bx	lr
 80022ea:	bf00      	nop

080022ec <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 80022ec:	6943      	ldr	r3, [r0, #20]
 80022ee:	4059      	eors	r1, r3
 80022f0:	6141      	str	r1, [r0, #20]
 80022f2:	4770      	bx	lr

080022f4 <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bits to be locked.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80022f4:	b082      	sub	sp, #8
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
 80022f6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80022fa:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
 80022fc:	9b01      	ldr	r3, [sp, #4]
 80022fe:	430b      	orrs	r3, r1
 8002300:	9301      	str	r3, [sp, #4]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 8002302:	9b01      	ldr	r3, [sp, #4]
 8002304:	61c3      	str	r3, [r0, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
 8002306:	61c1      	str	r1, [r0, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 8002308:	9b01      	ldr	r3, [sp, #4]
 800230a:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800230c:	69c3      	ldr	r3, [r0, #28]
 800230e:	9301      	str	r3, [sp, #4]

  if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
 8002310:	69c0      	ldr	r0, [r0, #28]
 8002312:	f480 3080 	eor.w	r0, r0, #65536	; 0x10000
  }
  else
  {
    return HAL_ERROR;
  }
}
 8002316:	f3c0 4000 	ubfx	r0, r0, #16, #1
 800231a:	b002      	add	sp, #8
 800231c:	4770      	bx	lr
 800231e:	bf00      	nop

08002320 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 8002320:	4770      	bx	lr
 8002322:	bf00      	nop

08002324 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8002324:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 8002326:	4a04      	ldr	r2, [pc, #16]	; (8002338 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 8002328:	6951      	ldr	r1, [r2, #20]
 800232a:	4208      	tst	r0, r1
 800232c:	d002      	beq.n	8002334 <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800232e:	6150      	str	r0, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8002330:	f7ff fff6 	bl	8002320 <HAL_GPIO_EXTI_Callback>
 8002334:	bd08      	pop	{r3, pc}
 8002336:	bf00      	nop
 8002338:	40010400 	.word	0x40010400

0800233c <I2C_IsAcknowledgeFailed>:
  *                the configuration information for the specified I2C.
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
{
 800233c:	b570      	push	{r4, r5, r6, lr}
 800233e:	4605      	mov	r5, r0
 8002340:	460c      	mov	r4, r1
  uint32_t tickstart = 0x00;
  tickstart = HAL_GetTick();
 8002342:	f7fe fbe1 	bl	8000b08 <HAL_GetTick>

  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8002346:	682a      	ldr	r2, [r5, #0]
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
{
  uint32_t tickstart = 0x00;
  tickstart = HAL_GetTick();
 8002348:	4606      	mov	r6, r0

  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800234a:	6990      	ldr	r0, [r2, #24]
 800234c:	f010 0010 	ands.w	r0, r0, #16
 8002350:	d024      	beq.n	800239c <I2C_IsAcknowledgeFailed+0x60>
  {
    /* Generate stop if necessary only in case of I2C peripheral in MASTER mode */
    if((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX)
 8002352:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
 8002356:	2b12      	cmp	r3, #18
 8002358:	d021      	beq.n	800239e <I2C_IsAcknowledgeFailed+0x62>
 800235a:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
 800235e:	2b52      	cmp	r3, #82	; 0x52
 8002360:	d01d      	beq.n	800239e <I2C_IsAcknowledgeFailed+0x62>
       || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX))
 8002362:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
 8002366:	2b62      	cmp	r3, #98	; 0x62
 8002368:	d102      	bne.n	8002370 <I2C_IsAcknowledgeFailed+0x34>
 800236a:	e018      	b.n	800239e <I2C_IsAcknowledgeFailed+0x62>
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800236c:	1c61      	adds	r1, r4, #1
 800236e:	d11f      	bne.n	80023b0 <I2C_IsAcknowledgeFailed+0x74>
      }
    }
		
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002370:	6993      	ldr	r3, [r2, #24]
 8002372:	069b      	lsls	r3, r3, #26
 8002374:	d5fa      	bpl.n	800236c <I2C_IsAcknowledgeFailed+0x30>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002376:	2310      	movs	r3, #16
 8002378:	61d3      	str	r3, [r2, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800237a:	682a      	ldr	r2, [r5, #0]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800237c:	4b14      	ldr	r3, [pc, #80]	; (80023d0 <I2C_IsAcknowledgeFailed+0x94>)

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800237e:	2120      	movs	r1, #32
 8002380:	61d1      	str	r1, [r2, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8002382:	6829      	ldr	r1, [r5, #0]
 8002384:	684a      	ldr	r2, [r1, #4]

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8002386:	2604      	movs	r6, #4

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8002388:	4013      	ands	r3, r2

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
    hi2c->State= HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800238a:	2400      	movs	r4, #0

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
    hi2c->State= HAL_I2C_STATE_READY;
 800238c:	2201      	movs	r2, #1

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800238e:	604b      	str	r3, [r1, #4]
    hi2c->State= HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    return HAL_ERROR;
 8002390:	4610      	mov	r0, r2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8002392:	63ae      	str	r6, [r5, #56]	; 0x38
    hi2c->State= HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002394:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
    hi2c->State= HAL_I2C_STATE_READY;
 8002398:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35
    __HAL_UNLOCK(hi2c);

    return HAL_ERROR;
  }
  return HAL_OK;
}
 800239c:	bd70      	pop	{r4, r5, r6, pc}
    if((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX)
       || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX))
    {
      /* No need to generate the STOP condition if AUTOEND mode is enabled */
      /* Generate the STOP condition only in case of SOFTEND mode is enabled */
      if((hi2c->Instance->CR2 & I2C_AUTOEND_MODE) != I2C_AUTOEND_MODE)
 800239e:	6853      	ldr	r3, [r2, #4]
 80023a0:	0198      	lsls	r0, r3, #6
 80023a2:	d4e5      	bmi.n	8002370 <I2C_IsAcknowledgeFailed+0x34>
      {
        /* Generate Stop */
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
 80023a4:	6853      	ldr	r3, [r2, #4]
 80023a6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80023aa:	6053      	str	r3, [r2, #4]
 80023ac:	682a      	ldr	r2, [r5, #0]
 80023ae:	e7df      	b.n	8002370 <I2C_IsAcknowledgeFailed+0x34>
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 80023b0:	b134      	cbz	r4, 80023c0 <I2C_IsAcknowledgeFailed+0x84>
 80023b2:	f7fe fba9 	bl	8000b08 <HAL_GetTick>
 80023b6:	1b80      	subs	r0, r0, r6
 80023b8:	4284      	cmp	r4, r0
 80023ba:	d301      	bcc.n	80023c0 <I2C_IsAcknowledgeFailed+0x84>
 80023bc:	682a      	ldr	r2, [r5, #0]
 80023be:	e7d7      	b.n	8002370 <I2C_IsAcknowledgeFailed+0x34>
        {
          hi2c->State= HAL_I2C_STATE_READY;
 80023c0:	2201      	movs	r2, #1
          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 80023c2:	2300      	movs	r3, #0
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
        {
          hi2c->State= HAL_I2C_STATE_READY;
 80023c4:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35
          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 80023c8:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
          return HAL_TIMEOUT;
 80023cc:	2003      	movs	r0, #3
 80023ce:	bd70      	pop	{r4, r5, r6, pc}
 80023d0:	fe00e800 	.word	0xfe00e800

080023d4 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Status: The new Flag status (SET or RESET).
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout)  
{  
 80023d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80023d8:	4690      	mov	r8, r2
 80023da:	4605      	mov	r5, r0
 80023dc:	460e      	mov	r6, r1
 80023de:	461c      	mov	r4, r3
  uint32_t tickstart = HAL_GetTick();
 80023e0:	f7fe fb92 	bl	8000b08 <HAL_GetTick>
 80023e4:	4607      	mov	r7, r0
     
  /* Wait until flag is set */
  if(Status == RESET)
 80023e6:	f1b8 0f00 	cmp.w	r8, #0
 80023ea:	d112      	bne.n	8002412 <I2C_WaitOnFlagUntilTimeout+0x3e>
 80023ec:	682b      	ldr	r3, [r5, #0]
 80023ee:	e001      	b.n	80023f4 <I2C_WaitOnFlagUntilTimeout+0x20>
  {    
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 80023f0:	1c61      	adds	r1, r4, #1
 80023f2:	d11b      	bne.n	800242c <I2C_WaitOnFlagUntilTimeout+0x58>
  uint32_t tickstart = HAL_GetTick();
     
  /* Wait until flag is set */
  if(Status == RESET)
  {    
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 80023f4:	699a      	ldr	r2, [r3, #24]
 80023f6:	43d2      	mvns	r2, r2
 80023f8:	f3c2 0210 	ubfx	r2, r2, #0, #17
 80023fc:	4232      	tst	r2, r6
 80023fe:	d1f7      	bne.n	80023f0 <I2C_WaitOnFlagUntilTimeout+0x1c>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 8002400:	2000      	movs	r0, #0
 8002402:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8002406:	b1bc      	cbz	r4, 8002438 <I2C_WaitOnFlagUntilTimeout+0x64>
 8002408:	f7fe fb7e 	bl	8000b08 <HAL_GetTick>
 800240c:	1bc0      	subs	r0, r0, r7
 800240e:	4284      	cmp	r4, r0
 8002410:	d312      	bcc.n	8002438 <I2C_WaitOnFlagUntilTimeout+0x64>
 8002412:	682b      	ldr	r3, [r5, #0]
 8002414:	e001      	b.n	800241a <I2C_WaitOnFlagUntilTimeout+0x46>
  else
  {
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 8002416:	1c62      	adds	r2, r4, #1
 8002418:	d1f5      	bne.n	8002406 <I2C_WaitOnFlagUntilTimeout+0x32>
      }
    }
  }
  else
  {
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
 800241a:	699a      	ldr	r2, [r3, #24]
 800241c:	43d2      	mvns	r2, r2
 800241e:	f3c2 0210 	ubfx	r2, r2, #0, #17
 8002422:	4232      	tst	r2, r6
 8002424:	d0f7      	beq.n	8002416 <I2C_WaitOnFlagUntilTimeout+0x42>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 8002426:	2000      	movs	r0, #0
 8002428:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 800242c:	b124      	cbz	r4, 8002438 <I2C_WaitOnFlagUntilTimeout+0x64>
 800242e:	f7fe fb6b 	bl	8000b08 <HAL_GetTick>
 8002432:	1bc0      	subs	r0, r0, r7
 8002434:	4284      	cmp	r4, r0
 8002436:	d2d9      	bcs.n	80023ec <I2C_WaitOnFlagUntilTimeout+0x18>
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
        {
          hi2c->State= HAL_I2C_STATE_READY;
 8002438:	2201      	movs	r2, #1
          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 800243a:	2300      	movs	r3, #0
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
        {
          hi2c->State= HAL_I2C_STATE_READY;
 800243c:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35
          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8002440:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
          return HAL_TIMEOUT;
 8002444:	2003      	movs	r0, #3
 8002446:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800244a:	bf00      	nop

0800244c <I2C_WaitOnTXISFlagUntilTimeout>:
  *                the configuration information for the specified I2C.
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)  
{  
 800244c:	b570      	push	{r4, r5, r6, lr}
 800244e:	4604      	mov	r4, r0
 8002450:	460d      	mov	r5, r1
  uint32_t tickstart = HAL_GetTick();
 8002452:	f7fe fb59 	bl	8000b08 <HAL_GetTick>
 8002456:	4606      	mov	r6, r0
  
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8002458:	e004      	b.n	8002464 <I2C_WaitOnTXISFlagUntilTimeout+0x18>
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
 800245a:	f7ff ff6f 	bl	800233c <I2C_IsAcknowledgeFailed>
 800245e:	b948      	cbnz	r0, 8002474 <I2C_WaitOnTXISFlagUntilTimeout+0x28>
    {
      return HAL_ERROR;
    }
		
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 8002460:	1c6a      	adds	r2, r5, #1
 8002462:	d109      	bne.n	8002478 <I2C_WaitOnTXISFlagUntilTimeout+0x2c>
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)  
{  
  uint32_t tickstart = HAL_GetTick();
  
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8002464:	6823      	ldr	r3, [r4, #0]
 8002466:	699b      	ldr	r3, [r3, #24]
 8002468:	079b      	lsls	r3, r3, #30
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
 800246a:	4629      	mov	r1, r5
 800246c:	4620      	mov	r0, r4
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)  
{  
  uint32_t tickstart = HAL_GetTick();
  
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 800246e:	d5f4      	bpl.n	800245a <I2C_WaitOnTXISFlagUntilTimeout+0xe>

        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;      
 8002470:	2000      	movs	r0, #0
 8002472:	bd70      	pop	{r4, r5, r6, pc}
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
    {
      return HAL_ERROR;
 8002474:	2001      	movs	r0, #1
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;      
}
 8002476:	bd70      	pop	{r4, r5, r6, pc}
    }
		
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8002478:	b125      	cbz	r5, 8002484 <I2C_WaitOnTXISFlagUntilTimeout+0x38>
 800247a:	f7fe fb45 	bl	8000b08 <HAL_GetTick>
 800247e:	1b80      	subs	r0, r0, r6
 8002480:	4285      	cmp	r5, r0
 8002482:	d2ef      	bcs.n	8002464 <I2C_WaitOnTXISFlagUntilTimeout+0x18>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002484:	6ba3      	ldr	r3, [r4, #56]	; 0x38
        hi2c->State= HAL_I2C_STATE_READY;
 8002486:	2201      	movs	r2, #1
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002488:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State= HAL_I2C_STATE_READY;

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800248c:	2100      	movs	r1, #0
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800248e:	63a3      	str	r3, [r4, #56]	; 0x38
        hi2c->State= HAL_I2C_STATE_READY;

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8002490:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
        hi2c->State= HAL_I2C_STATE_READY;
 8002494:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8002498:	2003      	movs	r0, #3
 800249a:	bd70      	pop	{r4, r5, r6, pc}

0800249c <I2C_RequestMemoryWrite>:
  * @param  MemAddSize: Size of internal memory address
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)   
{
 800249c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 800249e:	6806      	ldr	r6, [r0, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80024a0:	4c19      	ldr	r4, [pc, #100]	; (8002508 <I2C_RequestMemoryWrite+0x6c>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80024a2:	6877      	ldr	r7, [r6, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80024a4:	403c      	ands	r4, r7
 80024a6:	f044 7480 	orr.w	r4, r4, #16777216	; 0x1000000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80024aa:	f3c1 0109 	ubfx	r1, r1, #0, #10
 80024ae:	f444 5400 	orr.w	r4, r4, #8192	; 0x2000
 80024b2:	430c      	orrs	r4, r1
 80024b4:	b2d9      	uxtb	r1, r3
 80024b6:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80024ba:	6074      	str	r4, [r6, #4]
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)   
{
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);

  /* Wait until TXIS flag is set */
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 80024bc:	9906      	ldr	r1, [sp, #24]
  * @param  MemAddSize: Size of internal memory address
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)   
{
 80024be:	4605      	mov	r5, r0
 80024c0:	461f      	mov	r7, r3
 80024c2:	4614      	mov	r4, r2
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);

  /* Wait until TXIS flag is set */
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 80024c4:	f7ff ffc2 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
 80024c8:	b948      	cbnz	r0, 80024de <I2C_RequestMemoryWrite+0x42>
      return HAL_TIMEOUT;
    }
  }

  /* If Memory address size is 8Bit */
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 80024ca:	2f01      	cmp	r7, #1
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);    
 80024cc:	682b      	ldr	r3, [r5, #0]
      return HAL_TIMEOUT;
    }
  }

  /* If Memory address size is 8Bit */
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 80024ce:	d00d      	beq.n	80024ec <I2C_RequestMemoryWrite+0x50>
  }      
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress); 
 80024d0:	0a22      	lsrs	r2, r4, #8
 80024d2:	629a      	str	r2, [r3, #40]	; 0x28
    
    /* Wait until TXIS flag is set */
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 80024d4:	4628      	mov	r0, r5
 80024d6:	9906      	ldr	r1, [sp, #24]
 80024d8:	f7ff ffb8 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
 80024dc:	b128      	cbz	r0, 80024ea <I2C_RequestMemoryWrite+0x4e>
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);

  /* Wait until TXIS flag is set */
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80024de:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80024e0:	2b04      	cmp	r3, #4
    {
      return HAL_ERROR;
 80024e2:	bf0c      	ite	eq
 80024e4:	2001      	moveq	r0, #1
    }
    else
    {
      return HAL_TIMEOUT;
 80024e6:	2003      	movne	r0, #3
 80024e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
      }
    }
    
    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);  
 80024ea:	682b      	ldr	r3, [r5, #0]
 80024ec:	b2e4      	uxtb	r4, r4
 80024ee:	629c      	str	r4, [r3, #40]	; 0x28
  }
  
  /* Wait until TCR flag is set */
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
 80024f0:	4628      	mov	r0, r5
 80024f2:	2180      	movs	r1, #128	; 0x80
 80024f4:	2200      	movs	r2, #0
 80024f6:	9b06      	ldr	r3, [sp, #24]
 80024f8:	f7ff ff6c 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
  {
    return HAL_TIMEOUT;
 80024fc:	2800      	cmp	r0, #0
 80024fe:	bf14      	ite	ne
 8002500:	2003      	movne	r0, #3
 8002502:	2000      	moveq	r0, #0
  }

return HAL_OK;
}
 8002504:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002506:	bf00      	nop
 8002508:	fc009800 	.word	0xfc009800

0800250c <I2C_RequestMemoryRead>:
  * @param  MemAddSize: Size of internal memory address
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
{
 800250c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 800250e:	6806      	ldr	r6, [r0, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002510:	4c18      	ldr	r4, [pc, #96]	; (8002574 <I2C_RequestMemoryRead+0x68>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002512:	6877      	ldr	r7, [r6, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002514:	403c      	ands	r4, r7
 8002516:	f444 5400 	orr.w	r4, r4, #8192	; 0x2000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 800251a:	f3c1 0109 	ubfx	r1, r1, #0, #10
 800251e:	4321      	orrs	r1, r4
  * @param  MemAddSize: Size of internal memory address
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
{
 8002520:	461f      	mov	r7, r3
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002522:	b2db      	uxtb	r3, r3
 8002524:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002528:	6071      	str	r1, [r6, #4]
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
{
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
  
  /* Wait until TXIS flag is set */
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 800252a:	9906      	ldr	r1, [sp, #24]
  * @param  MemAddSize: Size of internal memory address
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
{
 800252c:	4605      	mov	r5, r0
 800252e:	4614      	mov	r4, r2
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
  
  /* Wait until TXIS flag is set */
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 8002530:	f7ff ff8c 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
 8002534:	b948      	cbnz	r0, 800254a <I2C_RequestMemoryRead+0x3e>
      return HAL_TIMEOUT;
    }
  }
  
  /* If Memory address size is 8Bit */
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8002536:	2f01      	cmp	r7, #1
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);    
 8002538:	682b      	ldr	r3, [r5, #0]
      return HAL_TIMEOUT;
    }
  }
  
  /* If Memory address size is 8Bit */
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800253a:	d00d      	beq.n	8002558 <I2C_RequestMemoryRead+0x4c>
  }      
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress); 
 800253c:	0a22      	lsrs	r2, r4, #8
 800253e:	629a      	str	r2, [r3, #40]	; 0x28
    
    /* Wait until TXIS flag is set */
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 8002540:	4628      	mov	r0, r5
 8002542:	9906      	ldr	r1, [sp, #24]
 8002544:	f7ff ff82 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
 8002548:	b128      	cbz	r0, 8002556 <I2C_RequestMemoryRead+0x4a>
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
  
  /* Wait until TXIS flag is set */
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800254a:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800254c:	2b04      	cmp	r3, #4
    {
      return HAL_ERROR;
 800254e:	bf0c      	ite	eq
 8002550:	2001      	moveq	r0, #1
    }
    else
    {
      return HAL_TIMEOUT;
 8002552:	2003      	movne	r0, #3
 8002554:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
      }
    }
    
    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);  
 8002556:	682b      	ldr	r3, [r5, #0]
 8002558:	b2e4      	uxtb	r4, r4
 800255a:	629c      	str	r4, [r3, #40]	; 0x28
  }
  
  /* Wait until TC flag is set */
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout) != HAL_OK)      
 800255c:	4628      	mov	r0, r5
 800255e:	2140      	movs	r1, #64	; 0x40
 8002560:	2200      	movs	r2, #0
 8002562:	9b06      	ldr	r3, [sp, #24]
 8002564:	f7ff ff36 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
  {
    return HAL_TIMEOUT;
 8002568:	2800      	cmp	r0, #0
 800256a:	bf14      	ite	ne
 800256c:	2003      	movne	r0, #3
 800256e:	2000      	moveq	r0, #0
  }
  
  return HAL_OK;
}
 8002570:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002572:	bf00      	nop
 8002574:	fc009800 	.word	0xfc009800

08002578 <I2C_WaitOnSTOPFlagUntilTimeout>:
  *                the configuration information for the specified I2C.
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
{  
 8002578:	b570      	push	{r4, r5, r6, lr}
 800257a:	4605      	mov	r5, r0
 800257c:	460c      	mov	r4, r1
  uint32_t tickstart = 0x00;
  tickstart = HAL_GetTick();
 800257e:	f7fe fac3 	bl	8000b08 <HAL_GetTick>
 8002582:	4606      	mov	r6, r0
  
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002584:	e008      	b.n	8002598 <I2C_WaitOnSTOPFlagUntilTimeout+0x20>
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
 8002586:	f7ff fed9 	bl	800233c <I2C_IsAcknowledgeFailed>
 800258a:	b9c8      	cbnz	r0, 80025c0 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    {
      return HAL_ERROR;
    }
		
    /* Check for the Timeout */
    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 800258c:	b164      	cbz	r4, 80025a8 <I2C_WaitOnSTOPFlagUntilTimeout+0x30>
 800258e:	f7fe fabb 	bl	8000b08 <HAL_GetTick>
 8002592:	1b80      	subs	r0, r0, r6
 8002594:	4284      	cmp	r4, r0
 8002596:	d307      	bcc.n	80025a8 <I2C_WaitOnSTOPFlagUntilTimeout+0x30>
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
{  
  uint32_t tickstart = 0x00;
  tickstart = HAL_GetTick();
  
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002598:	682b      	ldr	r3, [r5, #0]
 800259a:	699b      	ldr	r3, [r3, #24]
 800259c:	069b      	lsls	r3, r3, #26
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
 800259e:	4621      	mov	r1, r4
 80025a0:	4628      	mov	r0, r5
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
{  
  uint32_t tickstart = 0x00;
  tickstart = HAL_GetTick();
  
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80025a2:	d5f0      	bpl.n	8002586 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      __HAL_UNLOCK(hi2c);

      return HAL_TIMEOUT;
    }
  }
  return HAL_OK;
 80025a4:	2000      	movs	r0, #0
 80025a6:	bd70      	pop	{r4, r5, r6, pc}
    }
		
    /* Check for the Timeout */
    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80025a8:	6bab      	ldr	r3, [r5, #56]	; 0x38
      hi2c->State= HAL_I2C_STATE_READY;
 80025aa:	2201      	movs	r2, #1
    }
		
    /* Check for the Timeout */
    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80025ac:	f043 0320 	orr.w	r3, r3, #32
      hi2c->State= HAL_I2C_STATE_READY;

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 80025b0:	2100      	movs	r1, #0
    }
		
    /* Check for the Timeout */
    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80025b2:	63ab      	str	r3, [r5, #56]	; 0x38
      hi2c->State= HAL_I2C_STATE_READY;

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 80025b4:	f885 1034 	strb.w	r1, [r5, #52]	; 0x34
		
    /* Check for the Timeout */
    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
      hi2c->State= HAL_I2C_STATE_READY;
 80025b8:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 80025bc:	2003      	movs	r0, #3
 80025be:	bd70      	pop	{r4, r5, r6, pc}
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
    {
      return HAL_ERROR;
 80025c0:	2001      	movs	r0, #1

      return HAL_TIMEOUT;
    }
  }
  return HAL_OK;
}
 80025c2:	bd70      	pop	{r4, r5, r6, pc}
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
 __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
 80025c4:	4770      	bx	lr
 80025c6:	bf00      	nop

080025c8 <HAL_I2C_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{ 
  /* Check the I2C handle allocation */
  if(hi2c == NULL)
 80025c8:	2800      	cmp	r0, #0
 80025ca:	d054      	beq.n	8002676 <HAL_I2C_Init+0xae>
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{ 
 80025cc:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if(hi2c->State == HAL_I2C_STATE_RESET)
 80025ce:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80025d2:	4604      	mov	r4, r0
 80025d4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80025d8:	2b00      	cmp	r3, #0
 80025da:	d047      	beq.n	800266c <HAL_I2C_Init+0xa4>
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
  
  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 80025dc:	6822      	ldr	r2, [r4, #0]

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 80025de:	2302      	movs	r3, #2
 80025e0:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  
  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 80025e4:	6813      	ldr	r3, [r2, #0]
 80025e6:	f023 0301 	bic.w	r3, r3, #1
 80025ea:	6013      	str	r3, [r2, #0]
  
  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 80025ec:	e894 000c 	ldmia.w	r4, {r2, r3}
 80025f0:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 80025f4:	6113      	str	r3, [r2, #16]
  
  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 80025f6:	6822      	ldr	r2, [r4, #0]
 80025f8:	6893      	ldr	r3, [r2, #8]
 80025fa:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80025fe:	6093      	str	r3, [r2, #8]
  if(hi2c->Init.OwnAddress1 != 0)
 8002600:	68a3      	ldr	r3, [r4, #8]
 8002602:	bb13      	cbnz	r3, 800264a <HAL_I2C_Init+0x82>
    }
  }
  
  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8002604:	68e3      	ldr	r3, [r4, #12]
 8002606:	2b02      	cmp	r3, #2
 8002608:	d02b      	beq.n	8002662 <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800260a:	6822      	ldr	r2, [r4, #0]
 800260c:	6853      	ldr	r3, [r2, #4]
 800260e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8002612:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002616:	6053      	str	r3, [r2, #4]
  
  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8002618:	6960      	ldr	r0, [r4, #20]
 800261a:	6923      	ldr	r3, [r4, #16]
 800261c:	69a1      	ldr	r1, [r4, #24]
 800261e:	6822      	ldr	r2, [r4, #0]
 8002620:	4303      	orrs	r3, r0
 8002622:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8002626:	60d3      	str	r3, [r2, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8002628:	6a21      	ldr	r1, [r4, #32]
 800262a:	69e3      	ldr	r3, [r4, #28]
 800262c:	6822      	ldr	r2, [r4, #0]
 800262e:	430b      	orrs	r3, r1
 8002630:	6013      	str	r3, [r2, #0]
  
  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8002632:	6821      	ldr	r1, [r4, #0]
 8002634:	680b      	ldr	r3, [r1, #0]
  
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002636:	2200      	movs	r2, #0
  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
  
  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8002638:	f043 0301 	orr.w	r3, r3, #1
  
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
  hi2c->State = HAL_I2C_STATE_READY;
 800263c:	2501      	movs	r5, #1
  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
  
  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800263e:	600b      	str	r3, [r1, #0]
  
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002640:	63a2      	str	r2, [r4, #56]	; 0x38
  hi2c->State = HAL_I2C_STATE_READY;
 8002642:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
  
  return HAL_OK;
 8002646:	4610      	mov	r0, r2
 8002648:	bd38      	pop	{r3, r4, r5, pc}
  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
  if(hi2c->Init.OwnAddress1 != 0)
  {
    if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800264a:	68e2      	ldr	r2, [r4, #12]
 800264c:	2a01      	cmp	r2, #1
    {
      hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800264e:	6822      	ldr	r2, [r4, #0]
 8002650:	bf0c      	ite	eq
 8002652:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
    }
    else /* I2C_ADDRESSINGMODE_10BIT */
    {
      hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8002656:	f443 4304 	orrne.w	r3, r3, #33792	; 0x8400
 800265a:	6093      	str	r3, [r2, #8]
    }
  }
  
  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800265c:	68e3      	ldr	r3, [r4, #12]
 800265e:	2b02      	cmp	r3, #2
 8002660:	d1d3      	bne.n	800260a <HAL_I2C_Init+0x42>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8002662:	6823      	ldr	r3, [r4, #0]
 8002664:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8002668:	605a      	str	r2, [r3, #4]
 800266a:	e7ce      	b.n	800260a <HAL_I2C_Init+0x42>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if(hi2c->State == HAL_I2C_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800266c:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 8002670:	f7fd ff08 	bl	8000484 <HAL_I2C_MspInit>
 8002674:	e7b2      	b.n	80025dc <HAL_I2C_Init+0x14>
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{ 
  /* Check the I2C handle allocation */
  if(hi2c == NULL)
  {
    return HAL_ERROR;
 8002676:	2001      	movs	r0, #1
 8002678:	4770      	bx	lr
 800267a:	bf00      	nop
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
 __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
 800267c:	4770      	bx	lr
 800267e:	bf00      	nop

08002680 <HAL_I2C_DeInit>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
  /* Check the I2C handle allocation */
  if(hi2c == NULL)
 8002680:	b190      	cbz	r0, 80026a8 <HAL_I2C_DeInit+0x28>
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
 8002682:	b510      	push	{r4, lr}
  }
  
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  
  hi2c->State = HAL_I2C_STATE_BUSY;
 8002684:	2302      	movs	r3, #2
  
  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 8002686:	6802      	ldr	r2, [r0, #0]
  }
  
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  
  hi2c->State = HAL_I2C_STATE_BUSY;
 8002688:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  
  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 800268c:	6813      	ldr	r3, [r2, #0]
 800268e:	f023 0301 	bic.w	r3, r3, #1
 8002692:	4604      	mov	r4, r0
 8002694:	6013      	str	r3, [r2, #0]
  
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
 8002696:	f7fd ff1f 	bl	80004d8 <HAL_I2C_MspDeInit>
  
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800269a:	2000      	movs	r0, #0
 800269c:	63a0      	str	r0, [r4, #56]	; 0x38

  hi2c->State = HAL_I2C_STATE_RESET;
  
  /* Release Lock */
  __HAL_UNLOCK(hi2c);
 800269e:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
  
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;

  hi2c->State = HAL_I2C_STATE_RESET;
 80026a2:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
  
  /* Release Lock */
  __HAL_UNLOCK(hi2c);

  return HAL_OK;
 80026a6:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
  /* Check the I2C handle allocation */
  if(hi2c == NULL)
  {
    return HAL_ERROR;
 80026a8:	2001      	movs	r0, #1
 80026aa:	4770      	bx	lr

080026ac <HAL_I2C_Master_Transmit>:
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80026ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80026b0:	4604      	mov	r4, r0
  uint32_t sizetmp = 0;

  if(hi2c->State == HAL_I2C_STATE_READY)
 80026b2:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
 80026b6:	b2c0      	uxtb	r0, r0
 80026b8:	2801      	cmp	r0, #1
 80026ba:	d002      	beq.n	80026c2 <HAL_I2C_Master_Transmit+0x16>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 80026bc:	2002      	movs	r0, #2
 80026be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80026c2:	4690      	mov	r8, r2
{
  uint32_t sizetmp = 0;

  if(hi2c->State == HAL_I2C_STATE_READY)
  {    
    if((pData == NULL ) || (Size == 0)) 
 80026c4:	2a00      	cmp	r2, #0
 80026c6:	d045      	beq.n	8002754 <HAL_I2C_Master_Transmit+0xa8>
 80026c8:	461d      	mov	r5, r3
 80026ca:	2b00      	cmp	r3, #0
 80026cc:	d042      	beq.n	8002754 <HAL_I2C_Master_Transmit+0xa8>
    {
      return  HAL_ERROR;                                    
    }
    
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 80026ce:	6822      	ldr	r2, [r4, #0]
 80026d0:	6993      	ldr	r3, [r2, #24]
 80026d2:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
 80026d6:	d1f1      	bne.n	80026bc <HAL_I2C_Master_Transmit+0x10>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80026d8:	f894 6034 	ldrb.w	r6, [r4, #52]	; 0x34
 80026dc:	2e01      	cmp	r6, #1
 80026de:	d0ed      	beq.n	80026bc <HAL_I2C_Master_Transmit+0x10>
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
 80026e0:	2612      	movs	r6, #18
 80026e2:	f884 6035 	strb.w	r6, [r4, #53]	; 0x35
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80026e6:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 80026ea:	63a3      	str	r3, [r4, #56]	; 0x38
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80026ec:	6850      	ldr	r0, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80026ee:	4b38      	ldr	r3, [pc, #224]	; (80027d0 <HAL_I2C_Master_Transmit+0x124>)
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    /* Size > 255, need to set RELOAD bit */
    if(Size > 255)
 80026f0:	2dff      	cmp	r5, #255	; 0xff
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80026f2:	ea03 0300 	and.w	r3, r3, r0
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    /* Size > 255, need to set RELOAD bit */
    if(Size > 255)
 80026f6:	d95c      	bls.n	80027b2 <HAL_I2C_Master_Transmit+0x106>
 80026f8:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80026fc:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8002700:	f443 3390 	orr.w	r3, r3, #73728	; 0x12000
 8002704:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002706:	6053      	str	r3, [r2, #4]
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    /* Size > 255, need to set RELOAD bit */
    if(Size > 255)
    {
      I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
      sizetmp = 255;
 8002708:	27ff      	movs	r7, #255	; 0xff
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 800270a:	b28e      	uxth	r6, r1
    }
      
    do
    {
      /* Wait until TXIS flag is set */
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 800270c:	4620      	mov	r0, r4
 800270e:	9906      	ldr	r1, [sp, #24]
 8002710:	f7ff fe9c 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
        }
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = (*pData++);
      sizetmp--;
      Size--;
 8002714:	3d01      	subs	r5, #1
 8002716:	b2ad      	uxth	r5, r5
    }
      
    do
    {
      /* Wait until TXIS flag is set */
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 8002718:	2800      	cmp	r0, #0
 800271a:	d144      	bne.n	80027a6 <HAL_I2C_Master_Transmit+0xfa>
        {
          return HAL_TIMEOUT;
        }
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = (*pData++);
 800271c:	6823      	ldr	r3, [r4, #0]
 800271e:	f818 2b01 	ldrb.w	r2, [r8], #1
 8002722:	629a      	str	r2, [r3, #40]	; 0x28
      sizetmp--;
      Size--;

      if((sizetmp == 0)&&(Size!=0))
 8002724:	3f01      	subs	r7, #1
 8002726:	d118      	bne.n	800275a <HAL_I2C_Master_Transmit+0xae>
 8002728:	b9d5      	cbnz	r5, 8002760 <HAL_I2C_Master_Transmit+0xb4>

    }while(Size > 0);
    
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 800272a:	4620      	mov	r0, r4
 800272c:	9906      	ldr	r1, [sp, #24]
 800272e:	f7ff ff23 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8002732:	2800      	cmp	r0, #0
 8002734:	d137      	bne.n	80027a6 <HAL_I2C_Master_Transmit+0xfa>
        return HAL_TIMEOUT;
      }
    }
    
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002736:	6822      	ldr	r2, [r4, #0]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8002738:	4b26      	ldr	r3, [pc, #152]	; (80027d4 <HAL_I2C_Master_Transmit+0x128>)
        return HAL_TIMEOUT;
      }
    }
    
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800273a:	2120      	movs	r1, #32
 800273c:	61d1      	str	r1, [r2, #28]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800273e:	6822      	ldr	r2, [r4, #0]
 8002740:	6855      	ldr	r5, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY; 	  
 8002742:	2101      	movs	r1, #1
    
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8002744:	402b      	ands	r3, r5
 8002746:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY; 	  
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002748:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY; 	  
 800274c:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    return HAL_OK;
 8002750:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if(hi2c->State == HAL_I2C_STATE_READY)
  {    
    if((pData == NULL ) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 8002754:	2001      	movs	r0, #1
 8002756:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
          sizetmp = Size;
        }
      }

    }while(Size > 0);
 800275a:	2d00      	cmp	r5, #0
 800275c:	d1d6      	bne.n	800270c <HAL_I2C_Master_Transmit+0x60>
 800275e:	e7e4      	b.n	800272a <HAL_I2C_Master_Transmit+0x7e>
      Size--;

      if((sizetmp == 0)&&(Size!=0))
      {
        /* Wait until TXE flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
 8002760:	463a      	mov	r2, r7
 8002762:	2180      	movs	r1, #128	; 0x80
 8002764:	9b06      	ldr	r3, [sp, #24]
 8002766:	4620      	mov	r0, r4
 8002768:	f7ff fe34 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800276c:	4a18      	ldr	r2, [pc, #96]	; (80027d0 <HAL_I2C_Master_Transmit+0x124>)
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 800276e:	042b      	lsls	r3, r5, #16
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002770:	4611      	mov	r1, r2
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002772:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
      Size--;

      if((sizetmp == 0)&&(Size!=0))
      {
        /* Wait until TXE flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
 8002776:	b9c8      	cbnz	r0, 80027ac <HAL_I2C_Master_Transmit+0x100>
        {
          return HAL_TIMEOUT;
        }
        
        if(Size > 255)
 8002778:	2dff      	cmp	r5, #255	; 0xff
 800277a:	d90a      	bls.n	8002792 <HAL_I2C_Master_Transmit+0xe6>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 800277c:	6823      	ldr	r3, [r4, #0]
 800277e:	6859      	ldr	r1, [r3, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002780:	400a      	ands	r2, r1
 8002782:	f042 72ff 	orr.w	r2, r2, #33423360	; 0x1fe0000
 8002786:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 800278a:	4332      	orrs	r2, r6
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 800278c:	605a      	str	r2, [r3, #4]
        }
        
        if(Size > 255)
        {
          I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
          sizetmp = 255;
 800278e:	27ff      	movs	r7, #255	; 0xff
 8002790:	e7bc      	b.n	800270c <HAL_I2C_Master_Transmit+0x60>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002792:	6822      	ldr	r2, [r4, #0]
 8002794:	6850      	ldr	r0, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002796:	4001      	ands	r1, r0
 8002798:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 800279c:	430b      	orrs	r3, r1
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 800279e:	4333      	orrs	r3, r6
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80027a0:	6053      	str	r3, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80027a2:	462f      	mov	r7, r5
 80027a4:	e7b2      	b.n	800270c <HAL_I2C_Master_Transmit+0x60>
    
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80027a6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80027a8:	2b04      	cmp	r3, #4
 80027aa:	d0d3      	beq.n	8002754 <HAL_I2C_Master_Transmit+0xa8>
      if((sizetmp == 0)&&(Size!=0))
      {
        /* Wait until TXE flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
        {
          return HAL_TIMEOUT;
 80027ac:	2003      	movs	r0, #3
  }
  else
  {
    return HAL_BUSY; 
  }
}
 80027ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80027b2:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80027b6:	f3c1 0109 	ubfx	r1, r1, #0, #10
 80027ba:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80027be:	0428      	lsls	r0, r5, #16
 80027c0:	430b      	orrs	r3, r1
 80027c2:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 80027c6:	4303      	orrs	r3, r0
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80027c8:	6053      	str	r3, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80027ca:	462f      	mov	r7, r5
 80027cc:	e79d      	b.n	800270a <HAL_I2C_Master_Transmit+0x5e>
 80027ce:	bf00      	nop
 80027d0:	fc009800 	.word	0xfc009800
 80027d4:	fe00e800 	.word	0xfe00e800

080027d8 <HAL_I2C_Master_Receive>:
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80027d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80027dc:	4604      	mov	r4, r0
  uint32_t sizetmp = 0;

  if(hi2c->State == HAL_I2C_STATE_READY)
 80027de:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
 80027e2:	b2c0      	uxtb	r0, r0
 80027e4:	2801      	cmp	r0, #1
 80027e6:	d002      	beq.n	80027ee <HAL_I2C_Master_Receive+0x16>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 80027e8:	2002      	movs	r0, #2
  }
}
 80027ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80027ee:	4690      	mov	r8, r2
{
  uint32_t sizetmp = 0;

  if(hi2c->State == HAL_I2C_STATE_READY)
  {    
    if((pData == NULL ) || (Size == 0)) 
 80027f0:	2a00      	cmp	r2, #0
 80027f2:	d03c      	beq.n	800286e <HAL_I2C_Master_Receive+0x96>
 80027f4:	461d      	mov	r5, r3
 80027f6:	2b00      	cmp	r3, #0
 80027f8:	d039      	beq.n	800286e <HAL_I2C_Master_Receive+0x96>
    {
      return  HAL_ERROR;                                    
    }
    
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 80027fa:	6822      	ldr	r2, [r4, #0]
 80027fc:	6993      	ldr	r3, [r2, #24]
 80027fe:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
 8002802:	d1f1      	bne.n	80027e8 <HAL_I2C_Master_Receive+0x10>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002804:	f894 6034 	ldrb.w	r6, [r4, #52]	; 0x34
 8002808:	2e01      	cmp	r6, #1
 800280a:	d0ed      	beq.n	80027e8 <HAL_I2C_Master_Receive+0x10>
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
 800280c:	2622      	movs	r6, #34	; 0x22
 800280e:	f884 6035 	strb.w	r6, [r4, #53]	; 0x35
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002812:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002816:	63a3      	str	r3, [r4, #56]	; 0x38
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002818:	6850      	ldr	r0, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800281a:	4b38      	ldr	r3, [pc, #224]	; (80028fc <HAL_I2C_Master_Receive+0x124>)
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    /* Size > 255, need to set RELOAD bit */
    if(Size > 255)
 800281c:	2dff      	cmp	r5, #255	; 0xff
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800281e:	ea03 0300 	and.w	r3, r3, r0
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    /* Size > 255, need to set RELOAD bit */
    if(Size > 255)
 8002822:	d94e      	bls.n	80028c2 <HAL_I2C_Master_Receive+0xea>
 8002824:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002828:	f3c1 0609 	ubfx	r6, r1, #0, #10
 800282c:	f443 3392 	orr.w	r3, r3, #74752	; 0x12400
 8002830:	4333      	orrs	r3, r6
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002832:	6053      	str	r3, [r2, #4]
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    /* Size > 255, need to set RELOAD bit */
    if(Size > 255)
    {
      I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
      sizetmp = 255;
 8002834:	27ff      	movs	r7, #255	; 0xff
    }
    
    do
    {
      /* Wait until RXNE flag is set */
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)      
 8002836:	4620      	mov	r0, r4
 8002838:	2104      	movs	r1, #4
 800283a:	2200      	movs	r2, #0
 800283c:	9b06      	ldr	r3, [sp, #24]
 800283e:	f7ff fdc9 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
      }
     
      /* Write data to RXDR */
      (*pData++) =hi2c->Instance->RXDR;
      sizetmp--;
      Size--;
 8002842:	3d01      	subs	r5, #1
 8002844:	b2ad      	uxth	r5, r5
    }
    
    do
    {
      /* Wait until RXNE flag is set */
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)      
 8002846:	b978      	cbnz	r0, 8002868 <HAL_I2C_Master_Receive+0x90>
      {
        return HAL_TIMEOUT;
      }
     
      /* Write data to RXDR */
      (*pData++) =hi2c->Instance->RXDR;
 8002848:	6823      	ldr	r3, [r4, #0]
      sizetmp--;
      Size--;

      if((sizetmp == 0)&&(Size!=0))
 800284a:	3f01      	subs	r7, #1
      {
        return HAL_TIMEOUT;
      }
     
      /* Write data to RXDR */
      (*pData++) =hi2c->Instance->RXDR;
 800284c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800284e:	f808 3b01 	strb.w	r3, [r8], #1
      sizetmp--;
      Size--;

      if((sizetmp == 0)&&(Size!=0))
 8002852:	d10f      	bne.n	8002874 <HAL_I2C_Master_Receive+0x9c>
 8002854:	b98d      	cbnz	r5, 800287a <HAL_I2C_Master_Receive+0xa2>

    }while(Size > 0);
    
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8002856:	4620      	mov	r0, r4
 8002858:	2119      	movs	r1, #25
 800285a:	f7ff fe8d 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 800285e:	2800      	cmp	r0, #0
 8002860:	d03d      	beq.n	80028de <HAL_I2C_Master_Receive+0x106>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8002862:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002864:	2b04      	cmp	r3, #4
 8002866:	d002      	beq.n	800286e <HAL_I2C_Master_Receive+0x96>
      {
        return HAL_ERROR;
      }
      else
      {
        return HAL_TIMEOUT;
 8002868:	2003      	movs	r0, #3
 800286a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if(hi2c->State == HAL_I2C_STATE_READY)
  {    
    if((pData == NULL ) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 800286e:	2001      	movs	r0, #1
 8002870:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
          sizetmp = Size;
        }
      }

    }while(Size > 0);
 8002874:	2d00      	cmp	r5, #0
 8002876:	d1de      	bne.n	8002836 <HAL_I2C_Master_Receive+0x5e>
 8002878:	e7ed      	b.n	8002856 <HAL_I2C_Master_Receive+0x7e>
      Size--;

      if((sizetmp == 0)&&(Size!=0))
      {
        /* Wait until TCR flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
 800287a:	463a      	mov	r2, r7
 800287c:	2180      	movs	r1, #128	; 0x80
 800287e:	9b06      	ldr	r3, [sp, #24]
 8002880:	4620      	mov	r0, r4
 8002882:	f7ff fda7 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002886:	4a1d      	ldr	r2, [pc, #116]	; (80028fc <HAL_I2C_Master_Receive+0x124>)
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002888:	042b      	lsls	r3, r5, #16
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800288a:	4611      	mov	r1, r2
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 800288c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
      Size--;

      if((sizetmp == 0)&&(Size!=0))
      {
        /* Wait until TCR flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
 8002890:	2800      	cmp	r0, #0
 8002892:	d1e9      	bne.n	8002868 <HAL_I2C_Master_Receive+0x90>
        {
          return HAL_TIMEOUT;
        }
        
        if(Size > 255)
 8002894:	2dff      	cmp	r5, #255	; 0xff
 8002896:	d90a      	bls.n	80028ae <HAL_I2C_Master_Receive+0xd6>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002898:	6823      	ldr	r3, [r4, #0]
 800289a:	6859      	ldr	r1, [r3, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800289c:	400a      	ands	r2, r1
 800289e:	f042 72ff 	orr.w	r2, r2, #33423360	; 0x1fe0000
 80028a2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80028a6:	4332      	orrs	r2, r6
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80028a8:	605a      	str	r2, [r3, #4]
        }
        
        if(Size > 255)
        {
          I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
          sizetmp = 255;
 80028aa:	27ff      	movs	r7, #255	; 0xff
 80028ac:	e7c3      	b.n	8002836 <HAL_I2C_Master_Receive+0x5e>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80028ae:	6822      	ldr	r2, [r4, #0]
 80028b0:	6850      	ldr	r0, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80028b2:	4001      	ands	r1, r0
 80028b4:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 80028b8:	430b      	orrs	r3, r1
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80028ba:	4333      	orrs	r3, r6
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80028bc:	6053      	str	r3, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80028be:	462f      	mov	r7, r5
 80028c0:	e7b9      	b.n	8002836 <HAL_I2C_Master_Receive+0x5e>
 80028c2:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80028c6:	f3c1 0609 	ubfx	r6, r1, #0, #10
 80028ca:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 80028ce:	0429      	lsls	r1, r5, #16
 80028d0:	4333      	orrs	r3, r6
 80028d2:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 80028d6:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80028d8:	6053      	str	r3, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80028da:	462f      	mov	r7, r5
 80028dc:	e7ab      	b.n	8002836 <HAL_I2C_Master_Receive+0x5e>
        return HAL_TIMEOUT;
      }
    }
    
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80028de:	6822      	ldr	r2, [r4, #0]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80028e0:	4b07      	ldr	r3, [pc, #28]	; (8002900 <HAL_I2C_Master_Receive+0x128>)
        return HAL_TIMEOUT;
      }
    }
    
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80028e2:	2120      	movs	r1, #32
 80028e4:	61d1      	str	r1, [r2, #28]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80028e6:	6822      	ldr	r2, [r4, #0]
 80028e8:	6855      	ldr	r5, [r2, #4]
    
    hi2c->State = HAL_I2C_STATE_READY; 	  
 80028ea:	2101      	movs	r1, #1
    
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80028ec:	402b      	ands	r3, r5
 80028ee:	6053      	str	r3, [r2, #4]
    
    hi2c->State = HAL_I2C_STATE_READY; 	  
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80028f0:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
    
    hi2c->State = HAL_I2C_STATE_READY; 	  
 80028f4:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    return HAL_OK;
 80028f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80028fc:	fc009800 	.word	0xfc009800
 8002900:	fe00e800 	.word	0xfe00e800

08002904 <HAL_I2C_Slave_Transmit>:
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8002904:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002908:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 800290c:	b2e4      	uxtb	r4, r4
 800290e:	2c01      	cmp	r4, #1
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8002910:	4605      	mov	r5, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002912:	d002      	beq.n	800291a <HAL_I2C_Slave_Transmit+0x16>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 8002914:	2002      	movs	r0, #2
 8002916:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {    
    if((pData == NULL ) || (Size == 0)) 
 800291a:	b311      	cbz	r1, 8002962 <HAL_I2C_Slave_Transmit+0x5e>
 800291c:	b30a      	cbz	r2, 8002962 <HAL_I2C_Slave_Transmit+0x5e>
    {
      return  HAL_ERROR;                                    
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800291e:	f890 7034 	ldrb.w	r7, [r0, #52]	; 0x34
 8002922:	2f01      	cmp	r7, #1
 8002924:	d0f6      	beq.n	8002914 <HAL_I2C_Slave_Transmit+0x10>
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
 8002926:	f8d0 e000 	ldr.w	lr, [r0]
    {
      return  HAL_ERROR;                                    
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800292a:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
 800292e:	4690      	mov	r8, r2
 8002930:	460f      	mov	r7, r1
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002932:	2200      	movs	r2, #0
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
 8002934:	2142      	movs	r1, #66	; 0x42
 8002936:	f880 1035 	strb.w	r1, [r0, #53]	; 0x35
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 800293a:	6382      	str	r2, [r0, #56]	; 0x38
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
 800293c:	f8de 1004 	ldr.w	r1, [lr, #4]
 8002940:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 8002944:	f8ce 1004 	str.w	r1, [lr, #4]

    /* Wait until ADDR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
 8002948:	2108      	movs	r1, #8
 800294a:	461e      	mov	r6, r3
 800294c:	f7ff fd42 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8002950:	b150      	cbz	r0, 8002968 <HAL_I2C_Slave_Transmit+0x64>

    /* Wait until DIR flag is set Transmitter mode */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout) != HAL_OK)      
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002952:	682a      	ldr	r2, [r5, #0]
 8002954:	6853      	ldr	r3, [r2, #4]
 8002956:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800295a:	6053      	str	r3, [r2, #4]
      return HAL_TIMEOUT;
 800295c:	2003      	movs	r0, #3
 800295e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {    
    if((pData == NULL ) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 8002962:	2001      	movs	r0, #1
 8002964:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
      return HAL_TIMEOUT;
    }
    
    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
 8002968:	682b      	ldr	r3, [r5, #0]
 800296a:	2408      	movs	r4, #8
 800296c:	61dc      	str	r4, [r3, #28]

    /* If 10bit addressing mode is selected */
    if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800296e:	68eb      	ldr	r3, [r5, #12]
 8002970:	2b02      	cmp	r3, #2
 8002972:	d026      	beq.n	80029c2 <HAL_I2C_Slave_Transmit+0xbe>
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
    }

    /* Wait until DIR flag is set Transmitter mode */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout) != HAL_OK)      
 8002974:	4628      	mov	r0, r5
 8002976:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800297a:	2200      	movs	r2, #0
 800297c:	4633      	mov	r3, r6
 800297e:	f7ff fd29 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8002982:	2800      	cmp	r0, #0
 8002984:	d1e5      	bne.n	8002952 <HAL_I2C_Slave_Transmit+0x4e>
 8002986:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 800298a:	fa17 f888 	uxtah	r8, r7, r8
 800298e:	1e7c      	subs	r4, r7, #1
 8002990:	e005      	b.n	800299e <HAL_I2C_Slave_Transmit+0x9a>
          return HAL_TIMEOUT;
        }
      }
      
      /* Read data from TXDR */
      hi2c->Instance->TXDR = (*pData++);
 8002992:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 8002996:	682b      	ldr	r3, [r5, #0]
      Size--;
    }while(Size > 0);
 8002998:	4544      	cmp	r4, r8
          return HAL_TIMEOUT;
        }
      }
      
      /* Read data from TXDR */
      hi2c->Instance->TXDR = (*pData++);
 800299a:	629a      	str	r2, [r3, #40]	; 0x28
      Size--;
    }while(Size > 0);
 800299c:	d01c      	beq.n	80029d8 <HAL_I2C_Slave_Transmit+0xd4>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 800299e:	4628      	mov	r0, r5
 80029a0:	4631      	mov	r1, r6
 80029a2:	f7ff fd53 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
 80029a6:	4607      	mov	r7, r0
 80029a8:	2800      	cmp	r0, #0
 80029aa:	d0f2      	beq.n	8002992 <HAL_I2C_Slave_Transmit+0x8e>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
 80029ac:	682a      	ldr	r2, [r5, #0]
 80029ae:	6853      	ldr	r3, [r2, #4]
 80029b0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80029b4:	6053      	str	r3, [r2, #4]

        if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80029b6:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80029b8:	2b04      	cmp	r3, #4
 80029ba:	d0d2      	beq.n	8002962 <HAL_I2C_Slave_Transmit+0x5e>
	/* A NACK is generated to confirm the end of transfer */
	hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
      }
      else
      {
        return HAL_TIMEOUT;
 80029bc:	2003      	movs	r0, #3
  }
  else
  {
    return HAL_BUSY; 
  }
}
 80029be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    /* If 10bit addressing mode is selected */
    if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    {
      /* Wait until ADDR flag is set */
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
 80029c2:	4602      	mov	r2, r0
 80029c4:	4621      	mov	r1, r4
 80029c6:	4628      	mov	r0, r5
 80029c8:	4633      	mov	r3, r6
 80029ca:	f7ff fd03 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 80029ce:	2800      	cmp	r0, #0
 80029d0:	d1bf      	bne.n	8002952 <HAL_I2C_Slave_Transmit+0x4e>
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
        return HAL_TIMEOUT;
      }
    
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
 80029d2:	682b      	ldr	r3, [r5, #0]
 80029d4:	61dc      	str	r4, [r3, #28]
 80029d6:	e7cd      	b.n	8002974 <HAL_I2C_Slave_Transmit+0x70>
      hi2c->Instance->TXDR = (*pData++);
      Size--;
    }while(Size > 0);
    
    /* Wait until STOP flag is set */
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 80029d8:	4628      	mov	r0, r5
 80029da:	2119      	movs	r1, #25
 80029dc:	f7ff fdcc 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 80029e0:	b140      	cbz	r0, 80029f4 <HAL_I2C_Slave_Transmit+0xf0>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 80029e2:	682a      	ldr	r2, [r5, #0]
 80029e4:	6853      	ldr	r3, [r2, #4]
 80029e6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80029ea:	6053      	str	r3, [r2, #4]

      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80029ec:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80029ee:	2b04      	cmp	r3, #4
 80029f0:	d1e4      	bne.n	80029bc <HAL_I2C_Slave_Transmit+0xb8>
      {
	/* Normal use case for Transmitter mode */
	/* A NACK is generated to confirm the end of transfer */
	hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80029f2:	63af      	str	r7, [r5, #56]	; 0x38
        return HAL_TIMEOUT;
      }
    }
    
    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
 80029f4:	682a      	ldr	r2, [r5, #0]
 80029f6:	2120      	movs	r1, #32
 80029f8:	61d1      	str	r1, [r2, #28]
    
    /* Wait until BUSY flag is reset */ 
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
 80029fa:	4633      	mov	r3, r6
 80029fc:	2201      	movs	r2, #1
 80029fe:	4628      	mov	r0, r5
 8002a00:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8002a04:	f7ff fce6 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002a08:	682a      	ldr	r2, [r5, #0]
 8002a0a:	6853      	ldr	r3, [r2, #4]
    
    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
    
    /* Wait until BUSY flag is reset */ 
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
 8002a0c:	b128      	cbz	r0, 8002a1a <HAL_I2C_Slave_Transmit+0x116>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002a0e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002a12:	6053      	str	r3, [r2, #4]
      return HAL_TIMEOUT;
 8002a14:	2003      	movs	r0, #3
 8002a16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    
    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;

    hi2c->State = HAL_I2C_STATE_READY;
 8002a1a:	2101      	movs	r1, #1
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
      return HAL_TIMEOUT;
    }
    
    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002a1c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002a20:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002a22:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
    }
    
    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;

    hi2c->State = HAL_I2C_STATE_READY;
 8002a26:	f885 1035 	strb.w	r1, [r5, #53]	; 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    return HAL_OK;
 8002a2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002a2e:	bf00      	nop

08002a30 <HAL_I2C_Slave_Receive>:
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8002a30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002a34:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 8002a38:	b2e4      	uxtb	r4, r4
 8002a3a:	2c01      	cmp	r4, #1
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8002a3c:	4605      	mov	r5, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002a3e:	d002      	beq.n	8002a46 <HAL_I2C_Slave_Receive+0x16>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 8002a40:	2002      	movs	r0, #2
 8002a42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {  
    if((pData == NULL ) || (Size == 0)) 
 8002a46:	b311      	cbz	r1, 8002a8e <HAL_I2C_Slave_Receive+0x5e>
 8002a48:	b30a      	cbz	r2, 8002a8e <HAL_I2C_Slave_Receive+0x5e>
    {
      return  HAL_ERROR;                                    
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002a4a:	f890 7034 	ldrb.w	r7, [r0, #52]	; 0x34
 8002a4e:	2f01      	cmp	r7, #1
 8002a50:	d0f6      	beq.n	8002a40 <HAL_I2C_Slave_Receive+0x10>
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
 8002a52:	f8d0 e000 	ldr.w	lr, [r0]
    {
      return  HAL_ERROR;                                    
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002a56:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
 8002a5a:	4690      	mov	r8, r2
 8002a5c:	460f      	mov	r7, r1
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002a5e:	2200      	movs	r2, #0
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
 8002a60:	2142      	movs	r1, #66	; 0x42
 8002a62:	f880 1035 	strb.w	r1, [r0, #53]	; 0x35
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002a66:	6382      	str	r2, [r0, #56]	; 0x38
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
 8002a68:	f8de 1004 	ldr.w	r1, [lr, #4]
 8002a6c:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 8002a70:	f8ce 1004 	str.w	r1, [lr, #4]

    /* Wait until ADDR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
 8002a74:	2108      	movs	r1, #8
 8002a76:	461e      	mov	r6, r3
 8002a78:	f7ff fcac 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8002a7c:	b150      	cbz	r0, 8002a94 <HAL_I2C_Slave_Receive+0x64>
    
    /* Wait until DIR flag is reset Receiver mode */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout) != HAL_OK)      
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002a7e:	682a      	ldr	r2, [r5, #0]
 8002a80:	6853      	ldr	r3, [r2, #4]
 8002a82:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002a86:	6053      	str	r3, [r2, #4]
      return HAL_TIMEOUT;
 8002a88:	2003      	movs	r0, #3
 8002a8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {  
    if((pData == NULL ) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 8002a8e:	2001      	movs	r0, #1
 8002a90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
      return HAL_TIMEOUT;
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
 8002a94:	682b      	ldr	r3, [r5, #0]
 8002a96:	2108      	movs	r1, #8
 8002a98:	61d9      	str	r1, [r3, #28]
    
    /* Wait until DIR flag is reset Receiver mode */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout) != HAL_OK)      
 8002a9a:	4622      	mov	r2, r4
 8002a9c:	4628      	mov	r0, r5
 8002a9e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8002aa2:	4633      	mov	r3, r6
 8002aa4:	f7ff fc96 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8002aa8:	2800      	cmp	r0, #0
 8002aaa:	d1e8      	bne.n	8002a7e <HAL_I2C_Slave_Receive+0x4e>
 8002aac:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 8002ab0:	fa17 f482 	uxtah	r4, r7, r2
 8002ab4:	3f01      	subs	r7, #1
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
{  
  uint32_t tickstart = 0x00;
  tickstart = HAL_GetTick();
 8002ab6:	f7fe f827 	bl	8000b08 <HAL_GetTick>
 8002aba:	4680      	mov	r8, r0
 8002abc:	e009      	b.n	8002ad2 <HAL_I2C_Slave_Receive+0xa2>
  
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
  {
    /* Check if a STOPF is detected */
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 8002abe:	6991      	ldr	r1, [r2, #24]
 8002ac0:	0689      	lsls	r1, r1, #26
 8002ac2:	d437      	bmi.n	8002b34 <HAL_I2C_Slave_Receive+0x104>

      return HAL_ERROR;
    }
		
    /* Check for the Timeout */
    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8002ac4:	b30e      	cbz	r6, 8002b0a <HAL_I2C_Slave_Receive+0xda>
 8002ac6:	f7fe f81f 	bl	8000b08 <HAL_GetTick>
 8002aca:	ebc8 0000 	rsb	r0, r8, r0
 8002ace:	4286      	cmp	r6, r0
 8002ad0:	d31a      	bcc.n	8002b08 <HAL_I2C_Slave_Receive+0xd8>
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
{  
  uint32_t tickstart = 0x00;
  tickstart = HAL_GetTick();
  
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 8002ad2:	682a      	ldr	r2, [r5, #0]
 8002ad4:	6993      	ldr	r3, [r2, #24]
 8002ad6:	f013 0304 	ands.w	r3, r3, #4
 8002ada:	d0f0      	beq.n	8002abe <HAL_I2C_Slave_Receive+0x8e>
          return HAL_ERROR;
        }
      }
      
      /* Read data from RXDR */
      (*pData++) = hi2c->Instance->RXDR;
 8002adc:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8002ade:	f807 3f01 	strb.w	r3, [r7, #1]!
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
      return HAL_TIMEOUT;
    }

    while(Size > 0)
 8002ae2:	42a7      	cmp	r7, r4
 8002ae4:	d1e7      	bne.n	8002ab6 <HAL_I2C_Slave_Receive+0x86>
      (*pData++) = hi2c->Instance->RXDR;
      Size--;
    }
    
    /* Wait until STOP flag is set */
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8002ae6:	4628      	mov	r0, r5
 8002ae8:	2119      	movs	r1, #25
 8002aea:	f7ff fd45 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002aee:	682a      	ldr	r2, [r5, #0]
      (*pData++) = hi2c->Instance->RXDR;
      Size--;
    }
    
    /* Wait until STOP flag is set */
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8002af0:	2800      	cmp	r0, #0
 8002af2:	d02e      	beq.n	8002b52 <HAL_I2C_Slave_Receive+0x122>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002af4:	6853      	ldr	r3, [r2, #4]
 8002af6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002afa:	6053      	str	r3, [r2, #4]

      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8002afc:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8002afe:	2b04      	cmp	r3, #4
 8002b00:	d0c5      	beq.n	8002a8e <HAL_I2C_Slave_Receive+0x5e>
    /* Wait until BUSY flag is reset */ 
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
      return HAL_TIMEOUT;
 8002b02:	2003      	movs	r0, #3
 8002b04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002b08:	682a      	ldr	r2, [r5, #0]
    }
		
    /* Check for the Timeout */
    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002b0a:	6bab      	ldr	r3, [r5, #56]	; 0x38
      hi2c->State= HAL_I2C_STATE_READY;
 8002b0c:	2101      	movs	r1, #1
    }
		
    /* Check for the Timeout */
    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002b0e:	f043 0320 	orr.w	r3, r3, #32
      hi2c->State= HAL_I2C_STATE_READY;

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8002b12:	2000      	movs	r0, #0
    }
		
    /* Check for the Timeout */
    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002b14:	63ab      	str	r3, [r5, #56]	; 0x38
      hi2c->State= HAL_I2C_STATE_READY;

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8002b16:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
		
    /* Check for the Timeout */
    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
      hi2c->State= HAL_I2C_STATE_READY;
 8002b1a:	f885 1035 	strb.w	r1, [r5, #53]	; 0x35
    {
      /* Wait until RXNE flag is set */
      if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002b1e:	6853      	ldr	r3, [r2, #4]
 8002b20:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002b24:	6053      	str	r3, [r2, #4]
        if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
 8002b26:	6bab      	ldr	r3, [r5, #56]	; 0x38
        {
          return HAL_TIMEOUT;
        }
        else
        {
          return HAL_ERROR;
 8002b28:	2b20      	cmp	r3, #32
 8002b2a:	bf0c      	ite	eq
 8002b2c:	2003      	moveq	r0, #3
 8002b2e:	2001      	movne	r0, #1
 8002b30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  {
    /* Check if a STOPF is detected */
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002b34:	2120      	movs	r1, #32
 8002b36:	61d1      	str	r1, [r2, #28]

      /* Clear Configuration Register 2 */
      I2C_RESET_CR2(hi2c);
 8002b38:	6829      	ldr	r1, [r5, #0]
 8002b3a:	4a13      	ldr	r2, [pc, #76]	; (8002b88 <HAL_I2C_Slave_Receive+0x158>)
 8002b3c:	6848      	ldr	r0, [r1, #4]
 8002b3e:	4002      	ands	r2, r0
 8002b40:	604a      	str	r2, [r1, #4]

      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
      hi2c->State= HAL_I2C_STATE_READY;
 8002b42:	2101      	movs	r1, #1
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

      /* Clear Configuration Register 2 */
      I2C_RESET_CR2(hi2c);

      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002b44:	63ab      	str	r3, [r5, #56]	; 0x38
      hi2c->State= HAL_I2C_STATE_READY;

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8002b46:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
 8002b4a:	682a      	ldr	r2, [r5, #0]

      /* Clear Configuration Register 2 */
      I2C_RESET_CR2(hi2c);

      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
      hi2c->State= HAL_I2C_STATE_READY;
 8002b4c:	f885 1035 	strb.w	r1, [r5, #53]	; 0x35
 8002b50:	e7e5      	b.n	8002b1e <HAL_I2C_Slave_Receive+0xee>
        return HAL_TIMEOUT;
      }
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
 8002b52:	2120      	movs	r1, #32
 8002b54:	61d1      	str	r1, [r2, #28]
    
    /* Wait until BUSY flag is reset */ 
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
 8002b56:	4633      	mov	r3, r6
 8002b58:	2201      	movs	r2, #1
 8002b5a:	4628      	mov	r0, r5
 8002b5c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8002b60:	f7ff fc38 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002b64:	682a      	ldr	r2, [r5, #0]
 8002b66:	6853      	ldr	r3, [r2, #4]

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
    
    /* Wait until BUSY flag is reset */ 
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
 8002b68:	b118      	cbz	r0, 8002b72 <HAL_I2C_Slave_Receive+0x142>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002b6a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002b6e:	6053      	str	r3, [r2, #4]
 8002b70:	e7c7      	b.n	8002b02 <HAL_I2C_Slave_Receive+0xd2>

    
    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
    
    hi2c->State = HAL_I2C_STATE_READY;
 8002b72:	2101      	movs	r1, #1
      return HAL_TIMEOUT;
    }

    
    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002b74:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002b78:	6053      	str	r3, [r2, #4]
    
    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002b7a:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34

    
    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
    
    hi2c->State = HAL_I2C_STATE_READY;
 8002b7e:	f885 1035 	strb.w	r1, [r5, #53]	; 0x35

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    return HAL_OK;
 8002b82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002b86:	bf00      	nop
 8002b88:	fe00e800 	.word	0xfe00e800

08002b8c <HAL_I2C_Master_Transmit_IT>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{   
 8002b8c:	b4f0      	push	{r4, r5, r6, r7}
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002b8e:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 8002b92:	b2e4      	uxtb	r4, r4
 8002b94:	2c01      	cmp	r4, #1
 8002b96:	d002      	beq.n	8002b9e <HAL_I2C_Master_Transmit_IT+0x12>
        
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8002b98:	2002      	movs	r0, #2
  } 
}
 8002b9a:	bcf0      	pop	{r4, r5, r6, r7}
 8002b9c:	4770      	bx	lr
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{   
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8002b9e:	b372      	cbz	r2, 8002bfe <HAL_I2C_Master_Transmit_IT+0x72>
 8002ba0:	b36b      	cbz	r3, 8002bfe <HAL_I2C_Master_Transmit_IT+0x72>
    {
      return  HAL_ERROR;                                    
    }
    
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 8002ba2:	6806      	ldr	r6, [r0, #0]
 8002ba4:	69b5      	ldr	r5, [r6, #24]
 8002ba6:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
 8002baa:	d1f5      	bne.n	8002b98 <HAL_I2C_Master_Transmit_IT+0xc>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002bac:	f890 7034 	ldrb.w	r7, [r0, #52]	; 0x34
 8002bb0:	2f01      	cmp	r7, #1
 8002bb2:	d0f1      	beq.n	8002b98 <HAL_I2C_Master_Transmit_IT+0xc>
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
 8002bb4:	2712      	movs	r7, #18
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
 8002bb6:	2bff      	cmp	r3, #255	; 0xff
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
 8002bb8:	f880 7035 	strb.w	r7, [r0, #53]	; 0x35
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002bbc:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002bc0:	6385      	str	r5, [r0, #56]	; 0x38
    
    hi2c->pBuffPtr = pData;
 8002bc2:	6242      	str	r2, [r0, #36]	; 0x24
    hi2c->XferCount = Size;
 8002bc4:	8543      	strh	r3, [r0, #42]	; 0x2a
    if(Size > 255)
 8002bc6:	d91c      	bls.n	8002c02 <HAL_I2C_Master_Transmit_IT+0x76>
    {
      hi2c->XferSize = 255;
 8002bc8:	23ff      	movs	r3, #255	; 0xff
 8002bca:	8503      	strh	r3, [r0, #40]	; 0x28
      hi2c->XferSize = Size;
    }
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8002bcc:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8002bce:	b29b      	uxth	r3, r3
 8002bd0:	2bff      	cmp	r3, #255	; 0xff
 8002bd2:	d928      	bls.n	8002c26 <HAL_I2C_Master_Transmit_IT+0x9a>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002bd4:	6872      	ldr	r2, [r6, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002bd6:	4b15      	ldr	r3, [pc, #84]	; (8002c2c <HAL_I2C_Master_Transmit_IT+0xa0>)
 8002bd8:	4013      	ands	r3, r2
 8002bda:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002bde:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8002be2:	f443 3390 	orr.w	r3, r3, #73728	; 0x12000
 8002be6:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002be8:	6073      	str	r3, [r6, #4]


    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
 8002bea:	6802      	ldr	r2, [r0, #0]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
    }
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c); 
 8002bec:	2400      	movs	r4, #0
 8002bee:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34


    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
 8002bf2:	6813      	ldr	r3, [r2, #0]
 8002bf4:	f043 03f2 	orr.w	r3, r3, #242	; 0xf2
        
    return HAL_OK;
 8002bf8:	4620      	mov	r0, r4


    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
 8002bfa:	6013      	str	r3, [r2, #0]
        
    return HAL_OK;
 8002bfc:	e7cd      	b.n	8002b9a <HAL_I2C_Master_Transmit_IT+0xe>
{   
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 8002bfe:	4620      	mov	r0, r4
 8002c00:	e7cb      	b.n	8002b9a <HAL_I2C_Master_Transmit_IT+0xe>
    {
      hi2c->XferSize = 255;
    }
    else
    {
      hi2c->XferSize = Size;
 8002c02:	8503      	strh	r3, [r0, #40]	; 0x28
    }
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8002c04:	d0e2      	beq.n	8002bcc <HAL_I2C_Master_Transmit_IT+0x40>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002c06:	6874      	ldr	r4, [r6, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002c08:	4a08      	ldr	r2, [pc, #32]	; (8002c2c <HAL_I2C_Master_Transmit_IT+0xa0>)
 8002c0a:	4022      	ands	r2, r4
 8002c0c:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002c10:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8002c14:	041b      	lsls	r3, r3, #16
 8002c16:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002c1a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8002c1e:	430a      	orrs	r2, r1
 8002c20:	4313      	orrs	r3, r2
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002c22:	6073      	str	r3, [r6, #4]
 8002c24:	e7e1      	b.n	8002bea <HAL_I2C_Master_Transmit_IT+0x5e>
 8002c26:	23ff      	movs	r3, #255	; 0xff
 8002c28:	e7ed      	b.n	8002c06 <HAL_I2C_Master_Transmit_IT+0x7a>
 8002c2a:	bf00      	nop
 8002c2c:	fc009800 	.word	0xfc009800

08002c30 <HAL_I2C_Master_Receive_IT>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
 8002c30:	b4f0      	push	{r4, r5, r6, r7}
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002c32:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 8002c36:	b2e4      	uxtb	r4, r4
 8002c38:	2c01      	cmp	r4, #1
 8002c3a:	d002      	beq.n	8002c42 <HAL_I2C_Master_Receive_IT+0x12>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 8002c3c:	2002      	movs	r0, #2
  } 
}
 8002c3e:	bcf0      	pop	{r4, r5, r6, r7}
 8002c40:	4770      	bx	lr
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8002c42:	b372      	cbz	r2, 8002ca2 <HAL_I2C_Master_Receive_IT+0x72>
 8002c44:	b36b      	cbz	r3, 8002ca2 <HAL_I2C_Master_Receive_IT+0x72>
    {
      return  HAL_ERROR;                                    
    }
    
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 8002c46:	6806      	ldr	r6, [r0, #0]
 8002c48:	69b5      	ldr	r5, [r6, #24]
 8002c4a:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
 8002c4e:	d1f5      	bne.n	8002c3c <HAL_I2C_Master_Receive_IT+0xc>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002c50:	f890 7034 	ldrb.w	r7, [r0, #52]	; 0x34
 8002c54:	2f01      	cmp	r7, #1
 8002c56:	d0f1      	beq.n	8002c3c <HAL_I2C_Master_Receive_IT+0xc>
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
 8002c58:	2722      	movs	r7, #34	; 0x22
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
 8002c5a:	2bff      	cmp	r3, #255	; 0xff
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
 8002c5c:	f880 7035 	strb.w	r7, [r0, #53]	; 0x35
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002c60:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002c64:	6385      	str	r5, [r0, #56]	; 0x38
    
    hi2c->pBuffPtr = pData;
 8002c66:	6242      	str	r2, [r0, #36]	; 0x24
    hi2c->XferCount = Size;
 8002c68:	8543      	strh	r3, [r0, #42]	; 0x2a
    if(Size > 255)
 8002c6a:	d91c      	bls.n	8002ca6 <HAL_I2C_Master_Receive_IT+0x76>
    {
      hi2c->XferSize = 255;
 8002c6c:	23ff      	movs	r3, #255	; 0xff
 8002c6e:	8503      	strh	r3, [r0, #40]	; 0x28
      hi2c->XferSize = Size;
    }
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8002c70:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8002c72:	b29b      	uxth	r3, r3
 8002c74:	2bff      	cmp	r3, #255	; 0xff
 8002c76:	d928      	bls.n	8002cca <HAL_I2C_Master_Receive_IT+0x9a>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002c78:	6872      	ldr	r2, [r6, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002c7a:	4b15      	ldr	r3, [pc, #84]	; (8002cd0 <HAL_I2C_Master_Receive_IT+0xa0>)
 8002c7c:	4013      	ands	r3, r2
 8002c7e:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002c82:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8002c86:	f443 3392 	orr.w	r3, r3, #74752	; 0x12400
 8002c8a:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002c8c:	6073      	str	r3, [r6, #4]
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI );
 8002c8e:	6802      	ldr	r2, [r0, #0]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
    }
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c); 
 8002c90:	2400      	movs	r4, #0
 8002c92:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI );
 8002c96:	6813      	ldr	r3, [r2, #0]
 8002c98:	f043 03f4 	orr.w	r3, r3, #244	; 0xf4
    
    return HAL_OK;
 8002c9c:	4620      	mov	r0, r4
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI );
 8002c9e:	6013      	str	r3, [r2, #0]
    
    return HAL_OK;
 8002ca0:	e7cd      	b.n	8002c3e <HAL_I2C_Master_Receive_IT+0xe>
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 8002ca2:	4620      	mov	r0, r4
 8002ca4:	e7cb      	b.n	8002c3e <HAL_I2C_Master_Receive_IT+0xe>
    {
      hi2c->XferSize = 255;
    }
    else
    {
      hi2c->XferSize = Size;
 8002ca6:	8503      	strh	r3, [r0, #40]	; 0x28
    }
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8002ca8:	d0e2      	beq.n	8002c70 <HAL_I2C_Master_Receive_IT+0x40>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002caa:	6874      	ldr	r4, [r6, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002cac:	4a08      	ldr	r2, [pc, #32]	; (8002cd0 <HAL_I2C_Master_Receive_IT+0xa0>)
 8002cae:	4022      	ands	r2, r4
 8002cb0:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002cb4:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8002cb8:	041b      	lsls	r3, r3, #16
 8002cba:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400
 8002cbe:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8002cc2:	430a      	orrs	r2, r1
 8002cc4:	4313      	orrs	r3, r2
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002cc6:	6073      	str	r3, [r6, #4]
 8002cc8:	e7e1      	b.n	8002c8e <HAL_I2C_Master_Receive_IT+0x5e>
 8002cca:	23ff      	movs	r3, #255	; 0xff
 8002ccc:	e7ed      	b.n	8002caa <HAL_I2C_Master_Receive_IT+0x7a>
 8002cce:	bf00      	nop
 8002cd0:	fc009800 	.word	0xfc009800

08002cd4 <HAL_I2C_Slave_Transmit_IT>:
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002cd4:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8002cd8:	b2db      	uxtb	r3, r3
 8002cda:	2b01      	cmp	r3, #1
 8002cdc:	d001      	beq.n	8002ce2 <HAL_I2C_Slave_Transmit_IT+0xe>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 8002cde:	2002      	movs	r0, #2
  } 
}
 8002ce0:	4770      	bx	lr
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8002ce2:	b1f1      	cbz	r1, 8002d22 <HAL_I2C_Slave_Transmit_IT+0x4e>
 8002ce4:	b1ea      	cbz	r2, 8002d22 <HAL_I2C_Slave_Transmit_IT+0x4e>
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
 8002ce6:	b470      	push	{r4, r5, r6}
    {
      return  HAL_ERROR;                                    
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002ce8:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 8002cec:	2c01      	cmp	r4, #1
 8002cee:	d01a      	beq.n	8002d26 <HAL_I2C_Slave_Transmit_IT+0x52>
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
 8002cf0:	6805      	ldr	r5, [r0, #0]
    {
      return  HAL_ERROR;                                    
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002cf2:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002cf6:	2400      	movs	r4, #0
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
 8002cf8:	2632      	movs	r6, #50	; 0x32
 8002cfa:	f880 6035 	strb.w	r6, [r0, #53]	; 0x35
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002cfe:	6384      	str	r4, [r0, #56]	; 0x38
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
 8002d00:	686b      	ldr	r3, [r5, #4]
 8002d02:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8002d06:	606b      	str	r3, [r5, #4]
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_TXI );
 8002d08:	6803      	ldr	r3, [r0, #0]
    hi2c->pBuffPtr = pData;
    hi2c->XferSize = Size;
    hi2c->XferCount = Size;
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c); 
 8002d0a:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;

    hi2c->pBuffPtr = pData;
 8002d0e:	6241      	str	r1, [r0, #36]	; 0x24
    hi2c->XferSize = Size;
 8002d10:	8502      	strh	r2, [r0, #40]	; 0x28
    hi2c->XferCount = Size;
 8002d12:	8542      	strh	r2, [r0, #42]	; 0x2a
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_TXI );
 8002d14:	681a      	ldr	r2, [r3, #0]
 8002d16:	f042 02fa 	orr.w	r2, r2, #250	; 0xfa
    
    return HAL_OK;
 8002d1a:	4620      	mov	r0, r4
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_TXI );
 8002d1c:	601a      	str	r2, [r3, #0]
  }
  else
  {
    return HAL_BUSY; 
  } 
}
 8002d1e:	bc70      	pop	{r4, r5, r6}
 8002d20:	4770      	bx	lr
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 8002d22:	4618      	mov	r0, r3
 8002d24:	4770      	bx	lr
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 8002d26:	2002      	movs	r0, #2
 8002d28:	e7f9      	b.n	8002d1e <HAL_I2C_Slave_Transmit_IT+0x4a>
 8002d2a:	bf00      	nop

08002d2c <HAL_I2C_Slave_Receive_IT>:
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002d2c:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8002d30:	b2db      	uxtb	r3, r3
 8002d32:	2b01      	cmp	r3, #1
 8002d34:	d001      	beq.n	8002d3a <HAL_I2C_Slave_Receive_IT+0xe>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 8002d36:	2002      	movs	r0, #2
  }
}
 8002d38:	4770      	bx	lr
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8002d3a:	b1f1      	cbz	r1, 8002d7a <HAL_I2C_Slave_Receive_IT+0x4e>
 8002d3c:	b1ea      	cbz	r2, 8002d7a <HAL_I2C_Slave_Receive_IT+0x4e>
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
 8002d3e:	b470      	push	{r4, r5, r6}
    {
      return  HAL_ERROR;                                    
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002d40:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 8002d44:	2c01      	cmp	r4, #1
 8002d46:	d01a      	beq.n	8002d7e <HAL_I2C_Slave_Receive_IT+0x52>
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
 8002d48:	6805      	ldr	r5, [r0, #0]
    {
      return  HAL_ERROR;                                    
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002d4a:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002d4e:	2400      	movs	r4, #0
    }
    
    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
 8002d50:	2642      	movs	r6, #66	; 0x42
 8002d52:	f880 6035 	strb.w	r6, [r0, #53]	; 0x35
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002d56:	6384      	str	r4, [r0, #56]	; 0x38
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
 8002d58:	686b      	ldr	r3, [r5, #4]
 8002d5a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8002d5e:	606b      	str	r3, [r5, #4]
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI);
 8002d60:	6803      	ldr	r3, [r0, #0]
    hi2c->pBuffPtr = pData;
    hi2c->XferSize = Size;
    hi2c->XferCount = Size;
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c); 
 8002d62:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;

    hi2c->pBuffPtr = pData;
 8002d66:	6241      	str	r1, [r0, #36]	; 0x24
    hi2c->XferSize = Size;
 8002d68:	8502      	strh	r2, [r0, #40]	; 0x28
    hi2c->XferCount = Size;
 8002d6a:	8542      	strh	r2, [r0, #42]	; 0x2a
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI);
 8002d6c:	681a      	ldr	r2, [r3, #0]
 8002d6e:	f042 02fc 	orr.w	r2, r2, #252	; 0xfc
    
    return HAL_OK;
 8002d72:	4620      	mov	r0, r4
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI);
 8002d74:	601a      	str	r2, [r3, #0]
  }
  else
  {
    return HAL_BUSY; 
  }
}
 8002d76:	bc70      	pop	{r4, r5, r6}
 8002d78:	4770      	bx	lr
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 8002d7a:	4618      	mov	r0, r3
 8002d7c:	4770      	bx	lr
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 8002d7e:	2002      	movs	r0, #2
 8002d80:	e7f9      	b.n	8002d76 <HAL_I2C_Slave_Receive_IT+0x4a>
 8002d82:	bf00      	nop

08002d84 <HAL_I2C_Master_Transmit_DMA>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
 8002d84:	b570      	push	{r4, r5, r6, lr}
 8002d86:	4604      	mov	r4, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002d88:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
 8002d8c:	b2c0      	uxtb	r0, r0
 8002d8e:	2801      	cmp	r0, #1
 8002d90:	d001      	beq.n	8002d96 <HAL_I2C_Master_Transmit_DMA+0x12>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8002d92:	2002      	movs	r0, #2
  }
}
 8002d94:	bd70      	pop	{r4, r5, r6, pc}
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8002d96:	2a00      	cmp	r2, #0
 8002d98:	d047      	beq.n	8002e2a <HAL_I2C_Master_Transmit_DMA+0xa6>
 8002d9a:	2b00      	cmp	r3, #0
 8002d9c:	d045      	beq.n	8002e2a <HAL_I2C_Master_Transmit_DMA+0xa6>
 8002d9e:	460d      	mov	r5, r1
    {
      return  HAL_ERROR;                                    
    }     

    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 8002da0:	6821      	ldr	r1, [r4, #0]
 8002da2:	6989      	ldr	r1, [r1, #24]
 8002da4:	f411 4100 	ands.w	r1, r1, #32768	; 0x8000
 8002da8:	d1f3      	bne.n	8002d92 <HAL_I2C_Master_Transmit_DMA+0xe>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002daa:	f894 6034 	ldrb.w	r6, [r4, #52]	; 0x34
 8002dae:	2e01      	cmp	r6, #1
 8002db0:	d0ef      	beq.n	8002d92 <HAL_I2C_Master_Transmit_DMA+0xe>
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
 8002db2:	2bff      	cmp	r3, #255	; 0xff
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
 8002db4:	f04f 0612 	mov.w	r6, #18
 8002db8:	f884 6035 	strb.w	r6, [r4, #53]	; 0x35
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002dbc:	63a1      	str	r1, [r4, #56]	; 0x38
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
 8002dbe:	8563      	strh	r3, [r4, #42]	; 0x2a
    if(Size > 255)
    {
      hi2c->XferSize = 255;
 8002dc0:	bf88      	it	hi
 8002dc2:	23ff      	movhi	r3, #255	; 0xff
    }
    else
    {
      hi2c->XferSize = Size;
 8002dc4:	8523      	strh	r3, [r4, #40]	; 0x28
    }
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
 8002dc6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002dc8:	4925      	ldr	r1, [pc, #148]	; (8002e60 <HAL_I2C_Master_Transmit_DMA+0xdc>)
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002dca:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
 8002dce:	6262      	str	r2, [r4, #36]	; 0x24
    {
      hi2c->XferSize = Size;
    }
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
 8002dd0:	62d9      	str	r1, [r3, #44]	; 0x2c
    
    /* Set the DMA error callback */
    hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
 8002dd2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002dd4:	4923      	ldr	r1, [pc, #140]	; (8002e64 <HAL_I2C_Master_Transmit_DMA+0xe0>)
 8002dd6:	6359      	str	r1, [r3, #52]	; 0x34
    
    /* Enable the DMA channel */
    HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 8002dd8:	6826      	ldr	r6, [r4, #0]
 8002dda:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8002ddc:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8002dde:	4611      	mov	r1, r2
 8002de0:	f106 0228 	add.w	r2, r6, #40	; 0x28
 8002de4:	f7fe fba0 	bl	8001528 <HAL_DMA_Start_IT>
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8002de8:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8002dea:	2aff      	cmp	r2, #255	; 0xff
 8002dec:	d026      	beq.n	8002e3c <HAL_I2C_Master_Transmit_DMA+0xb8>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002dee:	6821      	ldr	r1, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002df0:	4b1d      	ldr	r3, [pc, #116]	; (8002e68 <HAL_I2C_Master_Transmit_DMA+0xe4>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002df2:	6848      	ldr	r0, [r1, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002df4:	4003      	ands	r3, r0
 8002df6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002dfa:	f3c5 0509 	ubfx	r5, r5, #0, #10
 8002dfe:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002e02:	b2d2      	uxtb	r2, r2
 8002e04:	432b      	orrs	r3, r5
 8002e06:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002e0a:	604b      	str	r3, [r1, #4]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
    }  

    /* Wait until TXIS flag is set */
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
 8002e0c:	4620      	mov	r0, r4
 8002e0e:	2119      	movs	r1, #25
 8002e10:	f7ff fb1c 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002e14:	6822      	ldr	r2, [r4, #0]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
    }  

    /* Wait until TXIS flag is set */
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
 8002e16:	b150      	cbz	r0, 8002e2e <HAL_I2C_Master_Transmit_DMA+0xaa>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002e18:	6853      	ldr	r3, [r2, #4]
 8002e1a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002e1e:	6053      	str	r3, [r2, #4]

      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8002e20:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002e22:	2b04      	cmp	r3, #4
 8002e24:	d001      	beq.n	8002e2a <HAL_I2C_Master_Transmit_DMA+0xa6>
      {
        return HAL_ERROR;
      }
      else
      {
        return HAL_TIMEOUT;
 8002e26:	2003      	movs	r0, #3
 8002e28:	bd70      	pop	{r4, r5, r6, pc}
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 8002e2a:	2001      	movs	r0, #1
 8002e2c:	bd70      	pop	{r4, r5, r6, pc}
      }
    }

    
    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;   
 8002e2e:	6813      	ldr	r3, [r2, #0]
 8002e30:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002e34:	6013      	str	r3, [r2, #0]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002e36:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    
    return HAL_OK;
 8002e3a:	bd70      	pop	{r4, r5, r6, pc}
    /* Enable the DMA channel */
    HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8002e3c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8002e3e:	b29b      	uxth	r3, r3
 8002e40:	2bff      	cmp	r3, #255	; 0xff
 8002e42:	d9d4      	bls.n	8002dee <HAL_I2C_Master_Transmit_DMA+0x6a>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002e44:	6822      	ldr	r2, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002e46:	4b08      	ldr	r3, [pc, #32]	; (8002e68 <HAL_I2C_Master_Transmit_DMA+0xe4>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002e48:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002e4a:	400b      	ands	r3, r1
 8002e4c:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002e50:	f3c5 0509 	ubfx	r5, r5, #0, #10
 8002e54:	f443 3390 	orr.w	r3, r3, #73728	; 0x12000
 8002e58:	432b      	orrs	r3, r5
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002e5a:	6053      	str	r3, [r2, #4]
 8002e5c:	e7d6      	b.n	8002e0c <HAL_I2C_Master_Transmit_DMA+0x88>
 8002e5e:	bf00      	nop
 8002e60:	0800389d 	.word	0x0800389d
 8002e64:	08003875 	.word	0x08003875
 8002e68:	fc009800 	.word	0xfc009800

08002e6c <HAL_I2C_Master_Receive_DMA>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
 8002e6c:	b570      	push	{r4, r5, r6, lr}
 8002e6e:	4604      	mov	r4, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002e70:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
 8002e74:	b2c0      	uxtb	r0, r0
 8002e76:	2801      	cmp	r0, #1
 8002e78:	d001      	beq.n	8002e7e <HAL_I2C_Master_Receive_DMA+0x12>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8002e7a:	2002      	movs	r0, #2
 8002e7c:	bd70      	pop	{r4, r5, r6, pc}
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8002e7e:	2a00      	cmp	r2, #0
 8002e80:	d03e      	beq.n	8002f00 <HAL_I2C_Master_Receive_DMA+0x94>
 8002e82:	2b00      	cmp	r3, #0
 8002e84:	d03c      	beq.n	8002f00 <HAL_I2C_Master_Receive_DMA+0x94>
 8002e86:	460d      	mov	r5, r1
    {
      return  HAL_ERROR;                                    
    }  

    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 8002e88:	6821      	ldr	r1, [r4, #0]
 8002e8a:	6989      	ldr	r1, [r1, #24]
 8002e8c:	f411 4100 	ands.w	r1, r1, #32768	; 0x8000
 8002e90:	d1f3      	bne.n	8002e7a <HAL_I2C_Master_Receive_DMA+0xe>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002e92:	f894 6034 	ldrb.w	r6, [r4, #52]	; 0x34
 8002e96:	2e01      	cmp	r6, #1
 8002e98:	d0ef      	beq.n	8002e7a <HAL_I2C_Master_Receive_DMA+0xe>
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
 8002e9a:	2bff      	cmp	r3, #255	; 0xff
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
 8002e9c:	f04f 0622 	mov.w	r6, #34	; 0x22
 8002ea0:	f884 6035 	strb.w	r6, [r4, #53]	; 0x35
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002ea4:	63a1      	str	r1, [r4, #56]	; 0x38
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
 8002ea6:	8563      	strh	r3, [r4, #42]	; 0x2a
    if(Size > 255)
    {
      hi2c->XferSize = 255;
 8002ea8:	bf88      	it	hi
 8002eaa:	23ff      	movhi	r3, #255	; 0xff
    }
    else
    {
      hi2c->XferSize = Size;
 8002eac:	8523      	strh	r3, [r4, #40]	; 0x28
    }
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
 8002eae:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002eb0:	4920      	ldr	r1, [pc, #128]	; (8002f34 <HAL_I2C_Master_Receive_DMA+0xc8>)
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002eb2:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
 8002eb6:	6262      	str	r2, [r4, #36]	; 0x24
    {
      hi2c->XferSize = Size;
    }
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
 8002eb8:	62d9      	str	r1, [r3, #44]	; 0x2c
    
    /* Set the DMA error callback */
    hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
 8002eba:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002ebc:	491e      	ldr	r1, [pc, #120]	; (8002f38 <HAL_I2C_Master_Receive_DMA+0xcc>)
 8002ebe:	6359      	str	r1, [r3, #52]	; 0x34
    
    /* Enable the DMA channel */
    HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
 8002ec0:	6821      	ldr	r1, [r4, #0]
 8002ec2:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8002ec4:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8002ec6:	3124      	adds	r1, #36	; 0x24
 8002ec8:	f7fe fb2e 	bl	8001528 <HAL_DMA_Start_IT>
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8002ecc:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8002ece:	2aff      	cmp	r2, #255	; 0xff
 8002ed0:	d01f      	beq.n	8002f12 <HAL_I2C_Master_Receive_DMA+0xa6>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002ed2:	6821      	ldr	r1, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002ed4:	4b19      	ldr	r3, [pc, #100]	; (8002f3c <HAL_I2C_Master_Receive_DMA+0xd0>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002ed6:	6848      	ldr	r0, [r1, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002ed8:	4003      	ands	r3, r0
 8002eda:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002ede:	f3c5 0509 	ubfx	r5, r5, #0, #10
 8002ee2:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8002ee6:	b2d2      	uxtb	r2, r2
 8002ee8:	432b      	orrs	r3, r5
 8002eea:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002eee:	604b      	str	r3, [r1, #4]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
    }

    /* Wait until RXNE flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
 8002ef0:	4620      	mov	r0, r4
 8002ef2:	2104      	movs	r1, #4
 8002ef4:	2200      	movs	r2, #0
 8002ef6:	2319      	movs	r3, #25
 8002ef8:	f7ff fa6c 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8002efc:	b108      	cbz	r0, 8002f02 <HAL_I2C_Master_Receive_DMA+0x96>
    {
      return HAL_TIMEOUT;
 8002efe:	2003      	movs	r0, #3
  }
  else
  {
    return HAL_BUSY;
  }
}
 8002f00:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_TIMEOUT;
    }

    
    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;   
 8002f02:	6822      	ldr	r2, [r4, #0]
 8002f04:	6813      	ldr	r3, [r2, #0]
 8002f06:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002f0a:	6013      	str	r3, [r2, #0]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002f0c:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    
    return HAL_OK;
 8002f10:	bd70      	pop	{r4, r5, r6, pc}
    /* Enable the DMA channel */
    HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8002f12:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8002f14:	b29b      	uxth	r3, r3
 8002f16:	2bff      	cmp	r3, #255	; 0xff
 8002f18:	d9db      	bls.n	8002ed2 <HAL_I2C_Master_Receive_DMA+0x66>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002f1a:	6822      	ldr	r2, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002f1c:	4b07      	ldr	r3, [pc, #28]	; (8002f3c <HAL_I2C_Master_Receive_DMA+0xd0>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8002f1e:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8002f20:	400b      	ands	r3, r1
 8002f22:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8002f26:	f3c5 0509 	ubfx	r5, r5, #0, #10
 8002f2a:	f443 3392 	orr.w	r3, r3, #74752	; 0x12400
 8002f2e:	432b      	orrs	r3, r5
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8002f30:	6053      	str	r3, [r2, #4]
 8002f32:	e7dd      	b.n	8002ef0 <HAL_I2C_Master_Receive_DMA+0x84>
 8002f34:	080039f9 	.word	0x080039f9
 8002f38:	08003875 	.word	0x08003875
 8002f3c:	fc009800 	.word	0xfc009800

08002f40 <HAL_I2C_Slave_Transmit_DMA>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
 8002f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002f42:	4604      	mov	r4, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 8002f44:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
 8002f48:	b2c0      	uxtb	r0, r0
 8002f4a:	2801      	cmp	r0, #1
 8002f4c:	d001      	beq.n	8002f52 <HAL_I2C_Slave_Transmit_DMA+0x12>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8002f4e:	2002      	movs	r0, #2
  }
}
 8002f50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8002f52:	2900      	cmp	r1, #0
 8002f54:	d0fc      	beq.n	8002f50 <HAL_I2C_Slave_Transmit_DMA+0x10>
 8002f56:	2a00      	cmp	r2, #0
 8002f58:	d0fa      	beq.n	8002f50 <HAL_I2C_Slave_Transmit_DMA+0x10>
    {
      return  HAL_ERROR;                                    
    }   
    /* Process Locked */
    __HAL_LOCK(hi2c); 
 8002f5a:	f894 5034 	ldrb.w	r5, [r4, #52]	; 0x34
 8002f5e:	2d01      	cmp	r5, #1
 8002f60:	d0f5      	beq.n	8002f4e <HAL_I2C_Slave_Transmit_DMA+0xe>
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    hi2c->XferSize = Size;
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
 8002f62:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
    }   
    /* Process Locked */
    __HAL_LOCK(hi2c); 
 8002f64:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002f68:	2500      	movs	r5, #0
      return  HAL_ERROR;                                    
    }   
    /* Process Locked */
    __HAL_LOCK(hi2c); 
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
 8002f6a:	2032      	movs	r0, #50	; 0x32
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    hi2c->XferSize = Size;
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
 8002f6c:	4f26      	ldr	r7, [pc, #152]	; (8003008 <HAL_I2C_Slave_Transmit_DMA+0xc8>)
      return  HAL_ERROR;                                    
    }   
    /* Process Locked */
    __HAL_LOCK(hi2c); 
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
 8002f6e:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    hi2c->XferSize = Size;
 8002f72:	8522      	strh	r2, [r4, #40]	; 0x28
    __HAL_LOCK(hi2c); 
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
 8002f74:	6261      	str	r1, [r4, #36]	; 0x24
    }   
    /* Process Locked */
    __HAL_LOCK(hi2c); 
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8002f76:	63a5      	str	r5, [r4, #56]	; 0x38
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
 8002f78:	8562      	strh	r2, [r4, #42]	; 0x2a
    hi2c->XferSize = Size;
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
 8002f7a:	62f7      	str	r7, [r6, #44]	; 0x2c
    
    /* Set the DMA error callback */
    hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
 8002f7c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002f7e:	4a23      	ldr	r2, [pc, #140]	; (800300c <HAL_I2C_Slave_Transmit_DMA+0xcc>)
 8002f80:	635a      	str	r2, [r3, #52]	; 0x34
    
    /* Enable the DMA channel */
    HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 8002f82:	6822      	ldr	r2, [r4, #0]
 8002f84:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8002f86:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8002f88:	3228      	adds	r2, #40	; 0x28
 8002f8a:	f7fe facd 	bl	8001528 <HAL_DMA_Start_IT>
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
 8002f8e:	6821      	ldr	r1, [r4, #0]
 8002f90:	684b      	ldr	r3, [r1, #4]
 8002f92:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8002f96:	604b      	str	r3, [r1, #4]

    /* Wait until ADDR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
 8002f98:	462a      	mov	r2, r5
 8002f9a:	4620      	mov	r0, r4
 8002f9c:	2108      	movs	r1, #8
 8002f9e:	f242 7310 	movw	r3, #10000	; 0x2710
 8002fa2:	f7ff fa17 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8002fa6:	b130      	cbz	r0, 8002fb6 <HAL_I2C_Slave_Transmit_DMA+0x76>
    {
      /* Wait until ADDR flag is set */
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002fa8:	6822      	ldr	r2, [r4, #0]
 8002faa:	6853      	ldr	r3, [r2, #4]
 8002fac:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002fb0:	6053      	str	r3, [r2, #4]
        return HAL_TIMEOUT;
 8002fb2:	2003      	movs	r0, #3
 8002fb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
      return HAL_TIMEOUT;
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
 8002fb6:	6823      	ldr	r3, [r4, #0]
 8002fb8:	2508      	movs	r5, #8
 8002fba:	61dd      	str	r5, [r3, #28]
    
    /* If 10bits addressing mode is selected */
    if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8002fbc:	68e3      	ldr	r3, [r4, #12]
 8002fbe:	2b02      	cmp	r3, #2
 8002fc0:	d00e      	beq.n	8002fe0 <HAL_I2C_Slave_Transmit_DMA+0xa0>
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
    }
    
    /* Wait until DIR flag is set Transmitter mode */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, I2C_TIMEOUT_BUSY) != HAL_OK)      
 8002fc2:	2200      	movs	r2, #0
 8002fc4:	4620      	mov	r0, r4
 8002fc6:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8002fca:	2319      	movs	r3, #25
 8002fcc:	f7ff fa02 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002fd0:	6822      	ldr	r2, [r4, #0]
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
    }
    
    /* Wait until DIR flag is set Transmitter mode */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, I2C_TIMEOUT_BUSY) != HAL_OK)      
 8002fd2:	b188      	cbz	r0, 8002ff8 <HAL_I2C_Slave_Transmit_DMA+0xb8>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8002fd4:	6853      	ldr	r3, [r2, #4]
 8002fd6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002fda:	6053      	str	r3, [r2, #4]
      return HAL_TIMEOUT;
 8002fdc:	2003      	movs	r0, #3
 8002fde:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    
    /* If 10bits addressing mode is selected */
    if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    {
      /* Wait until ADDR flag is set */
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
 8002fe0:	4602      	mov	r2, r0
 8002fe2:	4629      	mov	r1, r5
 8002fe4:	4620      	mov	r0, r4
 8002fe6:	f242 7310 	movw	r3, #10000	; 0x2710
 8002fea:	f7ff f9f3 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8002fee:	2800      	cmp	r0, #0
 8002ff0:	d1da      	bne.n	8002fa8 <HAL_I2C_Slave_Transmit_DMA+0x68>
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
        return HAL_TIMEOUT;
      }

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
 8002ff2:	6823      	ldr	r3, [r4, #0]
 8002ff4:	61dd      	str	r5, [r3, #28]
 8002ff6:	e7e4      	b.n	8002fc2 <HAL_I2C_Slave_Transmit_DMA+0x82>
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
      return HAL_TIMEOUT;
    }
      
    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN; 
 8002ff8:	6813      	ldr	r3, [r2, #0]
 8002ffa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002ffe:	6013      	str	r3, [r2, #0]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8003000:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    
    return HAL_OK;
 8003004:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003006:	bf00      	nop
 8003008:	08003b65 	.word	0x08003b65
 800300c:	08003875 	.word	0x08003875

08003010 <HAL_I2C_Slave_Receive_DMA>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
 8003010:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(hi2c->State == HAL_I2C_STATE_READY)
 8003012:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 8003016:	b2e4      	uxtb	r4, r4
 8003018:	2c01      	cmp	r4, #1
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
 800301a:	4605      	mov	r5, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 800301c:	d001      	beq.n	8003022 <HAL_I2C_Slave_Receive_DMA+0x12>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 800301e:	2002      	movs	r0, #2
  }
}
 8003020:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8003022:	2900      	cmp	r1, #0
 8003024:	d031      	beq.n	800308a <HAL_I2C_Slave_Receive_DMA+0x7a>
 8003026:	4613      	mov	r3, r2
 8003028:	2a00      	cmp	r2, #0
 800302a:	d02e      	beq.n	800308a <HAL_I2C_Slave_Receive_DMA+0x7a>
    {
      return  HAL_ERROR;                                    
    }   
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800302c:	f890 2034 	ldrb.w	r2, [r0, #52]	; 0x34
 8003030:	2a01      	cmp	r2, #1
 8003032:	d0f4      	beq.n	800301e <HAL_I2C_Slave_Receive_DMA+0xe>
    hi2c->pBuffPtr = pData;
    hi2c->XferSize = Size;
    hi2c->XferCount = Size;
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
 8003034:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8003036:	4822      	ldr	r0, [pc, #136]	; (80030c0 <HAL_I2C_Slave_Receive_DMA+0xb0>)
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
 8003038:	6269      	str	r1, [r5, #36]	; 0x24
      return  HAL_ERROR;                                    
    }   
    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
 800303a:	2642      	movs	r6, #66	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 800303c:	2700      	movs	r7, #0
      return  HAL_ERROR;                                    
    }   
    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
 800303e:	f885 6035 	strb.w	r6, [r5, #53]	; 0x35
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferSize = Size;
 8003042:	852b      	strh	r3, [r5, #40]	; 0x28
    }   
    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8003044:	63af      	str	r7, [r5, #56]	; 0x38
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
    }   
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003046:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
    hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferSize = Size;
    hi2c->XferCount = Size;
 800304a:	856b      	strh	r3, [r5, #42]	; 0x2a
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
 800304c:	62d0      	str	r0, [r2, #44]	; 0x2c
    
    /* Set the DMA error callback */
    hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
 800304e:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8003050:	481c      	ldr	r0, [pc, #112]	; (80030c4 <HAL_I2C_Slave_Receive_DMA+0xb4>)
 8003052:	6350      	str	r0, [r2, #52]	; 0x34
    
    /* Enable the DMA channel */
    HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, Size);
 8003054:	682e      	ldr	r6, [r5, #0]
 8003056:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8003058:	460a      	mov	r2, r1
 800305a:	f106 0124 	add.w	r1, r6, #36	; 0x24
 800305e:	f7fe fa63 	bl	8001528 <HAL_DMA_Start_IT>
    
    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
 8003062:	6829      	ldr	r1, [r5, #0]
 8003064:	684b      	ldr	r3, [r1, #4]
 8003066:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800306a:	604b      	str	r3, [r1, #4]

    /* Wait until ADDR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
 800306c:	463a      	mov	r2, r7
 800306e:	4628      	mov	r0, r5
 8003070:	2108      	movs	r1, #8
 8003072:	f242 7310 	movw	r3, #10000	; 0x2710
 8003076:	f7ff f9ad 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 800307a:	b140      	cbz	r0, 800308e <HAL_I2C_Slave_Receive_DMA+0x7e>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 800307c:	682a      	ldr	r2, [r5, #0]
 800307e:	6853      	ldr	r3, [r2, #4]
 8003080:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003084:	6053      	str	r3, [r2, #4]
      return HAL_TIMEOUT;
 8003086:	2003      	movs	r0, #3
 8003088:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 800308a:	4620      	mov	r0, r4
 800308c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
      return HAL_TIMEOUT;
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
 800308e:	682b      	ldr	r3, [r5, #0]
 8003090:	2108      	movs	r1, #8
 8003092:	61d9      	str	r1, [r3, #28]
    
    /* Wait until DIR flag is set Receiver mode */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, I2C_TIMEOUT_DIR) != HAL_OK)      
 8003094:	4622      	mov	r2, r4
 8003096:	4628      	mov	r0, r5
 8003098:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800309c:	2319      	movs	r3, #25
 800309e:	f7ff f999 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 80030a2:	682a      	ldr	r2, [r5, #0]

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
    
    /* Wait until DIR flag is set Receiver mode */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, I2C_TIMEOUT_DIR) != HAL_OK)      
 80030a4:	b128      	cbz	r0, 80030b2 <HAL_I2C_Slave_Receive_DMA+0xa2>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
 80030a6:	6853      	ldr	r3, [r2, #4]
 80030a8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80030ac:	6053      	str	r3, [r2, #4]
      return HAL_TIMEOUT;
 80030ae:	2003      	movs	r0, #3
 80030b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
 
    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;  
 80030b2:	6813      	ldr	r3, [r2, #0]
 80030b4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80030b8:	6013      	str	r3, [r2, #0]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80030ba:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
    
    return HAL_OK;
 80030be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80030c0:	08003bc9 	.word	0x08003bc9
 80030c4:	08003875 	.word	0x08003875

080030c8 <HAL_I2C_Mem_Write>:
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80030c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t Sizetmp = 0;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 80030cc:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80030d0:	b083      	sub	sp, #12
  uint32_t Sizetmp = 0;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 80030d2:	b2e4      	uxtb	r4, r4
 80030d4:	2c01      	cmp	r4, #1
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80030d6:	4605      	mov	r5, r0
 80030d8:	f8bd 602c 	ldrh.w	r6, [sp, #44]	; 0x2c
  uint32_t Sizetmp = 0;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 80030dc:	d003      	beq.n	80030e6 <HAL_I2C_Mem_Write+0x1e>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 80030de:	2002      	movs	r0, #2
  }
}
 80030e0:	b003      	add	sp, #12
 80030e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
  { 
    if((pData == NULL) || (Size == 0)) 
 80030e6:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80030e8:	b30f      	cbz	r7, 800312e <HAL_I2C_Mem_Write+0x66>
 80030ea:	b306      	cbz	r6, 800312e <HAL_I2C_Mem_Write+0x66>
    {
      return  HAL_ERROR;                                    
    }

    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 80030ec:	6807      	ldr	r7, [r0, #0]
 80030ee:	69bf      	ldr	r7, [r7, #24]
 80030f0:	f417 4800 	ands.w	r8, r7, #32768	; 0x8000
 80030f4:	d1f3      	bne.n	80030de <HAL_I2C_Mem_Write+0x16>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80030f6:	f890 7034 	ldrb.w	r7, [r0, #52]	; 0x34
 80030fa:	2f01      	cmp	r7, #1
 80030fc:	d0ef      	beq.n	80030de <HAL_I2C_Mem_Write+0x16>
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
 80030fe:	f04f 0e52 	mov.w	lr, #82	; 0x52
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
 8003102:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003104:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
 8003108:	9700      	str	r7, [sp, #0]
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
 800310a:	f880 e035 	strb.w	lr, [r0, #53]	; 0x35
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800310e:	f8c0 8038 	str.w	r8, [r0, #56]	; 0x38
 8003112:	4689      	mov	r9, r1
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
 8003114:	f7ff f9c2 	bl	800249c <I2C_RequestMemoryWrite>
 8003118:	b158      	cbz	r0, 8003132 <HAL_I2C_Mem_Write+0x6a>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800311a:	6bab      	ldr	r3, [r5, #56]	; 0x38
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800311c:	f885 8034 	strb.w	r8, [r5, #52]	; 0x34
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003120:	2b04      	cmp	r3, #4
 8003122:	d004      	beq.n	800312e <HAL_I2C_Mem_Write+0x66>
      if((Sizetmp == 0)&&(Size!=0))
      {
        /* Wait until TCR flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
        {
          return HAL_TIMEOUT;
 8003124:	2003      	movs	r0, #3
 8003126:	e7db      	b.n	80030e0 <HAL_I2C_Mem_Write+0x18>
    
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003128:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800312a:	2b04      	cmp	r3, #4
 800312c:	d1fa      	bne.n	8003124 <HAL_I2C_Mem_Write+0x5c>
  
  if(hi2c->State == HAL_I2C_STATE_READY)
  { 
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 800312e:	2001      	movs	r0, #1
 8003130:	e7d6      	b.n	80030e0 <HAL_I2C_Mem_Write+0x18>
      }
    }

    /* Set NBYTES to write and reload if size > 255 */
    /* Size > 255, need to set RELOAD bit */
    if(Size > 255)
 8003132:	2eff      	cmp	r6, #255	; 0xff
 8003134:	d95e      	bls.n	80031f4 <HAL_I2C_Mem_Write+0x12c>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003136:	682a      	ldr	r2, [r5, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003138:	4b37      	ldr	r3, [pc, #220]	; (8003218 <HAL_I2C_Mem_Write+0x150>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 800313a:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800313c:	400b      	ands	r3, r1
 800313e:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003142:	f3c9 0e09 	ubfx	lr, r9, #0, #10
 8003146:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800314a:	ea43 030e 	orr.w	r3, r3, lr
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 800314e:	6053      	str	r3, [r2, #4]
    /* Set NBYTES to write and reload if size > 255 */
    /* Size > 255, need to set RELOAD bit */
    if(Size > 255)
    {
      I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
      Sizetmp = 255;
 8003150:	f04f 08ff 	mov.w	r8, #255	; 0xff
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003154:	fa1f f48e 	uxth.w	r4, lr
    }
    
    do
    {
      /* Wait until TXIS flag is set */
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 8003158:	4628      	mov	r0, r5
 800315a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800315c:	f7ff f976 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
      }
     
      /* Write data to DR */
      hi2c->Instance->TXDR = (*pData++);
      Sizetmp--;
      Size--;
 8003160:	3e01      	subs	r6, #1
 8003162:	b2b6      	uxth	r6, r6
    }
    
    do
    {
      /* Wait until TXIS flag is set */
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
 8003164:	2800      	cmp	r0, #0
 8003166:	d1df      	bne.n	8003128 <HAL_I2C_Mem_Write+0x60>
          return HAL_TIMEOUT;
        }
      }
     
      /* Write data to DR */
      hi2c->Instance->TXDR = (*pData++);
 8003168:	990a      	ldr	r1, [sp, #40]	; 0x28
 800316a:	682b      	ldr	r3, [r5, #0]
 800316c:	f811 2b01 	ldrb.w	r2, [r1], #1
 8003170:	910a      	str	r1, [sp, #40]	; 0x28
      Sizetmp--;
      Size--;

      if((Sizetmp == 0)&&(Size!=0))
 8003172:	f1b8 0801 	subs.w	r8, r8, #1
          return HAL_TIMEOUT;
        }
      }
     
      /* Write data to DR */
      hi2c->Instance->TXDR = (*pData++);
 8003176:	629a      	str	r2, [r3, #40]	; 0x28
      Sizetmp--;
      Size--;

      if((Sizetmp == 0)&&(Size!=0))
 8003178:	d114      	bne.n	80031a4 <HAL_I2C_Mem_Write+0xdc>
 800317a:	b9b6      	cbnz	r6, 80031aa <HAL_I2C_Mem_Write+0xe2>
      
    }while(Size > 0);
    
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 800317c:	4628      	mov	r0, r5
 800317e:	2119      	movs	r1, #25
 8003180:	f7ff f9fa 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003184:	2800      	cmp	r0, #0
 8003186:	d1cf      	bne.n	8003128 <HAL_I2C_Mem_Write+0x60>
        return HAL_TIMEOUT;
      }
    }
    
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003188:	682a      	ldr	r2, [r5, #0]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800318a:	4b24      	ldr	r3, [pc, #144]	; (800321c <HAL_I2C_Mem_Write+0x154>)
        return HAL_TIMEOUT;
      }
    }
    
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800318c:	2120      	movs	r1, #32
 800318e:	61d1      	str	r1, [r2, #28]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003190:	682a      	ldr	r2, [r5, #0]
 8003192:	6854      	ldr	r4, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY; 	  
 8003194:	2101      	movs	r1, #1
    
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003196:	4023      	ands	r3, r4
 8003198:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY; 	  
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800319a:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY; 	  
 800319e:	f885 1035 	strb.w	r1, [r5, #53]	; 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    return HAL_OK;
 80031a2:	e79d      	b.n	80030e0 <HAL_I2C_Mem_Write+0x18>
          I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
          Sizetmp = Size;
        }
      }
      
    }while(Size > 0);
 80031a4:	2e00      	cmp	r6, #0
 80031a6:	d1d7      	bne.n	8003158 <HAL_I2C_Mem_Write+0x90>
 80031a8:	e7e8      	b.n	800317c <HAL_I2C_Mem_Write+0xb4>
      Size--;

      if((Sizetmp == 0)&&(Size!=0))
      {
        /* Wait until TCR flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
 80031aa:	4642      	mov	r2, r8
 80031ac:	2180      	movs	r1, #128	; 0x80
 80031ae:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80031b0:	4628      	mov	r0, r5
 80031b2:	f7ff f90f 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80031b6:	4a18      	ldr	r2, [pc, #96]	; (8003218 <HAL_I2C_Mem_Write+0x150>)
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80031b8:	0433      	lsls	r3, r6, #16
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80031ba:	4611      	mov	r1, r2
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80031bc:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
      Size--;

      if((Sizetmp == 0)&&(Size!=0))
      {
        /* Wait until TCR flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
 80031c0:	2800      	cmp	r0, #0
 80031c2:	d1af      	bne.n	8003124 <HAL_I2C_Mem_Write+0x5c>
        {
          return HAL_TIMEOUT;
        }

        
        if(Size > 255)
 80031c4:	2eff      	cmp	r6, #255	; 0xff
 80031c6:	d90b      	bls.n	80031e0 <HAL_I2C_Mem_Write+0x118>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80031c8:	682b      	ldr	r3, [r5, #0]
 80031ca:	6859      	ldr	r1, [r3, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80031cc:	400a      	ands	r2, r1
 80031ce:	f042 72ff 	orr.w	r2, r2, #33423360	; 0x1fe0000
 80031d2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80031d6:	4322      	orrs	r2, r4
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80031d8:	605a      	str	r2, [r3, #4]

        
        if(Size > 255)
        {
          I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
          Sizetmp = 255;
 80031da:	f04f 08ff 	mov.w	r8, #255	; 0xff
 80031de:	e7bb      	b.n	8003158 <HAL_I2C_Mem_Write+0x90>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80031e0:	682a      	ldr	r2, [r5, #0]
 80031e2:	6850      	ldr	r0, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80031e4:	4001      	ands	r1, r0
 80031e6:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 80031ea:	430b      	orrs	r3, r1
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80031ec:	4323      	orrs	r3, r4
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80031ee:	6053      	str	r3, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80031f0:	46b0      	mov	r8, r6
 80031f2:	e7b1      	b.n	8003158 <HAL_I2C_Mem_Write+0x90>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80031f4:	6829      	ldr	r1, [r5, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80031f6:	4b08      	ldr	r3, [pc, #32]	; (8003218 <HAL_I2C_Mem_Write+0x150>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80031f8:	684a      	ldr	r2, [r1, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80031fa:	4013      	ands	r3, r2
 80031fc:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003200:	f3c9 0e09 	ubfx	lr, r9, #0, #10
 8003204:	0433      	lsls	r3, r6, #16
 8003206:	ea42 020e 	orr.w	r2, r2, lr
 800320a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800320e:	4313      	orrs	r3, r2
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003210:	604b      	str	r3, [r1, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003212:	46b0      	mov	r8, r6
 8003214:	e79e      	b.n	8003154 <HAL_I2C_Mem_Write+0x8c>
 8003216:	bf00      	nop
 8003218:	fc009800 	.word	0xfc009800
 800321c:	fe00e800 	.word	0xfe00e800

08003220 <HAL_I2C_Mem_Read>:
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8003220:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t Sizetmp = 0;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 8003224:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8003228:	b083      	sub	sp, #12
  uint32_t Sizetmp = 0;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 800322a:	b2e4      	uxtb	r4, r4
 800322c:	2c01      	cmp	r4, #1
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800322e:	4605      	mov	r5, r0
 8003230:	f8bd 602c 	ldrh.w	r6, [sp, #44]	; 0x2c
  uint32_t Sizetmp = 0;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 8003234:	d003      	beq.n	800323e <HAL_I2C_Mem_Read+0x1e>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8003236:	2002      	movs	r0, #2
  }
}
 8003238:	b003      	add	sp, #12
 800323a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
  {    
    if((pData == NULL) || (Size == 0)) 
 800323e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8003240:	2f00      	cmp	r7, #0
 8003242:	d04a      	beq.n	80032da <HAL_I2C_Mem_Read+0xba>
 8003244:	2e00      	cmp	r6, #0
 8003246:	d048      	beq.n	80032da <HAL_I2C_Mem_Read+0xba>
    {
      return  HAL_ERROR;                                    
    }

    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 8003248:	6807      	ldr	r7, [r0, #0]
 800324a:	69bf      	ldr	r7, [r7, #24]
 800324c:	f417 4800 	ands.w	r8, r7, #32768	; 0x8000
 8003250:	d1f1      	bne.n	8003236 <HAL_I2C_Mem_Read+0x16>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003252:	f890 7034 	ldrb.w	r7, [r0, #52]	; 0x34
 8003256:	2f01      	cmp	r7, #1
 8003258:	d0ed      	beq.n	8003236 <HAL_I2C_Mem_Read+0x16>
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
 800325a:	f04f 0e62 	mov.w	lr, #98	; 0x62
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
 800325e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003260:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
 8003264:	9700      	str	r7, [sp, #0]
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
 8003266:	f880 e035 	strb.w	lr, [r0, #53]	; 0x35
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800326a:	f8c0 8038 	str.w	r8, [r0, #56]	; 0x38
 800326e:	4689      	mov	r9, r1
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
 8003270:	f7ff f94c 	bl	800250c <I2C_RequestMemoryRead>
 8003274:	b130      	cbz	r0, 8003284 <HAL_I2C_Mem_Read+0x64>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003276:	6bab      	ldr	r3, [r5, #56]	; 0x38
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8003278:	f885 8034 	strb.w	r8, [r5, #52]	; 0x34
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800327c:	2b04      	cmp	r3, #4
 800327e:	d02c      	beq.n	80032da <HAL_I2C_Mem_Read+0xba>
      {
        return HAL_ERROR;
      }
      else
      {
        return HAL_TIMEOUT;
 8003280:	2003      	movs	r0, #3
 8003282:	e7d9      	b.n	8003238 <HAL_I2C_Mem_Read+0x18>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    /* Size > 255, need to set RELOAD bit */
    if(Size > 255)
 8003284:	2eff      	cmp	r6, #255	; 0xff
 8003286:	d951      	bls.n	800332c <HAL_I2C_Mem_Read+0x10c>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003288:	682a      	ldr	r2, [r5, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800328a:	4b38      	ldr	r3, [pc, #224]	; (800336c <HAL_I2C_Mem_Read+0x14c>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 800328c:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800328e:	400b      	ands	r3, r1
 8003290:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003294:	f3c9 0409 	ubfx	r4, r9, #0, #10
 8003298:	f443 3392 	orr.w	r3, r3, #74752	; 0x12400
 800329c:	4323      	orrs	r3, r4
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 800329e:	6053      	str	r3, [r2, #4]
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    /* Size > 255, need to set RELOAD bit */
    if(Size > 255)
    {
      I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
      Sizetmp = 255;
 80032a0:	27ff      	movs	r7, #255	; 0xff
    }
    
    do
    {  
      /* Wait until RXNE flag is set */
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)      
 80032a2:	4628      	mov	r0, r5
 80032a4:	2104      	movs	r1, #4
 80032a6:	2200      	movs	r2, #0
 80032a8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80032aa:	f7ff f893 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
      /* Read data from RXDR */
      (*pData++) = hi2c->Instance->RXDR;

      /* Decrement the Size counter */
      Sizetmp--;
      Size--;   
 80032ae:	3e01      	subs	r6, #1
 80032b0:	b2b6      	uxth	r6, r6
    }
    
    do
    {  
      /* Wait until RXNE flag is set */
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)      
 80032b2:	2800      	cmp	r0, #0
 80032b4:	d1e4      	bne.n	8003280 <HAL_I2C_Mem_Read+0x60>
      {
        return HAL_TIMEOUT;
      }
          
      /* Read data from RXDR */
      (*pData++) = hi2c->Instance->RXDR;
 80032b6:	682b      	ldr	r3, [r5, #0]
 80032b8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80032ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80032bc:	f802 3b01 	strb.w	r3, [r2], #1

      /* Decrement the Size counter */
      Sizetmp--;
      Size--;   

      if((Sizetmp == 0)&&(Size!=0))
 80032c0:	3f01      	subs	r7, #1
      {
        return HAL_TIMEOUT;
      }
          
      /* Read data from RXDR */
      (*pData++) = hi2c->Instance->RXDR;
 80032c2:	920a      	str	r2, [sp, #40]	; 0x28

      /* Decrement the Size counter */
      Sizetmp--;
      Size--;   

      if((Sizetmp == 0)&&(Size!=0))
 80032c4:	d10b      	bne.n	80032de <HAL_I2C_Mem_Read+0xbe>
 80032c6:	b96e      	cbnz	r6, 80032e4 <HAL_I2C_Mem_Read+0xc4>

    }while(Size > 0);

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 80032c8:	4628      	mov	r0, r5
 80032ca:	2119      	movs	r1, #25
 80032cc:	f7ff f954 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 80032d0:	2800      	cmp	r0, #0
 80032d2:	d03d      	beq.n	8003350 <HAL_I2C_Mem_Read+0x130>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80032d4:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80032d6:	2b04      	cmp	r3, #4
 80032d8:	d1d2      	bne.n	8003280 <HAL_I2C_Mem_Read+0x60>
  
  if(hi2c->State == HAL_I2C_STATE_READY)
  {    
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 80032da:	2001      	movs	r0, #1
 80032dc:	e7ac      	b.n	8003238 <HAL_I2C_Mem_Read+0x18>
          I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
          Sizetmp = Size;
        }
      }

    }while(Size > 0);
 80032de:	2e00      	cmp	r6, #0
 80032e0:	d1df      	bne.n	80032a2 <HAL_I2C_Mem_Read+0x82>
 80032e2:	e7f1      	b.n	80032c8 <HAL_I2C_Mem_Read+0xa8>
      Size--;   

      if((Sizetmp == 0)&&(Size!=0))
      {
        /* Wait until TCR flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
 80032e4:	463a      	mov	r2, r7
 80032e6:	2180      	movs	r1, #128	; 0x80
 80032e8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80032ea:	4628      	mov	r0, r5
 80032ec:	f7ff f872 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80032f0:	4a1e      	ldr	r2, [pc, #120]	; (800336c <HAL_I2C_Mem_Read+0x14c>)
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80032f2:	0433      	lsls	r3, r6, #16
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80032f4:	4611      	mov	r1, r2
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80032f6:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
      Size--;   

      if((Sizetmp == 0)&&(Size!=0))
      {
        /* Wait until TCR flag is set */
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
 80032fa:	2800      	cmp	r0, #0
 80032fc:	d1c0      	bne.n	8003280 <HAL_I2C_Mem_Read+0x60>
        {
          return HAL_TIMEOUT;
        }
        
        if(Size > 255)
 80032fe:	2eff      	cmp	r6, #255	; 0xff
 8003300:	d90a      	bls.n	8003318 <HAL_I2C_Mem_Read+0xf8>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003302:	682b      	ldr	r3, [r5, #0]
 8003304:	6859      	ldr	r1, [r3, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003306:	400a      	ands	r2, r1
 8003308:	f042 72ff 	orr.w	r2, r2, #33423360	; 0x1fe0000
 800330c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003310:	4322      	orrs	r2, r4
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003312:	605a      	str	r2, [r3, #4]
        }
        
        if(Size > 255)
        {
          I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
          Sizetmp = 255;
 8003314:	27ff      	movs	r7, #255	; 0xff
 8003316:	e7c4      	b.n	80032a2 <HAL_I2C_Mem_Read+0x82>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003318:	682a      	ldr	r2, [r5, #0]
 800331a:	6850      	ldr	r0, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800331c:	4001      	ands	r1, r0
 800331e:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 8003322:	430b      	orrs	r3, r1
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003324:	4323      	orrs	r3, r4
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003326:	6053      	str	r3, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003328:	4637      	mov	r7, r6
 800332a:	e7ba      	b.n	80032a2 <HAL_I2C_Mem_Read+0x82>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 800332c:	6829      	ldr	r1, [r5, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800332e:	4b0f      	ldr	r3, [pc, #60]	; (800336c <HAL_I2C_Mem_Read+0x14c>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003330:	684a      	ldr	r2, [r1, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003332:	4013      	ands	r3, r2
 8003334:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003338:	f3c9 0409 	ubfx	r4, r9, #0, #10
 800333c:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8003340:	0432      	lsls	r2, r6, #16
 8003342:	4323      	orrs	r3, r4
 8003344:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 8003348:	4313      	orrs	r3, r2
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 800334a:	604b      	str	r3, [r1, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 800334c:	4637      	mov	r7, r6
 800334e:	e7a8      	b.n	80032a2 <HAL_I2C_Mem_Read+0x82>
        return HAL_TIMEOUT;
      }
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003350:	682a      	ldr	r2, [r5, #0]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003352:	4b07      	ldr	r3, [pc, #28]	; (8003370 <HAL_I2C_Mem_Read+0x150>)
        return HAL_TIMEOUT;
      }
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003354:	2120      	movs	r1, #32
 8003356:	61d1      	str	r1, [r2, #28]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003358:	682a      	ldr	r2, [r5, #0]
 800335a:	6854      	ldr	r4, [r2, #4]
    
    hi2c->State = HAL_I2C_STATE_READY;
 800335c:	2101      	movs	r1, #1

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800335e:	4023      	ands	r3, r4
 8003360:	6053      	str	r3, [r2, #4]
    
    hi2c->State = HAL_I2C_STATE_READY;
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8003362:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
    
    hi2c->State = HAL_I2C_STATE_READY;
 8003366:	f885 1035 	strb.w	r1, [r5, #53]	; 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    return HAL_OK;
 800336a:	e765      	b.n	8003238 <HAL_I2C_Mem_Read+0x18>
 800336c:	fc009800 	.word	0xfc009800
 8003370:	fe00e800 	.word	0xfe00e800

08003374 <HAL_I2C_Mem_Write_IT>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 8003374:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 8003376:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 800337a:	b083      	sub	sp, #12
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 800337c:	b2e4      	uxtb	r4, r4
 800337e:	2c01      	cmp	r4, #1
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 8003380:	f8bd 5024 	ldrh.w	r5, [sp, #36]	; 0x24
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 8003384:	d002      	beq.n	800338c <HAL_I2C_Mem_Write_IT+0x18>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8003386:	2002      	movs	r0, #2
  }
}
 8003388:	b003      	add	sp, #12
 800338a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 800338c:	9e08      	ldr	r6, [sp, #32]
 800338e:	b366      	cbz	r6, 80033ea <HAL_I2C_Mem_Write_IT+0x76>
 8003390:	b35d      	cbz	r5, 80033ea <HAL_I2C_Mem_Write_IT+0x76>
    {
      return  HAL_ERROR;                                    
    }
    
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 8003392:	6806      	ldr	r6, [r0, #0]
 8003394:	69b6      	ldr	r6, [r6, #24]
 8003396:	f416 4600 	ands.w	r6, r6, #32768	; 0x8000
 800339a:	d1f4      	bne.n	8003386 <HAL_I2C_Mem_Write_IT+0x12>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800339c:	f890 7034 	ldrb.w	r7, [r0, #52]	; 0x34
 80033a0:	2f01      	cmp	r7, #1
 80033a2:	d0f0      	beq.n	8003386 <HAL_I2C_Mem_Write_IT+0x12>
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
 80033a4:	2dff      	cmp	r5, #255	; 0xff
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80033a6:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
 80033aa:	f04f 0752 	mov.w	r7, #82	; 0x52
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
 80033ae:	9c08      	ldr	r4, [sp, #32]
 80033b0:	6244      	str	r4, [r0, #36]	; 0x24
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
 80033b2:	f880 7035 	strb.w	r7, [r0, #53]	; 0x35
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
    {
      hi2c->XferSize = 255;
 80033b6:	bf8c      	ite	hi
 80033b8:	24ff      	movhi	r4, #255	; 0xff
    }
    else
    {
      hi2c->XferSize = Size;
 80033ba:	8505      	strhls	r5, [r0, #40]	; 0x28

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80033bc:	6386      	str	r6, [r0, #56]	; 0x38
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
 80033be:	8545      	strh	r5, [r0, #42]	; 0x2a
 80033c0:	460d      	mov	r5, r1
    {
      hi2c->XferSize = Size;
    }
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
 80033c2:	f04f 0119 	mov.w	r1, #25
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
    {
      hi2c->XferSize = 255;
 80033c6:	bf88      	it	hi
 80033c8:	8504      	strhhi	r4, [r0, #40]	; 0x28
    {
      hi2c->XferSize = Size;
    }
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
 80033ca:	9100      	str	r1, [sp, #0]
 80033cc:	4629      	mov	r1, r5
 80033ce:	4604      	mov	r4, r0
 80033d0:	f7ff f864 	bl	800249c <I2C_RequestMemoryWrite>
 80033d4:	b158      	cbz	r0, 80033ee <HAL_I2C_Mem_Write_IT+0x7a>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80033d6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80033d8:	2b04      	cmp	r3, #4
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80033da:	f04f 0300 	mov.w	r3, #0
 80033de:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        return HAL_ERROR;
 80033e2:	bf0c      	ite	eq
 80033e4:	2001      	moveq	r0, #1
      }
      else
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
        return HAL_TIMEOUT;
 80033e6:	2003      	movne	r0, #3
 80033e8:	e7ce      	b.n	8003388 <HAL_I2C_Mem_Write_IT+0x14>
  
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 80033ea:	4620      	mov	r0, r4
 80033ec:	e7cc      	b.n	8003388 <HAL_I2C_Mem_Write_IT+0x14>
      }
    }

    /* Set NBYTES to write and reload if size > 255 */
    /* Size > 255, need to set RELOAD bit */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80033ee:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 80033f0:	2aff      	cmp	r2, #255	; 0xff
 80033f2:	d015      	beq.n	8003420 <HAL_I2C_Mem_Write_IT+0xac>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80033f4:	6826      	ldr	r6, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80033f6:	4b13      	ldr	r3, [pc, #76]	; (8003444 <HAL_I2C_Mem_Write_IT+0xd0>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80033f8:	6871      	ldr	r1, [r6, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80033fa:	400b      	ands	r3, r1
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80033fc:	b2d2      	uxtb	r2, r2
 80033fe:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003402:	f3c5 0109 	ubfx	r1, r5, #0, #10
 8003406:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800340a:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 800340c:	6073      	str	r3, [r6, #4]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
    }  

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c); 
 800340e:	2300      	movs	r3, #0
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
 8003410:	6822      	ldr	r2, [r4, #0]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
    }  

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c); 
 8003412:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
 8003416:	6813      	ldr	r3, [r2, #0]
 8003418:	f043 03f2 	orr.w	r3, r3, #242	; 0xf2
 800341c:	6013      	str	r3, [r2, #0]
    
    return HAL_OK;
 800341e:	e7b3      	b.n	8003388 <HAL_I2C_Mem_Write_IT+0x14>
      }
    }

    /* Set NBYTES to write and reload if size > 255 */
    /* Size > 255, need to set RELOAD bit */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003420:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003422:	b29b      	uxth	r3, r3
 8003424:	2bff      	cmp	r3, #255	; 0xff
 8003426:	d9e5      	bls.n	80033f4 <HAL_I2C_Mem_Write_IT+0x80>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003428:	6822      	ldr	r2, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800342a:	4b06      	ldr	r3, [pc, #24]	; (8003444 <HAL_I2C_Mem_Write_IT+0xd0>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 800342c:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800342e:	400b      	ands	r3, r1
 8003430:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003434:	f3c5 0109 	ubfx	r1, r5, #0, #10
 8003438:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800343c:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 800343e:	6053      	str	r3, [r2, #4]
 8003440:	e7e5      	b.n	800340e <HAL_I2C_Mem_Write_IT+0x9a>
 8003442:	bf00      	nop
 8003444:	fc009800 	.word	0xfc009800

08003448 <HAL_I2C_Mem_Read_IT>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 8003448:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 800344a:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 800344e:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 8003450:	b2e4      	uxtb	r4, r4
 8003452:	2c01      	cmp	r4, #1
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 8003454:	f8bd 501c 	ldrh.w	r5, [sp, #28]
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 8003458:	d002      	beq.n	8003460 <HAL_I2C_Mem_Read_IT+0x18>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 800345a:	2002      	movs	r0, #2
  }   
}
 800345c:	b002      	add	sp, #8
 800345e:	bd70      	pop	{r4, r5, r6, pc}
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8003460:	9e06      	ldr	r6, [sp, #24]
 8003462:	b356      	cbz	r6, 80034ba <HAL_I2C_Mem_Read_IT+0x72>
 8003464:	b34d      	cbz	r5, 80034ba <HAL_I2C_Mem_Read_IT+0x72>
    {
      return  HAL_ERROR;                                    
    }
    
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 8003466:	6806      	ldr	r6, [r0, #0]
 8003468:	69b6      	ldr	r6, [r6, #24]
 800346a:	0436      	lsls	r6, r6, #16
 800346c:	d4f5      	bmi.n	800345a <HAL_I2C_Mem_Read_IT+0x12>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800346e:	f890 6034 	ldrb.w	r6, [r0, #52]	; 0x34
 8003472:	2e01      	cmp	r6, #1
 8003474:	d0f1      	beq.n	800345a <HAL_I2C_Mem_Read_IT+0x12>
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
 8003476:	2dff      	cmp	r5, #255	; 0xff
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003478:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
    
    hi2c->pBuffPtr = pData;
 800347c:	9c06      	ldr	r4, [sp, #24]
 800347e:	6244      	str	r4, [r0, #36]	; 0x24
    hi2c->XferCount = Size;
    if(Size > 255)
    {
      hi2c->XferSize = 255;
 8003480:	bf84      	itt	hi
 8003482:	24ff      	movhi	r4, #255	; 0xff
 8003484:	8504      	strhhi	r4, [r0, #40]	; 0x28
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
 8003486:	f04f 0662 	mov.w	r6, #98	; 0x62
 800348a:	460c      	mov	r4, r1
    {
      hi2c->XferSize = Size;
    }
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
 800348c:	f04f 0119 	mov.w	r1, #25
    {
      hi2c->XferSize = 255;
    }
    else
    {
      hi2c->XferSize = Size;
 8003490:	bf98      	it	ls
 8003492:	8505      	strhls	r5, [r0, #40]	; 0x28
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
 8003494:	f880 6035 	strb.w	r6, [r0, #53]	; 0x35
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
 8003498:	8545      	strh	r5, [r0, #42]	; 0x2a
    {
      hi2c->XferSize = Size;
    }
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
 800349a:	9100      	str	r1, [sp, #0]
 800349c:	4621      	mov	r1, r4
 800349e:	4605      	mov	r5, r0
 80034a0:	f7ff f834 	bl	800250c <I2C_RequestMemoryRead>
 80034a4:	b158      	cbz	r0, 80034be <HAL_I2C_Mem_Read_IT+0x76>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80034a6:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80034a8:	2b04      	cmp	r3, #4
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80034aa:	f04f 0300 	mov.w	r3, #0
 80034ae:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
        return HAL_ERROR;
 80034b2:	bf0c      	ite	eq
 80034b4:	2001      	moveq	r0, #1
      }
      else
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
        return HAL_TIMEOUT;
 80034b6:	2003      	movne	r0, #3
 80034b8:	e7d0      	b.n	800345c <HAL_I2C_Mem_Read_IT+0x14>
  
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
    {
      return  HAL_ERROR;                                    
 80034ba:	4620      	mov	r0, r4
 80034bc:	e7ce      	b.n	800345c <HAL_I2C_Mem_Read_IT+0x14>
      }
    }
      
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    /* Size > 255, need to set RELOAD bit */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80034be:	8d2a      	ldrh	r2, [r5, #40]	; 0x28
 80034c0:	2aff      	cmp	r2, #255	; 0xff
 80034c2:	d017      	beq.n	80034f4 <HAL_I2C_Mem_Read_IT+0xac>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80034c4:	682e      	ldr	r6, [r5, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80034c6:	4b14      	ldr	r3, [pc, #80]	; (8003518 <HAL_I2C_Mem_Read_IT+0xd0>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80034c8:	6871      	ldr	r1, [r6, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80034ca:	400b      	ands	r3, r1
 80034cc:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80034d0:	b2d2      	uxtb	r2, r2
 80034d2:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 80034d6:	f3c4 0109 	ubfx	r1, r4, #0, #10
 80034da:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80034de:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80034e0:	6073      	str	r3, [r6, #4]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c); 
 80034e2:	2300      	movs	r3, #0
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI );
 80034e4:	682a      	ldr	r2, [r5, #0]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c); 
 80034e6:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
              process unlock */
    
    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI );
 80034ea:	6813      	ldr	r3, [r2, #0]
 80034ec:	f043 03f4 	orr.w	r3, r3, #244	; 0xf4
 80034f0:	6013      	str	r3, [r2, #0]
    
    return HAL_OK;
 80034f2:	e7b3      	b.n	800345c <HAL_I2C_Mem_Read_IT+0x14>
      }
    }
      
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    /* Size > 255, need to set RELOAD bit */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80034f4:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
 80034f6:	b29b      	uxth	r3, r3
 80034f8:	2bff      	cmp	r3, #255	; 0xff
 80034fa:	d9e3      	bls.n	80034c4 <HAL_I2C_Mem_Read_IT+0x7c>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80034fc:	682a      	ldr	r2, [r5, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80034fe:	4b06      	ldr	r3, [pc, #24]	; (8003518 <HAL_I2C_Mem_Read_IT+0xd0>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003500:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003502:	400b      	ands	r3, r1
 8003504:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003508:	f3c4 0109 	ubfx	r1, r4, #0, #10
 800350c:	f443 3392 	orr.w	r3, r3, #74752	; 0x12400
 8003510:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003512:	6053      	str	r3, [r2, #4]
 8003514:	e7e5      	b.n	80034e2 <HAL_I2C_Mem_Read_IT+0x9a>
 8003516:	bf00      	nop
 8003518:	fc009800 	.word	0xfc009800

0800351c <HAL_I2C_Mem_Write_DMA>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 800351c:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 800351e:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 8003522:	b083      	sub	sp, #12
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 8003524:	b2e4      	uxtb	r4, r4
 8003526:	2c01      	cmp	r4, #1
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 8003528:	f8bd 5024 	ldrh.w	r5, [sp, #36]	; 0x24
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 800352c:	d002      	beq.n	8003534 <HAL_I2C_Mem_Write_DMA+0x18>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 800352e:	2002      	movs	r0, #2
  }
}
 8003530:	b003      	add	sp, #12
 8003532:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8003534:	9e08      	ldr	r6, [sp, #32]
 8003536:	2e00      	cmp	r6, #0
 8003538:	d056      	beq.n	80035e8 <HAL_I2C_Mem_Write_DMA+0xcc>
 800353a:	2d00      	cmp	r5, #0
 800353c:	d054      	beq.n	80035e8 <HAL_I2C_Mem_Write_DMA+0xcc>
    {
      return  HAL_ERROR;                                    
    }
    
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 800353e:	6806      	ldr	r6, [r0, #0]
 8003540:	69b6      	ldr	r6, [r6, #24]
 8003542:	f416 4600 	ands.w	r6, r6, #32768	; 0x8000
 8003546:	d1f2      	bne.n	800352e <HAL_I2C_Mem_Write_DMA+0x12>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003548:	f890 7034 	ldrb.w	r7, [r0, #52]	; 0x34
 800354c:	2f01      	cmp	r7, #1
 800354e:	d0ee      	beq.n	800352e <HAL_I2C_Mem_Write_DMA+0x12>
 8003550:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
 8003554:	2dff      	cmp	r5, #255	; 0xff
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
 8003556:	9c08      	ldr	r4, [sp, #32]
 8003558:	6244      	str	r4, [r0, #36]	; 0x24
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
 800355a:	f04f 0752 	mov.w	r7, #82	; 0x52
 800355e:	f880 7035 	strb.w	r7, [r0, #53]	; 0x35
    {
      hi2c->XferSize = 255;
    }
    else
    {
      hi2c->XferSize = Size;
 8003562:	bf98      	it	ls
 8003564:	8505      	strhls	r5, [r0, #40]	; 0x28

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003566:	6386      	str	r6, [r0, #56]	; 0x38
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
    {
      hi2c->XferSize = 255;
 8003568:	bf88      	it	hi
 800356a:	24ff      	movhi	r4, #255	; 0xff
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
 800356c:	8545      	strh	r5, [r0, #42]	; 0x2a
 800356e:	461d      	mov	r5, r3
    {
      hi2c->XferSize = Size;
    }
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmatx->XferCpltCallback = I2C_DMAMemTransmitCplt;
 8003570:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
    {
      hi2c->XferSize = 255;
 8003572:	bf88      	it	hi
 8003574:	8504      	strhhi	r4, [r0, #40]	; 0x28
 8003576:	4614      	mov	r4, r2
    {
      hi2c->XferSize = Size;
    }
    
    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmatx->XferCpltCallback = I2C_DMAMemTransmitCplt;
 8003578:	4a29      	ldr	r2, [pc, #164]	; (8003620 <HAL_I2C_Mem_Write_DMA+0x104>)
 800357a:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Set the DMA error callback */
    hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
 800357c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800357e:	4a29      	ldr	r2, [pc, #164]	; (8003624 <HAL_I2C_Mem_Write_DMA+0x108>)
 8003580:	635a      	str	r2, [r3, #52]	; 0x34
 8003582:	4606      	mov	r6, r0
    
    /* Enable the DMA channel */
    HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 8003584:	6802      	ldr	r2, [r0, #0]
 8003586:	8d33      	ldrh	r3, [r6, #40]	; 0x28
 8003588:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800358a:	460f      	mov	r7, r1
 800358c:	3228      	adds	r2, #40	; 0x28
 800358e:	9908      	ldr	r1, [sp, #32]
 8003590:	f7fd ffca 	bl	8001528 <HAL_DMA_Start_IT>
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
 8003594:	2119      	movs	r1, #25
 8003596:	9100      	str	r1, [sp, #0]
 8003598:	4622      	mov	r2, r4
 800359a:	462b      	mov	r3, r5
 800359c:	4630      	mov	r0, r6
 800359e:	4639      	mov	r1, r7
 80035a0:	f7fe ff7c 	bl	800249c <I2C_RequestMemoryWrite>
 80035a4:	b140      	cbz	r0, 80035b8 <HAL_I2C_Mem_Write_DMA+0x9c>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80035a6:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 80035a8:	2b04      	cmp	r3, #4
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80035aa:	f04f 0300 	mov.w	r3, #0
 80035ae:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
    HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80035b2:	d019      	beq.n	80035e8 <HAL_I2C_Mem_Write_DMA+0xcc>
      {
        return HAL_ERROR;
      }
      else
      {
        return HAL_TIMEOUT;
 80035b4:	2003      	movs	r0, #3
 80035b6:	e7bb      	b.n	8003530 <HAL_I2C_Mem_Write_DMA+0x14>
      }
    }
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80035b8:	8d32      	ldrh	r2, [r6, #40]	; 0x28
 80035ba:	2aff      	cmp	r2, #255	; 0xff
 80035bc:	d01e      	beq.n	80035fc <HAL_I2C_Mem_Write_DMA+0xe0>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80035be:	6830      	ldr	r0, [r6, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80035c0:	4b19      	ldr	r3, [pc, #100]	; (8003628 <HAL_I2C_Mem_Write_DMA+0x10c>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80035c2:	6841      	ldr	r1, [r0, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80035c4:	400b      	ands	r3, r1
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80035c6:	b2d2      	uxtb	r2, r2
 80035c8:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80035cc:	f3c7 0109 	ubfx	r1, r7, #0, #10
 80035d0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80035d4:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80035d6:	6043      	str	r3, [r0, #4]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
    }
    
    /* Wait until TXIS flag is set */
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
 80035d8:	4630      	mov	r0, r6
 80035da:	2119      	movs	r1, #25
 80035dc:	f7fe ff36 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
 80035e0:	b120      	cbz	r0, 80035ec <HAL_I2C_Mem_Write_DMA+0xd0>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80035e2:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 80035e4:	2b04      	cmp	r3, #4
 80035e6:	d1e5      	bne.n	80035b4 <HAL_I2C_Mem_Write_DMA+0x98>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
        return HAL_ERROR;
 80035e8:	2001      	movs	r0, #1
 80035ea:	e7a1      	b.n	8003530 <HAL_I2C_Mem_Write_DMA+0x14>
        return HAL_TIMEOUT;
      }
    }

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;  
 80035ec:	6832      	ldr	r2, [r6, #0]
 80035ee:	6813      	ldr	r3, [r2, #0]
 80035f0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80035f4:	6013      	str	r3, [r2, #0]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80035f6:	f886 0034 	strb.w	r0, [r6, #52]	; 0x34
    
    return HAL_OK;
 80035fa:	e799      	b.n	8003530 <HAL_I2C_Mem_Write_DMA+0x14>
      }
    }
    
    /* Send Slave Address */
    /* Set NBYTES to write and reload if size > 255 */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80035fc:	8d73      	ldrh	r3, [r6, #42]	; 0x2a
 80035fe:	b29b      	uxth	r3, r3
 8003600:	2bff      	cmp	r3, #255	; 0xff
 8003602:	d9dc      	bls.n	80035be <HAL_I2C_Mem_Write_DMA+0xa2>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003604:	6832      	ldr	r2, [r6, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003606:	4b08      	ldr	r3, [pc, #32]	; (8003628 <HAL_I2C_Mem_Write_DMA+0x10c>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003608:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800360a:	400b      	ands	r3, r1
 800360c:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003610:	f3c7 0109 	ubfx	r1, r7, #0, #10
 8003614:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003618:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 800361a:	6053      	str	r3, [r2, #4]
 800361c:	e7dc      	b.n	80035d8 <HAL_I2C_Mem_Write_DMA+0xbc>
 800361e:	bf00      	nop
 8003620:	08003c39 	.word	0x08003c39
 8003624:	08003875 	.word	0x08003875
 8003628:	fc009800 	.word	0xfc009800

0800362c <HAL_I2C_Mem_Read_DMA>:
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be read
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 800362c:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 800362e:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be read
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 8003632:	b083      	sub	sp, #12
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 8003634:	b2e4      	uxtb	r4, r4
 8003636:	2c01      	cmp	r4, #1
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be read
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 8003638:	f8bd 5024 	ldrh.w	r5, [sp, #36]	; 0x24
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
 800363c:	d002      	beq.n	8003644 <HAL_I2C_Mem_Read_DMA+0x18>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 800363e:	2002      	movs	r0, #2
  }
}
 8003640:	b003      	add	sp, #12
 8003642:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
  
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if((pData == NULL) || (Size == 0)) 
 8003644:	9e08      	ldr	r6, [sp, #32]
 8003646:	2e00      	cmp	r6, #0
 8003648:	d03b      	beq.n	80036c2 <HAL_I2C_Mem_Read_DMA+0x96>
 800364a:	2d00      	cmp	r5, #0
 800364c:	d039      	beq.n	80036c2 <HAL_I2C_Mem_Read_DMA+0x96>
    {
      return  HAL_ERROR;                                    
    }

    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 800364e:	6806      	ldr	r6, [r0, #0]
 8003650:	69b6      	ldr	r6, [r6, #24]
 8003652:	0436      	lsls	r6, r6, #16
 8003654:	d4f3      	bmi.n	800363e <HAL_I2C_Mem_Read_DMA+0x12>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003656:	f890 6034 	ldrb.w	r6, [r0, #52]	; 0x34
 800365a:	2e01      	cmp	r6, #1
 800365c:	d0ef      	beq.n	800363e <HAL_I2C_Mem_Read_DMA+0x12>
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
 800365e:	2662      	movs	r6, #98	; 0x62
 8003660:	f880 6035 	strb.w	r6, [r0, #53]	; 0x35
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003664:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
 8003668:	2dff      	cmp	r5, #255	; 0xff
    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
    
    hi2c->pBuffPtr = pData;
 800366a:	9c08      	ldr	r4, [sp, #32]
 800366c:	6244      	str	r4, [r0, #36]	; 0x24
 800366e:	461e      	mov	r6, r3
    {
      hi2c->XferSize = Size;
    }

    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmarx->XferCpltCallback = I2C_DMAMemReceiveCplt;
 8003670:	6b03      	ldr	r3, [r0, #48]	; 0x30
    {
      hi2c->XferSize = 255;
    }
    else
    {
      hi2c->XferSize = Size;
 8003672:	bf98      	it	ls
 8003674:	8505      	strhls	r5, [r0, #40]	; 0x28
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
 8003676:	8545      	strh	r5, [r0, #42]	; 0x2a
    if(Size > 255)
    {
      hi2c->XferSize = 255;
 8003678:	bf88      	it	hi
 800367a:	24ff      	movhi	r4, #255	; 0xff
 800367c:	4615      	mov	r5, r2
    {
      hi2c->XferSize = Size;
    }

    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmarx->XferCpltCallback = I2C_DMAMemReceiveCplt;
 800367e:	4a2b      	ldr	r2, [pc, #172]	; (800372c <HAL_I2C_Mem_Read_DMA+0x100>)
    
    hi2c->pBuffPtr = pData;
    hi2c->XferCount = Size;
    if(Size > 255)
    {
      hi2c->XferSize = 255;
 8003680:	bf88      	it	hi
 8003682:	8504      	strhhi	r4, [r0, #40]	; 0x28
    {
      hi2c->XferSize = Size;
    }

    /* Set the I2C DMA transfer complete callback */
    hi2c->hdmarx->XferCpltCallback = I2C_DMAMemReceiveCplt;
 8003684:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Set the DMA error callback */
    hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
 8003686:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8003688:	4a29      	ldr	r2, [pc, #164]	; (8003730 <HAL_I2C_Mem_Read_DMA+0x104>)
 800368a:	635a      	str	r2, [r3, #52]	; 0x34
 800368c:	4607      	mov	r7, r0
 800368e:	460c      	mov	r4, r1
    
    /* Enable the DMA channel */
    HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
 8003690:	6801      	ldr	r1, [r0, #0]
 8003692:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8003694:	9a08      	ldr	r2, [sp, #32]
 8003696:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8003698:	3124      	adds	r1, #36	; 0x24
 800369a:	f7fd ff45 	bl	8001528 <HAL_DMA_Start_IT>
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
 800369e:	2119      	movs	r1, #25
 80036a0:	9100      	str	r1, [sp, #0]
 80036a2:	462a      	mov	r2, r5
 80036a4:	4633      	mov	r3, r6
 80036a6:	4638      	mov	r0, r7
 80036a8:	4621      	mov	r1, r4
 80036aa:	f7fe ff2f 	bl	800250c <I2C_RequestMemoryRead>
 80036ae:	b150      	cbz	r0, 80036c6 <HAL_I2C_Mem_Read_DMA+0x9a>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80036b0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80036b2:	2b04      	cmp	r3, #4
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80036b4:	f04f 0300 	mov.w	r3, #0
 80036b8:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
    HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80036bc:	d001      	beq.n	80036c2 <HAL_I2C_Mem_Read_DMA+0x96>
    }

    /* Wait until RXNE flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
    {
      return HAL_TIMEOUT;
 80036be:	2003      	movs	r0, #3
 80036c0:	e7be      	b.n	8003640 <HAL_I2C_Mem_Read_DMA+0x14>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
        return HAL_ERROR;
 80036c2:	2001      	movs	r0, #1
 80036c4:	e7bc      	b.n	8003640 <HAL_I2C_Mem_Read_DMA+0x14>
        return HAL_TIMEOUT;
      }
    }
    
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80036c6:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 80036c8:	2aff      	cmp	r2, #255	; 0xff
 80036ca:	d01e      	beq.n	800370a <HAL_I2C_Mem_Read_DMA+0xde>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80036cc:	6838      	ldr	r0, [r7, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80036ce:	4b19      	ldr	r3, [pc, #100]	; (8003734 <HAL_I2C_Mem_Read_DMA+0x108>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80036d0:	6841      	ldr	r1, [r0, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80036d2:	400b      	ands	r3, r1
 80036d4:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80036d8:	b2d2      	uxtb	r2, r2
 80036da:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 80036de:	f3c4 0109 	ubfx	r1, r4, #0, #10
 80036e2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80036e6:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80036e8:	6043      	str	r3, [r0, #4]
    {
      I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
    }

    /* Wait until RXNE flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
 80036ea:	4638      	mov	r0, r7
 80036ec:	2104      	movs	r1, #4
 80036ee:	2200      	movs	r2, #0
 80036f0:	2319      	movs	r3, #25
 80036f2:	f7fe fe6f 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 80036f6:	2800      	cmp	r0, #0
 80036f8:	d1e1      	bne.n	80036be <HAL_I2C_Mem_Read_DMA+0x92>
    {
      return HAL_TIMEOUT;
    }
    
    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;  
 80036fa:	683a      	ldr	r2, [r7, #0]
 80036fc:	6813      	ldr	r3, [r2, #0]
 80036fe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003702:	6013      	str	r3, [r2, #0]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8003704:	f887 0034 	strb.w	r0, [r7, #52]	; 0x34
    
    return HAL_OK;
 8003708:	e79a      	b.n	8003640 <HAL_I2C_Mem_Read_DMA+0x14>
        return HAL_TIMEOUT;
      }
    }
    
    /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 800370a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800370c:	b29b      	uxth	r3, r3
 800370e:	2bff      	cmp	r3, #255	; 0xff
 8003710:	d9dc      	bls.n	80036cc <HAL_I2C_Mem_Read_DMA+0xa0>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003712:	683a      	ldr	r2, [r7, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003714:	4b07      	ldr	r3, [pc, #28]	; (8003734 <HAL_I2C_Mem_Read_DMA+0x108>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003716:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003718:	400b      	ands	r3, r1
 800371a:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 800371e:	f3c4 0109 	ubfx	r1, r4, #0, #10
 8003722:	f443 3392 	orr.w	r3, r3, #74752	; 0x12400
 8003726:	430b      	orrs	r3, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003728:	6053      	str	r3, [r2, #4]
 800372a:	e7de      	b.n	80036ea <HAL_I2C_Mem_Read_DMA+0xbe>
 800372c:	08003d95 	.word	0x08003d95
 8003730:	08003875 	.word	0x08003875
 8003734:	fc009800 	.word	0xfc009800

08003738 <HAL_I2C_IsDeviceReady>:
  * @param  Trials: Number of trials
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
{  
 8003738:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800373c:	b082      	sub	sp, #8
  uint32_t tickstart = 0;
  
  __IO uint32_t I2C_Trials = 0;
 800373e:	2400      	movs	r4, #0
 8003740:	9401      	str	r4, [sp, #4]
 
  if(hi2c->State == HAL_I2C_STATE_READY)
 8003742:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 8003746:	b2e4      	uxtb	r4, r4
 8003748:	2c01      	cmp	r4, #1
 800374a:	d003      	beq.n	8003754 <HAL_I2C_IsDeviceReady+0x1c>
        
    return HAL_TIMEOUT;
  }
  else
  {
    return HAL_BUSY;
 800374c:	2002      	movs	r0, #2
  }
}
 800374e:	b002      	add	sp, #8
 8003750:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  
  __IO uint32_t I2C_Trials = 0;
 
  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 8003754:	f8d0 e000 	ldr.w	lr, [r0]
 8003758:	f8de 5018 	ldr.w	r5, [lr, #24]
 800375c:	f415 4c00 	ands.w	ip, r5, #32768	; 0x8000
 8003760:	d1f4      	bne.n	800374c <HAL_I2C_IsDeviceReady+0x14>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003762:	f890 5034 	ldrb.w	r5, [r0, #52]	; 0x34
 8003766:	2d01      	cmp	r5, #1
 8003768:	d0f0      	beq.n	800374c <HAL_I2C_IsDeviceReady+0x14>
 800376a:	f3c1 0709 	ubfx	r7, r1, #0, #10
 800376e:	4699      	mov	r9, r3
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    do
    {
      /* Generate Start */
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode,DevAddress);
 8003770:	f047 7800 	orr.w	r8, r7, #33554432	; 0x2000000
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_BUSY;
 8003774:	2302      	movs	r3, #2
 8003776:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
 800377a:	4616      	mov	r6, r2
 800377c:	4605      	mov	r5, r0
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800377e:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    
    do
    {
      /* Generate Start */
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode,DevAddress);
 8003782:	f448 5800 	orr.w	r8, r8, #8192	; 0x2000

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    hi2c->State = HAL_I2C_STATE_BUSY;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003786:	f8c0 c038 	str.w	ip, [r0, #56]	; 0x38
    
    do
    {
      /* Generate Start */
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode,DevAddress);
 800378a:	68eb      	ldr	r3, [r5, #12]
 800378c:	2b01      	cmp	r3, #1
 800378e:	bf0c      	ite	eq
 8003790:	4643      	moveq	r3, r8
 8003792:	f447 5320 	orrne.w	r3, r7, #10240	; 0x2800
 8003796:	f8ce 3004 	str.w	r3, [lr, #4]
      
      /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
      /* Wait until STOPF flag is set or a NACK flag is set*/
      tickstart = HAL_GetTick();
 800379a:	f7fd f9b5 	bl	8000b08 <HAL_GetTick>
 800379e:	4682      	mov	sl, r0
 80037a0:	6829      	ldr	r1, [r5, #0]
 80037a2:	e009      	b.n	80037b8 <HAL_I2C_IsDeviceReady+0x80>
      while((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET) && (hi2c->State != HAL_I2C_STATE_TIMEOUT))
 80037a4:	698c      	ldr	r4, [r1, #24]
 80037a6:	06e3      	lsls	r3, r4, #27
 80037a8:	d409      	bmi.n	80037be <HAL_I2C_IsDeviceReady+0x86>
 80037aa:	f895 4035 	ldrb.w	r4, [r5, #53]	; 0x35
 80037ae:	2c03      	cmp	r4, #3
 80037b0:	d005      	beq.n	80037be <HAL_I2C_IsDeviceReady+0x86>
      {
      	if(Timeout != HAL_MAX_DELAY)
 80037b2:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
 80037b6:	d11e      	bne.n	80037f6 <HAL_I2C_IsDeviceReady+0xbe>
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode,DevAddress);
      
      /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
      /* Wait until STOPF flag is set or a NACK flag is set*/
      tickstart = HAL_GetTick();
      while((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET) && (hi2c->State != HAL_I2C_STATE_TIMEOUT))
 80037b8:	698c      	ldr	r4, [r1, #24]
 80037ba:	06a2      	lsls	r2, r4, #26
 80037bc:	d5f2      	bpl.n	80037a4 <HAL_I2C_IsDeviceReady+0x6c>
          }
        } 
      }
      
      /* Check if the NACKF flag has not been set */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
 80037be:	698a      	ldr	r2, [r1, #24]
 80037c0:	f012 0210 	ands.w	r2, r2, #16
 80037c4:	d038      	beq.n	8003838 <HAL_I2C_IsDeviceReady+0x100>
        return HAL_OK;
      }
      else
      {
        /* Wait until STOPF flag is reset */ 
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
 80037c6:	4628      	mov	r0, r5
 80037c8:	2120      	movs	r1, #32
 80037ca:	2200      	movs	r2, #0
 80037cc:	464b      	mov	r3, r9
 80037ce:	f7fe fe01 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 80037d2:	b9f8      	cbnz	r0, 8003814 <HAL_I2C_IsDeviceReady+0xdc>
        {
          return HAL_TIMEOUT;
        }

        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80037d4:	682b      	ldr	r3, [r5, #0]
 80037d6:	2210      	movs	r2, #16
 80037d8:	61da      	str	r2, [r3, #28]

        /* Clear STOP Flag, auto generated with autoend*/
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80037da:	682b      	ldr	r3, [r5, #0]
 80037dc:	2420      	movs	r4, #32
 80037de:	61dc      	str	r4, [r3, #28]
      }
      
      /* Check if the maximum allowed number of trials has been reached */
      if (I2C_Trials++ == Trials)
 80037e0:	9b01      	ldr	r3, [sp, #4]
 80037e2:	1c5a      	adds	r2, r3, #1
 80037e4:	42b3      	cmp	r3, r6
 80037e6:	9201      	str	r2, [sp, #4]
 80037e8:	d016      	beq.n	8003818 <HAL_I2C_IsDeviceReady+0xe0>
        }
        
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
      }      
    }while(I2C_Trials < Trials);
 80037ea:	9b01      	ldr	r3, [sp, #4]
 80037ec:	429e      	cmp	r6, r3
 80037ee:	d90b      	bls.n	8003808 <HAL_I2C_IsDeviceReady+0xd0>
 80037f0:	f8d5 e000 	ldr.w	lr, [r5]
 80037f4:	e7c9      	b.n	800378a <HAL_I2C_IsDeviceReady+0x52>
      tickstart = HAL_GetTick();
      while((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET) && (hi2c->State != HAL_I2C_STATE_TIMEOUT))
      {
      	if(Timeout != HAL_MAX_DELAY)
      	{
          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 80037f6:	f1b9 0f00 	cmp.w	r9, #0
 80037fa:	d005      	beq.n	8003808 <HAL_I2C_IsDeviceReady+0xd0>
 80037fc:	f7fd f984 	bl	8000b08 <HAL_GetTick>
 8003800:	ebca 0000 	rsb	r0, sl, r0
 8003804:	4581      	cmp	r9, r0
 8003806:	d2cb      	bcs.n	80037a0 <HAL_I2C_IsDeviceReady+0x68>
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
      }      
    }while(I2C_Trials < Trials);

    hi2c->State = HAL_I2C_STATE_READY;
 8003808:	2201      	movs	r2, #1

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800380a:	2300      	movs	r3, #0
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
      }      
    }while(I2C_Trials < Trials);

    hi2c->State = HAL_I2C_STATE_READY;
 800380c:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8003810:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
        
    return HAL_TIMEOUT;
 8003814:	2003      	movs	r0, #3
 8003816:	e79a      	b.n	800374e <HAL_I2C_IsDeviceReady+0x16>
      
      /* Check if the maximum allowed number of trials has been reached */
      if (I2C_Trials++ == Trials)
      {
        /* Generate Stop */
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
 8003818:	6829      	ldr	r1, [r5, #0]
 800381a:	684b      	ldr	r3, [r1, #4]
 800381c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003820:	604b      	str	r3, [r1, #4]
        
        /* Wait until STOPF flag is reset */ 
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
 8003822:	4602      	mov	r2, r0
 8003824:	4621      	mov	r1, r4
 8003826:	4628      	mov	r0, r5
 8003828:	464b      	mov	r3, r9
 800382a:	f7fe fdd3 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 800382e:	2800      	cmp	r0, #0
 8003830:	d1f0      	bne.n	8003814 <HAL_I2C_IsDeviceReady+0xdc>
        {
          return HAL_TIMEOUT;
        }
        
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003832:	682b      	ldr	r3, [r5, #0]
 8003834:	61dc      	str	r4, [r3, #28]
 8003836:	e7d8      	b.n	80037ea <HAL_I2C_IsDeviceReady+0xb2>
      
      /* Check if the NACKF flag has not been set */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
      {
        /* Wait until STOPF flag is reset */ 
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
 8003838:	464b      	mov	r3, r9
 800383a:	4628      	mov	r0, r5
 800383c:	2120      	movs	r1, #32
 800383e:	f7fe fdc9 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8003842:	2800      	cmp	r0, #0
 8003844:	d1e6      	bne.n	8003814 <HAL_I2C_IsDeviceReady+0xdc>
        {
          return HAL_TIMEOUT;
        }
        
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003846:	682a      	ldr	r2, [r5, #0]
 8003848:	2120      	movs	r1, #32

        /* Device is ready */
        hi2c->State = HAL_I2C_STATE_READY;
 800384a:	2301      	movs	r3, #1
        {
          return HAL_TIMEOUT;
        }
        
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800384c:	61d1      	str	r1, [r2, #28]

        /* Device is ready */
        hi2c->State = HAL_I2C_STATE_READY;
        
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800384e:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
        
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

        /* Device is ready */
        hi2c->State = HAL_I2C_STATE_READY;
 8003852:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
        
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
        
        return HAL_OK;
 8003856:	e77a      	b.n	800374e <HAL_I2C_IsDeviceReady+0x16>

08003858 <HAL_I2C_MasterTxCpltCallback>:
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
 __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8003858:	4770      	bx	lr
 800385a:	bf00      	nop

0800385c <HAL_I2C_MasterRxCpltCallback>:
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 800385c:	4770      	bx	lr
 800385e:	bf00      	nop

08003860 <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
 __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8003860:	4770      	bx	lr
 8003862:	bf00      	nop

08003864 <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8003864:	4770      	bx	lr
 8003866:	bf00      	nop

08003868 <HAL_I2C_MemTxCpltCallback>:
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
 __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8003868:	4770      	bx	lr
 800386a:	bf00      	nop

0800386c <HAL_I2C_MemRxCpltCallback>:
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 800386c:	4770      	bx	lr
 800386e:	bf00      	nop

08003870 <HAL_I2C_ErrorCallback>:
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
 __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
 8003870:	4770      	bx	lr
 8003872:	bf00      	nop

08003874 <I2C_DMAError>:
  * @brief  DMA I2C communication error callback. 
  * @param hdma : DMA handle
  * @retval None
  */
static void I2C_DMAError(DMA_HandleTypeDef *hdma)   
{
 8003874:	b510      	push	{r4, lr}
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8003876:	6a80      	ldr	r0, [r0, #40]	; 0x28
  
  /* Disable Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8003878:	6802      	ldr	r2, [r0, #0]
 800387a:	6853      	ldr	r3, [r2, #4]
  
  hi2c->XferCount = 0;
 800387c:	2400      	movs	r4, #0
static void I2C_DMAError(DMA_HandleTypeDef *hdma)   
{
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Disable Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 800387e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  
  hi2c->XferCount = 0;
  
  hi2c->State = HAL_I2C_STATE_READY;
 8003882:	2101      	movs	r1, #1
static void I2C_DMAError(DMA_HandleTypeDef *hdma)   
{
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Disable Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8003884:	6053      	str	r3, [r2, #4]
  
  hi2c->XferCount = 0;
 8003886:	8544      	strh	r4, [r0, #42]	; 0x2a
  
  hi2c->State = HAL_I2C_STATE_READY;
 8003888:	f880 1035 	strb.w	r1, [r0, #53]	; 0x35
  
  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
 800388c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800388e:	f043 0310 	orr.w	r3, r3, #16
 8003892:	6383      	str	r3, [r0, #56]	; 0x38
  
  HAL_I2C_ErrorCallback(hi2c);
 8003894:	f7ff ffec 	bl	8003870 <HAL_I2C_ErrorCallback>
 8003898:	bd10      	pop	{r4, pc}
 800389a:	bf00      	nop

0800389c <I2C_DMAMasterTransmitCplt>:
  * @brief  DMA I2C master transmit process complete callback.
  * @param  hdma: DMA handle
  * @retval None
  */
static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma) 
{
 800389c:	b538      	push	{r3, r4, r5, lr}
  uint16_t DevAddress;
  I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 800389e:	6a84      	ldr	r4, [r0, #40]	; 0x28
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80038a0:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 80038a2:	2bff      	cmp	r3, #255	; 0xff
  {
    /* Wait until TCR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
 80038a4:	4620      	mov	r0, r4
  uint16_t DevAddress;
  I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80038a6:	d026      	beq.n	80038f6 <I2C_DMAMasterTransmitCplt+0x5a>
  }
  else
  {
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 80038a8:	2119      	movs	r1, #25
 80038aa:	f7fe fe65 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 80038ae:	b9c0      	cbnz	r0, 80038e2 <I2C_DMAMasterTransmitCplt+0x46>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
      }
    }
  
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80038b0:	6822      	ldr	r2, [r4, #0]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80038b2:	4b4f      	ldr	r3, [pc, #316]	; (80039f0 <I2C_DMAMasterTransmitCplt+0x154>)
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
      }
    }
  
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80038b4:	2120      	movs	r1, #32
 80038b6:	61d1      	str	r1, [r2, #28]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80038b8:	6822      	ldr	r2, [r4, #0]
 80038ba:	6851      	ldr	r1, [r2, #4]
 80038bc:	400b      	ands	r3, r1
 80038be:	6053      	str	r3, [r2, #4]

    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 80038c0:	6822      	ldr	r2, [r4, #0]
 80038c2:	6813      	ldr	r3, [r2, #0]
  
    hi2c->XferCount = 0;
 80038c4:	2000      	movs	r0, #0
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 80038c6:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  
    hi2c->XferCount = 0;
  
    hi2c->State = HAL_I2C_STATE_READY;
 80038ca:	2101      	movs	r1, #1
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 80038cc:	6013      	str	r3, [r2, #0]
  
    hi2c->XferCount = 0;
 80038ce:	8560      	strh	r0, [r4, #42]	; 0x2a
  
    hi2c->State = HAL_I2C_STATE_READY;
 80038d0:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35

   /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 80038d4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    {
      HAL_I2C_ErrorCallback(hi2c);
 80038d6:	4620      	mov	r0, r4
    hi2c->XferCount = 0;
  
    hi2c->State = HAL_I2C_STATE_READY;

   /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 80038d8:	2b00      	cmp	r3, #0
 80038da:	d155      	bne.n	8003988 <I2C_DMAMasterTransmitCplt+0xec>
    {
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      HAL_I2C_MasterTxCpltCallback(hi2c);
 80038dc:	f7ff ffbc 	bl	8003858 <HAL_I2C_MasterTxCpltCallback>
 80038e0:	bd38      	pop	{r3, r4, r5, pc}
  {
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80038e2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80038e4:	2b04      	cmp	r3, #4
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80038e6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80038e8:	bf0c      	ite	eq
 80038ea:	f043 0304 	orreq.w	r3, r3, #4
      }
      else
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80038ee:	f043 0320 	orrne.w	r3, r3, #32
 80038f2:	63a3      	str	r3, [r4, #56]	; 0x38
 80038f4:	e7dc      	b.n	80038b0 <I2C_DMAMasterTransmitCplt+0x14>
  uint16_t DevAddress;
  I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80038f6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80038f8:	b29b      	uxth	r3, r3
 80038fa:	2bff      	cmp	r3, #255	; 0xff
 80038fc:	d9d4      	bls.n	80038a8 <I2C_DMAMasterTransmitCplt+0xc>
  {
    /* Wait until TCR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
 80038fe:	2180      	movs	r1, #128	; 0x80
 8003900:	2200      	movs	r2, #0
 8003902:	2319      	movs	r3, #25
 8003904:	f7fe fd66 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8003908:	b118      	cbz	r0, 8003912 <I2C_DMAMasterTransmitCplt+0x76>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800390a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800390c:	f043 0320 	orr.w	r3, r3, #32
 8003910:	63a3      	str	r3, [r4, #56]	; 0x38
    }

    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 8003912:	6822      	ldr	r2, [r4, #0]
 8003914:	6813      	ldr	r3, [r2, #0]
 8003916:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800391a:	6013      	str	r3, [r2, #0]
    
    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 800391c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800391e:	2b00      	cmp	r3, #0
 8003920:	d135      	bne.n	800398e <I2C_DMAMasterTransmitCplt+0xf2>
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
      hi2c->XferCount -= hi2c->XferSize;
 8003922:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003924:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8003926:	6a61      	ldr	r1, [r4, #36]	; 0x24
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
              
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 8003928:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
      hi2c->XferCount -= hi2c->XferSize;
 800392a:	1ad2      	subs	r2, r2, r3
 800392c:	b292      	uxth	r2, r2
 800392e:	8562      	strh	r2, [r4, #42]	; 0x2a
      if(hi2c->XferCount > 255)
 8003930:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003932:	4419      	add	r1, r3
      hi2c->XferCount -= hi2c->XferSize;
      if(hi2c->XferCount > 255)
 8003934:	b293      	uxth	r3, r2
 8003936:	2bff      	cmp	r3, #255	; 0xff
      {
        hi2c->XferSize = 255;
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
 8003938:	bf98      	it	ls
 800393a:	8d63      	ldrhls	r3, [r4, #42]	; 0x2a
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 800393c:	6822      	ldr	r2, [r4, #0]
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 800393e:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount -= hi2c->XferSize;
      if(hi2c->XferCount > 255)
      {
        hi2c->XferSize = 255;
 8003940:	bf8c      	ite	hi
 8003942:	23ff      	movhi	r3, #255	; 0xff
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
 8003944:	b29b      	uxthls	r3, r3
 8003946:	8523      	strh	r3, [r4, #40]	; 0x28
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003948:	6855      	ldr	r5, [r2, #4]
              
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 800394a:	3228      	adds	r2, #40	; 0x28
 800394c:	f7fd fdec 	bl	8001528 <HAL_DMA_Start_IT>
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003950:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8003952:	29ff      	cmp	r1, #255	; 0xff
      else
      {
        hi2c->XferSize = hi2c->XferCount;
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003954:	b2ad      	uxth	r5, r5
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003956:	d039      	beq.n	80039cc <I2C_DMAMasterTransmitCplt+0x130>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003958:	6820      	ldr	r0, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800395a:	4a26      	ldr	r2, [pc, #152]	; (80039f4 <I2C_DMAMasterTransmitCplt+0x158>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 800395c:	6843      	ldr	r3, [r0, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800395e:	401a      	ands	r2, r3
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003960:	f3c5 0309 	ubfx	r3, r5, #0, #10
 8003964:	f042 7500 	orr.w	r5, r2, #33554432	; 0x2000000
 8003968:	b2c9      	uxtb	r1, r1
 800396a:	431d      	orrs	r5, r3
 800396c:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003970:	6045      	str	r5, [r0, #4]
      {
        I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
      }  

      /* Wait until TXIS flag is set */
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
 8003972:	4620      	mov	r0, r4
 8003974:	2119      	movs	r1, #25
 8003976:	f7fe fd69 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
 800397a:	b940      	cbnz	r0, 800398e <I2C_DMAMasterTransmitCplt+0xf2>
        HAL_I2C_ErrorCallback(hi2c);
      }
      else
      {
        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
 800397c:	6822      	ldr	r2, [r4, #0]
 800397e:	6813      	ldr	r3, [r2, #0]
 8003980:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003984:	6013      	str	r3, [r2, #0]
 8003986:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->State = HAL_I2C_STATE_READY;

   /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
    {
      HAL_I2C_ErrorCallback(hi2c);
 8003988:	f7ff ff72 	bl	8003870 <HAL_I2C_ErrorCallback>
 800398c:	bd38      	pop	{r3, r4, r5, pc}
      /* Wait until TXIS flag is set */
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
      {
        /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
        /* Wait until STOPF flag is reset */ 
        if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 800398e:	4620      	mov	r0, r4
 8003990:	2119      	movs	r1, #25
 8003992:	f7fe fdf1 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003996:	b140      	cbz	r0, 80039aa <I2C_DMAMasterTransmitCplt+0x10e>
        {
          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003998:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800399a:	2b04      	cmp	r3, #4
          {
            hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800399c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800399e:	bf0c      	ite	eq
 80039a0:	f043 0304 	orreq.w	r3, r3, #4
          }
          else
          {
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80039a4:	f043 0320 	orrne.w	r3, r3, #32
 80039a8:	63a3      	str	r3, [r4, #56]	; 0x38
          }
        }
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80039aa:	6822      	ldr	r2, [r4, #0]
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 80039ac:	4b10      	ldr	r3, [pc, #64]	; (80039f0 <I2C_DMAMasterTransmitCplt+0x154>)
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
          }
        }
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80039ae:	2120      	movs	r1, #32
 80039b0:	61d1      	str	r1, [r2, #28]
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 80039b2:	6822      	ldr	r2, [r4, #0]
 80039b4:	6851      	ldr	r1, [r2, #4]

        hi2c->XferCount = 0;
 80039b6:	2500      	movs	r5, #0
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 80039b8:	400b      	ands	r3, r1

        hi2c->XferCount = 0;
      
        hi2c->State = HAL_I2C_STATE_READY;
 80039ba:	2101      	movs	r1, #1
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 80039bc:	6053      	str	r3, [r2, #4]

        hi2c->XferCount = 0;
      
        hi2c->State = HAL_I2C_STATE_READY;
        HAL_I2C_ErrorCallback(hi2c);
 80039be:	4620      	mov	r0, r4
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);

        hi2c->XferCount = 0;
 80039c0:	8565      	strh	r5, [r4, #42]	; 0x2a
      
        hi2c->State = HAL_I2C_STATE_READY;
 80039c2:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
        HAL_I2C_ErrorCallback(hi2c);
 80039c6:	f7ff ff53 	bl	8003870 <HAL_I2C_ErrorCallback>
 80039ca:	bd38      	pop	{r3, r4, r5, pc}
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80039cc:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80039ce:	b29b      	uxth	r3, r3
 80039d0:	2bff      	cmp	r3, #255	; 0xff
 80039d2:	d9c1      	bls.n	8003958 <I2C_DMAMasterTransmitCplt+0xbc>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80039d4:	6822      	ldr	r2, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80039d6:	4b07      	ldr	r3, [pc, #28]	; (80039f4 <I2C_DMAMasterTransmitCplt+0x158>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80039d8:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80039da:	400b      	ands	r3, r1
 80039dc:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80039e0:	f3c5 0509 	ubfx	r5, r5, #0, #10
 80039e4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80039e8:	432b      	orrs	r3, r5
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80039ea:	6053      	str	r3, [r2, #4]
 80039ec:	e7c1      	b.n	8003972 <I2C_DMAMasterTransmitCplt+0xd6>
 80039ee:	bf00      	nop
 80039f0:	fe00e800 	.word	0xfe00e800
 80039f4:	fc009800 	.word	0xfc009800

080039f8 <I2C_DMAMasterReceiveCplt>:
  * @brief DMA I2C master receive process complete callback 
  * @param  hdma: DMA handle
  * @retval None
  */
static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma) 
{
 80039f8:	b538      	push	{r3, r4, r5, lr}
  I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 80039fa:	6a84      	ldr	r4, [r0, #40]	; 0x28
  uint16_t DevAddress;
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 80039fc:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 80039fe:	2bff      	cmp	r3, #255	; 0xff
  {
    /* Wait until TCR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
 8003a00:	4620      	mov	r0, r4
  I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
  uint16_t DevAddress;
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003a02:	d026      	beq.n	8003a52 <I2C_DMAMasterReceiveCplt+0x5a>
  }
  else
  {
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8003a04:	2119      	movs	r1, #25
 8003a06:	f7fe fdb7 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003a0a:	b9c0      	cbnz	r0, 8003a3e <I2C_DMAMasterReceiveCplt+0x46>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
      }
    }
  
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003a0c:	6822      	ldr	r2, [r4, #0]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003a0e:	4b53      	ldr	r3, [pc, #332]	; (8003b5c <I2C_DMAMasterReceiveCplt+0x164>)
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
      }
    }
  
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003a10:	2120      	movs	r1, #32
 8003a12:	61d1      	str	r1, [r2, #28]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003a14:	6822      	ldr	r2, [r4, #0]
 8003a16:	6851      	ldr	r1, [r2, #4]
 8003a18:	400b      	ands	r3, r1
 8003a1a:	6053      	str	r3, [r2, #4]
  
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
 8003a1c:	6822      	ldr	r2, [r4, #0]
 8003a1e:	6813      	ldr	r3, [r2, #0]
  
    hi2c->XferCount = 0;
 8003a20:	2000      	movs	r0, #0
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
  
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
 8003a22:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  
    hi2c->XferCount = 0;
  
    hi2c->State = HAL_I2C_STATE_READY;
 8003a26:	2101      	movs	r1, #1
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
  
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
 8003a28:	6013      	str	r3, [r2, #0]
  
    hi2c->XferCount = 0;
 8003a2a:	8560      	strh	r0, [r4, #42]	; 0x2a
  
    hi2c->State = HAL_I2C_STATE_READY;
 8003a2c:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003a30:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    {
      HAL_I2C_ErrorCallback(hi2c);
 8003a32:	4620      	mov	r0, r4
    hi2c->XferCount = 0;
  
    hi2c->State = HAL_I2C_STATE_READY;

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003a34:	2b00      	cmp	r3, #0
 8003a36:	d15d      	bne.n	8003af4 <I2C_DMAMasterReceiveCplt+0xfc>
    {
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      HAL_I2C_MasterRxCpltCallback(hi2c);
 8003a38:	f7ff ff10 	bl	800385c <HAL_I2C_MasterRxCpltCallback>
 8003a3c:	bd38      	pop	{r3, r4, r5, pc}
  {
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003a3e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003a40:	2b04      	cmp	r3, #4
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8003a42:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003a44:	bf0c      	ite	eq
 8003a46:	f043 0304 	orreq.w	r3, r3, #4
      }
      else
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003a4a:	f043 0320 	orrne.w	r3, r3, #32
 8003a4e:	63a3      	str	r3, [r4, #56]	; 0x38
 8003a50:	e7dc      	b.n	8003a0c <I2C_DMAMasterReceiveCplt+0x14>
  I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
  uint16_t DevAddress;
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003a52:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003a54:	b29b      	uxth	r3, r3
 8003a56:	2bff      	cmp	r3, #255	; 0xff
 8003a58:	d9d4      	bls.n	8003a04 <I2C_DMAMasterReceiveCplt+0xc>
  {
    /* Wait until TCR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
 8003a5a:	2180      	movs	r1, #128	; 0x80
 8003a5c:	2200      	movs	r2, #0
 8003a5e:	2319      	movs	r3, #25
 8003a60:	f7fe fcb8 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8003a64:	b118      	cbz	r0, 8003a6e <I2C_DMAMasterReceiveCplt+0x76>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003a66:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003a68:	f043 0320 	orr.w	r3, r3, #32
 8003a6c:	63a3      	str	r3, [r4, #56]	; 0x38
    }

    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
 8003a6e:	6822      	ldr	r2, [r4, #0]
 8003a70:	6813      	ldr	r3, [r2, #0]
 8003a72:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003a76:	6013      	str	r3, [r2, #0]

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003a78:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003a7a:	2b00      	cmp	r3, #0
 8003a7c:	d13d      	bne.n	8003afa <I2C_DMAMasterReceiveCplt+0x102>
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
      hi2c->XferCount -= hi2c->XferSize;
 8003a7e:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003a80:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8003a82:	6a62      	ldr	r2, [r4, #36]	; 0x24
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
              
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
 8003a84:	6b20      	ldr	r0, [r4, #48]	; 0x30
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
      hi2c->XferCount -= hi2c->XferSize;
 8003a86:	1ac9      	subs	r1, r1, r3
 8003a88:	b289      	uxth	r1, r1
 8003a8a:	8561      	strh	r1, [r4, #42]	; 0x2a
      if(hi2c->XferCount > 255)
 8003a8c:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003a8e:	441a      	add	r2, r3
      hi2c->XferCount -= hi2c->XferSize;
      if(hi2c->XferCount > 255)
 8003a90:	b28b      	uxth	r3, r1
 8003a92:	2bff      	cmp	r3, #255	; 0xff
      {
        hi2c->XferSize = 255;
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
 8003a94:	bf98      	it	ls
 8003a96:	8d63      	ldrhls	r3, [r4, #42]	; 0x2a
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003a98:	6821      	ldr	r1, [r4, #0]
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003a9a:	6262      	str	r2, [r4, #36]	; 0x24
      hi2c->XferCount -= hi2c->XferSize;
      if(hi2c->XferCount > 255)
      {
        hi2c->XferSize = 255;
 8003a9c:	bf8c      	ite	hi
 8003a9e:	23ff      	movhi	r3, #255	; 0xff
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
 8003aa0:	b29b      	uxthls	r3, r3
 8003aa2:	8523      	strh	r3, [r4, #40]	; 0x28
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003aa4:	684d      	ldr	r5, [r1, #4]
              
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
 8003aa6:	3124      	adds	r1, #36	; 0x24
 8003aa8:	f7fd fd3e 	bl	8001528 <HAL_DMA_Start_IT>
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003aac:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8003aae:	29ff      	cmp	r1, #255	; 0xff
      else
      {
        hi2c->XferSize = hi2c->XferCount;
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003ab0:	b2ad      	uxth	r5, r5
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003ab2:	d041      	beq.n	8003b38 <I2C_DMAMasterReceiveCplt+0x140>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003ab4:	6820      	ldr	r0, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003ab6:	4a2a      	ldr	r2, [pc, #168]	; (8003b60 <I2C_DMAMasterReceiveCplt+0x168>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003ab8:	6843      	ldr	r3, [r0, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003aba:	401a      	ands	r2, r3
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003abc:	f3c5 0309 	ubfx	r3, r5, #0, #10
 8003ac0:	f042 7500 	orr.w	r5, r2, #33554432	; 0x2000000
 8003ac4:	b2c9      	uxtb	r1, r1
 8003ac6:	431d      	orrs	r5, r3
 8003ac8:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003acc:	6045      	str	r5, [r0, #4]
      {
        I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
      }  

      /* Wait until RXNE flag is set */
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
 8003ace:	4620      	mov	r0, r4
 8003ad0:	2104      	movs	r1, #4
 8003ad2:	2200      	movs	r2, #0
 8003ad4:	2319      	movs	r3, #25
 8003ad6:	f7fe fc7d 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8003ada:	b118      	cbz	r0, 8003ae4 <I2C_DMAMasterReceiveCplt+0xec>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003adc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003ade:	f043 0320 	orr.w	r3, r3, #32
 8003ae2:	63a3      	str	r3, [r4, #56]	; 0x38
      }
      
      /* Check if Errors has been detected during transfer */
      if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003ae4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003ae6:	b943      	cbnz	r3, 8003afa <I2C_DMAMasterReceiveCplt+0x102>
        HAL_I2C_ErrorCallback(hi2c);
      }
      else
      {
        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
 8003ae8:	6822      	ldr	r2, [r4, #0]
 8003aea:	6813      	ldr	r3, [r2, #0]
 8003aec:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003af0:	6013      	str	r3, [r2, #0]
 8003af2:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->State = HAL_I2C_STATE_READY;

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
    {
      HAL_I2C_ErrorCallback(hi2c);
 8003af4:	f7ff febc 	bl	8003870 <HAL_I2C_ErrorCallback>
 8003af8:	bd38      	pop	{r3, r4, r5, pc}
      /* Check if Errors has been detected during transfer */
      if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
      {
        /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
        /* Wait until STOPF flag is reset */ 
        if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8003afa:	4620      	mov	r0, r4
 8003afc:	2119      	movs	r1, #25
 8003afe:	f7fe fd3b 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003b02:	b140      	cbz	r0, 8003b16 <I2C_DMAMasterReceiveCplt+0x11e>
        {
          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003b04:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003b06:	2b04      	cmp	r3, #4
          {
            hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8003b08:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003b0a:	bf0c      	ite	eq
 8003b0c:	f043 0304 	orreq.w	r3, r3, #4
          }
          else
          {
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003b10:	f043 0320 	orrne.w	r3, r3, #32
 8003b14:	63a3      	str	r3, [r4, #56]	; 0x38
          }
        }
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003b16:	6822      	ldr	r2, [r4, #0]
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003b18:	4b10      	ldr	r3, [pc, #64]	; (8003b5c <I2C_DMAMasterReceiveCplt+0x164>)
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
          }
        }
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003b1a:	2120      	movs	r1, #32
 8003b1c:	61d1      	str	r1, [r2, #28]
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003b1e:	6822      	ldr	r2, [r4, #0]
 8003b20:	6851      	ldr	r1, [r2, #4]
      
        hi2c->XferCount = 0;
 8003b22:	2500      	movs	r5, #0
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003b24:	400b      	ands	r3, r1
      
        hi2c->XferCount = 0;
      
        hi2c->State = HAL_I2C_STATE_READY;
 8003b26:	2101      	movs	r1, #1
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003b28:	6053      	str	r3, [r2, #4]
      
        hi2c->XferCount = 0;
      
        hi2c->State = HAL_I2C_STATE_READY;
      
        HAL_I2C_ErrorCallback(hi2c);
 8003b2a:	4620      	mov	r0, r4
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
      
        hi2c->XferCount = 0;
 8003b2c:	8565      	strh	r5, [r4, #42]	; 0x2a
      
        hi2c->State = HAL_I2C_STATE_READY;
 8003b2e:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
      
        HAL_I2C_ErrorCallback(hi2c);
 8003b32:	f7ff fe9d 	bl	8003870 <HAL_I2C_ErrorCallback>
 8003b36:	bd38      	pop	{r3, r4, r5, pc}
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003b38:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003b3a:	b29b      	uxth	r3, r3
 8003b3c:	2bff      	cmp	r3, #255	; 0xff
 8003b3e:	d9b9      	bls.n	8003ab4 <I2C_DMAMasterReceiveCplt+0xbc>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003b40:	6822      	ldr	r2, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003b42:	4b07      	ldr	r3, [pc, #28]	; (8003b60 <I2C_DMAMasterReceiveCplt+0x168>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003b44:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003b46:	400b      	ands	r3, r1
 8003b48:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003b4c:	f3c5 0509 	ubfx	r5, r5, #0, #10
 8003b50:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003b54:	432b      	orrs	r3, r5
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003b56:	6053      	str	r3, [r2, #4]
 8003b58:	e7b9      	b.n	8003ace <I2C_DMAMasterReceiveCplt+0xd6>
 8003b5a:	bf00      	nop
 8003b5c:	fe00e800 	.word	0xfe00e800
 8003b60:	fc009800 	.word	0xfc009800

08003b64 <I2C_DMASlaveTransmitCplt>:
  * @brief  DMA I2C slave transmit process complete callback. 
  * @param  hdma: DMA handle
  * @retval None
  */
static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma) 
{
 8003b64:	b510      	push	{r4, lr}
  I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 8003b66:	6a84      	ldr	r4, [r0, #40]	; 0x28
  
  /* Wait until STOP flag is set */
  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8003b68:	2119      	movs	r1, #25
 8003b6a:	4620      	mov	r0, r4
 8003b6c:	f7fe fd04 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003b70:	b138      	cbz	r0, 8003b82 <I2C_DMASlaveTransmitCplt+0x1e>
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003b72:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003b74:	2b04      	cmp	r3, #4
      /* to inform slave the end of transfer */
      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    }
    else
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003b76:	bf16      	itet	ne
 8003b78:	6ba3      	ldrne	r3, [r4, #56]	; 0x38
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    {
      /* Normal Use case, a AF is generated by master */
      /* to inform slave the end of transfer */
      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003b7a:	2300      	moveq	r3, #0
    }
    else
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003b7c:	f043 0320 	orrne.w	r3, r3, #32
 8003b80:	63a3      	str	r3, [r4, #56]	; 0x38
    }
  }
  
  /* Clear STOP flag */
  __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
 8003b82:	6823      	ldr	r3, [r4, #0]
 8003b84:	2220      	movs	r2, #32
 8003b86:	61da      	str	r2, [r3, #28]
  
  /* Wait until BUSY flag is reset */ 
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY) != HAL_OK)      
 8003b88:	4620      	mov	r0, r4
 8003b8a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8003b8e:	2201      	movs	r2, #1
 8003b90:	2319      	movs	r3, #25
 8003b92:	f7fe fc1f 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8003b96:	b118      	cbz	r0, 8003ba0 <I2C_DMASlaveTransmitCplt+0x3c>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003b98:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003b9a:	f043 0320 	orr.w	r3, r3, #32
 8003b9e:	63a3      	str	r3, [r4, #56]	; 0x38
  }
  
  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 8003ba0:	6822      	ldr	r2, [r4, #0]
 8003ba2:	6813      	ldr	r3, [r2, #0]
  
  hi2c->XferCount = 0;
 8003ba4:	2000      	movs	r0, #0
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
  }
  
  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 8003ba6:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  
  hi2c->XferCount = 0;
  
  hi2c->State = HAL_I2C_STATE_READY;
 8003baa:	2101      	movs	r1, #1
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
  }
  
  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 8003bac:	6013      	str	r3, [r2, #0]
  
  hi2c->XferCount = 0;
 8003bae:	8560      	strh	r0, [r4, #42]	; 0x2a
  
  hi2c->State = HAL_I2C_STATE_READY;
 8003bb0:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35

  /* Check if Errors has been detected during transfer */
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003bb4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  {
    HAL_I2C_ErrorCallback(hi2c);
 8003bb6:	4620      	mov	r0, r4
  hi2c->XferCount = 0;
  
  hi2c->State = HAL_I2C_STATE_READY;

  /* Check if Errors has been detected during transfer */
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003bb8:	b913      	cbnz	r3, 8003bc0 <I2C_DMASlaveTransmitCplt+0x5c>
  {
    HAL_I2C_ErrorCallback(hi2c);
  }
  else
  {
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8003bba:	f7ff fe51 	bl	8003860 <HAL_I2C_SlaveTxCpltCallback>
 8003bbe:	bd10      	pop	{r4, pc}
  hi2c->State = HAL_I2C_STATE_READY;

  /* Check if Errors has been detected during transfer */
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
  {
    HAL_I2C_ErrorCallback(hi2c);
 8003bc0:	f7ff fe56 	bl	8003870 <HAL_I2C_ErrorCallback>
 8003bc4:	bd10      	pop	{r4, pc}
 8003bc6:	bf00      	nop

08003bc8 <I2C_DMASlaveReceiveCplt>:
  * @brief  DMA I2C slave receive process complete callback.
  * @param  hdma: DMA handle
  * @retval None
  */
static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma) 
{  
 8003bc8:	b510      	push	{r4, lr}
  I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 8003bca:	6a84      	ldr	r4, [r0, #40]	; 0x28
  
  /* Wait until STOPF flag is reset */ 
  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8003bcc:	2119      	movs	r1, #25
 8003bce:	4620      	mov	r0, r4
 8003bd0:	f7fe fcd2 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003bd4:	b140      	cbz	r0, 8003be8 <I2C_DMASlaveReceiveCplt+0x20>
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003bd6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003bd8:	2b04      	cmp	r3, #4
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8003bda:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003bdc:	bf0c      	ite	eq
 8003bde:	f043 0304 	orreq.w	r3, r3, #4
    }
    else
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003be2:	f043 0320 	orrne.w	r3, r3, #32
 8003be6:	63a3      	str	r3, [r4, #56]	; 0x38
    }
  }
  
  /* Clear STOPF flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003be8:	6823      	ldr	r3, [r4, #0]
 8003bea:	2220      	movs	r2, #32
 8003bec:	61da      	str	r2, [r3, #28]
  
  /* Wait until BUSY flag is reset */ 
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY) != HAL_OK)      
 8003bee:	4620      	mov	r0, r4
 8003bf0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8003bf4:	2201      	movs	r2, #1
 8003bf6:	2319      	movs	r3, #25
 8003bf8:	f7fe fbec 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8003bfc:	b118      	cbz	r0, 8003c06 <I2C_DMASlaveReceiveCplt+0x3e>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003bfe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003c00:	f043 0320 	orr.w	r3, r3, #32
 8003c04:	63a3      	str	r3, [r4, #56]	; 0x38
  }
  
  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
 8003c06:	6822      	ldr	r2, [r4, #0]
 8003c08:	6813      	ldr	r3, [r2, #0]
 8003c0a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003c0e:	6013      	str	r3, [r2, #0]
  
  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8003c10:	6822      	ldr	r2, [r4, #0]
 8003c12:	6853      	ldr	r3, [r2, #4]

  hi2c->XferCount = 0;
 8003c14:	2000      	movs	r0, #0
  
  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
  
  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8003c16:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000

  hi2c->XferCount = 0;
  
  hi2c->State = HAL_I2C_STATE_READY;
 8003c1a:	2101      	movs	r1, #1
  
  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
  
  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8003c1c:	6053      	str	r3, [r2, #4]

  hi2c->XferCount = 0;
 8003c1e:	8560      	strh	r0, [r4, #42]	; 0x2a
  
  hi2c->State = HAL_I2C_STATE_READY;
 8003c20:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35

  /* Check if Errors has been detected during transfer */
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003c24:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  {
    HAL_I2C_ErrorCallback(hi2c);
 8003c26:	4620      	mov	r0, r4
  hi2c->XferCount = 0;
  
  hi2c->State = HAL_I2C_STATE_READY;

  /* Check if Errors has been detected during transfer */
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003c28:	b913      	cbnz	r3, 8003c30 <I2C_DMASlaveReceiveCplt+0x68>
  {
    HAL_I2C_ErrorCallback(hi2c);
  }
  else
  {
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8003c2a:	f7ff fe1b 	bl	8003864 <HAL_I2C_SlaveRxCpltCallback>
 8003c2e:	bd10      	pop	{r4, pc}
  hi2c->State = HAL_I2C_STATE_READY;

  /* Check if Errors has been detected during transfer */
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
  {
    HAL_I2C_ErrorCallback(hi2c);
 8003c30:	f7ff fe1e 	bl	8003870 <HAL_I2C_ErrorCallback>
 8003c34:	bd10      	pop	{r4, pc}
 8003c36:	bf00      	nop

08003c38 <I2C_DMAMemTransmitCplt>:
  * @brief DMA I2C Memory Write process complete callback 
  * @param hdma : DMA handle
  * @retval None
  */
static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma)   
{
 8003c38:	b538      	push	{r3, r4, r5, lr}
  uint16_t DevAddress;
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8003c3a:	6a84      	ldr	r4, [r0, #40]	; 0x28
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003c3c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8003c3e:	2bff      	cmp	r3, #255	; 0xff
  {
    /* Wait until TCR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
 8003c40:	4620      	mov	r0, r4
  uint16_t DevAddress;
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003c42:	d026      	beq.n	8003c92 <I2C_DMAMemTransmitCplt+0x5a>
  }
  else
  {
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8003c44:	2119      	movs	r1, #25
 8003c46:	f7fe fc97 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003c4a:	b9c0      	cbnz	r0, 8003c7e <I2C_DMAMemTransmitCplt+0x46>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
      }
    }
  
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003c4c:	6822      	ldr	r2, [r4, #0]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003c4e:	4b4f      	ldr	r3, [pc, #316]	; (8003d8c <I2C_DMAMemTransmitCplt+0x154>)
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
      }
    }
  
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003c50:	2120      	movs	r1, #32
 8003c52:	61d1      	str	r1, [r2, #28]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003c54:	6822      	ldr	r2, [r4, #0]
 8003c56:	6851      	ldr	r1, [r2, #4]
 8003c58:	400b      	ands	r3, r1
 8003c5a:	6053      	str	r3, [r2, #4]

    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 8003c5c:	6822      	ldr	r2, [r4, #0]
 8003c5e:	6813      	ldr	r3, [r2, #0]
  
    hi2c->XferCount = 0;
 8003c60:	2000      	movs	r0, #0
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 8003c62:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  
    hi2c->XferCount = 0;
  
    hi2c->State = HAL_I2C_STATE_READY;
 8003c66:	2101      	movs	r1, #1
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 8003c68:	6013      	str	r3, [r2, #0]
  
    hi2c->XferCount = 0;
 8003c6a:	8560      	strh	r0, [r4, #42]	; 0x2a
  
    hi2c->State = HAL_I2C_STATE_READY;
 8003c6c:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003c70:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    {
      HAL_I2C_ErrorCallback(hi2c);
 8003c72:	4620      	mov	r0, r4
    hi2c->XferCount = 0;
  
    hi2c->State = HAL_I2C_STATE_READY;

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003c74:	2b00      	cmp	r3, #0
 8003c76:	d155      	bne.n	8003d24 <I2C_DMAMemTransmitCplt+0xec>
    {
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      HAL_I2C_MemTxCpltCallback(hi2c);
 8003c78:	f7ff fdf6 	bl	8003868 <HAL_I2C_MemTxCpltCallback>
 8003c7c:	bd38      	pop	{r3, r4, r5, pc}
  {
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003c7e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003c80:	2b04      	cmp	r3, #4
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8003c82:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003c84:	bf0c      	ite	eq
 8003c86:	f043 0304 	orreq.w	r3, r3, #4
      }
      else
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003c8a:	f043 0320 	orrne.w	r3, r3, #32
 8003c8e:	63a3      	str	r3, [r4, #56]	; 0x38
 8003c90:	e7dc      	b.n	8003c4c <I2C_DMAMemTransmitCplt+0x14>
  uint16_t DevAddress;
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003c92:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003c94:	b29b      	uxth	r3, r3
 8003c96:	2bff      	cmp	r3, #255	; 0xff
 8003c98:	d9d4      	bls.n	8003c44 <I2C_DMAMemTransmitCplt+0xc>
  {
    /* Wait until TCR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
 8003c9a:	2180      	movs	r1, #128	; 0x80
 8003c9c:	2200      	movs	r2, #0
 8003c9e:	2319      	movs	r3, #25
 8003ca0:	f7fe fb98 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8003ca4:	b118      	cbz	r0, 8003cae <I2C_DMAMemTransmitCplt+0x76>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003ca6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003ca8:	f043 0320 	orr.w	r3, r3, #32
 8003cac:	63a3      	str	r3, [r4, #56]	; 0x38
    }

    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
 8003cae:	6822      	ldr	r2, [r4, #0]
 8003cb0:	6813      	ldr	r3, [r2, #0]
 8003cb2:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003cb6:	6013      	str	r3, [r2, #0]
    
    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003cb8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003cba:	2b00      	cmp	r3, #0
 8003cbc:	d135      	bne.n	8003d2a <I2C_DMAMemTransmitCplt+0xf2>
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
      hi2c->XferCount -= hi2c->XferSize;
 8003cbe:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003cc0:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8003cc2:	6a61      	ldr	r1, [r4, #36]	; 0x24
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
              
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 8003cc4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
      hi2c->XferCount -= hi2c->XferSize;
 8003cc6:	1ad2      	subs	r2, r2, r3
 8003cc8:	b292      	uxth	r2, r2
 8003cca:	8562      	strh	r2, [r4, #42]	; 0x2a
      if(hi2c->XferCount > 255)
 8003ccc:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003cce:	4419      	add	r1, r3
      hi2c->XferCount -= hi2c->XferSize;
      if(hi2c->XferCount > 255)
 8003cd0:	b293      	uxth	r3, r2
 8003cd2:	2bff      	cmp	r3, #255	; 0xff
      {
        hi2c->XferSize = 255;
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
 8003cd4:	bf98      	it	ls
 8003cd6:	8d63      	ldrhls	r3, [r4, #42]	; 0x2a
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003cd8:	6822      	ldr	r2, [r4, #0]
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003cda:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount -= hi2c->XferSize;
      if(hi2c->XferCount > 255)
      {
        hi2c->XferSize = 255;
 8003cdc:	bf8c      	ite	hi
 8003cde:	23ff      	movhi	r3, #255	; 0xff
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
 8003ce0:	b29b      	uxthls	r3, r3
 8003ce2:	8523      	strh	r3, [r4, #40]	; 0x28
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003ce4:	6855      	ldr	r5, [r2, #4]
              
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 8003ce6:	3228      	adds	r2, #40	; 0x28
 8003ce8:	f7fd fc1e 	bl	8001528 <HAL_DMA_Start_IT>
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003cec:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8003cee:	29ff      	cmp	r1, #255	; 0xff
      else
      {
        hi2c->XferSize = hi2c->XferCount;
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003cf0:	b2ad      	uxth	r5, r5
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003cf2:	d039      	beq.n	8003d68 <I2C_DMAMemTransmitCplt+0x130>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003cf4:	6820      	ldr	r0, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003cf6:	4a26      	ldr	r2, [pc, #152]	; (8003d90 <I2C_DMAMemTransmitCplt+0x158>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003cf8:	6843      	ldr	r3, [r0, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003cfa:	401a      	ands	r2, r3
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003cfc:	f3c5 0309 	ubfx	r3, r5, #0, #10
 8003d00:	f042 7500 	orr.w	r5, r2, #33554432	; 0x2000000
 8003d04:	b2c9      	uxtb	r1, r1
 8003d06:	431d      	orrs	r5, r3
 8003d08:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003d0c:	6045      	str	r5, [r0, #4]
      {
        I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
      }  

      /* Wait until TXIS flag is set */
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
 8003d0e:	4620      	mov	r0, r4
 8003d10:	2119      	movs	r1, #25
 8003d12:	f7fe fb9b 	bl	800244c <I2C_WaitOnTXISFlagUntilTimeout>
 8003d16:	b940      	cbnz	r0, 8003d2a <I2C_DMAMemTransmitCplt+0xf2>
        HAL_I2C_ErrorCallback(hi2c);
      }
      else
      {
        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
 8003d18:	6822      	ldr	r2, [r4, #0]
 8003d1a:	6813      	ldr	r3, [r2, #0]
 8003d1c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003d20:	6013      	str	r3, [r2, #0]
 8003d22:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->State = HAL_I2C_STATE_READY;

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
    {
      HAL_I2C_ErrorCallback(hi2c);
 8003d24:	f7ff fda4 	bl	8003870 <HAL_I2C_ErrorCallback>
 8003d28:	bd38      	pop	{r3, r4, r5, pc}
      /* Wait until TXIS flag is set */
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
      {
        /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
        /* Wait until STOPF flag is reset */ 
        if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8003d2a:	4620      	mov	r0, r4
 8003d2c:	2119      	movs	r1, #25
 8003d2e:	f7fe fc23 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003d32:	b140      	cbz	r0, 8003d46 <I2C_DMAMemTransmitCplt+0x10e>
        {
          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003d34:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003d36:	2b04      	cmp	r3, #4
          {
            hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8003d38:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003d3a:	bf0c      	ite	eq
 8003d3c:	f043 0304 	orreq.w	r3, r3, #4
          }
          else
          {
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003d40:	f043 0320 	orrne.w	r3, r3, #32
 8003d44:	63a3      	str	r3, [r4, #56]	; 0x38
          }
        }
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003d46:	6822      	ldr	r2, [r4, #0]
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003d48:	4b10      	ldr	r3, [pc, #64]	; (8003d8c <I2C_DMAMemTransmitCplt+0x154>)
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
          }
        }
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003d4a:	2120      	movs	r1, #32
 8003d4c:	61d1      	str	r1, [r2, #28]
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003d4e:	6822      	ldr	r2, [r4, #0]
 8003d50:	6851      	ldr	r1, [r2, #4]

        hi2c->XferCount = 0;
 8003d52:	2500      	movs	r5, #0
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003d54:	400b      	ands	r3, r1

        hi2c->XferCount = 0;
      
        hi2c->State = HAL_I2C_STATE_READY;
 8003d56:	2101      	movs	r1, #1
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003d58:	6053      	str	r3, [r2, #4]

        hi2c->XferCount = 0;
      
        hi2c->State = HAL_I2C_STATE_READY;
        HAL_I2C_ErrorCallback(hi2c);
 8003d5a:	4620      	mov	r0, r4
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);

        hi2c->XferCount = 0;
 8003d5c:	8565      	strh	r5, [r4, #42]	; 0x2a
      
        hi2c->State = HAL_I2C_STATE_READY;
 8003d5e:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
        HAL_I2C_ErrorCallback(hi2c);
 8003d62:	f7ff fd85 	bl	8003870 <HAL_I2C_ErrorCallback>
 8003d66:	bd38      	pop	{r3, r4, r5, pc}
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003d68:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003d6a:	b29b      	uxth	r3, r3
 8003d6c:	2bff      	cmp	r3, #255	; 0xff
 8003d6e:	d9c1      	bls.n	8003cf4 <I2C_DMAMemTransmitCplt+0xbc>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003d70:	6822      	ldr	r2, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003d72:	4b07      	ldr	r3, [pc, #28]	; (8003d90 <I2C_DMAMemTransmitCplt+0x158>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003d74:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003d76:	400b      	ands	r3, r1
 8003d78:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003d7c:	f3c5 0509 	ubfx	r5, r5, #0, #10
 8003d80:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003d84:	432b      	orrs	r3, r5
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003d86:	6053      	str	r3, [r2, #4]
 8003d88:	e7c1      	b.n	8003d0e <I2C_DMAMemTransmitCplt+0xd6>
 8003d8a:	bf00      	nop
 8003d8c:	fe00e800 	.word	0xfe00e800
 8003d90:	fc009800 	.word	0xfc009800

08003d94 <I2C_DMAMemReceiveCplt>:
  * @brief  DMA I2C Memory Read process complete callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma)   
{  
 8003d94:	b538      	push	{r3, r4, r5, lr}
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
 8003d96:	6a84      	ldr	r4, [r0, #40]	; 0x28
  uint16_t DevAddress;
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003d98:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8003d9a:	2bff      	cmp	r3, #255	; 0xff
  {
    /* Wait until TCR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
 8003d9c:	4620      	mov	r0, r4
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
  uint16_t DevAddress;
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003d9e:	d026      	beq.n	8003dee <I2C_DMAMemReceiveCplt+0x5a>
  }
  else
  {
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8003da0:	2119      	movs	r1, #25
 8003da2:	f7fe fbe9 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003da6:	b9c0      	cbnz	r0, 8003dda <I2C_DMAMemReceiveCplt+0x46>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
      }
    }
  
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003da8:	6822      	ldr	r2, [r4, #0]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003daa:	4b53      	ldr	r3, [pc, #332]	; (8003ef8 <I2C_DMAMemReceiveCplt+0x164>)
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
      }
    }
  
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003dac:	2120      	movs	r1, #32
 8003dae:	61d1      	str	r1, [r2, #28]
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003db0:	6822      	ldr	r2, [r4, #0]
 8003db2:	6851      	ldr	r1, [r2, #4]
 8003db4:	400b      	ands	r3, r1
 8003db6:	6053      	str	r3, [r2, #4]
  
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
 8003db8:	6822      	ldr	r2, [r4, #0]
 8003dba:	6813      	ldr	r3, [r2, #0]
  
    hi2c->XferCount = 0;
 8003dbc:	2000      	movs	r0, #0
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
  
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
 8003dbe:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  
    hi2c->XferCount = 0;
  
    hi2c->State = HAL_I2C_STATE_READY;
 8003dc2:	2101      	movs	r1, #1
  	
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
  
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
 8003dc4:	6013      	str	r3, [r2, #0]
  
    hi2c->XferCount = 0;
 8003dc6:	8560      	strh	r0, [r4, #42]	; 0x2a
  
    hi2c->State = HAL_I2C_STATE_READY;
 8003dc8:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003dcc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    {
      HAL_I2C_ErrorCallback(hi2c);
 8003dce:	4620      	mov	r0, r4
    hi2c->XferCount = 0;
  
    hi2c->State = HAL_I2C_STATE_READY;

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003dd0:	2b00      	cmp	r3, #0
 8003dd2:	d15d      	bne.n	8003e90 <I2C_DMAMemReceiveCplt+0xfc>
    {
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      HAL_I2C_MemRxCpltCallback(hi2c);
 8003dd4:	f7ff fd4a 	bl	800386c <HAL_I2C_MemRxCpltCallback>
 8003dd8:	bd38      	pop	{r3, r4, r5, pc}
  {
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */ 
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003dda:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003ddc:	2b04      	cmp	r3, #4
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8003dde:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003de0:	bf0c      	ite	eq
 8003de2:	f043 0304 	orreq.w	r3, r3, #4
      }
      else
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003de6:	f043 0320 	orrne.w	r3, r3, #32
 8003dea:	63a3      	str	r3, [r4, #56]	; 0x38
 8003dec:	e7dc      	b.n	8003da8 <I2C_DMAMemReceiveCplt+0x14>
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
  uint16_t DevAddress;
  
  /* Check if last DMA request was done with RELOAD */
  /* Set NBYTES to write and reload if size > 255 */
  if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003dee:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003df0:	b29b      	uxth	r3, r3
 8003df2:	2bff      	cmp	r3, #255	; 0xff
 8003df4:	d9d4      	bls.n	8003da0 <I2C_DMAMemReceiveCplt+0xc>
  {
    /* Wait until TCR flag is set */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
 8003df6:	2180      	movs	r1, #128	; 0x80
 8003df8:	2200      	movs	r2, #0
 8003dfa:	2319      	movs	r3, #25
 8003dfc:	f7fe faea 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8003e00:	b118      	cbz	r0, 8003e0a <I2C_DMAMemReceiveCplt+0x76>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003e02:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003e04:	f043 0320 	orr.w	r3, r3, #32
 8003e08:	63a3      	str	r3, [r4, #56]	; 0x38
    }

    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
 8003e0a:	6822      	ldr	r2, [r4, #0]
 8003e0c:	6813      	ldr	r3, [r2, #0]
 8003e0e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003e12:	6013      	str	r3, [r2, #0]

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003e14:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003e16:	2b00      	cmp	r3, #0
 8003e18:	d13d      	bne.n	8003e96 <I2C_DMAMemReceiveCplt+0x102>
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
      hi2c->XferCount -= hi2c->XferSize;
 8003e1a:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003e1c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8003e1e:	6a62      	ldr	r2, [r4, #36]	; 0x24
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
              
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
 8003e20:	6b20      	ldr	r0, [r4, #48]	; 0x30
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
      hi2c->XferCount -= hi2c->XferSize;
 8003e22:	1ac9      	subs	r1, r1, r3
 8003e24:	b289      	uxth	r1, r1
 8003e26:	8561      	strh	r1, [r4, #42]	; 0x2a
      if(hi2c->XferCount > 255)
 8003e28:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003e2a:	441a      	add	r2, r3
      hi2c->XferCount -= hi2c->XferSize;
      if(hi2c->XferCount > 255)
 8003e2c:	b28b      	uxth	r3, r1
 8003e2e:	2bff      	cmp	r3, #255	; 0xff
      {
        hi2c->XferSize = 255;
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
 8003e30:	bf98      	it	ls
 8003e32:	8d63      	ldrhls	r3, [r4, #42]	; 0x2a
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003e34:	6821      	ldr	r1, [r4, #0]
      hi2c->State = HAL_I2C_STATE_READY;
      HAL_I2C_ErrorCallback(hi2c);
    }
    else
    {
      hi2c->pBuffPtr += hi2c->XferSize;
 8003e36:	6262      	str	r2, [r4, #36]	; 0x24
      hi2c->XferCount -= hi2c->XferSize;
      if(hi2c->XferCount > 255)
      {
        hi2c->XferSize = 255;
 8003e38:	bf8c      	ite	hi
 8003e3a:	23ff      	movhi	r3, #255	; 0xff
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
 8003e3c:	b29b      	uxthls	r3, r3
 8003e3e:	8523      	strh	r3, [r4, #40]	; 0x28
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003e40:	684d      	ldr	r5, [r1, #4]
              
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
 8003e42:	3124      	adds	r1, #36	; 0x24
 8003e44:	f7fd fb70 	bl	8001528 <HAL_DMA_Start_IT>
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003e48:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8003e4a:	29ff      	cmp	r1, #255	; 0xff
      else
      {
        hi2c->XferSize = hi2c->XferCount;
      }

      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8003e4c:	b2ad      	uxth	r5, r5
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003e4e:	d041      	beq.n	8003ed4 <I2C_DMAMemReceiveCplt+0x140>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003e50:	6820      	ldr	r0, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003e52:	4a2a      	ldr	r2, [pc, #168]	; (8003efc <I2C_DMAMemReceiveCplt+0x168>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003e54:	6843      	ldr	r3, [r0, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003e56:	401a      	ands	r2, r3
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003e58:	f3c5 0309 	ubfx	r3, r5, #0, #10
 8003e5c:	f042 7500 	orr.w	r5, r2, #33554432	; 0x2000000
 8003e60:	b2c9      	uxtb	r1, r1
 8003e62:	431d      	orrs	r5, r3
 8003e64:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003e68:	6045      	str	r5, [r0, #4]
      {
        I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
      }  

      /* Wait until RXNE flag is set */
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
 8003e6a:	4620      	mov	r0, r4
 8003e6c:	2104      	movs	r1, #4
 8003e6e:	2200      	movs	r2, #0
 8003e70:	2319      	movs	r3, #25
 8003e72:	f7fe faaf 	bl	80023d4 <I2C_WaitOnFlagUntilTimeout>
 8003e76:	b118      	cbz	r0, 8003e80 <I2C_DMAMemReceiveCplt+0xec>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003e78:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003e7a:	f043 0320 	orr.w	r3, r3, #32
 8003e7e:	63a3      	str	r3, [r4, #56]	; 0x38
      }
      
      /* Check if Errors has been detected during transfer */
      if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8003e80:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003e82:	b943      	cbnz	r3, 8003e96 <I2C_DMAMemReceiveCplt+0x102>
        HAL_I2C_ErrorCallback(hi2c);
      }
      else
      {
        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
 8003e84:	6822      	ldr	r2, [r4, #0]
 8003e86:	6813      	ldr	r3, [r2, #0]
 8003e88:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003e8c:	6013      	str	r3, [r2, #0]
 8003e8e:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->State = HAL_I2C_STATE_READY;

    /* Check if Errors has been detected during transfer */
    if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
    {
      HAL_I2C_ErrorCallback(hi2c);
 8003e90:	f7ff fcee 	bl	8003870 <HAL_I2C_ErrorCallback>
 8003e94:	bd38      	pop	{r3, r4, r5, pc}
      /* Check if Errors has been detected during transfer */
      if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
      {
        /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
        /* Wait until STOPF flag is reset */ 
        if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
 8003e96:	4620      	mov	r0, r4
 8003e98:	2119      	movs	r1, #25
 8003e9a:	f7fe fb6d 	bl	8002578 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003e9e:	b140      	cbz	r0, 8003eb2 <I2C_DMAMemReceiveCplt+0x11e>
        {
          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8003ea0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003ea2:	2b04      	cmp	r3, #4
          {
            hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8003ea4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003ea6:	bf0c      	ite	eq
 8003ea8:	f043 0304 	orreq.w	r3, r3, #4
          }
          else
          {
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003eac:	f043 0320 	orrne.w	r3, r3, #32
 8003eb0:	63a3      	str	r3, [r4, #56]	; 0x38
          }
        }
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003eb2:	6822      	ldr	r2, [r4, #0]
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003eb4:	4b10      	ldr	r3, [pc, #64]	; (8003ef8 <I2C_DMAMemReceiveCplt+0x164>)
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
          }
        }
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003eb6:	2120      	movs	r1, #32
 8003eb8:	61d1      	str	r1, [r2, #28]
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003eba:	6822      	ldr	r2, [r4, #0]
 8003ebc:	6851      	ldr	r1, [r2, #4]
      
        hi2c->XferCount = 0;
 8003ebe:	2500      	movs	r5, #0
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003ec0:	400b      	ands	r3, r1
      
        hi2c->XferCount = 0;
      
        hi2c->State = HAL_I2C_STATE_READY;
 8003ec2:	2101      	movs	r1, #1
      
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 8003ec4:	6053      	str	r3, [r2, #4]
      
        hi2c->XferCount = 0;
      
        hi2c->State = HAL_I2C_STATE_READY;
        HAL_I2C_ErrorCallback(hi2c);
 8003ec6:	4620      	mov	r0, r4
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
            
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
      
        hi2c->XferCount = 0;
 8003ec8:	8565      	strh	r5, [r4, #42]	; 0x2a
      
        hi2c->State = HAL_I2C_STATE_READY;
 8003eca:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
        HAL_I2C_ErrorCallback(hi2c);
 8003ece:	f7ff fccf 	bl	8003870 <HAL_I2C_ErrorCallback>
 8003ed2:	bd38      	pop	{r3, r4, r5, pc}
      /* Enable the DMA channel */
      HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
      
      /* Send Slave Address */
      /* Set NBYTES to write and reload if size > 255 */
      if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
 8003ed4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003ed6:	b29b      	uxth	r3, r3
 8003ed8:	2bff      	cmp	r3, #255	; 0xff
 8003eda:	d9b9      	bls.n	8003e50 <I2C_DMAMemReceiveCplt+0xbc>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003edc:	6822      	ldr	r2, [r4, #0]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003ede:	4b07      	ldr	r3, [pc, #28]	; (8003efc <I2C_DMAMemReceiveCplt+0x168>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8003ee0:	6851      	ldr	r1, [r2, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003ee2:	400b      	ands	r3, r1
 8003ee4:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8003ee8:	f3c5 0509 	ubfx	r5, r5, #0, #10
 8003eec:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003ef0:	432b      	orrs	r3, r5
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8003ef2:	6053      	str	r3, [r2, #4]
 8003ef4:	e7b9      	b.n	8003e6a <I2C_DMAMemReceiveCplt+0xd6>
 8003ef6:	bf00      	nop
 8003ef8:	fe00e800 	.word	0xfe00e800
 8003efc:	fc009800 	.word	0xfc009800

08003f00 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 8003f00:	b538      	push	{r3, r4, r5, lr}
  /* I2C in mode Transmitter ---------------------------------------------------*/
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI | I2C_IT_ADDRI)) == SET))
 8003f02:	6803      	ldr	r3, [r0, #0]
 8003f04:	699a      	ldr	r2, [r3, #24]
 8003f06:	0791      	lsls	r1, r2, #30
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 8003f08:	4604      	mov	r4, r0
  /* I2C in mode Transmitter ---------------------------------------------------*/
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI | I2C_IT_ADDRI)) == SET))
 8003f0a:	d402      	bmi.n	8003f12 <HAL_I2C_EV_IRQHandler+0x12>
 8003f0c:	699a      	ldr	r2, [r3, #24]
 8003f0e:	0612      	lsls	r2, r2, #24
 8003f10:	d54a      	bpl.n	8003fa8 <HAL_I2C_EV_IRQHandler+0xa8>
 8003f12:	681a      	ldr	r2, [r3, #0]
 8003f14:	f002 027a 	and.w	r2, r2, #122	; 0x7a
 8003f18:	2a7a      	cmp	r2, #122	; 0x7a
 8003f1a:	f000 808b 	beq.w	8004034 <HAL_I2C_EV_IRQHandler+0x134>
    {
      I2C_SlaveTransmit_ISR(hi2c);
    }
  }
    
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI)) == SET))
 8003f1e:	699a      	ldr	r2, [r3, #24]
 8003f20:	0792      	lsls	r2, r2, #30
 8003f22:	d402      	bmi.n	8003f2a <HAL_I2C_EV_IRQHandler+0x2a>
 8003f24:	699a      	ldr	r2, [r3, #24]
 8003f26:	0615      	lsls	r5, r2, #24
 8003f28:	d534      	bpl.n	8003f94 <HAL_I2C_EV_IRQHandler+0x94>
 8003f2a:	681a      	ldr	r2, [r3, #0]
 8003f2c:	f002 0272 	and.w	r2, r2, #114	; 0x72
 8003f30:	2a72      	cmp	r2, #114	; 0x72
 8003f32:	f000 80b8 	beq.w	80040a6 <HAL_I2C_EV_IRQHandler+0x1a6>
      I2C_MasterTransmit_ISR(hi2c);
    }
  }

  /* I2C in mode Receiver ----------------------------------------------------*/
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI | I2C_IT_ADDRI)) == SET))
 8003f36:	699a      	ldr	r2, [r3, #24]
 8003f38:	0752      	lsls	r2, r2, #29
 8003f3a:	d402      	bmi.n	8003f42 <HAL_I2C_EV_IRQHandler+0x42>
 8003f3c:	699a      	ldr	r2, [r3, #24]
 8003f3e:	0615      	lsls	r5, r2, #24
 8003f40:	d51b      	bpl.n	8003f7a <HAL_I2C_EV_IRQHandler+0x7a>
 8003f42:	681a      	ldr	r2, [r3, #0]
 8003f44:	f002 027c 	and.w	r2, r2, #124	; 0x7c
 8003f48:	2a7c      	cmp	r2, #124	; 0x7c
 8003f4a:	f000 8090 	beq.w	800406e <HAL_I2C_EV_IRQHandler+0x16e>
    if (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX)
    {
      I2C_SlaveReceive_ISR(hi2c);
    }
  } 
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI)) == SET))
 8003f4e:	699a      	ldr	r2, [r3, #24]
 8003f50:	0750      	lsls	r0, r2, #29
 8003f52:	d402      	bmi.n	8003f5a <HAL_I2C_EV_IRQHandler+0x5a>
 8003f54:	699a      	ldr	r2, [r3, #24]
 8003f56:	0611      	lsls	r1, r2, #24
 8003f58:	d505      	bpl.n	8003f66 <HAL_I2C_EV_IRQHandler+0x66>
 8003f5a:	681a      	ldr	r2, [r3, #0]
 8003f5c:	f002 0274 	and.w	r2, r2, #116	; 0x74
 8003f60:	2a74      	cmp	r2, #116	; 0x74
 8003f62:	d02e      	beq.n	8003fc2 <HAL_I2C_EV_IRQHandler+0xc2>
 8003f64:	bd38      	pop	{r3, r4, r5, pc}
 8003f66:	699a      	ldr	r2, [r3, #24]
 8003f68:	0652      	lsls	r2, r2, #25
 8003f6a:	d4f6      	bmi.n	8003f5a <HAL_I2C_EV_IRQHandler+0x5a>
 8003f6c:	699a      	ldr	r2, [r3, #24]
 8003f6e:	0695      	lsls	r5, r2, #26
 8003f70:	d4f3      	bmi.n	8003f5a <HAL_I2C_EV_IRQHandler+0x5a>
 8003f72:	699a      	ldr	r2, [r3, #24]
 8003f74:	06d0      	lsls	r0, r2, #27
 8003f76:	d5f5      	bpl.n	8003f64 <HAL_I2C_EV_IRQHandler+0x64>
 8003f78:	e7ef      	b.n	8003f5a <HAL_I2C_EV_IRQHandler+0x5a>
      I2C_MasterTransmit_ISR(hi2c);
    }
  }

  /* I2C in mode Receiver ----------------------------------------------------*/
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI | I2C_IT_ADDRI)) == SET))
 8003f7a:	699a      	ldr	r2, [r3, #24]
 8003f7c:	0650      	lsls	r0, r2, #25
 8003f7e:	d4e0      	bmi.n	8003f42 <HAL_I2C_EV_IRQHandler+0x42>
 8003f80:	699a      	ldr	r2, [r3, #24]
 8003f82:	0691      	lsls	r1, r2, #26
 8003f84:	d4dd      	bmi.n	8003f42 <HAL_I2C_EV_IRQHandler+0x42>
 8003f86:	699a      	ldr	r2, [r3, #24]
 8003f88:	06d2      	lsls	r2, r2, #27
 8003f8a:	d4da      	bmi.n	8003f42 <HAL_I2C_EV_IRQHandler+0x42>
 8003f8c:	699a      	ldr	r2, [r3, #24]
 8003f8e:	0715      	lsls	r5, r2, #28
 8003f90:	d5dd      	bpl.n	8003f4e <HAL_I2C_EV_IRQHandler+0x4e>
 8003f92:	e7d6      	b.n	8003f42 <HAL_I2C_EV_IRQHandler+0x42>
    {
      I2C_SlaveTransmit_ISR(hi2c);
    }
  }
    
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI)) == SET))
 8003f94:	699a      	ldr	r2, [r3, #24]
 8003f96:	0650      	lsls	r0, r2, #25
 8003f98:	d4c7      	bmi.n	8003f2a <HAL_I2C_EV_IRQHandler+0x2a>
 8003f9a:	699a      	ldr	r2, [r3, #24]
 8003f9c:	0691      	lsls	r1, r2, #26
 8003f9e:	d4c4      	bmi.n	8003f2a <HAL_I2C_EV_IRQHandler+0x2a>
 8003fa0:	699a      	ldr	r2, [r3, #24]
 8003fa2:	06d2      	lsls	r2, r2, #27
 8003fa4:	d5c7      	bpl.n	8003f36 <HAL_I2C_EV_IRQHandler+0x36>
 8003fa6:	e7c0      	b.n	8003f2a <HAL_I2C_EV_IRQHandler+0x2a>
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
  /* I2C in mode Transmitter ---------------------------------------------------*/
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI | I2C_IT_ADDRI)) == SET))
 8003fa8:	699a      	ldr	r2, [r3, #24]
 8003faa:	0655      	lsls	r5, r2, #25
 8003fac:	d4b1      	bmi.n	8003f12 <HAL_I2C_EV_IRQHandler+0x12>
 8003fae:	699a      	ldr	r2, [r3, #24]
 8003fb0:	0690      	lsls	r0, r2, #26
 8003fb2:	d4ae      	bmi.n	8003f12 <HAL_I2C_EV_IRQHandler+0x12>
 8003fb4:	699a      	ldr	r2, [r3, #24]
 8003fb6:	06d1      	lsls	r1, r2, #27
 8003fb8:	d4ab      	bmi.n	8003f12 <HAL_I2C_EV_IRQHandler+0x12>
 8003fba:	699a      	ldr	r2, [r3, #24]
 8003fbc:	0712      	lsls	r2, r2, #28
 8003fbe:	d5ae      	bpl.n	8003f1e <HAL_I2C_EV_IRQHandler+0x1e>
 8003fc0:	e7a7      	b.n	8003f12 <HAL_I2C_EV_IRQHandler+0x12>
    }
  } 
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI)) == SET))
  {
    /* Master mode selected */
    if ((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX))
 8003fc2:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 8003fc6:	2a22      	cmp	r2, #34	; 0x22
 8003fc8:	d003      	beq.n	8003fd2 <HAL_I2C_EV_IRQHandler+0xd2>
 8003fca:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 8003fce:	2a62      	cmp	r2, #98	; 0x62
 8003fd0:	d1c8      	bne.n	8003f64 <HAL_I2C_EV_IRQHandler+0x64>
static HAL_StatusTypeDef I2C_MasterReceive_ISR(I2C_HandleTypeDef *hi2c) 
{
  uint16_t DevAddress;

  /* Process Locked */
  __HAL_LOCK(hi2c);
 8003fd2:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 8003fd6:	2a01      	cmp	r2, #1
 8003fd8:	d0c4      	beq.n	8003f64 <HAL_I2C_EV_IRQHandler+0x64>
 8003fda:	2201      	movs	r2, #1
 8003fdc:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8003fe0:	6999      	ldr	r1, [r3, #24]
 8003fe2:	0749      	lsls	r1, r1, #29
 8003fe4:	f100 8099 	bmi.w	800411a <HAL_I2C_EV_IRQHandler+0x21a>
    /* Read data from RXDR */
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
    hi2c->XferSize--;
    hi2c->XferCount--;
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET)
 8003fe8:	6999      	ldr	r1, [r3, #24]
 8003fea:	f011 0180 	ands.w	r1, r1, #128	; 0x80
 8003fee:	f000 80af 	beq.w	8004150 <HAL_I2C_EV_IRQHandler+0x250>
  {
    if((hi2c->XferSize == 0)&&(hi2c->XferCount!=0))
 8003ff2:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8003ff4:	2a00      	cmp	r2, #0
 8003ff6:	f040 80b9 	bne.w	800416c <HAL_I2C_EV_IRQHandler+0x26c>
 8003ffa:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8003ffc:	b292      	uxth	r2, r2
 8003ffe:	2a00      	cmp	r2, #0
 8004000:	f000 80b4 	beq.w	800416c <HAL_I2C_EV_IRQHandler+0x26c>
    {                  
      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 8004004:	685a      	ldr	r2, [r3, #4]
      
      if(hi2c->XferCount > 255)
 8004006:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 8004008:	b289      	uxth	r1, r1
 800400a:	29ff      	cmp	r1, #255	; 0xff
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET)
  {
    if((hi2c->XferSize == 0)&&(hi2c->XferCount!=0))
    {                  
      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 800400c:	b292      	uxth	r2, r2
      
      if(hi2c->XferCount > 255)
 800400e:	f240 8163 	bls.w	80042d8 <HAL_I2C_EV_IRQHandler+0x3d8>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8004012:	6858      	ldr	r0, [r3, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8004014:	49ae      	ldr	r1, [pc, #696]	; (80042d0 <HAL_I2C_EV_IRQHandler+0x3d0>)
 8004016:	4001      	ands	r1, r0
 8004018:	f041 71ff 	orr.w	r1, r1, #33423360	; 0x1fe0000
 800401c:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8004020:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8004024:	430a      	orrs	r2, r1
      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
      
      if(hi2c->XferCount > 255)
      {
        I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
        hi2c->XferSize = 255;
 8004026:	21ff      	movs	r1, #255	; 0xff
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8004028:	605a      	str	r2, [r3, #4]
      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
      
      if(hi2c->XferCount > 255)
      {
        I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
        hi2c->XferSize = 255;
 800402a:	8521      	strh	r1, [r4, #40]	; 0x28
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    HAL_I2C_ErrorCallback(hi2c);
  }
    
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c); 
 800402c:	2300      	movs	r3, #0
 800402e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8004032:	e797      	b.n	8003f64 <HAL_I2C_EV_IRQHandler+0x64>
{
  /* I2C in mode Transmitter ---------------------------------------------------*/
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI | I2C_IT_ADDRI)) == SET))
  {     
    /* Slave mode selected */
    if (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX)
 8004034:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 8004038:	2a32      	cmp	r2, #50	; 0x32
 800403a:	f47f af70 	bne.w	8003f1e <HAL_I2C_EV_IRQHandler+0x1e>
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_SlaveTransmit_ISR(I2C_HandleTypeDef *hi2c) 
{
  /* Process locked */
  __HAL_LOCK(hi2c);
 800403e:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 8004042:	2a01      	cmp	r2, #1
 8004044:	f43f af6b 	beq.w	8003f1e <HAL_I2C_EV_IRQHandler+0x1e>
 8004048:	2201      	movs	r2, #1
 800404a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) != RESET)
 800404e:	6999      	ldr	r1, [r3, #24]
 8004050:	06cd      	lsls	r5, r1, #27
 8004052:	f140 80c2 	bpl.w	80041da <HAL_I2C_EV_IRQHandler+0x2da>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if(hi2c->XferCount == 0)
 8004056:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8004058:	b292      	uxth	r2, r2
 800405a:	2a00      	cmp	r2, #0
 800405c:	f040 8180 	bne.w	8004360 <HAL_I2C_EV_IRQHandler+0x460>
    {
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8004060:	2210      	movs	r2, #16
 8004062:	61da      	str	r2, [r3, #28]
 8004064:	6823      	ldr	r3, [r4, #0]
      hi2c->XferCount--;
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 8004066:	2200      	movs	r2, #0
 8004068:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
 800406c:	e757      	b.n	8003f1e <HAL_I2C_EV_IRQHandler+0x1e>

  /* I2C in mode Receiver ----------------------------------------------------*/
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI | I2C_IT_ADDRI)) == SET))
  {
    /* Slave mode selected */
    if (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX)
 800406e:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 8004072:	2a42      	cmp	r2, #66	; 0x42
 8004074:	f47f af6b 	bne.w	8003f4e <HAL_I2C_EV_IRQHandler+0x4e>
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_SlaveReceive_ISR(I2C_HandleTypeDef *hi2c) 
{
  /* Process Locked */
  __HAL_LOCK(hi2c);
 8004078:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 800407c:	2a01      	cmp	r2, #1
 800407e:	f43f af66 	beq.w	8003f4e <HAL_I2C_EV_IRQHandler+0x4e>
 8004082:	2201      	movs	r2, #1
 8004084:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) != RESET)
 8004088:	6999      	ldr	r1, [r3, #24]
 800408a:	06c8      	lsls	r0, r1, #27
 800408c:	f100 80e9 	bmi.w	8004262 <HAL_I2C_EV_IRQHandler+0x362>
    __HAL_UNLOCK(hi2c);
    
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    HAL_I2C_ErrorCallback(hi2c);
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
 8004090:	6999      	ldr	r1, [r3, #24]
 8004092:	0709      	lsls	r1, r1, #28
 8004094:	f140 80b5 	bpl.w	8004202 <HAL_I2C_EV_IRQHandler+0x302>
  {
    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8004098:	2208      	movs	r2, #8
 800409a:	61da      	str	r2, [r3, #28]
 800409c:	6823      	ldr	r3, [r4, #0]

    HAL_I2C_SlaveRxCpltCallback(hi2c);
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 800409e:	2200      	movs	r2, #0
 80040a0:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
 80040a4:	e753      	b.n	8003f4e <HAL_I2C_EV_IRQHandler+0x4e>
  }
    
  if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI)) == SET))
  {     
    /* Master mode selected */
    if ((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX))
 80040a6:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 80040aa:	2a12      	cmp	r2, #18
 80040ac:	d004      	beq.n	80040b8 <HAL_I2C_EV_IRQHandler+0x1b8>
 80040ae:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 80040b2:	2a52      	cmp	r2, #82	; 0x52
 80040b4:	f47f af3f 	bne.w	8003f36 <HAL_I2C_EV_IRQHandler+0x36>
static HAL_StatusTypeDef I2C_MasterTransmit_ISR(I2C_HandleTypeDef *hi2c) 
{
  uint16_t DevAddress;
  
  /* Process Locked */
  __HAL_LOCK(hi2c); 
 80040b8:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 80040bc:	2a01      	cmp	r2, #1
 80040be:	f43f af3a 	beq.w	8003f36 <HAL_I2C_EV_IRQHandler+0x36>
 80040c2:	2201      	movs	r2, #1
 80040c4:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
 80040c8:	6999      	ldr	r1, [r3, #24]
 80040ca:	078d      	lsls	r5, r1, #30
 80040cc:	d432      	bmi.n	8004134 <HAL_I2C_EV_IRQHandler+0x234>
    /* Write data to TXDR */
    hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
    hi2c->XferSize--;
    hi2c->XferCount--;	
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET)
 80040ce:	6999      	ldr	r1, [r3, #24]
 80040d0:	f011 0180 	ands.w	r1, r1, #128	; 0x80
 80040d4:	d055      	beq.n	8004182 <HAL_I2C_EV_IRQHandler+0x282>
  {
    if((hi2c->XferSize == 0)&&(hi2c->XferCount!=0))
 80040d6:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 80040d8:	2a00      	cmp	r2, #0
 80040da:	f040 8086 	bne.w	80041ea <HAL_I2C_EV_IRQHandler+0x2ea>
 80040de:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 80040e0:	b292      	uxth	r2, r2
 80040e2:	2a00      	cmp	r2, #0
 80040e4:	f000 8081 	beq.w	80041ea <HAL_I2C_EV_IRQHandler+0x2ea>
    {
      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 80040e8:	685a      	ldr	r2, [r3, #4]
      
      if(hi2c->XferCount > 255)
 80040ea:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 80040ec:	b289      	uxth	r1, r1
 80040ee:	29ff      	cmp	r1, #255	; 0xff
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET)
  {
    if((hi2c->XferSize == 0)&&(hi2c->XferCount!=0))
    {
      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
 80040f0:	b292      	uxth	r2, r2
      
      if(hi2c->XferCount > 255)
 80040f2:	f240 8143 	bls.w	800437c <HAL_I2C_EV_IRQHandler+0x47c>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80040f6:	6858      	ldr	r0, [r3, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80040f8:	4975      	ldr	r1, [pc, #468]	; (80042d0 <HAL_I2C_EV_IRQHandler+0x3d0>)
 80040fa:	4001      	ands	r1, r0
 80040fc:	f041 71ff 	orr.w	r1, r1, #33423360	; 0x1fe0000
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8004100:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8004104:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8004108:	430a      	orrs	r2, r1
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 800410a:	605a      	str	r2, [r3, #4]
 800410c:	6823      	ldr	r3, [r4, #0]
      DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
      
      if(hi2c->XferCount > 255)
      {    
        I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
        hi2c->XferSize = 255;
 800410e:	22ff      	movs	r2, #255	; 0xff
 8004110:	8522      	strh	r2, [r4, #40]	; 0x28
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    HAL_I2C_ErrorCallback(hi2c);
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 8004112:	2200      	movs	r2, #0
 8004114:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
 8004118:	e70d      	b.n	8003f36 <HAL_I2C_EV_IRQHandler+0x36>
  __HAL_LOCK(hi2c);
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
  {  
    /* Read data from RXDR */
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 800411a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800411c:	1c51      	adds	r1, r2, #1
 800411e:	6261      	str	r1, [r4, #36]	; 0x24
 8004120:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004122:	7013      	strb	r3, [r2, #0]
    hi2c->XferSize--;
    hi2c->XferCount--;
 8004124:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
  {  
    /* Read data from RXDR */
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
    hi2c->XferSize--;
 8004126:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->XferCount--;
 8004128:	3b01      	subs	r3, #1
 800412a:	b29b      	uxth	r3, r3
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
  {  
    /* Read data from RXDR */
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
    hi2c->XferSize--;
 800412c:	3a01      	subs	r2, #1
    hi2c->XferCount--;
 800412e:	8563      	strh	r3, [r4, #42]	; 0x2a
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
  {  
    /* Read data from RXDR */
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
    hi2c->XferSize--;
 8004130:	8522      	strh	r2, [r4, #40]	; 0x28
 8004132:	e77b      	b.n	800402c <HAL_I2C_EV_IRQHandler+0x12c>
  __HAL_LOCK(hi2c); 
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 8004134:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004136:	1c51      	adds	r1, r2, #1
 8004138:	6261      	str	r1, [r4, #36]	; 0x24
 800413a:	7812      	ldrb	r2, [r2, #0]
 800413c:	629a      	str	r2, [r3, #40]	; 0x28
    hi2c->XferSize--;
    hi2c->XferCount--;	
 800413e:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
    hi2c->XferSize--;
 8004140:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8004142:	6823      	ldr	r3, [r4, #0]
    hi2c->XferCount--;	
 8004144:	3a01      	subs	r2, #1
 8004146:	b292      	uxth	r2, r2
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
    hi2c->XferSize--;
 8004148:	3901      	subs	r1, #1
    hi2c->XferCount--;	
 800414a:	8562      	strh	r2, [r4, #42]	; 0x2a
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
    hi2c->XferSize--;
 800414c:	8521      	strh	r1, [r4, #40]	; 0x28
 800414e:	e7e0      	b.n	8004112 <HAL_I2C_EV_IRQHandler+0x212>
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
      HAL_I2C_ErrorCallback(hi2c);
    }
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET)
 8004150:	6998      	ldr	r0, [r3, #24]
 8004152:	f010 0040 	ands.w	r0, r0, #64	; 0x40
 8004156:	d023      	beq.n	80041a0 <HAL_I2C_EV_IRQHandler+0x2a0>
  {
    if(hi2c->XferCount == 0)
 8004158:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 800415a:	b292      	uxth	r2, r2
 800415c:	2a00      	cmp	r2, #0
 800415e:	f040 80f5 	bne.w	800434c <HAL_I2C_EV_IRQHandler+0x44c>
    {
      /* Generate Stop */
      hi2c->Instance->CR2 |= I2C_CR2_STOP;
 8004162:	685a      	ldr	r2, [r3, #4]
 8004164:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8004168:	605a      	str	r2, [r3, #4]
 800416a:	e75f      	b.n	800402c <HAL_I2C_EV_IRQHandler+0x12c>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
      
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
 800416c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      } 
    } 
    else
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800416e:	2200      	movs	r2, #0
      
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
 8004170:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004174:	63a3      	str	r3, [r4, #56]	; 0x38
      } 
    } 
    else
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8004176:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
      HAL_I2C_ErrorCallback(hi2c);
 800417a:	4620      	mov	r0, r4
 800417c:	f7ff fb78 	bl	8003870 <HAL_I2C_ErrorCallback>
 8004180:	e754      	b.n	800402c <HAL_I2C_EV_IRQHandler+0x12c>
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
      HAL_I2C_ErrorCallback(hi2c);
    }
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET)
 8004182:	6998      	ldr	r0, [r3, #24]
 8004184:	f010 0040 	ands.w	r0, r0, #64	; 0x40
 8004188:	d04d      	beq.n	8004226 <HAL_I2C_EV_IRQHandler+0x326>
  {
    if(hi2c->XferCount == 0)
 800418a:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 800418c:	b292      	uxth	r2, r2
 800418e:	2a00      	cmp	r2, #0
 8004190:	f040 8105 	bne.w	800439e <HAL_I2C_EV_IRQHandler+0x49e>
    {
      /* Generate Stop */
      hi2c->Instance->CR2 |= I2C_CR2_STOP;
 8004194:	685a      	ldr	r2, [r3, #4]
 8004196:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800419a:	605a      	str	r2, [r3, #4]
 800419c:	6823      	ldr	r3, [r4, #0]
 800419e:	e7b8      	b.n	8004112 <HAL_I2C_EV_IRQHandler+0x212>
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
      HAL_I2C_ErrorCallback(hi2c);
    }
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 80041a0:	6999      	ldr	r1, [r3, #24]
 80041a2:	f011 0120 	ands.w	r1, r1, #32
 80041a6:	d06a      	beq.n	800427e <HAL_I2C_EV_IRQHandler+0x37e>
  {
    /* Disable ERR, TC, STOP, NACK, TXI interrupt */
    __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI );
 80041a8:	681d      	ldr	r5, [r3, #0]
      
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
      
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80041aa:	494a      	ldr	r1, [pc, #296]	; (80042d4 <HAL_I2C_EV_IRQHandler+0x3d4>)
    }
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
  {
    /* Disable ERR, TC, STOP, NACK, TXI interrupt */
    __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI );
 80041ac:	f025 05f4 	bic.w	r5, r5, #244	; 0xf4
 80041b0:	601d      	str	r5, [r3, #0]
      
    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80041b2:	6823      	ldr	r3, [r4, #0]
 80041b4:	2520      	movs	r5, #32
 80041b6:	61dd      	str	r5, [r3, #28]
      
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80041b8:	6823      	ldr	r3, [r4, #0]
 80041ba:	685d      	ldr	r5, [r3, #4]
 80041bc:	4029      	ands	r1, r5
 80041be:	6059      	str	r1, [r3, #4]
    
    hi2c->State = HAL_I2C_STATE_READY;
 80041c0:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX)
 80041c4:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    I2C_RESET_CR2(hi2c);
    
    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80041c8:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    
    if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX)
 80041cc:	2b62      	cmp	r3, #98	; 0x62
    {
      HAL_I2C_MemRxCpltCallback(hi2c);
 80041ce:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX)
 80041d0:	f000 80f0 	beq.w	80043b4 <HAL_I2C_EV_IRQHandler+0x4b4>
    {
      HAL_I2C_MemRxCpltCallback(hi2c);
    }
    else
    {
      HAL_I2C_MasterRxCpltCallback(hi2c);
 80041d4:	f7ff fb42 	bl	800385c <HAL_I2C_MasterRxCpltCallback>
 80041d8:	e728      	b.n	800402c <HAL_I2C_EV_IRQHandler+0x12c>
    
      /* Call the Error callback to prevent upper layer */
      HAL_I2C_ErrorCallback(hi2c);
    }
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
 80041da:	6999      	ldr	r1, [r3, #24]
 80041dc:	f011 0108 	ands.w	r1, r1, #8
 80041e0:	d05d      	beq.n	800429e <HAL_I2C_EV_IRQHandler+0x39e>
  {
    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 80041e2:	2208      	movs	r2, #8
 80041e4:	61da      	str	r2, [r3, #28]
 80041e6:	6823      	ldr	r3, [r4, #0]
 80041e8:	e73d      	b.n	8004066 <HAL_I2C_EV_IRQHandler+0x166>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
      
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
 80041ea:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      }
    }
    else
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 80041ec:	2200      	movs	r2, #0
      
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
 80041ee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80041f2:	63a3      	str	r3, [r4, #56]	; 0x38
      }
    }
    else
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 80041f4:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
      HAL_I2C_ErrorCallback(hi2c);
 80041f8:	4620      	mov	r0, r4
 80041fa:	f7ff fb39 	bl	8003870 <HAL_I2C_ErrorCallback>
 80041fe:	6823      	ldr	r3, [r4, #0]
 8004200:	e787      	b.n	8004112 <HAL_I2C_EV_IRQHandler+0x212>
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
  {
    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8004202:	6999      	ldr	r1, [r3, #24]
 8004204:	f011 0104 	ands.w	r1, r1, #4
 8004208:	d076      	beq.n	80042f8 <HAL_I2C_EV_IRQHandler+0x3f8>
  {
    /* Read data from RXDR */
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 800420a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800420c:	1c51      	adds	r1, r2, #1
 800420e:	6261      	str	r1, [r4, #36]	; 0x24
 8004210:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004212:	7013      	strb	r3, [r2, #0]
    hi2c->XferSize--;
    hi2c->XferCount--;
 8004214:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
  {
    /* Read data from RXDR */
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
    hi2c->XferSize--;
 8004216:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8004218:	6823      	ldr	r3, [r4, #0]
    hi2c->XferCount--;
 800421a:	3a01      	subs	r2, #1
 800421c:	b292      	uxth	r2, r2
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
  {
    /* Read data from RXDR */
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
    hi2c->XferSize--;
 800421e:	3901      	subs	r1, #1
    hi2c->XferCount--;
 8004220:	8562      	strh	r2, [r4, #42]	; 0x2a
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
  {
    /* Read data from RXDR */
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
    hi2c->XferSize--;
 8004222:	8521      	strh	r1, [r4, #40]	; 0x28
 8004224:	e73b      	b.n	800409e <HAL_I2C_EV_IRQHandler+0x19e>
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
      HAL_I2C_ErrorCallback(hi2c);
    }
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 8004226:	6999      	ldr	r1, [r3, #24]
 8004228:	f011 0120 	ands.w	r1, r1, #32
 800422c:	d07d      	beq.n	800432a <HAL_I2C_EV_IRQHandler+0x42a>
  {
    /* Disable ERR, TC, STOP, NACK, TXI interrupt */
    __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
 800422e:	681d      	ldr	r5, [r3, #0]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8004230:	4928      	ldr	r1, [pc, #160]	; (80042d4 <HAL_I2C_EV_IRQHandler+0x3d4>)
    }
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
  {
    /* Disable ERR, TC, STOP, NACK, TXI interrupt */
    __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
 8004232:	f025 05f2 	bic.w	r5, r5, #242	; 0xf2
 8004236:	601d      	str	r5, [r3, #0]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8004238:	6823      	ldr	r3, [r4, #0]
 800423a:	2520      	movs	r5, #32
 800423c:	61dd      	str	r5, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800423e:	6823      	ldr	r3, [r4, #0]
 8004240:	685d      	ldr	r5, [r3, #4]
 8004242:	4029      	ands	r1, r5
 8004244:	6059      	str	r1, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 8004246:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX)
 800424a:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800424e:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34

    if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX)
 8004252:	2b52      	cmp	r3, #82	; 0x52
    {
      HAL_I2C_MemTxCpltCallback(hi2c);
 8004254:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX)
 8004256:	f000 80c5 	beq.w	80043e4 <HAL_I2C_EV_IRQHandler+0x4e4>
    {
      HAL_I2C_MemTxCpltCallback(hi2c);
    }
    else
    {
      HAL_I2C_MasterTxCpltCallback(hi2c);
 800425a:	f7ff fafd 	bl	8003858 <HAL_I2C_MasterTxCpltCallback>
 800425e:	6823      	ldr	r3, [r4, #0]
 8004260:	e757      	b.n	8004112 <HAL_I2C_EV_IRQHandler+0x212>
  __HAL_LOCK(hi2c);
  
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) != RESET)
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8004262:	2210      	movs	r2, #16
 8004264:	61da      	str	r2, [r3, #28]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8004266:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8004268:	2200      	movs	r2, #0
    
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800426a:	f043 0304 	orr.w	r3, r3, #4
 800426e:	63a3      	str	r3, [r4, #56]	; 0x38
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8004270:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    HAL_I2C_ErrorCallback(hi2c);
 8004274:	4620      	mov	r0, r4
 8004276:	f7ff fafb 	bl	8003870 <HAL_I2C_ErrorCallback>
 800427a:	6823      	ldr	r3, [r4, #0]
 800427c:	e70f      	b.n	800409e <HAL_I2C_EV_IRQHandler+0x19e>
    else
    {
      HAL_I2C_MasterRxCpltCallback(hi2c);
    }
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800427e:	699a      	ldr	r2, [r3, #24]
 8004280:	06d2      	lsls	r2, r2, #27
 8004282:	f57f aed3 	bpl.w	800402c <HAL_I2C_EV_IRQHandler+0x12c>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8004286:	2210      	movs	r2, #16
 8004288:	61da      	str	r2, [r3, #28]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800428a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800428c:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
    
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8004290:	f043 0304 	orr.w	r3, r3, #4
 8004294:	63a3      	str	r3, [r4, #56]	; 0x38
    HAL_I2C_ErrorCallback(hi2c);
 8004296:	4620      	mov	r0, r4
 8004298:	f7ff faea 	bl	8003870 <HAL_I2C_ErrorCallback>
 800429c:	e6c6      	b.n	800402c <HAL_I2C_EV_IRQHandler+0x12c>
  }
  /* Check first if STOPF is set          */
  /* to prevent a Write Data in TX buffer */
  /* which is stuck in TXDR until next    */
  /* communication with Master            */
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 800429e:	6998      	ldr	r0, [r3, #24]
 80042a0:	0680      	lsls	r0, r0, #26
 80042a2:	f100 808a 	bmi.w	80043ba <HAL_I2C_EV_IRQHandler+0x4ba>
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    HAL_I2C_SlaveTxCpltCallback(hi2c);
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
 80042a6:	699a      	ldr	r2, [r3, #24]
 80042a8:	0791      	lsls	r1, r2, #30
 80042aa:	f57f aedc 	bpl.w	8004066 <HAL_I2C_EV_IRQHandler+0x166>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    if(hi2c->XferCount > 0)
 80042ae:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 80042b0:	b292      	uxth	r2, r2
 80042b2:	2a00      	cmp	r2, #0
 80042b4:	f43f aed7 	beq.w	8004066 <HAL_I2C_EV_IRQHandler+0x166>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 80042b8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80042ba:	1c51      	adds	r1, r2, #1
 80042bc:	6261      	str	r1, [r4, #36]	; 0x24
 80042be:	7812      	ldrb	r2, [r2, #0]
 80042c0:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 80042c2:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 80042c4:	6823      	ldr	r3, [r4, #0]
 80042c6:	3a01      	subs	r2, #1
 80042c8:	b292      	uxth	r2, r2
 80042ca:	8562      	strh	r2, [r4, #42]	; 0x2a
 80042cc:	e6cb      	b.n	8004066 <HAL_I2C_EV_IRQHandler+0x166>
 80042ce:	bf00      	nop
 80042d0:	fc009800 	.word	0xfc009800
 80042d4:	fe00e800 	.word	0xfe00e800
        I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
        hi2c->XferSize = 255;
      }      
      else
      {    
        I2C_TransferConfig(hi2c,DevAddress,hi2c->XferCount, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80042d8:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80042da:	4944      	ldr	r1, [pc, #272]	; (80043ec <HAL_I2C_EV_IRQHandler+0x4ec>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80042dc:	685d      	ldr	r5, [r3, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80042de:	4029      	ands	r1, r5
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80042e0:	f3c2 0209 	ubfx	r2, r2, #0, #10
 80042e4:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 80042e8:	b2c0      	uxtb	r0, r0
 80042ea:	430a      	orrs	r2, r1
 80042ec:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 80042f0:	605a      	str	r2, [r3, #4]
        hi2c->XferSize = 255;
      }      
      else
      {    
        I2C_TransferConfig(hi2c,DevAddress,hi2c->XferCount, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
        hi2c->XferSize = hi2c->XferCount;
 80042f2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80042f4:	8523      	strh	r3, [r4, #40]	; 0x28
 80042f6:	e699      	b.n	800402c <HAL_I2C_EV_IRQHandler+0x12c>
    /* Read data from RXDR */
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
    hi2c->XferSize--;
    hi2c->XferCount--;
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 80042f8:	6998      	ldr	r0, [r3, #24]
 80042fa:	0685      	lsls	r5, r0, #26
 80042fc:	f57f aecf 	bpl.w	800409e <HAL_I2C_EV_IRQHandler+0x19e>
  {
    /* Disable ERRI, TCI, STOPI, NACKI, ADDRI, RXI, TXI interrupt */
    __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_RXI );
 8004300:	6818      	ldr	r0, [r3, #0]
 8004302:	f020 00fc 	bic.w	r0, r0, #252	; 0xfc
 8004306:	6018      	str	r0, [r3, #0]
    
    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8004308:	6820      	ldr	r0, [r4, #0]
 800430a:	6843      	ldr	r3, [r0, #4]
 800430c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004310:	6043      	str	r3, [r0, #4]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8004312:	6823      	ldr	r3, [r4, #0]
 8004314:	2020      	movs	r0, #32
 8004316:	61d8      	str	r0, [r3, #28]
    hi2c->State = HAL_I2C_STATE_READY;
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8004318:	4620      	mov	r0, r4
    hi2c->Instance->CR2 |= I2C_CR2_NACK;

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

    hi2c->State = HAL_I2C_STATE_READY;
 800431a:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800431e:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34

    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8004322:	f7ff fa9f 	bl	8003864 <HAL_I2C_SlaveRxCpltCallback>
 8004326:	6823      	ldr	r3, [r4, #0]
 8004328:	e6b9      	b.n	800409e <HAL_I2C_EV_IRQHandler+0x19e>
    else
    {
      HAL_I2C_MasterTxCpltCallback(hi2c);
    }
  }
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800432a:	699a      	ldr	r2, [r3, #24]
 800432c:	06d0      	lsls	r0, r2, #27
 800432e:	f57f aef0 	bpl.w	8004112 <HAL_I2C_EV_IRQHandler+0x212>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8004332:	2210      	movs	r2, #16
 8004334:	61da      	str	r2, [r3, #28]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8004336:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8004338:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
    
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800433c:	f043 0304 	orr.w	r3, r3, #4
 8004340:	63a3      	str	r3, [r4, #56]	; 0x38
    HAL_I2C_ErrorCallback(hi2c);
 8004342:	4620      	mov	r0, r4
 8004344:	f7ff fa94 	bl	8003870 <HAL_I2C_ErrorCallback>
 8004348:	6823      	ldr	r3, [r4, #0]
 800434a:	e6e2      	b.n	8004112 <HAL_I2C_EV_IRQHandler+0x212>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
      
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
 800434c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hi2c->Instance->CR2 |= I2C_CR2_STOP;
    }
    else
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800434e:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
 8004352:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004356:	63a3      	str	r3, [r4, #56]	; 0x38
      HAL_I2C_ErrorCallback(hi2c);
 8004358:	4620      	mov	r0, r4
 800435a:	f7ff fa89 	bl	8003870 <HAL_I2C_ErrorCallback>
 800435e:	e665      	b.n	800402c <HAL_I2C_EV_IRQHandler+0x12c>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8004360:	2210      	movs	r2, #16
 8004362:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8004364:	6ba3      	ldr	r3, [r4, #56]	; 0x38

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8004366:	2200      	movs	r2, #0
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8004368:	f043 0304 	orr.w	r3, r3, #4
 800436c:	63a3      	str	r3, [r4, #56]	; 0x38

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800436e:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    
      /* Call the Error callback to prevent upper layer */
      HAL_I2C_ErrorCallback(hi2c);
 8004372:	4620      	mov	r0, r4
 8004374:	f7ff fa7c 	bl	8003870 <HAL_I2C_ErrorCallback>
 8004378:	6823      	ldr	r3, [r4, #0]
 800437a:	e674      	b.n	8004066 <HAL_I2C_EV_IRQHandler+0x166>
        I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
        hi2c->XferSize = 255;
      }
      else
      {
        I2C_TransferConfig(hi2c,DevAddress,hi2c->XferCount, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800437c:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 800437e:	491b      	ldr	r1, [pc, #108]	; (80043ec <HAL_I2C_EV_IRQHandler+0x4ec>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));
    
  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8004380:	685d      	ldr	r5, [r3, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8004382:	4029      	ands	r1, r5
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8004384:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8004388:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 800438c:	b2c0      	uxtb	r0, r0
 800438e:	430a      	orrs	r2, r1
 8004390:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
            (uint32_t)Mode | (uint32_t)Request);
  
  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;  
 8004394:	605a      	str	r2, [r3, #4]
        hi2c->XferSize = 255;
      }
      else
      {
        I2C_TransferConfig(hi2c,DevAddress,hi2c->XferCount, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
        hi2c->XferSize = hi2c->XferCount;
 8004396:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8004398:	8523      	strh	r3, [r4, #40]	; 0x28
 800439a:	6823      	ldr	r3, [r4, #0]
 800439c:	e6b9      	b.n	8004112 <HAL_I2C_EV_IRQHandler+0x212>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
      
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
 800439e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hi2c->Instance->CR2 |= I2C_CR2_STOP;
    }
    else
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 80043a0:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      
      /* Wrong size Status regarding TCR flag event */
      hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
 80043a4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80043a8:	63a3      	str	r3, [r4, #56]	; 0x38
      HAL_I2C_ErrorCallback(hi2c);
 80043aa:	4620      	mov	r0, r4
 80043ac:	f7ff fa60 	bl	8003870 <HAL_I2C_ErrorCallback>
 80043b0:	6823      	ldr	r3, [r4, #0]
 80043b2:	e6ae      	b.n	8004112 <HAL_I2C_EV_IRQHandler+0x212>
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    
    if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX)
    {
      HAL_I2C_MemRxCpltCallback(hi2c);
 80043b4:	f7ff fa5a 	bl	800386c <HAL_I2C_MemRxCpltCallback>
 80043b8:	e638      	b.n	800402c <HAL_I2C_EV_IRQHandler+0x12c>
  /* which is stuck in TXDR until next    */
  /* communication with Master            */
  else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
  {
    /* Disable ERRI, TCI, STOPI, NACKI, ADDRI, RXI, TXI interrupt */
    __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI );
 80043ba:	6818      	ldr	r0, [r3, #0]
 80043bc:	f020 00fe 	bic.w	r0, r0, #254	; 0xfe
 80043c0:	6018      	str	r0, [r3, #0]
    
    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
 80043c2:	6820      	ldr	r0, [r4, #0]
 80043c4:	6843      	ldr	r3, [r0, #4]
 80043c6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80043ca:	6043      	str	r3, [r0, #4]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80043cc:	6823      	ldr	r3, [r4, #0]
 80043ce:	2020      	movs	r0, #32
 80043d0:	61d8      	str	r0, [r3, #28]
    hi2c->State = HAL_I2C_STATE_READY;
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    HAL_I2C_SlaveTxCpltCallback(hi2c);
 80043d2:	4620      	mov	r0, r4
    hi2c->Instance->CR2 |= I2C_CR2_NACK;

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

    hi2c->State = HAL_I2C_STATE_READY;
 80043d4:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80043d8:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34

    HAL_I2C_SlaveTxCpltCallback(hi2c);
 80043dc:	f7ff fa40 	bl	8003860 <HAL_I2C_SlaveTxCpltCallback>
 80043e0:	6823      	ldr	r3, [r4, #0]
 80043e2:	e640      	b.n	8004066 <HAL_I2C_EV_IRQHandler+0x166>
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX)
    {
      HAL_I2C_MemTxCpltCallback(hi2c);
 80043e4:	f7ff fa40 	bl	8003868 <HAL_I2C_MemTxCpltCallback>
 80043e8:	6823      	ldr	r3, [r4, #0]
 80043ea:	e692      	b.n	8004112 <HAL_I2C_EV_IRQHandler+0x212>
 80043ec:	fc009800 	.word	0xfc009800

080043f0 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 80043f0:	b508      	push	{r3, lr}
  /* I2C Bus error interrupt occurred ------------------------------------*/
  if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BERR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
 80043f2:	6803      	ldr	r3, [r0, #0]
 80043f4:	699a      	ldr	r2, [r3, #24]
 80043f6:	05d1      	lsls	r1, r2, #23
 80043f8:	d502      	bpl.n	8004400 <HAL_I2C_ER_IRQHandler+0x10>
 80043fa:	681a      	ldr	r2, [r3, #0]
 80043fc:	0612      	lsls	r2, r2, #24
 80043fe:	d424      	bmi.n	800444a <HAL_I2C_ER_IRQHandler+0x5a>
    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
  }
  
  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_OVR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
 8004400:	699a      	ldr	r2, [r3, #24]
 8004402:	0551      	lsls	r1, r2, #21
 8004404:	d502      	bpl.n	800440c <HAL_I2C_ER_IRQHandler+0x1c>
 8004406:	681a      	ldr	r2, [r3, #0]
 8004408:	0612      	lsls	r2, r2, #24
 800440a:	d415      	bmi.n	8004438 <HAL_I2C_ER_IRQHandler+0x48>
    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ARLO) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
 800440c:	699a      	ldr	r2, [r3, #24]
 800440e:	0591      	lsls	r1, r2, #22
 8004410:	d502      	bpl.n	8004418 <HAL_I2C_ER_IRQHandler+0x28>
 8004412:	681a      	ldr	r2, [r3, #0]
 8004414:	0612      	lsls	r2, r2, #24
 8004416:	d407      	bmi.n	8004428 <HAL_I2C_ER_IRQHandler+0x38>
    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
  }

  /* Call the Error Callback in case of Error detected */
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8004418:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800441a:	b123      	cbz	r3, 8004426 <HAL_I2C_ER_IRQHandler+0x36>
  {
    hi2c->State = HAL_I2C_STATE_READY;
 800441c:	2301      	movs	r3, #1
 800441e:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    
    HAL_I2C_ErrorCallback(hi2c);
 8004422:	f7ff fa25 	bl	8003870 <HAL_I2C_ErrorCallback>
 8004426:	bd08      	pop	{r3, pc}
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ARLO) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
  { 
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 8004428:	6b82      	ldr	r2, [r0, #56]	; 0x38

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 800442a:	f44f 7100 	mov.w	r1, #512	; 0x200
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ARLO) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
  { 
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 800442e:	f042 0202 	orr.w	r2, r2, #2
 8004432:	6382      	str	r2, [r0, #56]	; 0x38

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8004434:	61d9      	str	r1, [r3, #28]
 8004436:	e7ef      	b.n	8004418 <HAL_I2C_ER_IRQHandler+0x28>
  }
  
  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_OVR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
  { 
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8004438:	6b82      	ldr	r2, [r0, #56]	; 0x38

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 800443a:	f44f 6180 	mov.w	r1, #1024	; 0x400
  }
  
  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_OVR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
  { 
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 800443e:	f042 0208 	orr.w	r2, r2, #8
 8004442:	6382      	str	r2, [r0, #56]	; 0x38

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8004444:	61d9      	str	r1, [r3, #28]
 8004446:	6803      	ldr	r3, [r0, #0]
 8004448:	e7e0      	b.n	800440c <HAL_I2C_ER_IRQHandler+0x1c>
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
  /* I2C Bus error interrupt occurred ------------------------------------*/
  if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BERR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
  { 
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 800444a:	6b82      	ldr	r2, [r0, #56]	; 0x38
   
    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 800444c:	f44f 7180 	mov.w	r1, #256	; 0x100
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
  /* I2C Bus error interrupt occurred ------------------------------------*/
  if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BERR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
  { 
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 8004450:	f042 0201 	orr.w	r2, r2, #1
 8004454:	6382      	str	r2, [r0, #56]	; 0x38
   
    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8004456:	61d9      	str	r1, [r3, #28]
 8004458:	6803      	ldr	r3, [r0, #0]
 800445a:	e7d1      	b.n	8004400 <HAL_I2C_ER_IRQHandler+0x10>

0800445c <HAL_I2C_GetState>:
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
  /* Return I2C handle state */
  return hi2c->State;
 800445c:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
 8004460:	4770      	bx	lr
 8004462:	bf00      	nop

08004464 <HAL_I2C_GetError>:
  *              the configuration information for the specified I2C.
* @retval I2C Error Code
*/
uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
{
  return hi2c->ErrorCode;
 8004464:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 8004466:	4770      	bx	lr

08004468 <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
  
  if((hi2c->State == HAL_I2C_STATE_BUSY) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX)
 8004468:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800446c:	b2db      	uxtb	r3, r3
 800446e:	2b02      	cmp	r3, #2
 8004470:	d036      	beq.n	80044e0 <HAL_I2CEx_ConfigAnalogFilter+0x78>
 8004472:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8004476:	2b12      	cmp	r3, #18
 8004478:	d031      	beq.n	80044de <HAL_I2CEx_ConfigAnalogFilter+0x76>
 800447a:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800447e:	2b22      	cmp	r3, #34	; 0x22
 8004480:	d02d      	beq.n	80044de <HAL_I2CEx_ConfigAnalogFilter+0x76>
     || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX))
 8004482:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8004486:	2b32      	cmp	r3, #50	; 0x32
 8004488:	d029      	beq.n	80044de <HAL_I2CEx_ConfigAnalogFilter+0x76>
 800448a:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800448e:	2b42      	cmp	r3, #66	; 0x42
 8004490:	d025      	beq.n	80044de <HAL_I2CEx_ConfigAnalogFilter+0x76>
  {
    return HAL_BUSY;
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);
 8004492:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 8004496:	2b01      	cmp	r3, #1
 8004498:	d021      	beq.n	80044de <HAL_I2CEx_ConfigAnalogFilter+0x76>
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter : new state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 800449a:	b410      	push	{r4}
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);

  hi2c->State = HAL_I2C_STATE_BUSY;
 800449c:	2302      	movs	r3, #2
  
  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);    
 800449e:	6802      	ldr	r2, [r0, #0]
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);

  hi2c->State = HAL_I2C_STATE_BUSY;
 80044a0:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  {
    return HAL_BUSY;
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);
 80044a4:	2401      	movs	r4, #1
 80044a6:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34

  hi2c->State = HAL_I2C_STATE_BUSY;
  
  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);    
 80044aa:	6813      	ldr	r3, [r2, #0]
 80044ac:	f023 0301 	bic.w	r3, r3, #1
 80044b0:	6013      	str	r3, [r2, #0]
  
  /* Reset I2Cx ANOFF bit */
  hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);    
 80044b2:	6802      	ldr	r2, [r0, #0]
 80044b4:	6813      	ldr	r3, [r2, #0]
 80044b6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80044ba:	6013      	str	r3, [r2, #0]
  
  /* Set analog filter bit*/
  hi2c->Instance->CR1 |= AnalogFilter;
 80044bc:	6802      	ldr	r2, [r0, #0]
 80044be:	6813      	ldr	r3, [r2, #0]
 80044c0:	4319      	orrs	r1, r3
 80044c2:	6011      	str	r1, [r2, #0]
  
  __HAL_I2C_ENABLE(hi2c); 
 80044c4:	6801      	ldr	r1, [r0, #0]
 80044c6:	680b      	ldr	r3, [r1, #0]
  
  hi2c->State = HAL_I2C_STATE_READY;
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 80044c8:	2200      	movs	r2, #0
  hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);    
  
  /* Set analog filter bit*/
  hi2c->Instance->CR1 |= AnalogFilter;
  
  __HAL_I2C_ENABLE(hi2c); 
 80044ca:	4323      	orrs	r3, r4
 80044cc:	600b      	str	r3, [r1, #0]
  
  hi2c->State = HAL_I2C_STATE_READY;
 80044ce:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 80044d2:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

  return HAL_OK; 
}
 80044d6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80044da:	4610      	mov	r0, r2
 80044dc:	4770      	bx	lr
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
  
  if((hi2c->State == HAL_I2C_STATE_BUSY) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX)
     || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX))
  {
    return HAL_BUSY;
 80044de:	2302      	movs	r3, #2
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);

  return HAL_OK; 
}
 80044e0:	4618      	mov	r0, r3
 80044e2:	4770      	bx	lr

080044e4 <HAL_I2CEx_ConfigDigitalFilter>:
  
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
  
  if((hi2c->State == HAL_I2C_STATE_BUSY) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX)
 80044e4:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80044e8:	b2db      	uxtb	r3, r3
 80044ea:	2b02      	cmp	r3, #2
 80044ec:	d034      	beq.n	8004558 <HAL_I2CEx_ConfigDigitalFilter+0x74>
 80044ee:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80044f2:	2b12      	cmp	r3, #18
 80044f4:	d02f      	beq.n	8004556 <HAL_I2CEx_ConfigDigitalFilter+0x72>
 80044f6:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80044fa:	2b22      	cmp	r3, #34	; 0x22
 80044fc:	d02b      	beq.n	8004556 <HAL_I2CEx_ConfigDigitalFilter+0x72>
     || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX))
 80044fe:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8004502:	2b32      	cmp	r3, #50	; 0x32
 8004504:	d027      	beq.n	8004556 <HAL_I2CEx_ConfigDigitalFilter+0x72>
 8004506:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800450a:	2b42      	cmp	r3, #66	; 0x42
 800450c:	d023      	beq.n	8004556 <HAL_I2CEx_ConfigDigitalFilter+0x72>
  {
    return HAL_BUSY;
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);
 800450e:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 8004512:	2b01      	cmp	r3, #1
 8004514:	d01f      	beq.n	8004556 <HAL_I2CEx_ConfigDigitalFilter+0x72>
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter : Coefficient of digital noise filter between 0x00 and 0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 8004516:	b410      	push	{r4}
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);

  hi2c->State = HAL_I2C_STATE_BUSY;
 8004518:	2302      	movs	r3, #2
  
  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);  
 800451a:	6802      	ldr	r2, [r0, #0]
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);

  hi2c->State = HAL_I2C_STATE_BUSY;
 800451c:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  {
    return HAL_BUSY;
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);
 8004520:	2401      	movs	r4, #1
 8004522:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34

  hi2c->State = HAL_I2C_STATE_BUSY;
  
  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);  
 8004526:	6813      	ldr	r3, [r2, #0]
 8004528:	f023 0301 	bic.w	r3, r3, #1
 800452c:	6013      	str	r3, [r2, #0]
  
  /* Get the old register value */
  tmpreg = hi2c->Instance->CR1;
 800452e:	6802      	ldr	r2, [r0, #0]
 8004530:	6813      	ldr	r3, [r2, #0]
  
  /* Reset I2Cx DNF bits [11:8] */
  tmpreg &= ~(I2C_CR1_DNF);
 8004532:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  
  /* Set I2Cx DNF coefficient */
  tmpreg |= DigitalFilter << 8;
 8004536:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
  
  /* Store the new register value */
  hi2c->Instance->CR1 = tmpreg;
 800453a:	6011      	str	r1, [r2, #0]
  
  __HAL_I2C_ENABLE(hi2c); 
 800453c:	6801      	ldr	r1, [r0, #0]
 800453e:	680b      	ldr	r3, [r1, #0]
  
  hi2c->State = HAL_I2C_STATE_READY;
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 8004540:	2200      	movs	r2, #0
  tmpreg |= DigitalFilter << 8;
  
  /* Store the new register value */
  hi2c->Instance->CR1 = tmpreg;
  
  __HAL_I2C_ENABLE(hi2c); 
 8004542:	4323      	orrs	r3, r4
 8004544:	600b      	str	r3, [r1, #0]
  
  hi2c->State = HAL_I2C_STATE_READY;
 8004546:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 800454a:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

  return HAL_OK; 
}  
 800454e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004552:	4610      	mov	r0, r2
 8004554:	4770      	bx	lr
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
  
  if((hi2c->State == HAL_I2C_STATE_BUSY) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX)
     || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX))
  {
    return HAL_BUSY;
 8004556:	2302      	movs	r3, #2
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);

  return HAL_OK; 
}  
 8004558:	4618      	mov	r0, r3
 800455a:	4770      	bx	lr

0800455c <HAL_I2CEx_EnableWakeUp>:
HAL_StatusTypeDef HAL_I2CEx_EnableWakeUp (I2C_HandleTypeDef *hi2c)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  
  if((hi2c->State == HAL_I2C_STATE_BUSY) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX)
 800455c:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8004560:	b2db      	uxtb	r3, r3
 8004562:	2b02      	cmp	r3, #2
 8004564:	d032      	beq.n	80045cc <HAL_I2CEx_EnableWakeUp+0x70>
 8004566:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800456a:	2b12      	cmp	r3, #18
 800456c:	d02d      	beq.n	80045ca <HAL_I2CEx_EnableWakeUp+0x6e>
 800456e:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8004572:	2b22      	cmp	r3, #34	; 0x22
 8004574:	d029      	beq.n	80045ca <HAL_I2CEx_EnableWakeUp+0x6e>
     || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX))
 8004576:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800457a:	2b32      	cmp	r3, #50	; 0x32
 800457c:	d025      	beq.n	80045ca <HAL_I2CEx_EnableWakeUp+0x6e>
 800457e:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8004582:	2b42      	cmp	r3, #66	; 0x42
 8004584:	d021      	beq.n	80045ca <HAL_I2CEx_EnableWakeUp+0x6e>
  {
    return HAL_BUSY;
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);
 8004586:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 800458a:	2b01      	cmp	r3, #1
 800458c:	d01d      	beq.n	80045ca <HAL_I2CEx_EnableWakeUp+0x6e>
  * @param  hi2c : pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_EnableWakeUp (I2C_HandleTypeDef *hi2c)
{
 800458e:	b410      	push	{r4}
  {
    return HAL_BUSY;
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);
 8004590:	2101      	movs	r1, #1

  hi2c->State = HAL_I2C_STATE_BUSY;
  
  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);  
 8004592:	6802      	ldr	r2, [r0, #0]
  {
    return HAL_BUSY;
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);
 8004594:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34

  hi2c->State = HAL_I2C_STATE_BUSY;
 8004598:	2302      	movs	r3, #2
 800459a:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  
  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);  
 800459e:	6813      	ldr	r3, [r2, #0]
 80045a0:	f023 0301 	bic.w	r3, r3, #1
 80045a4:	6013      	str	r3, [r2, #0]
  
  /* Enable wakeup from stop mode */
  hi2c->Instance->CR1 |= I2C_CR1_WUPEN;   
 80045a6:	6802      	ldr	r2, [r0, #0]
 80045a8:	6813      	ldr	r3, [r2, #0]
 80045aa:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80045ae:	6013      	str	r3, [r2, #0]
  
  __HAL_I2C_ENABLE(hi2c); 
 80045b0:	6804      	ldr	r4, [r0, #0]
 80045b2:	6823      	ldr	r3, [r4, #0]
  
  hi2c->State = HAL_I2C_STATE_READY;
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 80045b4:	2200      	movs	r2, #0
  __HAL_I2C_DISABLE(hi2c);  
  
  /* Enable wakeup from stop mode */
  hi2c->Instance->CR1 |= I2C_CR1_WUPEN;   
  
  __HAL_I2C_ENABLE(hi2c); 
 80045b6:	430b      	orrs	r3, r1
 80045b8:	6023      	str	r3, [r4, #0]
  
  hi2c->State = HAL_I2C_STATE_READY;
 80045ba:	f880 1035 	strb.w	r1, [r0, #53]	; 0x35
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 80045be:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

  return HAL_OK; 
}  
 80045c2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80045c6:	4610      	mov	r0, r2
 80045c8:	4770      	bx	lr
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  
  if((hi2c->State == HAL_I2C_STATE_BUSY) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX)
     || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX))
  {
    return HAL_BUSY;
 80045ca:	2302      	movs	r3, #2
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);

  return HAL_OK; 
}  
 80045cc:	4618      	mov	r0, r3
 80045ce:	4770      	bx	lr

080045d0 <HAL_I2CEx_DisableWakeUp>:
HAL_StatusTypeDef HAL_I2CEx_DisableWakeUp (I2C_HandleTypeDef *hi2c)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  
  if((hi2c->State == HAL_I2C_STATE_BUSY) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX)
 80045d0:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80045d4:	b2db      	uxtb	r3, r3
 80045d6:	2b02      	cmp	r3, #2
 80045d8:	d032      	beq.n	8004640 <HAL_I2CEx_DisableWakeUp+0x70>
 80045da:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80045de:	2b12      	cmp	r3, #18
 80045e0:	d02d      	beq.n	800463e <HAL_I2CEx_DisableWakeUp+0x6e>
 80045e2:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80045e6:	2b22      	cmp	r3, #34	; 0x22
 80045e8:	d029      	beq.n	800463e <HAL_I2CEx_DisableWakeUp+0x6e>
     || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX))
 80045ea:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80045ee:	2b32      	cmp	r3, #50	; 0x32
 80045f0:	d025      	beq.n	800463e <HAL_I2CEx_DisableWakeUp+0x6e>
 80045f2:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80045f6:	2b42      	cmp	r3, #66	; 0x42
 80045f8:	d021      	beq.n	800463e <HAL_I2CEx_DisableWakeUp+0x6e>
  {
    return HAL_BUSY;
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);
 80045fa:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 80045fe:	2b01      	cmp	r3, #1
 8004600:	d01d      	beq.n	800463e <HAL_I2CEx_DisableWakeUp+0x6e>
  * @param  hi2c : pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_DisableWakeUp (I2C_HandleTypeDef *hi2c)
{
 8004602:	b410      	push	{r4}
  {
    return HAL_BUSY;
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);
 8004604:	2101      	movs	r1, #1

  hi2c->State = HAL_I2C_STATE_BUSY;
  
  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);  
 8004606:	6802      	ldr	r2, [r0, #0]
  {
    return HAL_BUSY;
  }
  
  /* Process Locked */
  __HAL_LOCK(hi2c);
 8004608:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34

  hi2c->State = HAL_I2C_STATE_BUSY;
 800460c:	2302      	movs	r3, #2
 800460e:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  
  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);  
 8004612:	6813      	ldr	r3, [r2, #0]
 8004614:	f023 0301 	bic.w	r3, r3, #1
 8004618:	6013      	str	r3, [r2, #0]
  
  /* Enable wakeup from stop mode */
  hi2c->Instance->CR1 &= ~(I2C_CR1_WUPEN);   
 800461a:	6802      	ldr	r2, [r0, #0]
 800461c:	6813      	ldr	r3, [r2, #0]
 800461e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8004622:	6013      	str	r3, [r2, #0]
  
  __HAL_I2C_ENABLE(hi2c); 
 8004624:	6804      	ldr	r4, [r0, #0]
 8004626:	6823      	ldr	r3, [r4, #0]
  
  hi2c->State = HAL_I2C_STATE_READY;
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 8004628:	2200      	movs	r2, #0
  __HAL_I2C_DISABLE(hi2c);  
  
  /* Enable wakeup from stop mode */
  hi2c->Instance->CR1 &= ~(I2C_CR1_WUPEN);   
  
  __HAL_I2C_ENABLE(hi2c); 
 800462a:	430b      	orrs	r3, r1
 800462c:	6023      	str	r3, [r4, #0]
  
  hi2c->State = HAL_I2C_STATE_READY;
 800462e:	f880 1035 	strb.w	r1, [r0, #53]	; 0x35
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 8004632:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

  return HAL_OK; 
}  
 8004636:	f85d 4b04 	ldr.w	r4, [sp], #4
 800463a:	4610      	mov	r0, r2
 800463c:	4770      	bx	lr
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  
  if((hi2c->State == HAL_I2C_STATE_BUSY) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX)
     || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX))
  {
    return HAL_BUSY;
 800463e:	2302      	movs	r3, #2
  
  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);

  return HAL_OK; 
}  
 8004640:	4618      	mov	r0, r3
 8004642:	4770      	bx	lr

08004644 <HAL_I2CEx_EnableFastModePlus>:
{
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));
  
  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004644:	4b08      	ldr	r3, [pc, #32]	; (8004668 <HAL_I2CEx_EnableFastModePlus+0x24>)
  
  /* Enable fast mode plus driving capability for selected pin */
  SET_BIT(SYSCFG->CFGR1, (uint32_t)ConfigFastModePlus);
 8004646:	4909      	ldr	r1, [pc, #36]	; (800466c <HAL_I2CEx_EnableFastModePlus+0x28>)
{
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));
  
  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004648:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800464a:	f042 0201 	orr.w	r2, r2, #1
 800464e:	661a      	str	r2, [r3, #96]	; 0x60
 8004650:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  * @note  For all I2C3 pins fast mode plus driving capability can be enabled
  *        only by using I2C_FASTMODEPLUS_I2C3 parameter.
  * @retval None
  */
void HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus)
{
 8004652:	b082      	sub	sp, #8
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));
  
  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004654:	f003 0301 	and.w	r3, r3, #1
 8004658:	9301      	str	r3, [sp, #4]
 800465a:	9b01      	ldr	r3, [sp, #4]
  
  /* Enable fast mode plus driving capability for selected pin */
  SET_BIT(SYSCFG->CFGR1, (uint32_t)ConfigFastModePlus);
 800465c:	684b      	ldr	r3, [r1, #4]
 800465e:	4318      	orrs	r0, r3
 8004660:	6048      	str	r0, [r1, #4]
}
 8004662:	b002      	add	sp, #8
 8004664:	4770      	bx	lr
 8004666:	bf00      	nop
 8004668:	40021000 	.word	0x40021000
 800466c:	40010000 	.word	0x40010000

08004670 <HAL_I2CEx_DisableFastModePlus>:
{
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));
  
  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004670:	4b08      	ldr	r3, [pc, #32]	; (8004694 <HAL_I2CEx_DisableFastModePlus+0x24>)

  /* Disable fast mode plus driving capability for selected pin */
  CLEAR_BIT(SYSCFG->CFGR1, (uint32_t)ConfigFastModePlus);
 8004672:	4909      	ldr	r1, [pc, #36]	; (8004698 <HAL_I2CEx_DisableFastModePlus+0x28>)
{
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));
  
  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004674:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8004676:	f042 0201 	orr.w	r2, r2, #1
 800467a:	661a      	str	r2, [r3, #96]	; 0x60
 800467c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  * @note  For all I2C3 pins fast mode plus driving capability can be disabled
  *        only by using I2C_FASTMODEPLUS_I2C3 parameter.
  * @retval None
  */
void HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus)
{
 800467e:	b082      	sub	sp, #8
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));
  
  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004680:	f003 0301 	and.w	r3, r3, #1
 8004684:	9301      	str	r3, [sp, #4]
 8004686:	9b01      	ldr	r3, [sp, #4]

  /* Disable fast mode plus driving capability for selected pin */
  CLEAR_BIT(SYSCFG->CFGR1, (uint32_t)ConfigFastModePlus);
 8004688:	684b      	ldr	r3, [r1, #4]
 800468a:	ea23 0000 	bic.w	r0, r3, r0
 800468e:	6048      	str	r0, [r1, #4]
}
 8004690:	b002      	add	sp, #8
 8004692:	4770      	bx	lr
 8004694:	40021000 	.word	0x40021000
 8004698:	40010000 	.word	0x40010000
  * @brief  Initializes the PCD MSP.
  * @param  hpcd: PCD handle
  * @retval None
  */
__weak void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
{
 800469c:	4770      	bx	lr
 800469e:	bf00      	nop

080046a0 <HAL_PCD_Init>:
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
  uint32_t i = 0;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 80046a0:	2800      	cmp	r0, #0
 80046a2:	f000 8084 	beq.w	80047ae <HAL_PCD_Init+0x10e>
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 80046a6:	b5f0      	push	{r4, r5, r6, r7, lr}
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
  
  if(hpcd->State == HAL_PCD_STATE_RESET)
 80046a8:	f890 3381 	ldrb.w	r3, [r0, #897]	; 0x381
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 80046ac:	b08b      	sub	sp, #44	; 0x2c
 80046ae:	4605      	mov	r5, r0
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
  
  if(hpcd->State == HAL_PCD_STATE_RESET)
 80046b0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80046b4:	2b00      	cmp	r3, #0
 80046b6:	d06d      	beq.n	8004794 <HAL_PCD_Init+0xf4>

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80046b8:	2303      	movs	r3, #3

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);

  /*Init the Core (common init.) */
  USB_CoreInit(hpcd->Instance, hpcd->Init);
 80046ba:	462e      	mov	r6, r5

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80046bc:	f885 3381 	strb.w	r3, [r5, #897]	; 0x381

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 80046c0:	6828      	ldr	r0, [r5, #0]
 80046c2:	f006 fb05 	bl	800acd0 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  USB_CoreInit(hpcd->Instance, hpcd->Init);
 80046c6:	f856 eb10 	ldr.w	lr, [r6], #16
 80046ca:	4637      	mov	r7, r6
 80046cc:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80046ce:	466c      	mov	r4, sp
 80046d0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80046d2:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80046d4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80046d6:	e897 0003 	ldmia.w	r7, {r0, r1}
 80046da:	e884 0003 	stmia.w	r4, {r0, r1}
 80046de:	1d2f      	adds	r7, r5, #4
 80046e0:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 80046e4:	4670      	mov	r0, lr
 80046e6:	f006 fac3 	bl	800ac70 <USB_CoreInit>

  /* Force Device Mode*/
  USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 80046ea:	6828      	ldr	r0, [r5, #0]
 80046ec:	2100      	movs	r1, #0
 80046ee:	f006 faf7 	bl	800ace0 <USB_SetCurrentMode>

  /* Init endpoints structures */
  for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 80046f2:	6868      	ldr	r0, [r5, #4]
 80046f4:	b378      	cbz	r0, 8004756 <HAL_PCD_Init+0xb6>
 80046f6:	2100      	movs	r1, #0
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1;
    hpcd->IN_ep[i].num = i;
    hpcd->IN_ep[i].tx_fifo_num = i;
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80046f8:	460c      	mov	r4, r1
 80046fa:	462b      	mov	r3, r5

  /* Force Device Mode*/
  USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);

  /* Init endpoints structures */
  for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 80046fc:	462a      	mov	r2, r5
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1;
 80046fe:	f04f 0e01 	mov.w	lr, #1
    hpcd->IN_ep[i].num = i;
 8004702:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
    hpcd->IN_ep[i].tx_fifo_num = i;
 8004706:	87d1      	strh	r1, [r2, #62]	; 0x3e

  /* Force Device Mode*/
  USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);

  /* Init endpoints structures */
  for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 8004708:	3101      	adds	r1, #1
 800470a:	4281      	cmp	r1, r0
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1;
 800470c:	f882 e039 	strb.w	lr, [r2, #57]	; 0x39
    hpcd->IN_ep[i].num = i;
    hpcd->IN_ep[i].tx_fifo_num = i;
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8004710:	f882 403b 	strb.w	r4, [r2, #59]	; 0x3b
    hpcd->IN_ep[i].maxpacket =  0;
 8004714:	6414      	str	r4, [r2, #64]	; 0x40
    hpcd->IN_ep[i].xfer_buff = 0;
 8004716:	6454      	str	r4, [r2, #68]	; 0x44
    hpcd->IN_ep[i].xfer_len = 0;
 8004718:	64d4      	str	r4, [r2, #76]	; 0x4c
 800471a:	f102 021c 	add.w	r2, r2, #28

  /* Force Device Mode*/
  USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);

  /* Init endpoints structures */
  for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 800471e:	d1f0      	bne.n	8004702 <HAL_PCD_Init+0x62>
 8004720:	2200      	movs	r2, #0
    hpcd->IN_ep[i].xfer_len = 0;
  }
 
  for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
  {
    hpcd->OUT_ep[i].is_in = 0;
 8004722:	4611      	mov	r1, r2
    hpcd->OUT_ep[i].num = i;
 8004724:	f883 21dc 	strb.w	r2, [r3, #476]	; 0x1dc
    hpcd->IN_ep[i].tx_fifo_num = i;
 8004728:	87da      	strh	r2, [r3, #62]	; 0x3e
    hpcd->IN_ep[i].xfer_len = 0;
  }
 
  for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
  {
    hpcd->OUT_ep[i].is_in = 0;
 800472a:	f883 11dd 	strb.w	r1, [r3, #477]	; 0x1dd
    hpcd->OUT_ep[i].num = i;
    hpcd->IN_ep[i].tx_fifo_num = i;
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 800472e:	f883 11df 	strb.w	r1, [r3, #479]	; 0x1df
    hpcd->OUT_ep[i].maxpacket = 0;
 8004732:	f8c3 11e4 	str.w	r1, [r3, #484]	; 0x1e4
    hpcd->OUT_ep[i].xfer_buff = 0;
 8004736:	f8c3 11e8 	str.w	r1, [r3, #488]	; 0x1e8
    hpcd->OUT_ep[i].xfer_len = 0;
 800473a:	f8c3 11f0 	str.w	r1, [r3, #496]	; 0x1f0

    hpcd->Instance->DIEPTXF[i] = 0;
 800473e:	6828      	ldr	r0, [r5, #0]
 8004740:	f102 0440 	add.w	r4, r2, #64	; 0x40
 8004744:	eb00 0084 	add.w	r0, r0, r4, lsl #2
    hpcd->IN_ep[i].maxpacket =  0;
    hpcd->IN_ep[i].xfer_buff = 0;
    hpcd->IN_ep[i].xfer_len = 0;
  }
 
  for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 8004748:	3201      	adds	r2, #1
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
    hpcd->OUT_ep[i].maxpacket = 0;
    hpcd->OUT_ep[i].xfer_buff = 0;
    hpcd->OUT_ep[i].xfer_len = 0;

    hpcd->Instance->DIEPTXF[i] = 0;
 800474a:	6041      	str	r1, [r0, #4]
    hpcd->IN_ep[i].maxpacket =  0;
    hpcd->IN_ep[i].xfer_buff = 0;
    hpcd->IN_ep[i].xfer_len = 0;
  }
 
  for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 800474c:	6868      	ldr	r0, [r5, #4]
 800474e:	4290      	cmp	r0, r2
 8004750:	f103 031c 	add.w	r3, r3, #28
 8004754:	d8e6      	bhi.n	8004724 <HAL_PCD_Init+0x84>

    hpcd->Instance->DIEPTXF[i] = 0;
  }

  /* Init Device */
  USB_DevInit(hpcd->Instance, hpcd->Init);
 8004756:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8004758:	466c      	mov	r4, sp
 800475a:	f8d5 e000 	ldr.w	lr, [r5]
 800475e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8004760:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8004762:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8004764:	e896 0003 	ldmia.w	r6, {r0, r1}
 8004768:	e884 0003 	stmia.w	r4, {r0, r1}
 800476c:	4670      	mov	r0, lr
 800476e:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8004772:	f006 facf 	bl	800ad14 <USB_DevInit>

  hpcd->State= HAL_PCD_STATE_READY;
  
   /* Activate LPM */
  if (hpcd->Init.lpm_enable ==1)
 8004776:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  }

  /* Init Device */
  USB_DevInit(hpcd->Instance, hpcd->Init);

  hpcd->State= HAL_PCD_STATE_READY;
 8004778:	2201      	movs	r2, #1
  
   /* Activate LPM */
  if (hpcd->Init.lpm_enable ==1)
 800477a:	4293      	cmp	r3, r2
  }

  /* Init Device */
  USB_DevInit(hpcd->Instance, hpcd->Init);

  hpcd->State= HAL_PCD_STATE_READY;
 800477c:	f885 2381 	strb.w	r2, [r5, #897]	; 0x381
  
   /* Activate LPM */
  if (hpcd->Init.lpm_enable ==1)
 8004780:	d011      	beq.n	80047a6 <HAL_PCD_Init+0x106>
  {
    HAL_PCDEx_ActivateLPM(hpcd);
  }  
  /* Activate Battery charging */
  if (hpcd->Init.battery_charging_enable ==1)
 8004782:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8004784:	2b01      	cmp	r3, #1
 8004786:	d00a      	beq.n	800479e <HAL_PCD_Init+0xfe>
  {
    HAL_PCDEx_ActivateBCD(hpcd);
  }
  USB_DevDisconnect (hpcd->Instance);  
 8004788:	6828      	ldr	r0, [r5, #0]
 800478a:	f006 ff87 	bl	800b69c <USB_DevDisconnect>
  return HAL_OK;
 800478e:	2000      	movs	r0, #0
}
 8004790:	b00b      	add	sp, #44	; 0x2c
 8004792:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
  
  if(hpcd->State == HAL_PCD_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 8004794:	f880 2380 	strb.w	r2, [r0, #896]	; 0x380

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 8004798:	f7fc f908 	bl	80009ac <HAL_PCD_MspInit>
 800479c:	e78c      	b.n	80046b8 <HAL_PCD_Init+0x18>
    HAL_PCDEx_ActivateLPM(hpcd);
  }  
  /* Activate Battery charging */
  if (hpcd->Init.battery_charging_enable ==1)
  {
    HAL_PCDEx_ActivateBCD(hpcd);
 800479e:	4628      	mov	r0, r5
 80047a0:	f000 fd0e 	bl	80051c0 <HAL_PCDEx_ActivateBCD>
 80047a4:	e7f0      	b.n	8004788 <HAL_PCD_Init+0xe8>
  hpcd->State= HAL_PCD_STATE_READY;
  
   /* Activate LPM */
  if (hpcd->Init.lpm_enable ==1)
  {
    HAL_PCDEx_ActivateLPM(hpcd);
 80047a6:	4628      	mov	r0, r5
 80047a8:	f000 fce6 	bl	8005178 <HAL_PCDEx_ActivateLPM>
 80047ac:	e7e9      	b.n	8004782 <HAL_PCD_Init+0xe2>
  uint32_t i = 0;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
  {
    return HAL_ERROR;
 80047ae:	2001      	movs	r0, #1
 80047b0:	4770      	bx	lr
 80047b2:	bf00      	nop
  * @brief  DeInitializes PCD MSP.
  * @param  hpcd: PCD handle
  * @retval None
  */
__weak void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
{
 80047b4:	4770      	bx	lr
 80047b6:	bf00      	nop

080047b8 <HAL_PCD_DeInit>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
{
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 80047b8:	b1f0      	cbz	r0, 80047f8 <HAL_PCD_DeInit+0x40>
  * @brief  DeInitializes the PCD peripheral.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
{
 80047ba:	b510      	push	{r4, lr}
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 80047bc:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
  if(hpcd == NULL)
  {
    return HAL_ERROR;
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80047c0:	2203      	movs	r2, #3
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 80047c2:	2b01      	cmp	r3, #1
 80047c4:	4604      	mov	r4, r0
  if(hpcd == NULL)
  {
    return HAL_ERROR;
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80047c6:	f880 2381 	strb.w	r2, [r0, #897]	; 0x381
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 80047ca:	d00e      	beq.n	80047ea <HAL_PCD_DeInit+0x32>
 80047cc:	2301      	movs	r3, #1
 80047ce:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  __HAL_PCD_DISABLE(hpcd);
 80047d2:	6800      	ldr	r0, [r0, #0]
 80047d4:	f006 fa7c 	bl	800acd0 <USB_DisableGlobalInt>
  USB_StopDevice(hpcd->Instance);
 80047d8:	6820      	ldr	r0, [r4, #0]
 80047da:	f006 ff11 	bl	800b600 <USB_StopDevice>
  USB_DevDisconnect (hpcd->Instance);
 80047de:	6820      	ldr	r0, [r4, #0]
 80047e0:	f006 ff5c 	bl	800b69c <USB_DevDisconnect>
  __HAL_UNLOCK(hpcd); 
 80047e4:	2300      	movs	r3, #0
 80047e6:	f884 3380 	strb.w	r3, [r4, #896]	; 0x380
  
  /* Stop Device */
  HAL_PCD_Stop(hpcd);
    
  /* DeInit the low level hardware */
  HAL_PCD_MspDeInit(hpcd);
 80047ea:	4620      	mov	r0, r4
 80047ec:	f7fc f918 	bl	8000a20 <HAL_PCD_MspDeInit>
  
  hpcd->State = HAL_PCD_STATE_RESET; 
 80047f0:	2000      	movs	r0, #0
 80047f2:	f884 0381 	strb.w	r0, [r4, #897]	; 0x381
  
  return HAL_OK;
 80047f6:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
{
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
  {
    return HAL_ERROR;
 80047f8:	2001      	movs	r0, #1
 80047fa:	4770      	bx	lr

080047fc <HAL_PCD_Start>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 80047fc:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8004800:	2b01      	cmp	r3, #1
 8004802:	d101      	bne.n	8004808 <HAL_PCD_Start+0xc>
 8004804:	2002      	movs	r0, #2
 8004806:	4770      	bx	lr
  * @brief  Start The USB OTG Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
 8004808:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd); 
 800480a:	2301      	movs	r3, #1
 800480c:	4604      	mov	r4, r0
 800480e:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_DevConnect (hpcd->Instance);  
 8004812:	6800      	ldr	r0, [r0, #0]
 8004814:	f006 ff36 	bl	800b684 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 8004818:	6820      	ldr	r0, [r4, #0]
 800481a:	f006 fa51 	bl	800acc0 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd); 
 800481e:	2000      	movs	r0, #0
 8004820:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8004824:	bd10      	pop	{r4, pc}
 8004826:	bf00      	nop

08004828 <HAL_PCD_Stop>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8004828:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 800482c:	2b01      	cmp	r3, #1
 800482e:	d101      	bne.n	8004834 <HAL_PCD_Stop+0xc>
 8004830:	2002      	movs	r0, #2
 8004832:	4770      	bx	lr
  * @brief  Stop The USB OTG Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
 8004834:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd); 
 8004836:	2301      	movs	r3, #1
 8004838:	4604      	mov	r4, r0
 800483a:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  __HAL_PCD_DISABLE(hpcd);
 800483e:	6800      	ldr	r0, [r0, #0]
 8004840:	f006 fa46 	bl	800acd0 <USB_DisableGlobalInt>
  USB_StopDevice(hpcd->Instance);
 8004844:	6820      	ldr	r0, [r4, #0]
 8004846:	f006 fedb 	bl	800b600 <USB_StopDevice>
  USB_DevDisconnect (hpcd->Instance);
 800484a:	6820      	ldr	r0, [r4, #0]
 800484c:	f006 ff26 	bl	800b69c <USB_DevDisconnect>
  __HAL_UNLOCK(hpcd); 
 8004850:	2000      	movs	r0, #0
 8004852:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
 8004856:	bd10      	pop	{r4, pc}

08004858 <HAL_PCD_DataOutStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: endpoint number
  * @retval None
  */
 __weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8004858:	4770      	bx	lr
 800485a:	bf00      	nop

0800485c <HAL_PCD_DataInStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: endpoint number
  * @retval None
  */
 __weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 800485c:	4770      	bx	lr
 800485e:	bf00      	nop

08004860 <HAL_PCD_SetupStageCallback>:
  * @brief  Setup stage callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
 __weak void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
 8004860:	4770      	bx	lr
 8004862:	bf00      	nop

08004864 <HAL_PCD_SOFCallback>:
  * @brief  USB Start Of Frame callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
 __weak void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
 8004864:	4770      	bx	lr
 8004866:	bf00      	nop

08004868 <HAL_PCD_ResetCallback>:
  * @brief  USB Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
 __weak void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{
 8004868:	4770      	bx	lr
 800486a:	bf00      	nop

0800486c <HAL_PCD_SuspendCallback>:
  * @brief  Suspend event callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
 __weak void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
 800486c:	4770      	bx	lr
 800486e:	bf00      	nop

08004870 <HAL_PCD_ResumeCallback>:
  * @brief  Resume event callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
 __weak void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
 8004870:	4770      	bx	lr
 8004872:	bf00      	nop

08004874 <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: endpoint number
  * @retval None
  */
 __weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8004874:	4770      	bx	lr
 8004876:	bf00      	nop

08004878 <HAL_PCD_ISOINIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: endpoint number
  * @retval None
  */
 __weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8004878:	4770      	bx	lr
 800487a:	bf00      	nop

0800487c <HAL_PCD_ConnectCallback>:
  * @brief  Connection event callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
 __weak void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
 800487c:	4770      	bx	lr
 800487e:	bf00      	nop

08004880 <HAL_PCD_DisconnectCallback>:
  * @brief  Disconnection event callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
 __weak void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
 8004880:	4770      	bx	lr
 8004882:	bf00      	nop

08004884 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8004884:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8004888:	6806      	ldr	r6, [r0, #0]
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800488a:	b087      	sub	sp, #28
 800488c:	4604      	mov	r4, r0
  uint32_t i = 0, ep_intr = 0, epint = 0, epnum = 0;
  uint32_t fifoemptymsk = 0, temp = 0;
  USB_OTG_EPTypeDef *ep;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 800488e:	4630      	mov	r0, r6
 8004890:	f006 ff44 	bl	800b71c <USB_GetMode>
 8004894:	b110      	cbz	r0, 800489c <HAL_PCD_IRQHandler+0x18>
        HAL_PCD_DisconnectCallback(hpcd);
      }
      hpcd->Instance->GOTGINT |= temp;
    }
  }
}
 8004896:	b007      	add	sp, #28
 8004898:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
  {
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
 800489c:	6820      	ldr	r0, [r4, #0]
 800489e:	f006 ff09 	bl	800b6b4 <USB_ReadInterrupts>
 80048a2:	2800      	cmp	r0, #0
 80048a4:	d0f7      	beq.n	8004896 <HAL_PCD_IRQHandler+0x12>
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 80048a6:	6820      	ldr	r0, [r4, #0]
 80048a8:	f006 ff04 	bl	800b6b4 <USB_ReadInterrupts>
 80048ac:	0785      	lsls	r5, r0, #30
 80048ae:	d504      	bpl.n	80048ba <HAL_PCD_IRQHandler+0x36>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 80048b0:	6822      	ldr	r2, [r4, #0]
 80048b2:	6953      	ldr	r3, [r2, #20]
 80048b4:	f003 0302 	and.w	r3, r3, #2
 80048b8:	6153      	str	r3, [r2, #20]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 80048ba:	6820      	ldr	r0, [r4, #0]
 80048bc:	f006 fefa 	bl	800b6b4 <USB_ReadInterrupts>
 80048c0:	0300      	lsls	r0, r0, #12
 80048c2:	f100 813d 	bmi.w	8004b40 <HAL_PCD_IRQHandler+0x2bc>
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
  uint32_t i = 0, ep_intr = 0, epint = 0, epnum = 0;
 80048c6:	2700      	movs	r7, #0
        epnum++;
        ep_intr >>= 1;
      }
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 80048c8:	6820      	ldr	r0, [r4, #0]
 80048ca:	f006 fef3 	bl	800b6b4 <USB_ReadInterrupts>
 80048ce:	0345      	lsls	r5, r0, #13
 80048d0:	f100 8091 	bmi.w	80049f6 <HAL_PCD_IRQHandler+0x172>
        ep_intr >>= 1;
      }
    }
    
    /* Handle Resume Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80048d4:	6820      	ldr	r0, [r4, #0]
 80048d6:	f006 feed 	bl	800b6b4 <USB_ReadInterrupts>
 80048da:	2800      	cmp	r0, #0
 80048dc:	f2c0 81f8 	blt.w	8004cd0 <HAL_PCD_IRQHandler+0x44c>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
    }
    
    /* Handle Suspend Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 80048e0:	6820      	ldr	r0, [r4, #0]
 80048e2:	f006 fee7 	bl	800b6b4 <USB_ReadInterrupts>
 80048e6:	0502      	lsls	r2, r0, #20
 80048e8:	d509      	bpl.n	80048fe <HAL_PCD_IRQHandler+0x7a>
    {
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80048ea:	f8d6 3808 	ldr.w	r3, [r6, #2056]	; 0x808
 80048ee:	07db      	lsls	r3, r3, #31
 80048f0:	f100 821a 	bmi.w	8004d28 <HAL_PCD_IRQHandler+0x4a4>
      {
        
        HAL_PCD_SuspendCallback(hpcd);
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80048f4:	6822      	ldr	r2, [r4, #0]
 80048f6:	6953      	ldr	r3, [r2, #20]
 80048f8:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80048fc:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle LPM Interrupt */ 
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 80048fe:	6820      	ldr	r0, [r4, #0]
 8004900:	f006 fed8 	bl	800b6b4 <USB_ReadInterrupts>
 8004904:	0105      	lsls	r5, r0, #4
 8004906:	d514      	bpl.n	8004932 <HAL_PCD_IRQHandler+0xae>
    {
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);      
 8004908:	6822      	ldr	r2, [r4, #0]
 800490a:	6953      	ldr	r3, [r2, #20]
 800490c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8004910:	6153      	str	r3, [r2, #20]
      if( hpcd->LPM_State == LPM_L0)
 8004912:	f894 33b4 	ldrb.w	r3, [r4, #948]	; 0x3b4
 8004916:	2b00      	cmp	r3, #0
 8004918:	d157      	bne.n	80049ca <HAL_PCD_IRQHandler+0x146>
      {   
        hpcd->LPM_State = LPM_L1;
 800491a:	2101      	movs	r1, #1
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >>2 ;  
 800491c:	6823      	ldr	r3, [r4, #0]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
    {
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);      
      if( hpcd->LPM_State == LPM_L0)
      {   
        hpcd->LPM_State = LPM_L1;
 800491e:	f884 13b4 	strb.w	r1, [r4, #948]	; 0x3b4
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >>2 ;  
 8004922:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004924:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004928:	f8c4 33b8 	str.w	r3, [r4, #952]	; 0x3b8
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 800492c:	4620      	mov	r0, r4
 800492e:	f000 fc5b 	bl	80051e8 <HAL_PCDEx_LPM_Callback>
        HAL_PCD_SuspendCallback(hpcd);
      }
    }
    
    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8004932:	6820      	ldr	r0, [r4, #0]
 8004934:	f006 febe 	bl	800b6b4 <USB_ReadInterrupts>
 8004938:	04c0      	lsls	r0, r0, #19
 800493a:	f100 8189 	bmi.w	8004c50 <HAL_PCD_IRQHandler+0x3cc>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
    }
    
    /* Handle Enumeration done Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 800493e:	6820      	ldr	r0, [r4, #0]
 8004940:	f006 feb8 	bl	800b6b4 <USB_ReadInterrupts>
 8004944:	0481      	lsls	r1, r0, #18
 8004946:	f100 8143 	bmi.w	8004bd0 <HAL_PCD_IRQHandler+0x34c>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
    }
    
    /* Handle RxQLevel Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 800494a:	6820      	ldr	r0, [r4, #0]
 800494c:	f006 feb2 	bl	800b6b4 <USB_ReadInterrupts>
 8004950:	06c2      	lsls	r2, r0, #27
 8004952:	d513      	bpl.n	800497c <HAL_PCD_IRQHandler+0xf8>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8004954:	6822      	ldr	r2, [r4, #0]
 8004956:	6993      	ldr	r3, [r2, #24]
 8004958:	f023 0310 	bic.w	r3, r3, #16
 800495c:	6193      	str	r3, [r2, #24]
      
      temp = USBx->GRXSTSP;
 800495e:	6a35      	ldr	r5, [r6, #32]
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8004960:	f3c5 4343 	ubfx	r3, r5, #17, #4
 8004964:	2b02      	cmp	r3, #2
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
      
      temp = USBx->GRXSTSP;
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8004966:	f005 080f 	and.w	r8, r5, #15
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800496a:	f000 81e1 	beq.w	8004d30 <HAL_PCD_IRQHandler+0x4ac>
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4);
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
 800496e:	2b06      	cmp	r3, #6
 8004970:	d02f      	beq.n	80049d2 <HAL_PCD_IRQHandler+0x14e>
      {
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8);
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8004972:	6822      	ldr	r2, [r4, #0]
 8004974:	6993      	ldr	r3, [r2, #24]
 8004976:	f043 0310 	orr.w	r3, r3, #16
 800497a:	6193      	str	r3, [r2, #24]
    }
    
    /* Handle SOF Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 800497c:	6820      	ldr	r0, [r4, #0]
 800497e:	f006 fe99 	bl	800b6b4 <USB_ReadInterrupts>
 8004982:	0703      	lsls	r3, r0, #28
 8004984:	f100 815b 	bmi.w	8004c3e <HAL_PCD_IRQHandler+0x3ba>
      HAL_PCD_SOFCallback(hpcd);
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
    }
    
    /* Handle Incomplete ISO IN Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8004988:	6820      	ldr	r0, [r4, #0]
 800498a:	f006 fe93 	bl	800b6b4 <USB_ReadInterrupts>
 800498e:	02c6      	lsls	r6, r0, #11
 8004990:	f100 814b 	bmi.w	8004c2a <HAL_PCD_IRQHandler+0x3a6>
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
    } 
    
    /* Handle Incomplete ISO OUT Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8004994:	6820      	ldr	r0, [r4, #0]
 8004996:	f006 fe8d 	bl	800b6b4 <USB_ReadInterrupts>
 800499a:	0285      	lsls	r5, r0, #10
 800499c:	f100 813b 	bmi.w	8004c16 <HAL_PCD_IRQHandler+0x392>
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
    } 
    
    /* Handle Connection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 80049a0:	6820      	ldr	r0, [r4, #0]
 80049a2:	f006 fe87 	bl	800b6b4 <USB_ReadInterrupts>
 80049a6:	0040      	lsls	r0, r0, #1
 80049a8:	f100 812c 	bmi.w	8004c04 <HAL_PCD_IRQHandler+0x380>
      HAL_PCD_ConnectCallback(hpcd);
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
    } 
    
    /* Handle Disconnection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 80049ac:	6820      	ldr	r0, [r4, #0]
 80049ae:	f006 fe81 	bl	800b6b4 <USB_ReadInterrupts>
 80049b2:	0741      	lsls	r1, r0, #29
 80049b4:	f57f af6f 	bpl.w	8004896 <HAL_PCD_IRQHandler+0x12>
    {
      temp = hpcd->Instance->GOTGINT;
 80049b8:	6823      	ldr	r3, [r4, #0]
 80049ba:	685d      	ldr	r5, [r3, #4]
      
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 80049bc:	076a      	lsls	r2, r5, #29
 80049be:	f100 81a5 	bmi.w	8004d0c <HAL_PCD_IRQHandler+0x488>
      {
        HAL_PCD_DisconnectCallback(hpcd);
      }
      hpcd->Instance->GOTGINT |= temp;
 80049c2:	685a      	ldr	r2, [r3, #4]
 80049c4:	4315      	orrs	r5, r2
 80049c6:	605d      	str	r5, [r3, #4]
 80049c8:	e765      	b.n	8004896 <HAL_PCD_IRQHandler+0x12>
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >>2 ;  
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
      }
      else
      {
        HAL_PCD_SuspendCallback(hpcd);
 80049ca:	4620      	mov	r0, r4
 80049cc:	f7ff ff4e 	bl	800486c <HAL_PCD_SuspendCallback>
 80049d0:	e7af      	b.n	8004932 <HAL_PCD_IRQHandler+0xae>
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
      {
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8);
 80049d2:	2208      	movs	r2, #8
 80049d4:	4630      	mov	r0, r6
 80049d6:	f504 7161 	add.w	r1, r4, #900	; 0x384
 80049da:	f006 fdbd 	bl	800b558 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80049de:	ebc8 03c8 	rsb	r3, r8, r8, lsl #3
 80049e2:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80049e6:	f3c5 150a 	ubfx	r5, r5, #4, #11
 80049ea:	f8d3 21f4 	ldr.w	r2, [r3, #500]	; 0x1f4
 80049ee:	4415      	add	r5, r2
 80049f0:	f8c3 51f4 	str.w	r5, [r3, #500]	; 0x1f4
 80049f4:	e7bd      	b.n	8004972 <HAL_PCD_IRQHandler+0xee>
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 80049f6:	6820      	ldr	r0, [r4, #0]
 80049f8:	f006 fe68 	bl	800b6cc <USB_ReadDevAllInEpInterrupt>
      
      epnum = 0;
      
      while ( ep_intr )
 80049fc:	4682      	mov	sl, r0
 80049fe:	2800      	cmp	r0, #0
 8004a00:	f000 81e9 	beq.w	8004dd6 <HAL_PCD_IRQHandler+0x552>
 8004a04:	4625      	mov	r5, r4
 8004a06:	f506 6810 	add.w	r8, r6, #2304	; 0x900
 8004a0a:	2700      	movs	r7, #0
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
          }
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8004a0c:	9603      	str	r6, [sp, #12]
 8004a0e:	e009      	b.n	8004a24 <HAL_PCD_IRQHandler+0x1a0>
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
      
      epnum = 0;
      
      while ( ep_intr )
 8004a10:	ea5f 0a5a 	movs.w	sl, sl, lsr #1
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
          }
        }
        epnum++;
 8004a14:	f107 0701 	add.w	r7, r7, #1
 8004a18:	f105 051c 	add.w	r5, r5, #28
 8004a1c:	f108 0820 	add.w	r8, r8, #32
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
      
      epnum = 0;
      
      while ( ep_intr )
 8004a20:	f000 816b 	beq.w	8004cfa <HAL_PCD_IRQHandler+0x476>
      {
        if (ep_intr & 0x1) /* In ITR */
 8004a24:	f01a 0f01 	tst.w	sl, #1
 8004a28:	d0f2      	beq.n	8004a10 <HAL_PCD_IRQHandler+0x18c>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 8004a2a:	fa5f f987 	uxtb.w	r9, r7
 8004a2e:	4649      	mov	r1, r9
 8004a30:	6820      	ldr	r0, [r4, #0]
 8004a32:	f006 fe5d 	bl	800b6f0 <USB_ReadDevInEPInterrupt>
 8004a36:	4606      	mov	r6, r0
          
          if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8004a38:	07f0      	lsls	r0, r6, #31
 8004a3a:	d517      	bpl.n	8004a6c <HAL_PCD_IRQHandler+0x1e8>
          {
            fifoemptymsk = 0x1 << epnum;
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8004a3c:	9b03      	ldr	r3, [sp, #12]
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
          
          if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
          {
            fifoemptymsk = 0x1 << epnum;
 8004a3e:	2201      	movs	r2, #1
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8004a40:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
          
          if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
          {
            fifoemptymsk = 0x1 << epnum;
 8004a44:	40ba      	lsls	r2, r7
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8004a46:	ea21 0202 	bic.w	r2, r1, r2
 8004a4a:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
            
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8004a4e:	2301      	movs	r3, #1
 8004a50:	f8c8 3008 	str.w	r3, [r8, #8]
            
            if (hpcd->Init.dma_enable == 1)
 8004a54:	6923      	ldr	r3, [r4, #16]
 8004a56:	2b01      	cmp	r3, #1
 8004a58:	f000 8194 	beq.w	8004d84 <HAL_PCD_IRQHandler+0x500>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
            }
            
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 8004a5c:	4649      	mov	r1, r9
 8004a5e:	4620      	mov	r0, r4
 8004a60:	f7ff fefc 	bl	800485c <HAL_PCD_DataInStageCallback>
            
            if (hpcd->Init.dma_enable == 1)
 8004a64:	6921      	ldr	r1, [r4, #16]
 8004a66:	2901      	cmp	r1, #1
 8004a68:	f000 817f 	beq.w	8004d6a <HAL_PCD_IRQHandler+0x4e6>
                /* prepare to rx more setup packets */
                USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
              }
            }           
          }
          if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8004a6c:	0731      	lsls	r1, r6, #28
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8004a6e:	bf44      	itt	mi
 8004a70:	2308      	movmi	r3, #8
 8004a72:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8004a76:	06f2      	lsls	r2, r6, #27
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8004a78:	bf44      	itt	mi
 8004a7a:	2310      	movmi	r3, #16
 8004a7c:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8004a80:	0673      	lsls	r3, r6, #25
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8004a82:	bf44      	itt	mi
 8004a84:	2340      	movmi	r3, #64	; 0x40
 8004a86:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8004a8a:	07b0      	lsls	r0, r6, #30
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8004a8c:	bf44      	itt	mi
 8004a8e:	2302      	movmi	r3, #2
 8004a90:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }       
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8004a94:	0631      	lsls	r1, r6, #24
 8004a96:	d5bb      	bpl.n	8004a10 <HAL_PCD_IRQHandler+0x18c>
  * @param  epnum: endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 8004a98:	6823      	ldr	r3, [r4, #0]
  int32_t len = 0;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 8004a9a:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
 8004a9c:	f8d5 c050 	ldr.w	ip, [r5, #80]	; 0x50
  
  if (len > ep->maxpacket)
 8004aa0:	6c2a      	ldr	r2, [r5, #64]	; 0x40
  * @param  epnum: endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 8004aa2:	9304      	str	r3, [sp, #16]
 8004aa4:	f503 6b10 	add.w	fp, r3, #2304	; 0x900
  }
  
  
  len32b = (len + 3) / 4;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8004aa8:	eb0b 1b47 	add.w	fp, fp, r7, lsl #5
  int32_t len = 0;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 8004aac:	ebcc 0300 	rsb	r3, ip, r0
 8004ab0:	4293      	cmp	r3, r2
 8004ab2:	461e      	mov	r6, r3
  }
  
  
  len32b = (len + 3) / 4;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8004ab4:	f8db 1018 	ldr.w	r1, [fp, #24]
  int32_t len = 0;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 8004ab8:	bf28      	it	cs
 8004aba:	4616      	movcs	r6, r2
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3) / 4;
 8004abc:	f116 0e03 	adds.w	lr, r6, #3
 8004ac0:	bf48      	it	mi
 8004ac2:	f106 0e06 	addmi.w	lr, r6, #6
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8004ac6:	b289      	uxth	r1, r1
 8004ac8:	ebb1 0fae 	cmp.w	r1, lr, asr #2
 8004acc:	d92b      	bls.n	8004b26 <HAL_PCD_IRQHandler+0x2a2>
 8004ace:	4560      	cmp	r0, ip
 8004ad0:	d929      	bls.n	8004b26 <HAL_PCD_IRQHandler+0x2a2>
          ep->xfer_count < ep->xfer_len &&
 8004ad2:	b340      	cbz	r0, 8004b26 <HAL_PCD_IRQHandler+0x2a2>
 8004ad4:	6c69      	ldr	r1, [r5, #68]	; 0x44
 8004ad6:	9705      	str	r7, [sp, #20]
 8004ad8:	461e      	mov	r6, r3
 8004ada:	462f      	mov	r7, r5
 8004adc:	4625      	mov	r5, r4
 8004ade:	465c      	mov	r4, fp
 8004ae0:	f8dd b010 	ldr.w	fp, [sp, #16]
 8004ae4:	e004      	b.n	8004af0 <HAL_PCD_IRQHandler+0x26c>
 8004ae6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  }
  
  
  len32b = (len + 3) / 4;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8004ae8:	429a      	cmp	r2, r3
 8004aea:	d919      	bls.n	8004b20 <HAL_PCD_IRQHandler+0x29c>
 8004aec:	1ad6      	subs	r6, r2, r3
 8004aee:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 8004af0:	7c2b      	ldrb	r3, [r5, #16]
 8004af2:	9300      	str	r3, [sp, #0]
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8004af4:	4296      	cmp	r6, r2
 8004af6:	bf28      	it	cs
 8004af8:	4616      	movcs	r6, r2
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 8004afa:	b2b3      	uxth	r3, r6
 8004afc:	464a      	mov	r2, r9
 8004afe:	4658      	mov	r0, fp
 8004b00:	f006 fd16 	bl	800b530 <USB_WritePacket>
    
    ep->xfer_buff  += len;
 8004b04:	6c79      	ldr	r1, [r7, #68]	; 0x44
    ep->xfer_count += len;
 8004b06:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    }
    len32b = (len + 3) / 4;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
    
    ep->xfer_buff  += len;
 8004b08:	4431      	add	r1, r6
    ep->xfer_count += len;
 8004b0a:	4433      	add	r3, r6
    }
    len32b = (len + 3) / 4;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
    
    ep->xfer_buff  += len;
 8004b0c:	6479      	str	r1, [r7, #68]	; 0x44
    ep->xfer_count += len;
 8004b0e:	653b      	str	r3, [r7, #80]	; 0x50
  }
  
  
  len32b = (len + 3) / 4;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8004b10:	69a2      	ldr	r2, [r4, #24]
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
 8004b12:	1cf0      	adds	r0, r6, #3
  }
  
  
  len32b = (len + 3) / 4;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8004b14:	b292      	uxth	r2, r2
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
 8004b16:	bf48      	it	mi
 8004b18:	1db0      	addmi	r0, r6, #6
  }
  
  
  len32b = (len + 3) / 4;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8004b1a:	ebb2 0fa0 	cmp.w	r2, r0, asr #2
 8004b1e:	d8e2      	bhi.n	8004ae6 <HAL_PCD_IRQHandler+0x262>
 8004b20:	462c      	mov	r4, r5
 8004b22:	463d      	mov	r5, r7
 8004b24:	9f05      	ldr	r7, [sp, #20]
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
  }
  
  if(len <= 0)
 8004b26:	2e00      	cmp	r6, #0
 8004b28:	f73f af72 	bgt.w	8004a10 <HAL_PCD_IRQHandler+0x18c>
  {
    fifoemptymsk = 0x1 << epnum;
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8004b2c:	9b04      	ldr	r3, [sp, #16]
 8004b2e:	f503 6100 	add.w	r1, r3, #2048	; 0x800
    ep->xfer_count += len;
  }
  
  if(len <= 0)
  {
    fifoemptymsk = 0x1 << epnum;
 8004b32:	2301      	movs	r3, #1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8004b34:	6b4a      	ldr	r2, [r1, #52]	; 0x34
    ep->xfer_count += len;
  }
  
  if(len <= 0)
  {
    fifoemptymsk = 0x1 << epnum;
 8004b36:	40bb      	lsls	r3, r7
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8004b38:	ea22 0303 	bic.w	r3, r2, r3
 8004b3c:	634b      	str	r3, [r1, #52]	; 0x34
 8004b3e:	e767      	b.n	8004a10 <HAL_PCD_IRQHandler+0x18c>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
    {
      epnum = 0;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8004b40:	6820      	ldr	r0, [r4, #0]
 8004b42:	f006 fdbb 	bl	800b6bc <USB_ReadDevAllOutEpInterrupt>
      
      while ( ep_intr )
 8004b46:	4605      	mov	r5, r0
 8004b48:	2800      	cmp	r0, #0
 8004b4a:	f43f aebc 	beq.w	80048c6 <HAL_PCD_IRQHandler+0x42>
 8004b4e:	f506 6930 	add.w	r9, r6, #2816	; 0xb00
 8004b52:	46c8      	mov	r8, r9
 8004b54:	46a2      	mov	sl, r4
 8004b56:	2700      	movs	r7, #0
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8004b58:	9603      	str	r6, [sp, #12]
 8004b5a:	e008      	b.n	8004b6e <HAL_PCD_IRQHandler+0x2ea>
      epnum = 0;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
 8004b5c:	086d      	lsrs	r5, r5, #1
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
          }
        }
        epnum++;
 8004b5e:	f107 0701 	add.w	r7, r7, #1
 8004b62:	f108 0820 	add.w	r8, r8, #32
 8004b66:	f10a 0a1c 	add.w	sl, sl, #28
      epnum = 0;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
 8004b6a:	f000 80c4 	beq.w	8004cf6 <HAL_PCD_IRQHandler+0x472>
      {
        if (ep_intr & 0x1)
 8004b6e:	07e9      	lsls	r1, r5, #31
 8004b70:	d5f4      	bpl.n	8004b5c <HAL_PCD_IRQHandler+0x2d8>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8004b72:	b2fe      	uxtb	r6, r7
 8004b74:	4631      	mov	r1, r6
 8004b76:	6820      	ldr	r0, [r4, #0]
 8004b78:	f006 fdb0 	bl	800b6dc <USB_ReadDevOutEPInterrupt>
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8004b7c:	f010 0f01 	tst.w	r0, #1
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1)
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8004b80:	4683      	mov	fp, r0
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8004b82:	d01a      	beq.n	8004bba <HAL_PCD_IRQHandler+0x336>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8004b84:	2301      	movs	r3, #1
 8004b86:	f8c8 3008 	str.w	r3, [r8, #8]
            
            if ((( (USBx_OUTEP(0)->DOEPINT & 0x8000) == 0)) )
 8004b8a:	f8d9 2008 	ldr.w	r2, [r9, #8]
 8004b8e:	0412      	lsls	r2, r2, #16
 8004b90:	d40b      	bmi.n	8004baa <HAL_PCD_IRQHandler+0x326>
            {
              
              if(hpcd->Init.dma_enable == 1)
 8004b92:	6922      	ldr	r2, [r4, #16]
 8004b94:	429a      	cmp	r2, r3
 8004b96:	f000 810f 	beq.w	8004db8 <HAL_PCD_IRQHandler+0x534>
              {
                hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
                hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
              }
              
              HAL_PCD_DataOutStageCallback(hpcd, epnum);
 8004b9a:	4631      	mov	r1, r6
 8004b9c:	4620      	mov	r0, r4
 8004b9e:	f7ff fe5b 	bl	8004858 <HAL_PCD_DataOutStageCallback>
              
              if(hpcd->Init.dma_enable == 1)
 8004ba2:	6921      	ldr	r1, [r4, #16]
 8004ba4:	2901      	cmp	r1, #1
 8004ba6:	f000 80f9 	beq.w	8004d9c <HAL_PCD_IRQHandler+0x518>
                  USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
                }              
              }
            }
            /* Clear the SetPktRcvd flag*/ 
            USBx_OUTEP(0)->DOEPINT |= 0x8020;
 8004baa:	f8d9 3008 	ldr.w	r3, [r9, #8]
 8004bae:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004bb2:	f043 0320 	orr.w	r3, r3, #32
 8004bb6:	f8c9 3008 	str.w	r3, [r9, #8]
          }
          
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8004bba:	f01b 0f08 	tst.w	fp, #8
 8004bbe:	f040 809e 	bne.w	8004cfe <HAL_PCD_IRQHandler+0x47a>
            /* Inform the upper layer that a setup packet is available */
            HAL_PCD_SetupStageCallback(hpcd);
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
          }
          
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8004bc2:	f01b 0f10 	tst.w	fp, #16
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8004bc6:	bf1c      	itt	ne
 8004bc8:	2310      	movne	r3, #16
 8004bca:	f8c8 3008 	strne.w	r3, [r8, #8]
 8004bce:	e7c5      	b.n	8004b5c <HAL_PCD_IRQHandler+0x2d8>
    }
    
    /* Handle Enumeration done Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
    {
      USB_ActivateSetup(hpcd->Instance);
 8004bd0:	6820      	ldr	r0, [r4, #0]
 8004bd2:	f006 fda7 	bl	800b724 <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8004bd6:	6822      	ldr	r2, [r4, #0]
 8004bd8:	68d3      	ldr	r3, [r2, #12]
 8004bda:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8004bde:	60d3      	str	r3, [r2, #12]
      
      hpcd->Init.speed            = USB_OTG_SPEED_FULL;
      hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
      hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_FS_TRDT_VALUE << 10) & USB_OTG_GUSBCFG_TRDT);
 8004be0:	6822      	ldr	r2, [r4, #0]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
    {
      USB_ActivateSetup(hpcd->Instance);
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
      
      hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 8004be2:	2103      	movs	r1, #3
      hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8004be4:	2340      	movs	r3, #64	; 0x40
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
    {
      USB_ActivateSetup(hpcd->Instance);
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
      
      hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 8004be6:	60e1      	str	r1, [r4, #12]
      hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8004be8:	6163      	str	r3, [r4, #20]
      hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_FS_TRDT_VALUE << 10) & USB_OTG_GUSBCFG_TRDT);
 8004bea:	68d3      	ldr	r3, [r2, #12]
 8004bec:	f443 53a0 	orr.w	r3, r3, #5120	; 0x1400
 8004bf0:	60d3      	str	r3, [r2, #12]
      
      HAL_PCD_ResetCallback(hpcd);
 8004bf2:	4620      	mov	r0, r4
 8004bf4:	f7ff fe38 	bl	8004868 <HAL_PCD_ResetCallback>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8004bf8:	6822      	ldr	r2, [r4, #0]
 8004bfa:	6953      	ldr	r3, [r2, #20]
 8004bfc:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8004c00:	6153      	str	r3, [r2, #20]
 8004c02:	e6a2      	b.n	800494a <HAL_PCD_IRQHandler+0xc6>
    } 
    
    /* Handle Connection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
    {
      HAL_PCD_ConnectCallback(hpcd);
 8004c04:	4620      	mov	r0, r4
 8004c06:	f7ff fe39 	bl	800487c <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8004c0a:	6822      	ldr	r2, [r4, #0]
 8004c0c:	6953      	ldr	r3, [r2, #20]
 8004c0e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8004c12:	6153      	str	r3, [r2, #20]
 8004c14:	e6ca      	b.n	80049ac <HAL_PCD_IRQHandler+0x128>
    } 
    
    /* Handle Incomplete ISO OUT Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
    {
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 8004c16:	b2f9      	uxtb	r1, r7
 8004c18:	4620      	mov	r0, r4
 8004c1a:	f7ff fe2b 	bl	8004874 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8004c1e:	6822      	ldr	r2, [r4, #0]
 8004c20:	6953      	ldr	r3, [r2, #20]
 8004c22:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8004c26:	6153      	str	r3, [r2, #20]
 8004c28:	e6ba      	b.n	80049a0 <HAL_PCD_IRQHandler+0x11c>
    }
    
    /* Handle Incomplete ISO IN Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
    {
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 8004c2a:	4620      	mov	r0, r4
 8004c2c:	b2f9      	uxtb	r1, r7
 8004c2e:	f7ff fe23 	bl	8004878 <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8004c32:	6822      	ldr	r2, [r4, #0]
 8004c34:	6953      	ldr	r3, [r2, #20]
 8004c36:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8004c3a:	6153      	str	r3, [r2, #20]
 8004c3c:	e6aa      	b.n	8004994 <HAL_PCD_IRQHandler+0x110>
    }
    
    /* Handle SOF Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
    {
      HAL_PCD_SOFCallback(hpcd);
 8004c3e:	4620      	mov	r0, r4
 8004c40:	f7ff fe10 	bl	8004864 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8004c44:	6822      	ldr	r2, [r4, #0]
 8004c46:	6953      	ldr	r3, [r2, #20]
 8004c48:	f003 0308 	and.w	r3, r3, #8
 8004c4c:	6153      	str	r3, [r2, #20]
 8004c4e:	e69b      	b.n	8004988 <HAL_PCD_IRQHandler+0x104>
    }
    
    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 8004c50:	f506 6500 	add.w	r5, r6, #2048	; 0x800
 8004c54:	686b      	ldr	r3, [r5, #4]
 8004c56:	f023 0301 	bic.w	r3, r3, #1
 8004c5a:	606b      	str	r3, [r5, #4]
      USB_FlushTxFifo(hpcd->Instance ,  0 );
 8004c5c:	2100      	movs	r1, #0
 8004c5e:	6820      	ldr	r0, [r4, #0]
 8004c60:	f006 f908 	bl	800ae74 <USB_FlushTxFifo>
      
      for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 8004c64:	6863      	ldr	r3, [r4, #4]
 8004c66:	b16b      	cbz	r3, 8004c84 <HAL_PCD_IRQHandler+0x400>
 8004c68:	f506 6330 	add.w	r3, r6, #2816	; 0xb00
 8004c6c:	2200      	movs	r2, #0
      {
        USBx_INEP(i)->DIEPINT = 0xFF;
 8004c6e:	21ff      	movs	r1, #255	; 0xff
 8004c70:	f5a3 7000 	sub.w	r0, r3, #512	; 0x200
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance ,  0 );
      
      for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 8004c74:	3201      	adds	r2, #1
      {
        USBx_INEP(i)->DIEPINT = 0xFF;
 8004c76:	6081      	str	r1, [r0, #8]
        USBx_OUTEP(i)->DOEPINT = 0xFF;
 8004c78:	6099      	str	r1, [r3, #8]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance ,  0 );
      
      for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 8004c7a:	6860      	ldr	r0, [r4, #4]
 8004c7c:	4290      	cmp	r0, r2
 8004c7e:	f103 0320 	add.w	r3, r3, #32
 8004c82:	d8f5      	bhi.n	8004c70 <HAL_PCD_IRQHandler+0x3ec>
      {
        USBx_INEP(i)->DIEPINT = 0xFF;
        USBx_OUTEP(i)->DOEPINT = 0xFF;
      }
      USBx_DEVICE->DAINT = 0xFFFFFFFF;
 8004c84:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004c88:	61ab      	str	r3, [r5, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001;
 8004c8a:	69eb      	ldr	r3, [r5, #28]
 8004c8c:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8004c90:	61eb      	str	r3, [r5, #28]
      
      if(hpcd->Init.use_dedicated_ep1)
 8004c92:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004c94:	2b00      	cmp	r3, #0
 8004c96:	d03e      	beq.n	8004d16 <HAL_PCD_IRQHandler+0x492>
      {
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 8004c98:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 8004c9c:	f043 030b 	orr.w	r3, r3, #11
 8004ca0:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 8004ca4:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8004ca6:	f043 030b 	orr.w	r3, r3, #11
 8004caa:	646b      	str	r3, [r5, #68]	; 0x44
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8004cac:	f8d6 3800 	ldr.w	r3, [r6, #2048]	; 0x800
 8004cb0:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8004cb4:	f8c6 3800 	str.w	r3, [r6, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8004cb8:	f504 7261 	add.w	r2, r4, #900	; 0x384
 8004cbc:	6820      	ldr	r0, [r4, #0]
 8004cbe:	7c21      	ldrb	r1, [r4, #16]
 8004cc0:	f006 fd4c 	bl	800b75c <USB_EP0_OutStart>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8004cc4:	6822      	ldr	r2, [r4, #0]
 8004cc6:	6953      	ldr	r3, [r2, #20]
 8004cc8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8004ccc:	6153      	str	r3, [r2, #20]
 8004cce:	e636      	b.n	800493e <HAL_PCD_IRQHandler+0xba>
    
    /* Handle Resume Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
    {    
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8004cd0:	f8d6 3804 	ldr.w	r3, [r6, #2052]	; 0x804
 8004cd4:	f023 0301 	bic.w	r3, r3, #1
 8004cd8:	f8c6 3804 	str.w	r3, [r6, #2052]	; 0x804
      
      if(hpcd->LPM_State == LPM_L1)
 8004cdc:	f894 33b4 	ldrb.w	r3, [r4, #948]	; 0x3b4
 8004ce0:	2b01      	cmp	r3, #1
 8004ce2:	d054      	beq.n	8004d8e <HAL_PCD_IRQHandler+0x50a>
        hpcd->LPM_State = LPM_L0;
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
      }
      else
      {
        HAL_PCD_ResumeCallback(hpcd);
 8004ce4:	4620      	mov	r0, r4
 8004ce6:	f7ff fdc3 	bl	8004870 <HAL_PCD_ResumeCallback>
      }
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8004cea:	6822      	ldr	r2, [r4, #0]
 8004cec:	6953      	ldr	r3, [r2, #20]
 8004cee:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8004cf2:	6153      	str	r3, [r2, #20]
 8004cf4:	e5f4      	b.n	80048e0 <HAL_PCD_IRQHandler+0x5c>
 8004cf6:	9e03      	ldr	r6, [sp, #12]
 8004cf8:	e5e6      	b.n	80048c8 <HAL_PCD_IRQHandler+0x44>
 8004cfa:	9e03      	ldr	r6, [sp, #12]
 8004cfc:	e5ea      	b.n	80048d4 <HAL_PCD_IRQHandler+0x50>
          }
          
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
          {
            /* Inform the upper layer that a setup packet is available */
            HAL_PCD_SetupStageCallback(hpcd);
 8004cfe:	4620      	mov	r0, r4
 8004d00:	f7ff fdae 	bl	8004860 <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8004d04:	2308      	movs	r3, #8
 8004d06:	f8c8 3008 	str.w	r3, [r8, #8]
 8004d0a:	e75a      	b.n	8004bc2 <HAL_PCD_IRQHandler+0x33e>
    {
      temp = hpcd->Instance->GOTGINT;
      
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
      {
        HAL_PCD_DisconnectCallback(hpcd);
 8004d0c:	4620      	mov	r0, r4
 8004d0e:	f7ff fdb7 	bl	8004880 <HAL_PCD_DisconnectCallback>
 8004d12:	6823      	ldr	r3, [r4, #0]
 8004d14:	e655      	b.n	80049c2 <HAL_PCD_IRQHandler+0x13e>
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 8004d16:	696b      	ldr	r3, [r5, #20]
 8004d18:	f043 030b 	orr.w	r3, r3, #11
 8004d1c:	616b      	str	r3, [r5, #20]
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8004d1e:	692b      	ldr	r3, [r5, #16]
 8004d20:	f043 030b 	orr.w	r3, r3, #11
 8004d24:	612b      	str	r3, [r5, #16]
 8004d26:	e7c1      	b.n	8004cac <HAL_PCD_IRQHandler+0x428>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
    {
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
      {
        
        HAL_PCD_SuspendCallback(hpcd);
 8004d28:	4620      	mov	r0, r4
 8004d2a:	f7ff fd9f 	bl	800486c <HAL_PCD_SuspendCallback>
 8004d2e:	e5e1      	b.n	80048f4 <HAL_PCD_IRQHandler+0x70>
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
      {
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0)
 8004d30:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8004d34:	402b      	ands	r3, r5
 8004d36:	2b00      	cmp	r3, #0
 8004d38:	f43f ae1b 	beq.w	8004972 <HAL_PCD_IRQHandler+0xee>
        {
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4);
 8004d3c:	ebc8 08c8 	rsb	r8, r8, r8, lsl #3
 8004d40:	eb04 0588 	add.w	r5, r4, r8, lsl #2
 8004d44:	ea4f 1813 	mov.w	r8, r3, lsr #4
 8004d48:	4630      	mov	r0, r6
 8004d4a:	f8d5 11e8 	ldr.w	r1, [r5, #488]	; 0x1e8
 8004d4e:	4642      	mov	r2, r8
 8004d50:	f006 fc02 	bl	800b558 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8004d54:	f8d5 31e8 	ldr.w	r3, [r5, #488]	; 0x1e8
 8004d58:	4443      	add	r3, r8
 8004d5a:	f8c5 31e8 	str.w	r3, [r5, #488]	; 0x1e8
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8004d5e:	f8d5 31f4 	ldr.w	r3, [r5, #500]	; 0x1f4
 8004d62:	4443      	add	r3, r8
 8004d64:	f8c5 31f4 	str.w	r3, [r5, #500]	; 0x1f4
 8004d68:	e603      	b.n	8004972 <HAL_PCD_IRQHandler+0xee>
            HAL_PCD_DataInStageCallback(hpcd, epnum);
            
            if (hpcd->Init.dma_enable == 1)
            {
              /* this is ZLP, so prepare EP0 for next setup */
              if((epnum == 0) && (hpcd->IN_ep[epnum].xfer_len == 0))
 8004d6a:	2f00      	cmp	r7, #0
 8004d6c:	f47f ae7e 	bne.w	8004a6c <HAL_PCD_IRQHandler+0x1e8>
 8004d70:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8004d72:	2b00      	cmp	r3, #0
 8004d74:	f47f ae7a 	bne.w	8004a6c <HAL_PCD_IRQHandler+0x1e8>
              {
                /* prepare to rx more setup packets */
                USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
 8004d78:	6820      	ldr	r0, [r4, #0]
 8004d7a:	f504 7261 	add.w	r2, r4, #900	; 0x384
 8004d7e:	f006 fced 	bl	800b75c <USB_EP0_OutStart>
 8004d82:	e673      	b.n	8004a6c <HAL_PCD_IRQHandler+0x1e8>
            
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
            
            if (hpcd->Init.dma_enable == 1)
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 8004d84:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8004d86:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8004d88:	4413      	add	r3, r2
 8004d8a:	646b      	str	r3, [r5, #68]	; 0x44
 8004d8c:	e666      	b.n	8004a5c <HAL_PCD_IRQHandler+0x1d8>
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
      
      if(hpcd->LPM_State == LPM_L1)
      {
        hpcd->LPM_State = LPM_L0;
 8004d8e:	2100      	movs	r1, #0
 8004d90:	f884 13b4 	strb.w	r1, [r4, #948]	; 0x3b4
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8004d94:	4620      	mov	r0, r4
 8004d96:	f000 fa27 	bl	80051e8 <HAL_PCDEx_LPM_Callback>
 8004d9a:	e7a6      	b.n	8004cea <HAL_PCD_IRQHandler+0x466>
              
              HAL_PCD_DataOutStageCallback(hpcd, epnum);
              
              if(hpcd->Init.dma_enable == 1)
              {
                if((epnum == 0) && (hpcd->OUT_ep[epnum].xfer_len == 0))
 8004d9c:	2f00      	cmp	r7, #0
 8004d9e:	f47f af04 	bne.w	8004baa <HAL_PCD_IRQHandler+0x326>
 8004da2:	f8d4 31f0 	ldr.w	r3, [r4, #496]	; 0x1f0
 8004da6:	2b00      	cmp	r3, #0
 8004da8:	f47f aeff 	bne.w	8004baa <HAL_PCD_IRQHandler+0x326>
                {
                  /* this is ZLP, so prepare EP0 for next setup */
                  USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
 8004dac:	6820      	ldr	r0, [r4, #0]
 8004dae:	f504 7261 	add.w	r2, r4, #900	; 0x384
 8004db2:	f006 fcd3 	bl	800b75c <USB_EP0_OutStart>
 8004db6:	e6f8      	b.n	8004baa <HAL_PCD_IRQHandler+0x326>
            if ((( (USBx_OUTEP(0)->DOEPINT & 0x8000) == 0)) )
            {
              
              if(hpcd->Init.dma_enable == 1)
              {
                hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 8004db8:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8004dbc:	f8da 01e4 	ldr.w	r0, [sl, #484]	; 0x1e4
                hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 8004dc0:	f8da 11e8 	ldr.w	r1, [sl, #488]	; 0x1e8
            if ((( (USBx_OUTEP(0)->DOEPINT & 0x8000) == 0)) )
            {
              
              if(hpcd->Init.dma_enable == 1)
              {
                hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 8004dc4:	f3c2 0212 	ubfx	r2, r2, #0, #19
 8004dc8:	1a82      	subs	r2, r0, r2
                hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 8004dca:	4401      	add	r1, r0
            if ((( (USBx_OUTEP(0)->DOEPINT & 0x8000) == 0)) )
            {
              
              if(hpcd->Init.dma_enable == 1)
              {
                hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 8004dcc:	f8ca 21f4 	str.w	r2, [sl, #500]	; 0x1f4
                hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 8004dd0:	f8ca 11e8 	str.w	r1, [sl, #488]	; 0x1e8
 8004dd4:	e6e1      	b.n	8004b9a <HAL_PCD_IRQHandler+0x316>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
      
      epnum = 0;
 8004dd6:	4607      	mov	r7, r0
 8004dd8:	e57c      	b.n	80048d4 <HAL_PCD_IRQHandler+0x50>
 8004dda:	bf00      	nop

08004ddc <HAL_PCD_DevConnect>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd)
{
  __HAL_LOCK(hpcd); 
 8004ddc:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8004de0:	2b01      	cmp	r3, #1
 8004de2:	d101      	bne.n	8004de8 <HAL_PCD_DevConnect+0xc>
 8004de4:	2002      	movs	r0, #2
 8004de6:	4770      	bx	lr
  * @brief  Connect the USB device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd)
{
 8004de8:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd); 
 8004dea:	2301      	movs	r3, #1
 8004dec:	4604      	mov	r4, r0
 8004dee:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_DevConnect(hpcd->Instance);
 8004df2:	6800      	ldr	r0, [r0, #0]
 8004df4:	f006 fc46 	bl	800b684 <USB_DevConnect>
  __HAL_UNLOCK(hpcd); 
 8004df8:	2000      	movs	r0, #0
 8004dfa:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8004dfe:	bd10      	pop	{r4, pc}

08004e00 <HAL_PCD_DevDisconnect>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)
{
  __HAL_LOCK(hpcd); 
 8004e00:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8004e04:	2b01      	cmp	r3, #1
 8004e06:	d101      	bne.n	8004e0c <HAL_PCD_DevDisconnect+0xc>
 8004e08:	2002      	movs	r0, #2
 8004e0a:	4770      	bx	lr
  * @brief  Disconnect the USB device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)
{
 8004e0c:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd); 
 8004e0e:	2301      	movs	r3, #1
 8004e10:	4604      	mov	r4, r0
 8004e12:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_DevDisconnect(hpcd->Instance);
 8004e16:	6800      	ldr	r0, [r0, #0]
 8004e18:	f006 fc40 	bl	800b69c <USB_DevDisconnect>
  __HAL_UNLOCK(hpcd); 
 8004e1c:	2000      	movs	r0, #0
 8004e1e:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8004e22:	bd10      	pop	{r4, pc}

08004e24 <HAL_PCD_SetAddress>:
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd); 
 8004e24:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8004e28:	2b01      	cmp	r3, #1
 8004e2a:	d101      	bne.n	8004e30 <HAL_PCD_SetAddress+0xc>
 8004e2c:	2002      	movs	r0, #2
 8004e2e:	4770      	bx	lr
  * @param  hpcd: PCD handle
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8004e30:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd); 
 8004e32:	2301      	movs	r3, #1
 8004e34:	4604      	mov	r4, r0
 8004e36:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_SetDevAddress(hpcd->Instance, address);
 8004e3a:	6800      	ldr	r0, [r0, #0]
 8004e3c:	f006 fc12 	bl	800b664 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);   
 8004e40:	2000      	movs	r0, #0
 8004e42:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8004e46:	bd10      	pop	{r4, pc}

08004e48 <HAL_PCD_EP_Open>:
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8004e48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004e4a:	4605      	mov	r5, r0
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8004e4c:	0608      	lsls	r0, r1, #24
 8004e4e:	d424      	bmi.n	8004e9a <HAL_PCD_EP_Open+0x52>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8004e50:	ebc1 00c1 	rsb	r0, r1, r1, lsl #3
 8004e54:	0080      	lsls	r0, r0, #2
  }
  ep->num   = ep_addr & 0x7F;
 8004e56:	182f      	adds	r7, r5, r0
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8004e58:	f04f 0e00 	mov.w	lr, #0
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8004e5c:	f507 74ee 	add.w	r4, r7, #476	; 0x1dc
  }
  ep->num   = ep_addr & 0x7F;
 8004e60:	f887 11dc 	strb.w	r1, [r7, #476]	; 0x1dc
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8004e64:	f887 e1dd 	strb.w	lr, [r7, #477]	; 0x1dd
  ep->maxpacket = ep_mps;
 8004e68:	f8c7 21e4 	str.w	r2, [r7, #484]	; 0x1e4
  ep->type = ep_type;
 8004e6c:	f887 31df 	strb.w	r3, [r7, #479]	; 0x1df
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK )
 8004e70:	2b02      	cmp	r3, #2
  {
    ep->data_pid_start = 0;
 8004e72:	bf04      	itt	eq
 8004e74:	2300      	moveq	r3, #0
 8004e76:	7123      	strbeq	r3, [r4, #4]
  }
  
  __HAL_LOCK(hpcd); 
 8004e78:	f895 3380 	ldrb.w	r3, [r5, #896]	; 0x380
 8004e7c:	2b01      	cmp	r3, #1
 8004e7e:	d101      	bne.n	8004e84 <HAL_PCD_EP_Open+0x3c>
 8004e80:	2002      	movs	r0, #2
  USB_ActivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);   
  return ret;
}
 8004e82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0;
  }
  
  __HAL_LOCK(hpcd); 
 8004e84:	2301      	movs	r3, #1
  USB_ActivateEndpoint(hpcd->Instance , ep);
 8004e86:	4621      	mov	r1, r4
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0;
  }
  
  __HAL_LOCK(hpcd); 
 8004e88:	f885 3380 	strb.w	r3, [r5, #896]	; 0x380
  USB_ActivateEndpoint(hpcd->Instance , ep);
 8004e8c:	6828      	ldr	r0, [r5, #0]
 8004e8e:	f006 f837 	bl	800af00 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8004e92:	2000      	movs	r0, #0
 8004e94:	f885 0380 	strb.w	r0, [r5, #896]	; 0x380
  return ret;
 8004e98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8004e9a:	f001 007f 	and.w	r0, r1, #127	; 0x7f
 8004e9e:	ebc0 04c0 	rsb	r4, r0, r0, lsl #3
 8004ea2:	00a4      	lsls	r4, r4, #2
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8004ea4:	192e      	adds	r6, r5, r4
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8004ea6:	2701      	movs	r7, #1
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8004ea8:	3438      	adds	r4, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8004eaa:	f886 0038 	strb.w	r0, [r6, #56]	; 0x38
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8004eae:	442c      	add	r4, r5
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8004eb0:	f886 7039 	strb.w	r7, [r6, #57]	; 0x39
  ep->maxpacket = ep_mps;
 8004eb4:	6432      	str	r2, [r6, #64]	; 0x40
  ep->type = ep_type;
 8004eb6:	f886 303b 	strb.w	r3, [r6, #59]	; 0x3b
  if (ep->is_in)
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8004eba:	87f0      	strh	r0, [r6, #62]	; 0x3e
 8004ebc:	e7d8      	b.n	8004e70 <HAL_PCD_EP_Open+0x28>
 8004ebe:	bf00      	nop

08004ec0 <HAL_PCD_EP_Close>:
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8004ec0:	b2ca      	uxtb	r2, r1
 8004ec2:	0613      	lsls	r3, r2, #24
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
 8004ec4:	b510      	push	{r4, lr}
 8004ec6:	4604      	mov	r4, r0
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8004ec8:	d419      	bmi.n	8004efe <HAL_PCD_EP_Close+0x3e>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8004eca:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8004ece:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8004ed2:	f503 73ee 	add.w	r3, r3, #476	; 0x1dc
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8004ed6:	09d2      	lsrs	r2, r2, #7
 8004ed8:	705a      	strb	r2, [r3, #1]
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8004eda:	7019      	strb	r1, [r3, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
  
  __HAL_LOCK(hpcd); 
 8004edc:	f894 2380 	ldrb.w	r2, [r4, #896]	; 0x380
 8004ee0:	2a01      	cmp	r2, #1
 8004ee2:	d101      	bne.n	8004ee8 <HAL_PCD_EP_Close+0x28>
 8004ee4:	2002      	movs	r0, #2
  USB_DeactivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);   
  return HAL_OK;
}
 8004ee6:	bd10      	pop	{r4, pc}
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
  
  __HAL_LOCK(hpcd); 
 8004ee8:	2201      	movs	r2, #1
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 8004eea:	4619      	mov	r1, r3
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
  
  __HAL_LOCK(hpcd); 
 8004eec:	f884 2380 	strb.w	r2, [r4, #896]	; 0x380
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 8004ef0:	6820      	ldr	r0, [r4, #0]
 8004ef2:	f006 f8c3 	bl	800b07c <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8004ef6:	2000      	movs	r0, #0
 8004ef8:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8004efc:	bd10      	pop	{r4, pc}
{  
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8004efe:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8004f02:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8004f06:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8004f0a:	3338      	adds	r3, #56	; 0x38
 8004f0c:	e7e3      	b.n	8004ed6 <HAL_PCD_EP_Close+0x16>
 8004f0e:	bf00      	nop

08004f10 <HAL_PCD_EP_Receive>:
  * @param  pBuf: pointer to the reception buffer   
  * @param  len: amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8004f10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8004f12:	f001 067f 	and.w	r6, r1, #127	; 0x7f
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8004f16:	00f5      	lsls	r5, r6, #3
 8004f18:	1bac      	subs	r4, r5, r6
 8004f1a:	eb00 0484 	add.w	r4, r0, r4, lsl #2
  ep->xfer_len = len;
  ep->xfer_count = 0;
 8004f1e:	2700      	movs	r7, #0
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8004f20:	f8c4 21e8 	str.w	r2, [r4, #488]	; 0x1e8
  ep->xfer_len = len;
 8004f24:	f8c4 31f0 	str.w	r3, [r4, #496]	; 0x1f0
  ep->xfer_count = 0;
 8004f28:	f8c4 71f4 	str.w	r7, [r4, #500]	; 0x1f4
  ep->is_in = 0;
 8004f2c:	f884 71dd 	strb.w	r7, [r4, #477]	; 0x1dd
  ep->num = ep_addr & 0x7F;
 8004f30:	f884 61dc 	strb.w	r6, [r4, #476]	; 0x1dc
  
  if (hpcd->Init.dma_enable == 1)
 8004f34:	6903      	ldr	r3, [r0, #16]
 8004f36:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pBuf;  
 8004f38:	bf08      	it	eq
 8004f3a:	f8c4 21ec 	streq.w	r2, [r4, #492]	; 0x1ec
  }
  
  __HAL_LOCK(hpcd); 
 8004f3e:	f890 2380 	ldrb.w	r2, [r0, #896]	; 0x380
 8004f42:	2a01      	cmp	r2, #1
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
  ep->xfer_len = len;
 8004f44:	f504 7ef4 	add.w	lr, r4, #488	; 0x1e8
  if (hpcd->Init.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8004f48:	d017      	beq.n	8004f7a <HAL_PCD_EP_Receive+0x6a>
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8004f4a:	1bad      	subs	r5, r5, r6
 8004f4c:	eb00 0585 	add.w	r5, r0, r5, lsl #2
  if (hpcd->Init.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8004f50:	2201      	movs	r2, #1
 8004f52:	f880 2380 	strb.w	r2, [r0, #896]	; 0x380
 8004f56:	4604      	mov	r4, r0
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8004f58:	f505 71ee 	add.w	r1, r5, #476	; 0x1dc
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7F) == 0 )
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8004f5c:	b2da      	uxtb	r2, r3
 8004f5e:	6800      	ldr	r0, [r0, #0]
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7F) == 0 )
 8004f60:	b12e      	cbz	r6, 8004f6e <HAL_PCD_EP_Receive+0x5e>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8004f62:	f006 f8fd 	bl	800b160 <USB_EPStartXfer>
  }
  __HAL_UNLOCK(hpcd); 
 8004f66:	2000      	movs	r0, #0
 8004f68:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  
  return HAL_OK;
 8004f6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7F) == 0 )
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8004f6e:	f006 fa27 	bl	800b3c0 <USB_EP0StartXfer>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
  }
  __HAL_UNLOCK(hpcd); 
 8004f72:	2000      	movs	r0, #0
 8004f74:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  
  return HAL_OK;
 8004f78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (hpcd->Init.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8004f7a:	2002      	movs	r0, #2
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
  }
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 8004f7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004f7e:	bf00      	nop

08004f80 <HAL_PCD_EP_GetRxCount>:
  * @param  ep_addr: endpoint address
  * @retval Data Size
  */
uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  return hpcd->OUT_ep[ep_addr & 0x7F].xfer_count;
 8004f80:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8004f84:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8004f88:	eb00 0081 	add.w	r0, r0, r1, lsl #2
}
 8004f8c:	f8b0 01f4 	ldrh.w	r0, [r0, #500]	; 0x1f4
 8004f90:	4770      	bx	lr
 8004f92:	bf00      	nop

08004f94 <HAL_PCD_EP_Transmit>:
  * @param  pBuf: pointer to the transmission buffer   
  * @param  len: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8004f94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8004f96:	f001 067f 	and.w	r6, r1, #127	; 0x7f
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8004f9a:	00f5      	lsls	r5, r6, #3
 8004f9c:	1bac      	subs	r4, r5, r6
 8004f9e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
  ep->xfer_len = len;
  ep->xfer_count = 0;
  ep->is_in = 1;
 8004fa2:	2101      	movs	r1, #1
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
  ep->xfer_len = len;
  ep->xfer_count = 0;
 8004fa4:	2700      	movs	r7, #0
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8004fa6:	6462      	str	r2, [r4, #68]	; 0x44
  ep->xfer_len = len;
 8004fa8:	64e3      	str	r3, [r4, #76]	; 0x4c
  ep->xfer_count = 0;
  ep->is_in = 1;
  ep->num = ep_addr & 0x7F;
 8004faa:	f884 6038 	strb.w	r6, [r4, #56]	; 0x38
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
  ep->xfer_len = len;
  ep->xfer_count = 0;
 8004fae:	6527      	str	r7, [r4, #80]	; 0x50
  ep->is_in = 1;
 8004fb0:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  ep->num = ep_addr & 0x7F;
  
  if (hpcd->Init.dma_enable == 1)
 8004fb4:	6903      	ldr	r3, [r0, #16]
 8004fb6:	428b      	cmp	r3, r1
  {
    ep->dma_addr = (uint32_t)pBuf;  
 8004fb8:	bf08      	it	eq
 8004fba:	64a2      	streq	r2, [r4, #72]	; 0x48
  }
  
  __HAL_LOCK(hpcd); 
 8004fbc:	f890 2380 	ldrb.w	r2, [r0, #896]	; 0x380
 8004fc0:	2a01      	cmp	r2, #1
 8004fc2:	d017      	beq.n	8004ff4 <HAL_PCD_EP_Transmit+0x60>
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8004fc4:	1bad      	subs	r5, r5, r6
 8004fc6:	eb00 0585 	add.w	r5, r0, r5, lsl #2
  if (hpcd->Init.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8004fca:	2201      	movs	r2, #1
 8004fcc:	f880 2380 	strb.w	r2, [r0, #896]	; 0x380
 8004fd0:	4604      	mov	r4, r0
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8004fd2:	f105 0138 	add.w	r1, r5, #56	; 0x38
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7F) == 0 )
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8004fd6:	b2da      	uxtb	r2, r3
 8004fd8:	6800      	ldr	r0, [r0, #0]
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7F) == 0 )
 8004fda:	b12e      	cbz	r6, 8004fe8 <HAL_PCD_EP_Transmit+0x54>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8004fdc:	f006 f8c0 	bl	800b160 <USB_EPStartXfer>
  }
  
  __HAL_UNLOCK(hpcd);
 8004fe0:	2000      	movs	r0, #0
 8004fe2:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
     
  return HAL_OK;
 8004fe6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7F) == 0 )
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8004fe8:	f006 f9ea 	bl	800b3c0 <USB_EP0StartXfer>
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
  }
  
  __HAL_UNLOCK(hpcd);
 8004fec:	2000      	movs	r0, #0
 8004fee:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
     
  return HAL_OK;
 8004ff2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (hpcd->Init.dma_enable == 1)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8004ff4:	2002      	movs	r0, #2
  }
  
  __HAL_UNLOCK(hpcd);
     
  return HAL_OK;
}
 8004ff6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004ff8 <HAL_PCD_EP_SetStall>:
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
 8004ff8:	b2ca      	uxtb	r2, r1
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8004ffa:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
 8004ffc:	0613      	lsls	r3, r2, #24
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8004ffe:	4605      	mov	r5, r0
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
 8005000:	d41c      	bmi.n	800503c <HAL_PCD_EP_SetStall+0x44>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8005002:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8005006:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800500a:	f503 73ee 	add.w	r3, r3, #476	; 0x1dc
 800500e:	460c      	mov	r4, r1
  }
  
  ep->is_stall = 1;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8005010:	09d2      	lsrs	r2, r2, #7
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1;
 8005012:	2101      	movs	r1, #1
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8005014:	705a      	strb	r2, [r3, #1]
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1;
  ep->num   = ep_addr & 0x7F;
 8005016:	701c      	strb	r4, [r3, #0]
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1;
 8005018:	7099      	strb	r1, [r3, #2]
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  
  __HAL_LOCK(hpcd); 
 800501a:	f895 2380 	ldrb.w	r2, [r5, #896]	; 0x380
 800501e:	428a      	cmp	r2, r1
 8005020:	d101      	bne.n	8005026 <HAL_PCD_EP_SetStall+0x2e>
 8005022:	2002      	movs	r0, #2
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
  }
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 8005024:	bd38      	pop	{r3, r4, r5, pc}
  ep->is_stall = 1;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  
  __HAL_LOCK(hpcd); 
 8005026:	f885 1380 	strb.w	r1, [r5, #896]	; 0x380
  USB_EPSetStall(hpcd->Instance , ep);
 800502a:	6828      	ldr	r0, [r5, #0]
 800502c:	4619      	mov	r1, r3
 800502e:	f006 faa9 	bl	800b584 <USB_EPSetStall>
  if((ep_addr & 0x7F) == 0)
 8005032:	b15c      	cbz	r4, 800504c <HAL_PCD_EP_SetStall+0x54>
  {
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
  }
  __HAL_UNLOCK(hpcd); 
 8005034:	2000      	movs	r0, #0
 8005036:	f885 0380 	strb.w	r0, [r5, #896]	; 0x380
  
  return HAL_OK;
 800503a:	bd38      	pop	{r3, r4, r5, pc}
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800503c:	f001 047f 	and.w	r4, r1, #127	; 0x7f
 8005040:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 8005044:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8005048:	3338      	adds	r3, #56	; 0x38
 800504a:	e7e1      	b.n	8005010 <HAL_PCD_EP_SetStall+0x18>
  
  __HAL_LOCK(hpcd); 
  USB_EPSetStall(hpcd->Instance , ep);
  if((ep_addr & 0x7F) == 0)
  {
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 800504c:	6828      	ldr	r0, [r5, #0]
 800504e:	7c29      	ldrb	r1, [r5, #16]
 8005050:	f505 7261 	add.w	r2, r5, #900	; 0x384
 8005054:	f006 fb82 	bl	800b75c <USB_EP0_OutStart>
 8005058:	e7ec      	b.n	8005034 <HAL_PCD_EP_SetStall+0x3c>
 800505a:	bf00      	nop

0800505c <HAL_PCD_EP_ClrStall>:
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
 800505c:	b2ca      	uxtb	r2, r1
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800505e:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
 8005060:	0613      	lsls	r3, r2, #24
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8005062:	4605      	mov	r5, r0
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
 8005064:	d41b      	bmi.n	800509e <HAL_PCD_EP_ClrStall+0x42>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8005066:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 800506a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800506e:	f503 73ee 	add.w	r3, r3, #476	; 0x1dc
  }
  
  ep->is_stall = 0;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8005072:	09d2      	lsrs	r2, r2, #7
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 0;
 8005074:	2400      	movs	r4, #0
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8005076:	705a      	strb	r2, [r3, #1]
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 0;
  ep->num   = ep_addr & 0x7F;
 8005078:	7019      	strb	r1, [r3, #0]
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 0;
 800507a:	709c      	strb	r4, [r3, #2]
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  __HAL_LOCK(hpcd); 
 800507c:	f895 2380 	ldrb.w	r2, [r5, #896]	; 0x380
 8005080:	2a01      	cmp	r2, #1
 8005082:	d101      	bne.n	8005088 <HAL_PCD_EP_ClrStall+0x2c>
 8005084:	2002      	movs	r0, #2
  USB_EPClearStall(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd); 
    
  return HAL_OK;
}
 8005086:	bd38      	pop	{r3, r4, r5, pc}
  
  ep->is_stall = 0;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  __HAL_LOCK(hpcd); 
 8005088:	2201      	movs	r2, #1
  USB_EPClearStall(hpcd->Instance , ep);
 800508a:	4619      	mov	r1, r3
  
  ep->is_stall = 0;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  __HAL_LOCK(hpcd); 
 800508c:	f885 2380 	strb.w	r2, [r5, #896]	; 0x380
  USB_EPClearStall(hpcd->Instance , ep);
 8005090:	6828      	ldr	r0, [r5, #0]
 8005092:	f006 fa97 	bl	800b5c4 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 8005096:	f885 4380 	strb.w	r4, [r5, #896]	; 0x380
    
  return HAL_OK;
 800509a:	4620      	mov	r0, r4
 800509c:	bd38      	pop	{r3, r4, r5, pc}
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800509e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 80050a2:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 80050a6:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80050aa:	3338      	adds	r3, #56	; 0x38
 80050ac:	e7e1      	b.n	8005072 <HAL_PCD_EP_ClrStall+0x16>
 80050ae:	bf00      	nop

080050b0 <HAL_PCD_EP_Flush>:
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  __HAL_LOCK(hpcd); 
 80050b0:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 80050b4:	2b01      	cmp	r3, #1
 80050b6:	d00d      	beq.n	80050d4 <HAL_PCD_EP_Flush+0x24>
 80050b8:	2301      	movs	r3, #1
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 80050ba:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd); 
 80050bc:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  
  if ((ep_addr & 0x80) == 0x80)
 80050c0:	060b      	lsls	r3, r1, #24
 80050c2:	4604      	mov	r4, r0
 80050c4:	d408      	bmi.n	80050d8 <HAL_PCD_EP_Flush+0x28>
  {
    USB_FlushTxFifo(hpcd->Instance, ep_addr & 0x7F);
  }
  else
  {
    USB_FlushRxFifo(hpcd->Instance);
 80050c6:	6800      	ldr	r0, [r0, #0]
 80050c8:	f005 fee6 	bl	800ae98 <USB_FlushRxFifo>
  }
  
  __HAL_UNLOCK(hpcd); 
 80050cc:	2000      	movs	r0, #0
 80050ce:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
    
  return HAL_OK;
 80050d2:	bd10      	pop	{r4, pc}
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  __HAL_LOCK(hpcd); 
 80050d4:	2002      	movs	r0, #2
 80050d6:	4770      	bx	lr
  
  if ((ep_addr & 0x80) == 0x80)
  {
    USB_FlushTxFifo(hpcd->Instance, ep_addr & 0x7F);
 80050d8:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 80050dc:	6800      	ldr	r0, [r0, #0]
 80050de:	f005 fec9 	bl	800ae74 <USB_FlushTxFifo>
  else
  {
    USB_FlushRxFifo(hpcd->Instance);
  }
  
  __HAL_UNLOCK(hpcd); 
 80050e2:	2000      	movs	r0, #0
 80050e4:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
    
  return HAL_OK;
 80050e8:	bd10      	pop	{r4, pc}
 80050ea:	bf00      	nop

080050ec <HAL_PCD_ActivateRemoteWakeup>:
  */
HAL_StatusTypeDef HAL_PCD_ActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
    
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80050ec:	6803      	ldr	r3, [r0, #0]
 80050ee:	f8d3 2808 	ldr.w	r2, [r3, #2056]	; 0x808
 80050f2:	07d2      	lsls	r2, r2, #31
 80050f4:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80050f8:	d503      	bpl.n	8005102 <HAL_PCD_ActivateRemoteWakeup+0x16>
  {
    /* Activate Remote wakeup signaling */
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_RWUSIG;
 80050fa:	685a      	ldr	r2, [r3, #4]
 80050fc:	f042 0201 	orr.w	r2, r2, #1
 8005100:	605a      	str	r2, [r3, #4]
  }
  return HAL_OK;  
}
 8005102:	2000      	movs	r0, #0
 8005104:	4770      	bx	lr
 8005106:	bf00      	nop

08005108 <HAL_PCD_DeActivateRemoteWakeup>:
HAL_StatusTypeDef HAL_PCD_DeActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
  
  /* De-activate Remote wakeup signaling */
   USBx_DEVICE->DCTL &= ~(USB_OTG_DCTL_RWUSIG);
 8005108:	6803      	ldr	r3, [r0, #0]
 800510a:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
 800510e:	f022 0201 	bic.w	r2, r2, #1
  return HAL_OK;  
}
 8005112:	2000      	movs	r0, #0
HAL_StatusTypeDef HAL_PCD_DeActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
  
  /* De-activate Remote wakeup signaling */
   USBx_DEVICE->DCTL &= ~(USB_OTG_DCTL_RWUSIG);
 8005114:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
  return HAL_OK;  
}
 8005118:	4770      	bx	lr
 800511a:	bf00      	nop

0800511c <HAL_PCD_GetState>:
  * @param  hpcd: PCD handle
  * @retval HAL state
  */
PCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd)
{
  return hpcd->State;
 800511c:	f890 0381 	ldrb.w	r0, [r0, #897]	; 0x381
}
 8005120:	4770      	bx	lr
 8005122:	bf00      	nop

08005124 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo: The number of Tx fifo
  * @param  size: Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8005124:	b470      	push	{r4, r5, r6}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8005126:	6806      	ldr	r6, [r0, #0]
 8005128:	6a73      	ldr	r3, [r6, #36]	; 0x24
  
  if(fifo == 0)
 800512a:	b1d1      	cbz	r1, 8005162 <HAL_PCDEx_SetTxFiFo+0x3e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (size << 16) | Tx_Offset;
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 800512c:	6ab4      	ldr	r4, [r6, #40]	; 0x28
    for (i = 0; i < (fifo - 1); i++)
 800512e:	3901      	subs	r1, #1
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (size << 16) | Tx_Offset;
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8005130:	eb03 4414 	add.w	r4, r3, r4, lsr #16
    for (i = 0; i < (fifo - 1); i++)
 8005134:	d00c      	beq.n	8005150 <HAL_PCDEx_SetTxFiFo+0x2c>
 8005136:	2300      	movs	r3, #0
 8005138:	4618      	mov	r0, r3
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 800513a:	3340      	adds	r3, #64	; 0x40
 800513c:	eb06 0383 	add.w	r3, r6, r3, lsl #2
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (size << 16) | Tx_Offset;
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
    for (i = 0; i < (fifo - 1); i++)
 8005140:	3001      	adds	r0, #1
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8005142:	685d      	ldr	r5, [r3, #4]
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (size << 16) | Tx_Offset;
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
    for (i = 0; i < (fifo - 1); i++)
 8005144:	b2c0      	uxtb	r0, r0
 8005146:	4288      	cmp	r0, r1
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8005148:	eb04 4415 	add.w	r4, r4, r5, lsr #16
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (size << 16) | Tx_Offset;
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
    for (i = 0; i < (fifo - 1); i++)
 800514c:	4603      	mov	r3, r0
 800514e:	dbf4      	blt.n	800513a <HAL_PCDEx_SetTxFiFo+0x16>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
    }
    
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1] = (size << 16) | Tx_Offset;
 8005150:	3140      	adds	r1, #64	; 0x40
 8005152:	eb06 0181 	add.w	r1, r6, r1, lsl #2
 8005156:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 800515a:	604c      	str	r4, [r1, #4]
  }
  
  return HAL_OK;
}
 800515c:	2000      	movs	r0, #0
 800515e:	bc70      	pop	{r4, r5, r6}
 8005160:	4770      	bx	lr
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
  
  if(fifo == 0)
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (size << 16) | Tx_Offset;
 8005162:	ea43 4402 	orr.w	r4, r3, r2, lsl #16
 8005166:	62b4      	str	r4, [r6, #40]	; 0x28
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1] = (size << 16) | Tx_Offset;
  }
  
  return HAL_OK;
}
 8005168:	2000      	movs	r0, #0
 800516a:	bc70      	pop	{r4, r5, r6}
 800516c:	4770      	bx	lr
 800516e:	bf00      	nop

08005170 <HAL_PCDEx_SetRxFiFo>:
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8005170:	6803      	ldr	r3, [r0, #0]
  
  return HAL_OK;
}
 8005172:	2000      	movs	r0, #0
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8005174:	6259      	str	r1, [r3, #36]	; 0x24
  
  return HAL_OK;
}
 8005176:	4770      	bx	lr

08005178 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 8005178:	4603      	mov	r3, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
  
  hpcd->lpm_active = ENABLE;
 800517a:	2101      	movs	r1, #1
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 800517c:	6802      	ldr	r2, [r0, #0]
  
  hpcd->lpm_active = ENABLE;
 800517e:	f8c0 13bc 	str.w	r1, [r0, #956]	; 0x3bc
  hpcd->LPM_State = LPM_L0;
 8005182:	2000      	movs	r0, #0
 8005184:	f883 03b4 	strb.w	r0, [r3, #948]	; 0x3b4
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8005188:	6993      	ldr	r3, [r2, #24]
 800518a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800518e:	6193      	str	r3, [r2, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8005190:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8005192:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005196:	f043 0303 	orr.w	r3, r3, #3
 800519a:	6553      	str	r3, [r2, #84]	; 0x54

  return HAL_OK;  
}
 800519c:	4770      	bx	lr
 800519e:	bf00      	nop

080051a0 <HAL_PCDEx_DeActivateLPM>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_DeActivateLPM(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 80051a0:	6802      	ldr	r2, [r0, #0]
  
  hpcd->lpm_active = DISABLE;
 80051a2:	2100      	movs	r1, #0
 80051a4:	f8c0 13bc 	str.w	r1, [r0, #956]	; 0x3bc
  USBx->GINTMSK &= ~USB_OTG_GINTMSK_LPMINTM;
 80051a8:	6993      	ldr	r3, [r2, #24]
 80051aa:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
 80051ae:	6193      	str	r3, [r2, #24]
  USBx->GLPMCFG &= ~(USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 80051b0:	6d53      	ldr	r3, [r2, #84]	; 0x54
 80051b2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80051b6:	f023 0303 	bic.w	r3, r3, #3
  
  return HAL_OK;  
}
 80051ba:	4608      	mov	r0, r1
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
  
  hpcd->lpm_active = DISABLE;
  USBx->GINTMSK &= ~USB_OTG_GINTMSK_LPMINTM;
  USBx->GLPMCFG &= ~(USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 80051bc:	6553      	str	r3, [r2, #84]	; 0x54
  
  return HAL_OK;  
}
 80051be:	4770      	bx	lr

080051c0 <HAL_PCDEx_ActivateBCD>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateBCD(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 80051c0:	6802      	ldr	r2, [r0, #0]

  hpcd->battery_charging_active = ENABLE; 
 80051c2:	2301      	movs	r3, #1
 80051c4:	f8c0 33c0 	str.w	r3, [r0, #960]	; 0x3c0
  USBx->GCCFG |= (USB_OTG_GCCFG_BCDEN);
 80051c8:	6b93      	ldr	r3, [r2, #56]	; 0x38
 80051ca:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80051ce:	6393      	str	r3, [r2, #56]	; 0x38
  
  return HAL_OK;  
}
 80051d0:	2000      	movs	r0, #0
 80051d2:	4770      	bx	lr

080051d4 <HAL_PCDEx_DeActivateBCD>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_DeActivateBCD(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 80051d4:	6802      	ldr	r2, [r0, #0]
  hpcd->battery_charging_active = DISABLE; 
 80051d6:	2100      	movs	r1, #0
 80051d8:	f8c0 13c0 	str.w	r1, [r0, #960]	; 0x3c0
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
 80051dc:	6b93      	ldr	r3, [r2, #56]	; 0x38
 80051de:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  return HAL_OK;  
}
 80051e2:	4608      	mov	r0, r1
  */
HAL_StatusTypeDef HAL_PCDEx_DeActivateBCD(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
  hpcd->battery_charging_active = DISABLE; 
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
 80051e4:	6393      	str	r3, [r2, #56]	; 0x38
  return HAL_OK;  
}
 80051e6:	4770      	bx	lr

080051e8 <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd: PCD handle
  * @param  msg: LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{ 
 80051e8:	4770      	bx	lr
 80051ea:	bf00      	nop

080051ec <HAL_PCDEx_BCD_Callback>:
  * @param  hpcd: PCD handle
  * @param  msg: LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_BCD_Callback(PCD_HandleTypeDef *hpcd, PCD_BCD_MsgTypeDef msg)
{
 80051ec:	4770      	bx	lr
 80051ee:	bf00      	nop

080051f0 <HAL_PCDEx_BCD_VBUSDetect>:
  * @brief  Handle BatteryCharging Process.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCDEx_BCD_VBUSDetect(PCD_HandleTypeDef *hpcd)
{
 80051f0:	b570      	push	{r4, r5, r6, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 80051f2:	6804      	ldr	r4, [r0, #0]
  * @brief  Handle BatteryCharging Process.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCDEx_BCD_VBUSDetect(PCD_HandleTypeDef *hpcd)
{
 80051f4:	4606      	mov	r6, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
  uint32_t tickstart = HAL_GetTick();
 80051f6:	f7fb fc87 	bl	8000b08 <HAL_GetTick>
  
  /* Start BCD When device is connected */
  if (USBx_DEVICE->DCTL & USB_OTG_DCTL_SDIS)
 80051fa:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
 80051fe:	079d      	lsls	r5, r3, #30
 8005200:	d539      	bpl.n	8005276 <HAL_PCDEx_BCD_VBUSDetect+0x86>
  { 
    /* Enable DCD : Data Contact Detect */
    USBx->GCCFG |= USB_OTG_GCCFG_DCDEN;
 8005202:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005204:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8005208:	4605      	mov	r5, r0
 800520a:	63a3      	str	r3, [r4, #56]	; 0x38
    
    /* Wait Detect flag or a timeout is happen*/
    while ((USBx->GCCFG & USB_OTG_GCCFG_DCDET) == 0)
 800520c:	e005      	b.n	800521a <HAL_PCDEx_BCD_VBUSDetect+0x2a>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > 1000)
 800520e:	f7fb fc7b 	bl	8000b08 <HAL_GetTick>
 8005212:	1b40      	subs	r0, r0, r5
 8005214:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8005218:	d82e      	bhi.n	8005278 <HAL_PCDEx_BCD_VBUSDetect+0x88>
  { 
    /* Enable DCD : Data Contact Detect */
    USBx->GCCFG |= USB_OTG_GCCFG_DCDEN;
    
    /* Wait Detect flag or a timeout is happen*/
    while ((USBx->GCCFG & USB_OTG_GCCFG_DCDET) == 0)
 800521a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800521c:	07d8      	lsls	r0, r3, #31
 800521e:	d5f6      	bpl.n	800520e <HAL_PCDEx_BCD_VBUSDetect+0x1e>
        return;
      }
    }
    
    /* Right response got */
    HAL_Delay(100); 
 8005220:	2064      	movs	r0, #100	; 0x64
 8005222:	f7fb fc77 	bl	8000b14 <HAL_Delay>
    
    /* Check Detect flag*/
    if (USBx->GCCFG & USB_OTG_GCCFG_DCDET)
 8005226:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005228:	07d9      	lsls	r1, r3, #31
 800522a:	d42f      	bmi.n	800528c <HAL_PCDEx_BCD_VBUSDetect+0x9c>
      HAL_PCDEx_BCD_Callback(hpcd, PCD_BCD_CONTACT_DETECTION);
    }
    
    /*Primary detection: checks if connected to Standard Downstream Port  
    (without charging capability) */
    USBx->GCCFG &=~ USB_OTG_GCCFG_DCDEN;
 800522c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800522e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8005232:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG |=  USB_OTG_GCCFG_PDEN;
 8005234:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005236:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800523a:	63a3      	str	r3, [r4, #56]	; 0x38
    HAL_Delay(100); 
 800523c:	2064      	movs	r0, #100	; 0x64
 800523e:	f7fb fc69 	bl	8000b14 <HAL_Delay>
    
    if (!(USBx->GCCFG & USB_OTG_GCCFG_PDET))
 8005242:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005244:	079a      	lsls	r2, r3, #30
 8005246:	d51c      	bpl.n	8005282 <HAL_PCDEx_BCD_VBUSDetect+0x92>
    }
    else  
    {
      /* start secondary detection to check connection to Charging Downstream 
      Port or Dedicated Charging Port */
      USBx->GCCFG &=~ USB_OTG_GCCFG_PDEN;
 8005248:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800524a:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800524e:	63a3      	str	r3, [r4, #56]	; 0x38
      USBx->GCCFG |=  USB_OTG_GCCFG_SDEN;
 8005250:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005252:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8005256:	63a3      	str	r3, [r4, #56]	; 0x38
      HAL_Delay(100); 
 8005258:	2064      	movs	r0, #100	; 0x64
 800525a:	f7fb fc5b 	bl	8000b14 <HAL_Delay>
      
      if ((USBx->GCCFG) & USB_OTG_GCCFG_SDET)
 800525e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005260:	075b      	lsls	r3, r3, #29
      { 
        /* case Dedicated Charging Port  */
        HAL_PCDEx_BCD_Callback(hpcd, PCD_BCD_DEDICATED_CHARGING_PORT);
 8005262:	4630      	mov	r0, r6
 8005264:	bf4c      	ite	mi
 8005266:	21fb      	movmi	r1, #251	; 0xfb
      }
      else
      {
        /* case Charging Downstream Port  */
        HAL_PCDEx_BCD_Callback(hpcd, PCD_BCD_CHARGING_DOWNSTREAM_PORT);
 8005268:	21fc      	movpl	r1, #252	; 0xfc
 800526a:	f7ff ffbf 	bl	80051ec <HAL_PCDEx_BCD_Callback>
      }
    }
    /* Battery Charging capability discovery finished */
    HAL_PCDEx_BCD_Callback(hpcd, PCD_BCD_DISCOVERY_COMPLETED);
 800526e:	4630      	mov	r0, r6
 8005270:	2100      	movs	r1, #0
 8005272:	f7ff ffbb 	bl	80051ec <HAL_PCDEx_BCD_Callback>
 8005276:	bd70      	pop	{r4, r5, r6, pc}
    while ((USBx->GCCFG & USB_OTG_GCCFG_DCDET) == 0)
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > 1000)
      {
        HAL_PCDEx_BCD_Callback(hpcd, PCD_BCD_ERROR);
 8005278:	4630      	mov	r0, r6
 800527a:	21ff      	movs	r1, #255	; 0xff
 800527c:	f7ff ffb6 	bl	80051ec <HAL_PCDEx_BCD_Callback>
        return;
 8005280:	bd70      	pop	{r4, r5, r6, pc}
    HAL_Delay(100); 
    
    if (!(USBx->GCCFG & USB_OTG_GCCFG_PDET))
    {
      /* Case of Standard Downstream Port */
      HAL_PCDEx_BCD_Callback(hpcd, PCD_BCD_STD_DOWNSTREAM_PORT);
 8005282:	4630      	mov	r0, r6
 8005284:	21fd      	movs	r1, #253	; 0xfd
 8005286:	f7ff ffb1 	bl	80051ec <HAL_PCDEx_BCD_Callback>
 800528a:	e7f0      	b.n	800526e <HAL_PCDEx_BCD_VBUSDetect+0x7e>
    HAL_Delay(100); 
    
    /* Check Detect flag*/
    if (USBx->GCCFG & USB_OTG_GCCFG_DCDET)
    {
      HAL_PCDEx_BCD_Callback(hpcd, PCD_BCD_CONTACT_DETECTION);
 800528c:	4630      	mov	r0, r6
 800528e:	21fe      	movs	r1, #254	; 0xfe
 8005290:	f7ff ffac 	bl	80051ec <HAL_PCDEx_BCD_Callback>
 8005294:	e7ca      	b.n	800522c <HAL_PCDEx_BCD_VBUSDetect+0x3c>
 8005296:	bf00      	nop

08005298 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return  (PWR->CR1 & PWR_CR1_VOS);
 8005298:	4b02      	ldr	r3, [pc, #8]	; (80052a4 <HAL_PWREx_GetVoltageRange+0xc>)
 800529a:	6818      	ldr	r0, [r3, #0]
}
 800529c:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 80052a0:	4770      	bx	lr
 80052a2:	bf00      	nop
 80052a4:	40007000 	.word	0x40007000

080052a8 <HAL_PWREx_ControlVoltageScaling>:
  uint32_t wait_loop_index = 0;  

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 80052a8:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80052ac:	d00e      	beq.n	80052cc <HAL_PWREx_ControlVoltageScaling+0x24>
      }
    }
  }
  else
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 80052ae:	4a1b      	ldr	r2, [pc, #108]	; (800531c <HAL_PWREx_ControlVoltageScaling+0x74>)
 80052b0:	6813      	ldr	r3, [r2, #0]
 80052b2:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 80052b6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80052ba:	d02c      	beq.n	8005316 <HAL_PWREx_ControlVoltageScaling+0x6e>
    {
      /* Set Range 2 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 80052bc:	6813      	ldr	r3, [r2, #0]
 80052be:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80052c2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80052c6:	6013      	str	r3, [r2, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
  
  return HAL_OK;
 80052c8:	2000      	movs	r0, #0
 80052ca:	4770      	bx	lr
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 80052cc:	4913      	ldr	r1, [pc, #76]	; (800531c <HAL_PWREx_ControlVoltageScaling+0x74>)
 80052ce:	680b      	ldr	r3, [r1, #0]
 80052d0:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 80052d4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80052d8:	d01d      	beq.n	8005316 <HAL_PWREx_ControlVoltageScaling+0x6e>
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80052da:	6808      	ldr	r0, [r1, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 80052dc:	4b10      	ldr	r3, [pc, #64]	; (8005320 <HAL_PWREx_ControlVoltageScaling+0x78>)
 80052de:	4a11      	ldr	r2, [pc, #68]	; (8005324 <HAL_PWREx_ControlVoltageScaling+0x7c>)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80052e0:	f420 60c0 	bic.w	r0, r0, #1536	; 0x600
 80052e4:	f440 7000 	orr.w	r0, r0, #512	; 0x200
 80052e8:	6008      	str	r0, [r1, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 80052ea:	681b      	ldr	r3, [r3, #0]
 80052ec:	fba2 2303 	umull	r2, r3, r2, r3
 80052f0:	0c9a      	lsrs	r2, r3, #18
 80052f2:	2332      	movs	r3, #50	; 0x32
 80052f4:	fb03 f302 	mul.w	r3, r3, r2
      while ((wait_loop_index != 0) && (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)))
 80052f8:	b913      	cbnz	r3, 8005300 <HAL_PWREx_ControlVoltageScaling+0x58>
 80052fa:	e004      	b.n	8005306 <HAL_PWREx_ControlVoltageScaling+0x5e>
 80052fc:	3b01      	subs	r3, #1
 80052fe:	d002      	beq.n	8005306 <HAL_PWREx_ControlVoltageScaling+0x5e>
 8005300:	694a      	ldr	r2, [r1, #20]
 8005302:	0552      	lsls	r2, r2, #21
 8005304:	d4fa      	bmi.n	80052fc <HAL_PWREx_ControlVoltageScaling+0x54>
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8005306:	4b05      	ldr	r3, [pc, #20]	; (800531c <HAL_PWREx_ControlVoltageScaling+0x74>)
 8005308:	695b      	ldr	r3, [r3, #20]
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
  
  return HAL_OK;
 800530a:	f413 6f80 	tst.w	r3, #1024	; 0x400
 800530e:	bf14      	ite	ne
 8005310:	2003      	movne	r0, #3
 8005312:	2000      	moveq	r0, #0
 8005314:	4770      	bx	lr
 8005316:	2000      	movs	r0, #0
}  
 8005318:	4770      	bx	lr
 800531a:	bf00      	nop
 800531c:	40007000 	.word	0x40007000
 8005320:	20000000 	.word	0x20000000
 8005324:	431bde83 	.word	0x431bde83

08005328 <HAL_PWREx_EnableBatteryCharging>:
void HAL_PWREx_EnableBatteryCharging(uint32_t ResistorSelection)
{
  assert_param(IS_PWR_BATTERY_RESISTOR_SELECT(ResistorSelection));
  
  /* Specify resistor selection */
  MODIFY_REG(PWR->CR4, PWR_CR4_VBRS, ResistorSelection);
 8005328:	4a05      	ldr	r2, [pc, #20]	; (8005340 <HAL_PWREx_EnableBatteryCharging+0x18>)
 800532a:	68d3      	ldr	r3, [r2, #12]
 800532c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8005330:	4318      	orrs	r0, r3
 8005332:	60d0      	str	r0, [r2, #12]
  
  /* Enable battery charging */
  SET_BIT(PWR->CR4, PWR_CR4_VBE);
 8005334:	68d3      	ldr	r3, [r2, #12]
 8005336:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800533a:	60d3      	str	r3, [r2, #12]
 800533c:	4770      	bx	lr
 800533e:	bf00      	nop
 8005340:	40007000 	.word	0x40007000

08005344 <HAL_PWREx_DisableBatteryCharging>:
  * @brief Disable battery charging.  
  * @retval None
  */
void HAL_PWREx_DisableBatteryCharging(void)
{
  CLEAR_BIT(PWR->CR4, PWR_CR4_VBE); 
 8005344:	4a02      	ldr	r2, [pc, #8]	; (8005350 <HAL_PWREx_DisableBatteryCharging+0xc>)
 8005346:	68d3      	ldr	r3, [r2, #12]
 8005348:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800534c:	60d3      	str	r3, [r2, #12]
 800534e:	4770      	bx	lr
 8005350:	40007000 	.word	0x40007000

08005354 <HAL_PWREx_EnableVddUSB>:
  * @note  Remove VDDUSB electrical and logical isolation, once VDDUSB supply is present.  
  * @retval None
  */
void HAL_PWREx_EnableVddUSB(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_USV);
 8005354:	4a02      	ldr	r2, [pc, #8]	; (8005360 <HAL_PWREx_EnableVddUSB+0xc>)
 8005356:	6853      	ldr	r3, [r2, #4]
 8005358:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800535c:	6053      	str	r3, [r2, #4]
 800535e:	4770      	bx	lr
 8005360:	40007000 	.word	0x40007000

08005364 <HAL_PWREx_DisableVddUSB>:
  * @brief Disable VDDUSB supply. 
  * @retval None
  */
void HAL_PWREx_DisableVddUSB(void)
{
  CLEAR_BIT(PWR->CR2, PWR_CR2_USV);
 8005364:	4a02      	ldr	r2, [pc, #8]	; (8005370 <HAL_PWREx_DisableVddUSB+0xc>)
 8005366:	6853      	ldr	r3, [r2, #4]
 8005368:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800536c:	6053      	str	r3, [r2, #4]
 800536e:	4770      	bx	lr
 8005370:	40007000 	.word	0x40007000

08005374 <HAL_PWREx_EnableVddIO2>:
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present. 
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 8005374:	4a02      	ldr	r2, [pc, #8]	; (8005380 <HAL_PWREx_EnableVddIO2+0xc>)
 8005376:	6853      	ldr	r3, [r2, #4]
 8005378:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800537c:	6053      	str	r3, [r2, #4]
 800537e:	4770      	bx	lr
 8005380:	40007000 	.word	0x40007000

08005384 <HAL_PWREx_DisableVddIO2>:
  * @brief Disable VDDIO2 supply. 
  * @retval None
  */
void HAL_PWREx_DisableVddIO2(void)
{
  CLEAR_BIT(PWR->CR2, PWR_CR2_IOSV);
 8005384:	4a02      	ldr	r2, [pc, #8]	; (8005390 <HAL_PWREx_DisableVddIO2+0xc>)
 8005386:	6853      	ldr	r3, [r2, #4]
 8005388:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800538c:	6053      	str	r3, [r2, #4]
 800538e:	4770      	bx	lr
 8005390:	40007000 	.word	0x40007000

08005394 <HAL_PWREx_EnableInternalWakeUpLine>:
  * @brief Enable Internal Wake-up Line. 
  * @retval None
  */
void HAL_PWREx_EnableInternalWakeUpLine(void)
{
  SET_BIT(PWR->CR3, PWR_CR3_EIWF);
 8005394:	4a02      	ldr	r2, [pc, #8]	; (80053a0 <HAL_PWREx_EnableInternalWakeUpLine+0xc>)
 8005396:	6893      	ldr	r3, [r2, #8]
 8005398:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800539c:	6093      	str	r3, [r2, #8]
 800539e:	4770      	bx	lr
 80053a0:	40007000 	.word	0x40007000

080053a4 <HAL_PWREx_DisableInternalWakeUpLine>:
  * @brief Disable Internal Wake-up Line. 
  * @retval None
  */
void HAL_PWREx_DisableInternalWakeUpLine(void)
{
  CLEAR_BIT(PWR->CR3, PWR_CR3_EIWF);
 80053a4:	4a02      	ldr	r2, [pc, #8]	; (80053b0 <HAL_PWREx_DisableInternalWakeUpLine+0xc>)
 80053a6:	6893      	ldr	r3, [r2, #8]
 80053a8:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80053ac:	6093      	str	r3, [r2, #8]
 80053ae:	4770      	bx	lr
 80053b0:	40007000 	.word	0x40007000

080053b4 <HAL_PWREx_EnableGPIOPullUp>:
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{  
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
 80053b4:	2807      	cmp	r0, #7
 80053b6:	d85d      	bhi.n	8005474 <HAL_PWREx_EnableGPIOPullUp+0xc0>
 80053b8:	e8df f000 	tbb	[pc, r0]
 80053bc:	342a1e10 	.word	0x342a1e10
 80053c0:	0452483e 	.word	0x0452483e
    case PWR_GPIO_G:
       SET_BIT(PWR->PUCRG, GPIONumber);
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 80053c4:	4b2c      	ldr	r3, [pc, #176]	; (8005478 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 80053c6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80053c8:	f001 0103 	and.w	r1, r1, #3
 80053cc:	430a      	orrs	r2, r1
 80053ce:	659a      	str	r2, [r3, #88]	; 0x58
       CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));           
 80053d0:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80053d2:	ea22 0101 	bic.w	r1, r2, r1
 80053d6:	65d9      	str	r1, [r3, #92]	; 0x5c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80053d8:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));           
       break;                                                   
 80053da:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
  {
    case PWR_GPIO_A:
       SET_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
 80053dc:	4b26      	ldr	r3, [pc, #152]	; (8005478 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 80053de:	6a1a      	ldr	r2, [r3, #32]
 80053e0:	f421 4080 	bic.w	r0, r1, #16384	; 0x4000
 80053e4:	4302      	orrs	r2, r0
 80053e6:	621a      	str	r2, [r3, #32]
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                       
 80053e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80053ea:	f421 4120 	bic.w	r1, r1, #40960	; 0xa000
 80053ee:	ea22 0101 	bic.w	r1, r2, r1
 80053f2:	6259      	str	r1, [r3, #36]	; 0x24
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80053f4:	2000      	movs	r0, #0
  switch (GPIO)
  {
    case PWR_GPIO_A:
       SET_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                       
       break;
 80053f6:	4770      	bx	lr
    case PWR_GPIO_B:
       SET_BIT(PWR->PUCRB, GPIONumber);
 80053f8:	4b1f      	ldr	r3, [pc, #124]	; (8005478 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 80053fa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80053fc:	430a      	orrs	r2, r1
 80053fe:	629a      	str	r2, [r3, #40]	; 0x28
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));                  
 8005400:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005402:	f021 0110 	bic.w	r1, r1, #16
 8005406:	ea22 0101 	bic.w	r1, r2, r1
 800540a:	62d9      	str	r1, [r3, #44]	; 0x2c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 800540c:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                       
       break;
    case PWR_GPIO_B:
       SET_BIT(PWR->PUCRB, GPIONumber);
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));                  
       break; 
 800540e:	4770      	bx	lr
    case PWR_GPIO_C:
       SET_BIT(PWR->PUCRC, GPIONumber);
 8005410:	4b19      	ldr	r3, [pc, #100]	; (8005478 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8005412:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005414:	430a      	orrs	r2, r1
 8005416:	631a      	str	r2, [r3, #48]	; 0x30
       CLEAR_BIT(PWR->PDCRC, GPIONumber);         
 8005418:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800541a:	ea22 0101 	bic.w	r1, r2, r1
 800541e:	6359      	str	r1, [r3, #52]	; 0x34
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005420:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));                  
       break; 
    case PWR_GPIO_C:
       SET_BIT(PWR->PUCRC, GPIONumber);
       CLEAR_BIT(PWR->PDCRC, GPIONumber);         
       break; 
 8005422:	4770      	bx	lr
    case PWR_GPIO_D:
       SET_BIT(PWR->PUCRD, GPIONumber);
 8005424:	4b14      	ldr	r3, [pc, #80]	; (8005478 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8005426:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005428:	430a      	orrs	r2, r1
 800542a:	639a      	str	r2, [r3, #56]	; 0x38
       CLEAR_BIT(PWR->PDCRD, GPIONumber);         
 800542c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800542e:	ea22 0101 	bic.w	r1, r2, r1
 8005432:	63d9      	str	r1, [r3, #60]	; 0x3c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005434:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRC, GPIONumber);         
       break; 
    case PWR_GPIO_D:
       SET_BIT(PWR->PUCRD, GPIONumber);
       CLEAR_BIT(PWR->PDCRD, GPIONumber);         
       break;
 8005436:	4770      	bx	lr
    case PWR_GPIO_E:
       SET_BIT(PWR->PUCRE, GPIONumber);
 8005438:	4b0f      	ldr	r3, [pc, #60]	; (8005478 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 800543a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800543c:	430a      	orrs	r2, r1
 800543e:	641a      	str	r2, [r3, #64]	; 0x40
       CLEAR_BIT(PWR->PDCRE, GPIONumber);         
 8005440:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005442:	ea22 0101 	bic.w	r1, r2, r1
 8005446:	6459      	str	r1, [r3, #68]	; 0x44
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005448:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRD, GPIONumber);         
       break;
    case PWR_GPIO_E:
       SET_BIT(PWR->PUCRE, GPIONumber);
       CLEAR_BIT(PWR->PDCRE, GPIONumber);         
       break;
 800544a:	4770      	bx	lr
    case PWR_GPIO_F:
       SET_BIT(PWR->PUCRF, GPIONumber);
 800544c:	4b0a      	ldr	r3, [pc, #40]	; (8005478 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 800544e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8005450:	430a      	orrs	r2, r1
 8005452:	649a      	str	r2, [r3, #72]	; 0x48
       CLEAR_BIT(PWR->PDCRF, GPIONumber);         
 8005454:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8005456:	ea22 0101 	bic.w	r1, r2, r1
 800545a:	64d9      	str	r1, [r3, #76]	; 0x4c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 800545c:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRE, GPIONumber);         
       break;
    case PWR_GPIO_F:
       SET_BIT(PWR->PUCRF, GPIONumber);
       CLEAR_BIT(PWR->PDCRF, GPIONumber);         
       break;
 800545e:	4770      	bx	lr
    case PWR_GPIO_G:
       SET_BIT(PWR->PUCRG, GPIONumber);
 8005460:	4b05      	ldr	r3, [pc, #20]	; (8005478 <HAL_PWREx_EnableGPIOPullUp+0xc4>)
 8005462:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8005464:	430a      	orrs	r2, r1
 8005466:	651a      	str	r2, [r3, #80]	; 0x50
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
 8005468:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800546a:	ea22 0101 	bic.w	r1, r2, r1
 800546e:	6559      	str	r1, [r3, #84]	; 0x54
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005470:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PDCRF, GPIONumber);         
       break;
    case PWR_GPIO_G:
       SET_BIT(PWR->PUCRG, GPIONumber);
       CLEAR_BIT(PWR->PDCRG, GPIONumber);         
       break;
 8005472:	4770      	bx	lr
    case PWR_GPIO_H:
       SET_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));           
       break;                                                   
    default:
        return HAL_ERROR;
 8005474:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 8005476:	4770      	bx	lr
 8005478:	40007000 	.word	0x40007000

0800547c <HAL_PWREx_DisableGPIOPullUp>:
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{  
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
 800547c:	2807      	cmp	r0, #7
 800547e:	d841      	bhi.n	8005504 <HAL_PWREx_DisableGPIOPullUp+0x88>
 8005480:	e8df f000 	tbb	[pc, r0]
 8005484:	241d160d 	.word	0x241d160d
 8005488:	0439322b 	.word	0x0439322b
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 800548c:	4a1e      	ldr	r2, [pc, #120]	; (8005508 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 800548e:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8005490:	f001 0103 	and.w	r1, r1, #3
 8005494:	ea23 0101 	bic.w	r1, r3, r1
 8005498:	6591      	str	r1, [r2, #88]	; 0x58
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 800549a:	2000      	movs	r0, #0
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
 800549c:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));         
 800549e:	4a1a      	ldr	r2, [pc, #104]	; (8005508 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 80054a0:	6a13      	ldr	r3, [r2, #32]
 80054a2:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 80054a6:	ea23 0101 	bic.w	r1, r3, r1
 80054aa:	6211      	str	r1, [r2, #32]
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80054ac:	2000      	movs	r0, #0
  
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));         
       break;
 80054ae:	4770      	bx	lr
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
 80054b0:	4a15      	ldr	r2, [pc, #84]	; (8005508 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 80054b2:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80054b4:	ea23 0101 	bic.w	r1, r3, r1
 80054b8:	6291      	str	r1, [r2, #40]	; 0x28
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80054ba:	2000      	movs	r0, #0
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));         
       break;
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
       break; 
 80054bc:	4770      	bx	lr
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
 80054be:	4a12      	ldr	r2, [pc, #72]	; (8005508 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 80054c0:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80054c2:	ea23 0101 	bic.w	r1, r3, r1
 80054c6:	6311      	str	r1, [r2, #48]	; 0x30
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80054c8:	2000      	movs	r0, #0
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
       break; 
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
       break; 
 80054ca:	4770      	bx	lr
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
 80054cc:	4a0e      	ldr	r2, [pc, #56]	; (8005508 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 80054ce:	6b93      	ldr	r3, [r2, #56]	; 0x38
 80054d0:	ea23 0101 	bic.w	r1, r3, r1
 80054d4:	6391      	str	r1, [r2, #56]	; 0x38
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80054d6:	2000      	movs	r0, #0
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
       break; 
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
       break;
 80054d8:	4770      	bx	lr
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
 80054da:	4a0b      	ldr	r2, [pc, #44]	; (8005508 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 80054dc:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80054de:	ea23 0101 	bic.w	r1, r3, r1
 80054e2:	6411      	str	r1, [r2, #64]	; 0x40
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80054e4:	2000      	movs	r0, #0
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
       break;
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
       break;
 80054e6:	4770      	bx	lr
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PUCRF, GPIONumber);
 80054e8:	4a07      	ldr	r2, [pc, #28]	; (8005508 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 80054ea:	6c93      	ldr	r3, [r2, #72]	; 0x48
 80054ec:	ea23 0101 	bic.w	r1, r3, r1
 80054f0:	6491      	str	r1, [r2, #72]	; 0x48
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80054f2:	2000      	movs	r0, #0
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
       break;
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PUCRF, GPIONumber);
       break;
 80054f4:	4770      	bx	lr
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
 80054f6:	4a04      	ldr	r2, [pc, #16]	; (8005508 <HAL_PWREx_DisableGPIOPullUp+0x8c>)
 80054f8:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80054fa:	ea23 0101 	bic.w	r1, r3, r1
 80054fe:	6511      	str	r1, [r2, #80]	; 0x50
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005500:	2000      	movs	r0, #0
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PUCRF, GPIONumber);
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, GPIONumber);
       break;
 8005502:	4770      	bx	lr
    case PWR_GPIO_H:
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
    default:
        return HAL_ERROR;
 8005504:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 8005506:	4770      	bx	lr
 8005508:	40007000 	.word	0x40007000

0800550c <HAL_PWREx_EnableGPIOPullDown>:
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
{
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
 800550c:	2807      	cmp	r0, #7
 800550e:	d85d      	bhi.n	80055cc <HAL_PWREx_EnableGPIOPullDown+0xc0>
 8005510:	e8df f000 	tbb	[pc, r0]
 8005514:	342a1e10 	.word	0x342a1e10
 8005518:	0452483e 	.word	0x0452483e
    case PWR_GPIO_G:
       SET_BIT(PWR->PDCRG, GPIONumber);
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 800551c:	4b2c      	ldr	r3, [pc, #176]	; (80055d0 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 800551e:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8005520:	f001 0103 	and.w	r1, r1, #3
 8005524:	430a      	orrs	r2, r1
 8005526:	65da      	str	r2, [r3, #92]	; 0x5c
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));          
 8005528:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800552a:	ea22 0101 	bic.w	r1, r2, r1
 800552e:	6599      	str	r1, [r3, #88]	; 0x58
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005530:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
       break;
    case PWR_GPIO_H:
       SET_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));          
       break;                                                   
 8005532:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
  
  switch (GPIO)
  { 
    case PWR_GPIO_A:
       SET_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));        
 8005534:	4b26      	ldr	r3, [pc, #152]	; (80055d0 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8005536:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005538:	f421 4020 	bic.w	r0, r1, #40960	; 0xa000
 800553c:	4302      	orrs	r2, r0
 800553e:	625a      	str	r2, [r3, #36]	; 0x24
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));           
 8005540:	6a1a      	ldr	r2, [r3, #32]
 8005542:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8005546:	ea22 0101 	bic.w	r1, r2, r1
 800554a:	6219      	str	r1, [r3, #32]
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 800554c:	2000      	movs	r0, #0
  switch (GPIO)
  { 
    case PWR_GPIO_A:
       SET_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));        
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));           
       break;
 800554e:	4770      	bx	lr
    case PWR_GPIO_B:
       SET_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
 8005550:	4b1f      	ldr	r3, [pc, #124]	; (80055d0 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8005552:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005554:	f021 0010 	bic.w	r0, r1, #16
 8005558:	4302      	orrs	r2, r0
 800555a:	62da      	str	r2, [r3, #44]	; 0x2c
       CLEAR_BIT(PWR->PUCRB, GPIONumber);                    
 800555c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800555e:	ea22 0101 	bic.w	r1, r2, r1
 8005562:	6299      	str	r1, [r3, #40]	; 0x28
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005564:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));           
       break;
    case PWR_GPIO_B:
       SET_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
       CLEAR_BIT(PWR->PUCRB, GPIONumber);                    
       break; 
 8005566:	4770      	bx	lr
    case PWR_GPIO_C:
       SET_BIT(PWR->PDCRC, GPIONumber);
 8005568:	4b19      	ldr	r3, [pc, #100]	; (80055d0 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 800556a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800556c:	430a      	orrs	r2, r1
 800556e:	635a      	str	r2, [r3, #52]	; 0x34
       CLEAR_BIT(PWR->PUCRC, GPIONumber);        
 8005570:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005572:	ea22 0101 	bic.w	r1, r2, r1
 8005576:	6319      	str	r1, [r3, #48]	; 0x30
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005578:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRB, GPIONumber);                    
       break; 
    case PWR_GPIO_C:
       SET_BIT(PWR->PDCRC, GPIONumber);
       CLEAR_BIT(PWR->PUCRC, GPIONumber);        
       break; 
 800557a:	4770      	bx	lr
    case PWR_GPIO_D:
       SET_BIT(PWR->PDCRD, GPIONumber);
 800557c:	4b14      	ldr	r3, [pc, #80]	; (80055d0 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 800557e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8005580:	430a      	orrs	r2, r1
 8005582:	63da      	str	r2, [r3, #60]	; 0x3c
       CLEAR_BIT(PWR->PUCRD, GPIONumber);        
 8005584:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005586:	ea22 0101 	bic.w	r1, r2, r1
 800558a:	6399      	str	r1, [r3, #56]	; 0x38
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 800558c:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRC, GPIONumber);        
       break; 
    case PWR_GPIO_D:
       SET_BIT(PWR->PDCRD, GPIONumber);
       CLEAR_BIT(PWR->PUCRD, GPIONumber);        
       break;
 800558e:	4770      	bx	lr
    case PWR_GPIO_E:
       SET_BIT(PWR->PDCRE, GPIONumber);
 8005590:	4b0f      	ldr	r3, [pc, #60]	; (80055d0 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 8005592:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005594:	430a      	orrs	r2, r1
 8005596:	645a      	str	r2, [r3, #68]	; 0x44
       CLEAR_BIT(PWR->PUCRE, GPIONumber);        
 8005598:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800559a:	ea22 0101 	bic.w	r1, r2, r1
 800559e:	6419      	str	r1, [r3, #64]	; 0x40
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80055a0:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRD, GPIONumber);        
       break;
    case PWR_GPIO_E:
       SET_BIT(PWR->PDCRE, GPIONumber);
       CLEAR_BIT(PWR->PUCRE, GPIONumber);        
       break;
 80055a2:	4770      	bx	lr
    case PWR_GPIO_F:
       SET_BIT(PWR->PDCRF, GPIONumber);
 80055a4:	4b0a      	ldr	r3, [pc, #40]	; (80055d0 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 80055a6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80055a8:	430a      	orrs	r2, r1
 80055aa:	64da      	str	r2, [r3, #76]	; 0x4c
       CLEAR_BIT(PWR->PUCRF, GPIONumber);        
 80055ac:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80055ae:	ea22 0101 	bic.w	r1, r2, r1
 80055b2:	6499      	str	r1, [r3, #72]	; 0x48
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80055b4:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRE, GPIONumber);        
       break;
    case PWR_GPIO_F:
       SET_BIT(PWR->PDCRF, GPIONumber);
       CLEAR_BIT(PWR->PUCRF, GPIONumber);        
       break;
 80055b6:	4770      	bx	lr
    case PWR_GPIO_G:
       SET_BIT(PWR->PDCRG, GPIONumber);
 80055b8:	4b05      	ldr	r3, [pc, #20]	; (80055d0 <HAL_PWREx_EnableGPIOPullDown+0xc4>)
 80055ba:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80055bc:	430a      	orrs	r2, r1
 80055be:	655a      	str	r2, [r3, #84]	; 0x54
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
 80055c0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80055c2:	ea22 0101 	bic.w	r1, r2, r1
 80055c6:	6519      	str	r1, [r3, #80]	; 0x50
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80055c8:	2000      	movs	r0, #0
       CLEAR_BIT(PWR->PUCRF, GPIONumber);        
       break;
    case PWR_GPIO_G:
       SET_BIT(PWR->PDCRG, GPIONumber);
       CLEAR_BIT(PWR->PUCRG, GPIONumber);        
       break;
 80055ca:	4770      	bx	lr
    case PWR_GPIO_H:
       SET_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       CLEAR_BIT(PWR->PUCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));          
       break;                                                   
    default:
        return HAL_ERROR;
 80055cc:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 80055ce:	4770      	bx	lr
 80055d0:	40007000 	.word	0x40007000

080055d4 <HAL_PWREx_DisableGPIOPullDown>:
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
{
  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
   
  switch (GPIO)
 80055d4:	2807      	cmp	r0, #7
 80055d6:	d843      	bhi.n	8005660 <HAL_PWREx_DisableGPIOPullDown+0x8c>
 80055d8:	e8df f000 	tbb	[pc, r0]
 80055dc:	261f160d 	.word	0x261f160d
 80055e0:	043b342d 	.word	0x043b342d
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
      CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
 80055e4:	4a1f      	ldr	r2, [pc, #124]	; (8005664 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 80055e6:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
 80055e8:	f001 0103 	and.w	r1, r1, #3
 80055ec:	ea23 0101 	bic.w	r1, r3, r1
 80055f0:	65d1      	str	r1, [r2, #92]	; 0x5c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 80055f2:	2000      	movs	r0, #0
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
       break;
    case PWR_GPIO_H:
      CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
 80055f4:	4770      	bx	lr
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));
   
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                        
 80055f6:	4a1b      	ldr	r2, [pc, #108]	; (8005664 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 80055f8:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80055fa:	f421 4120 	bic.w	r1, r1, #40960	; 0xa000
 80055fe:	ea23 0101 	bic.w	r1, r3, r1
 8005602:	6251      	str	r1, [r2, #36]	; 0x24
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005604:	2000      	movs	r0, #0
   
  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                        
       break;
 8005606:	4770      	bx	lr
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));           
 8005608:	4a16      	ldr	r2, [pc, #88]	; (8005664 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 800560a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800560c:	f021 0110 	bic.w	r1, r1, #16
 8005610:	ea23 0101 	bic.w	r1, r3, r1
 8005614:	62d1      	str	r1, [r2, #44]	; 0x2c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005616:	2000      	movs	r0, #0
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));                        
       break;
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));           
       break; 
 8005618:	4770      	bx	lr
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
 800561a:	4a12      	ldr	r2, [pc, #72]	; (8005664 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 800561c:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800561e:	ea23 0101 	bic.w	r1, r3, r1
 8005622:	6351      	str	r1, [r2, #52]	; 0x34
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005624:	2000      	movs	r0, #0
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));           
       break; 
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
       break; 
 8005626:	4770      	bx	lr
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
 8005628:	4a0e      	ldr	r2, [pc, #56]	; (8005664 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 800562a:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800562c:	ea23 0101 	bic.w	r1, r3, r1
 8005630:	63d1      	str	r1, [r2, #60]	; 0x3c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005632:	2000      	movs	r0, #0
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
       break; 
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
       break;
 8005634:	4770      	bx	lr
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
 8005636:	4a0b      	ldr	r2, [pc, #44]	; (8005664 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8005638:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800563a:	ea23 0101 	bic.w	r1, r3, r1
 800563e:	6451      	str	r1, [r2, #68]	; 0x44
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 8005640:	2000      	movs	r0, #0
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
       break;
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
       break;
 8005642:	4770      	bx	lr
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PDCRF, GPIONumber);
 8005644:	4a07      	ldr	r2, [pc, #28]	; (8005664 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8005646:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8005648:	ea23 0101 	bic.w	r1, r3, r1
 800564c:	64d1      	str	r1, [r2, #76]	; 0x4c
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 800564e:	2000      	movs	r0, #0
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
       break;
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PDCRF, GPIONumber);
       break;
 8005650:	4770      	bx	lr
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
 8005652:	4a04      	ldr	r2, [pc, #16]	; (8005664 <HAL_PWREx_DisableGPIOPullDown+0x90>)
 8005654:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8005656:	ea23 0101 	bic.w	r1, r3, r1
 800565a:	6551      	str	r1, [r2, #84]	; 0x54
       break;                                                   
    default:
        return HAL_ERROR;
  }
       
  return HAL_OK;
 800565c:	2000      	movs	r0, #0
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PDCRF, GPIONumber);
       break;
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, GPIONumber);
       break;
 800565e:	4770      	bx	lr
    case PWR_GPIO_H:
      CLEAR_BIT(PWR->PDCRH, (GPIONumber & PWR_PORTH_AVAILABLE_PINS));
       break;                                                   
    default:
        return HAL_ERROR;
 8005660:	2001      	movs	r0, #1
  }
       
  return HAL_OK;
}
 8005662:	4770      	bx	lr
 8005664:	40007000 	.word	0x40007000

08005668 <HAL_PWREx_EnablePullUpPullDownConfig>:
  *        is no conflict when setting PUy or PDy bit.         
  * @retval None
  */
void HAL_PWREx_EnablePullUpPullDownConfig(void)
{
  SET_BIT(PWR->CR3, PWR_CR3_APC);
 8005668:	4a02      	ldr	r2, [pc, #8]	; (8005674 <HAL_PWREx_EnablePullUpPullDownConfig+0xc>)
 800566a:	6893      	ldr	r3, [r2, #8]
 800566c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8005670:	6093      	str	r3, [r2, #8]
 8005672:	4770      	bx	lr
 8005674:	40007000 	.word	0x40007000

08005678 <HAL_PWREx_DisablePullUpPullDownConfig>:
  *        PWR_PUCRx and PWR_PDCRx registers are not applied in Standby and Shutdown modes.     
  * @retval None
  */
void HAL_PWREx_DisablePullUpPullDownConfig(void)
{
  CLEAR_BIT(PWR->CR3, PWR_CR3_APC);
 8005678:	4a02      	ldr	r2, [pc, #8]	; (8005684 <HAL_PWREx_DisablePullUpPullDownConfig+0xc>)
 800567a:	6893      	ldr	r3, [r2, #8]
 800567c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8005680:	6093      	str	r3, [r2, #8]
 8005682:	4770      	bx	lr
 8005684:	40007000 	.word	0x40007000

08005688 <HAL_PWREx_EnableSRAM2ContentRetention>:
  *         Standby mode and its content is kept.    
  * @retval None
  */
void HAL_PWREx_EnableSRAM2ContentRetention(void)
{
  SET_BIT(PWR->CR3, PWR_CR3_RRS);
 8005688:	4a02      	ldr	r2, [pc, #8]	; (8005694 <HAL_PWREx_EnableSRAM2ContentRetention+0xc>)
 800568a:	6893      	ldr	r3, [r2, #8]
 800568c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005690:	6093      	str	r3, [r2, #8]
 8005692:	4770      	bx	lr
 8005694:	40007000 	.word	0x40007000

08005698 <HAL_PWREx_DisableSRAM2ContentRetention>:
  *        and its content is lost.      
  * @retval None
  */
void HAL_PWREx_DisableSRAM2ContentRetention(void)
{
  CLEAR_BIT(PWR->CR3, PWR_CR3_RRS);
 8005698:	4a02      	ldr	r2, [pc, #8]	; (80056a4 <HAL_PWREx_DisableSRAM2ContentRetention+0xc>)
 800569a:	6893      	ldr	r3, [r2, #8]
 800569c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80056a0:	6093      	str	r3, [r2, #8]
 80056a2:	4770      	bx	lr
 80056a4:	40007000 	.word	0x40007000

080056a8 <HAL_PWREx_EnablePVM1>:
  * @brief Enable the Power Voltage Monitoring 1: VDDUSB versus 1.2V.
  * @retval None
  */
void HAL_PWREx_EnablePVM1(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_1);    
 80056a8:	4a02      	ldr	r2, [pc, #8]	; (80056b4 <HAL_PWREx_EnablePVM1+0xc>)
 80056aa:	6853      	ldr	r3, [r2, #4]
 80056ac:	f043 0310 	orr.w	r3, r3, #16
 80056b0:	6053      	str	r3, [r2, #4]
 80056b2:	4770      	bx	lr
 80056b4:	40007000 	.word	0x40007000

080056b8 <HAL_PWREx_DisablePVM1>:
  * @brief Disable the Power Voltage Monitoring 1: VDDUSB versus 1.2V.
  * @retval None
  */
void HAL_PWREx_DisablePVM1(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_1);    
 80056b8:	4a02      	ldr	r2, [pc, #8]	; (80056c4 <HAL_PWREx_DisablePVM1+0xc>)
 80056ba:	6853      	ldr	r3, [r2, #4]
 80056bc:	f023 0310 	bic.w	r3, r3, #16
 80056c0:	6053      	str	r3, [r2, #4]
 80056c2:	4770      	bx	lr
 80056c4:	40007000 	.word	0x40007000

080056c8 <HAL_PWREx_EnablePVM2>:
  * @brief Enable the Power Voltage Monitoring 2: VDDIO2 versus 0.9V.
  * @retval None
  */
void HAL_PWREx_EnablePVM2(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_2);    
 80056c8:	4a02      	ldr	r2, [pc, #8]	; (80056d4 <HAL_PWREx_EnablePVM2+0xc>)
 80056ca:	6853      	ldr	r3, [r2, #4]
 80056cc:	f043 0320 	orr.w	r3, r3, #32
 80056d0:	6053      	str	r3, [r2, #4]
 80056d2:	4770      	bx	lr
 80056d4:	40007000 	.word	0x40007000

080056d8 <HAL_PWREx_DisablePVM2>:
  * @brief Disable the Power Voltage Monitoring 2: VDDIO2 versus 0.9V.
  * @retval None
  */
void HAL_PWREx_DisablePVM2(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_2);    
 80056d8:	4a02      	ldr	r2, [pc, #8]	; (80056e4 <HAL_PWREx_DisablePVM2+0xc>)
 80056da:	6853      	ldr	r3, [r2, #4]
 80056dc:	f023 0320 	bic.w	r3, r3, #32
 80056e0:	6053      	str	r3, [r2, #4]
 80056e2:	4770      	bx	lr
 80056e4:	40007000 	.word	0x40007000

080056e8 <HAL_PWREx_EnablePVM3>:
  * @brief Enable the Power Voltage Monitoring 3: VDDA versus 1.62V.
  * @retval None
  */
void HAL_PWREx_EnablePVM3(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_3);    
 80056e8:	4a02      	ldr	r2, [pc, #8]	; (80056f4 <HAL_PWREx_EnablePVM3+0xc>)
 80056ea:	6853      	ldr	r3, [r2, #4]
 80056ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80056f0:	6053      	str	r3, [r2, #4]
 80056f2:	4770      	bx	lr
 80056f4:	40007000 	.word	0x40007000

080056f8 <HAL_PWREx_DisablePVM3>:
  * @brief Disable the Power Voltage Monitoring 3: VDDA versus 1.62V.
  * @retval None
  */
void HAL_PWREx_DisablePVM3(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_3);    
 80056f8:	4a02      	ldr	r2, [pc, #8]	; (8005704 <HAL_PWREx_DisablePVM3+0xc>)
 80056fa:	6853      	ldr	r3, [r2, #4]
 80056fc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005700:	6053      	str	r3, [r2, #4]
 8005702:	4770      	bx	lr
 8005704:	40007000 	.word	0x40007000

08005708 <HAL_PWREx_EnablePVM4>:
  * @brief Enable the Power Voltage Monitoring 4:  VDDA versus 2.2V.
  * @retval None
  */
void HAL_PWREx_EnablePVM4(void)
{
  SET_BIT(PWR->CR2, PWR_PVM_4);    
 8005708:	4a02      	ldr	r2, [pc, #8]	; (8005714 <HAL_PWREx_EnablePVM4+0xc>)
 800570a:	6853      	ldr	r3, [r2, #4]
 800570c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005710:	6053      	str	r3, [r2, #4]
 8005712:	4770      	bx	lr
 8005714:	40007000 	.word	0x40007000

08005718 <HAL_PWREx_DisablePVM4>:
  * @brief Disable the Power Voltage Monitoring 4:  VDDA versus 2.2V.
  * @retval None
  */
void HAL_PWREx_DisablePVM4(void)
{
  CLEAR_BIT(PWR->CR2, PWR_PVM_4);    
 8005718:	4a02      	ldr	r2, [pc, #8]	; (8005724 <HAL_PWREx_DisablePVM4+0xc>)
 800571a:	6853      	ldr	r3, [r2, #4]
 800571c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005720:	6053      	str	r3, [r2, #4]
 8005722:	4770      	bx	lr
 8005724:	40007000 	.word	0x40007000

08005728 <HAL_PWREx_ConfigPVM>:


  /* Configure EXTI 35 to 38 interrupts if so required:
     scan thru PVMType to detect which PVMx is set and
     configure the corresponding EXTI line accordingly. */
  switch (sConfigPVM->PVMType)
 8005728:	6803      	ldr	r3, [r0, #0]
 800572a:	2b20      	cmp	r3, #32
 800572c:	f000 80a0 	beq.w	8005870 <HAL_PWREx_ConfigPVM+0x148>
 8005730:	d968      	bls.n	8005804 <HAL_PWREx_ConfigPVM+0xdc>
 8005732:	2b40      	cmp	r3, #64	; 0x40
 8005734:	d034      	beq.n	80057a0 <HAL_PWREx_ConfigPVM+0x78>
 8005736:	2b80      	cmp	r3, #128	; 0x80
 8005738:	f040 8098 	bne.w	800586c <HAL_PWREx_ConfigPVM+0x144>
      }
      break;
      
    case PWR_PVM_4:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM4_EXTI_DISABLE_EVENT();
 800573c:	4b65      	ldr	r3, [pc, #404]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 800573e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005740:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005744:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM4_EXTI_DISABLE_IT();
 8005746:	6a1a      	ldr	r2, [r3, #32]
 8005748:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800574c:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM4_EXTI_DISABLE_FALLING_EDGE(); 
 800574e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005750:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005754:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM4_EXTI_DISABLE_RISING_EDGE();
 8005756:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005758:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800575c:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 800575e:	6842      	ldr	r2, [r0, #4]
 8005760:	03d1      	lsls	r1, r2, #15
 8005762:	d504      	bpl.n	800576e <HAL_PWREx_ConfigPVM+0x46>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_IT();
 8005764:	6a1a      	ldr	r2, [r3, #32]
 8005766:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800576a:	621a      	str	r2, [r3, #32]
 800576c:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 800576e:	0393      	lsls	r3, r2, #14
 8005770:	d505      	bpl.n	800577e <HAL_PWREx_ConfigPVM+0x56>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_EVENT();
 8005772:	4a58      	ldr	r2, [pc, #352]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 8005774:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8005776:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800577a:	6253      	str	r3, [r2, #36]	; 0x24
 800577c:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 800577e:	07d1      	lsls	r1, r2, #31
 8005780:	d505      	bpl.n	800578e <HAL_PWREx_ConfigPVM+0x66>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_RISING_EDGE();
 8005782:	4a54      	ldr	r2, [pc, #336]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 8005784:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8005786:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800578a:	6293      	str	r3, [r2, #40]	; 0x28
 800578c:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 800578e:	0793      	lsls	r3, r2, #30
 8005790:	d56a      	bpl.n	8005868 <HAL_PWREx_ConfigPVM+0x140>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_FALLING_EDGE();
 8005792:	4a50      	ldr	r2, [pc, #320]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 8005794:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8005796:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800579a:	62d3      	str	r3, [r2, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 800579c:	2000      	movs	r0, #0
 800579e:	4770      	bx	lr
      }
      break;
      
    case PWR_PVM_3:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM3_EXTI_DISABLE_EVENT();
 80057a0:	4b4c      	ldr	r3, [pc, #304]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 80057a2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80057a4:	f022 0220 	bic.w	r2, r2, #32
 80057a8:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM3_EXTI_DISABLE_IT();
 80057aa:	6a1a      	ldr	r2, [r3, #32]
 80057ac:	f022 0220 	bic.w	r2, r2, #32
 80057b0:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM3_EXTI_DISABLE_FALLING_EDGE(); 
 80057b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80057b4:	f022 0220 	bic.w	r2, r2, #32
 80057b8:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM3_EXTI_DISABLE_RISING_EDGE();
 80057ba:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80057bc:	f022 0220 	bic.w	r2, r2, #32
 80057c0:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 80057c2:	6842      	ldr	r2, [r0, #4]
 80057c4:	03d1      	lsls	r1, r2, #15
 80057c6:	d504      	bpl.n	80057d2 <HAL_PWREx_ConfigPVM+0xaa>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_IT();
 80057c8:	6a1a      	ldr	r2, [r3, #32]
 80057ca:	f042 0220 	orr.w	r2, r2, #32
 80057ce:	621a      	str	r2, [r3, #32]
 80057d0:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 80057d2:	0391      	lsls	r1, r2, #14
 80057d4:	d505      	bpl.n	80057e2 <HAL_PWREx_ConfigPVM+0xba>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_EVENT();
 80057d6:	4a3f      	ldr	r2, [pc, #252]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 80057d8:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80057da:	f043 0320 	orr.w	r3, r3, #32
 80057de:	6253      	str	r3, [r2, #36]	; 0x24
 80057e0:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 80057e2:	07d3      	lsls	r3, r2, #31
 80057e4:	d505      	bpl.n	80057f2 <HAL_PWREx_ConfigPVM+0xca>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_RISING_EDGE();
 80057e6:	4a3b      	ldr	r2, [pc, #236]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 80057e8:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80057ea:	f043 0320 	orr.w	r3, r3, #32
 80057ee:	6293      	str	r3, [r2, #40]	; 0x28
 80057f0:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 80057f2:	0790      	lsls	r0, r2, #30
 80057f4:	d538      	bpl.n	8005868 <HAL_PWREx_ConfigPVM+0x140>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_FALLING_EDGE();
 80057f6:	4a37      	ldr	r2, [pc, #220]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 80057f8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80057fa:	f043 0320 	orr.w	r3, r3, #32
 80057fe:	62d3      	str	r3, [r2, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 8005800:	2000      	movs	r0, #0
 8005802:	4770      	bx	lr


  /* Configure EXTI 35 to 38 interrupts if so required:
     scan thru PVMType to detect which PVMx is set and
     configure the corresponding EXTI line accordingly. */
  switch (sConfigPVM->PVMType)
 8005804:	2b10      	cmp	r3, #16
 8005806:	d131      	bne.n	800586c <HAL_PWREx_ConfigPVM+0x144>
  {
#if defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx)
    case PWR_PVM_1:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM1_EXTI_DISABLE_EVENT();
 8005808:	4b32      	ldr	r3, [pc, #200]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 800580a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800580c:	f022 0208 	bic.w	r2, r2, #8
 8005810:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM1_EXTI_DISABLE_IT();
 8005812:	6a1a      	ldr	r2, [r3, #32]
 8005814:	f022 0208 	bic.w	r2, r2, #8
 8005818:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM1_EXTI_DISABLE_FALLING_EDGE(); 
 800581a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800581c:	f022 0208 	bic.w	r2, r2, #8
 8005820:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM1_EXTI_DISABLE_RISING_EDGE();
 8005822:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005824:	f022 0208 	bic.w	r2, r2, #8
 8005828:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 800582a:	6842      	ldr	r2, [r0, #4]
 800582c:	03d1      	lsls	r1, r2, #15
 800582e:	d504      	bpl.n	800583a <HAL_PWREx_ConfigPVM+0x112>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_IT();
 8005830:	6a1a      	ldr	r2, [r3, #32]
 8005832:	f042 0208 	orr.w	r2, r2, #8
 8005836:	621a      	str	r2, [r3, #32]
 8005838:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 800583a:	0391      	lsls	r1, r2, #14
 800583c:	d505      	bpl.n	800584a <HAL_PWREx_ConfigPVM+0x122>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_EVENT();
 800583e:	4a25      	ldr	r2, [pc, #148]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 8005840:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8005842:	f043 0308 	orr.w	r3, r3, #8
 8005846:	6253      	str	r3, [r2, #36]	; 0x24
 8005848:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 800584a:	07d3      	lsls	r3, r2, #31
 800584c:	d505      	bpl.n	800585a <HAL_PWREx_ConfigPVM+0x132>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_RISING_EDGE();
 800584e:	4a21      	ldr	r2, [pc, #132]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 8005850:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8005852:	f043 0308 	orr.w	r3, r3, #8
 8005856:	6293      	str	r3, [r2, #40]	; 0x28
 8005858:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 800585a:	0790      	lsls	r0, r2, #30
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_FALLING_EDGE();
 800585c:	bf41      	itttt	mi
 800585e:	4a1d      	ldrmi	r2, [pc, #116]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 8005860:	6ad3      	ldrmi	r3, [r2, #44]	; 0x2c
 8005862:	f043 0308 	orrmi.w	r3, r3, #8
 8005866:	62d3      	strmi	r3, [r2, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 8005868:	2000      	movs	r0, #0
 800586a:	4770      	bx	lr
        __HAL_PWR_PVM4_EXTI_ENABLE_FALLING_EDGE();
      }
      break;  
      
    default:
      return HAL_ERROR;                      
 800586c:	2001      	movs	r0, #1
    
  }   

  
  return HAL_OK;
}
 800586e:	4770      	bx	lr
      break; 
#endif /* defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) */        
    
    case PWR_PVM_2:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM2_EXTI_DISABLE_EVENT();
 8005870:	4b18      	ldr	r3, [pc, #96]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 8005872:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005874:	f022 0210 	bic.w	r2, r2, #16
 8005878:	625a      	str	r2, [r3, #36]	; 0x24
      __HAL_PWR_PVM2_EXTI_DISABLE_IT();
 800587a:	6a1a      	ldr	r2, [r3, #32]
 800587c:	f022 0210 	bic.w	r2, r2, #16
 8005880:	621a      	str	r2, [r3, #32]
      __HAL_PWR_PVM2_EXTI_DISABLE_FALLING_EDGE(); 
 8005882:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005884:	f022 0210 	bic.w	r2, r2, #16
 8005888:	62da      	str	r2, [r3, #44]	; 0x2c
      __HAL_PWR_PVM2_EXTI_DISABLE_RISING_EDGE();
 800588a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800588c:	f022 0210 	bic.w	r2, r2, #16
 8005890:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
 8005892:	6842      	ldr	r2, [r0, #4]
 8005894:	03d1      	lsls	r1, r2, #15
 8005896:	d504      	bpl.n	80058a2 <HAL_PWREx_ConfigPVM+0x17a>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_IT();
 8005898:	6a1a      	ldr	r2, [r3, #32]
 800589a:	f042 0210 	orr.w	r2, r2, #16
 800589e:	621a      	str	r2, [r3, #32]
 80058a0:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
 80058a2:	0391      	lsls	r1, r2, #14
 80058a4:	d505      	bpl.n	80058b2 <HAL_PWREx_ConfigPVM+0x18a>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_EVENT();
 80058a6:	4a0b      	ldr	r2, [pc, #44]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 80058a8:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80058aa:	f043 0310 	orr.w	r3, r3, #16
 80058ae:	6253      	str	r3, [r2, #36]	; 0x24
 80058b0:	6842      	ldr	r2, [r0, #4]
      }
  
      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
 80058b2:	07d3      	lsls	r3, r2, #31
 80058b4:	d505      	bpl.n	80058c2 <HAL_PWREx_ConfigPVM+0x19a>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_RISING_EDGE();
 80058b6:	4a07      	ldr	r2, [pc, #28]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 80058b8:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80058ba:	f043 0310 	orr.w	r3, r3, #16
 80058be:	6293      	str	r3, [r2, #40]	; 0x28
 80058c0:	6842      	ldr	r2, [r0, #4]
      }
  
      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
 80058c2:	0790      	lsls	r0, r2, #30
 80058c4:	d5d0      	bpl.n	8005868 <HAL_PWREx_ConfigPVM+0x140>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_FALLING_EDGE();
 80058c6:	4a03      	ldr	r2, [pc, #12]	; (80058d4 <HAL_PWREx_ConfigPVM+0x1ac>)
 80058c8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80058ca:	f043 0310 	orr.w	r3, r3, #16
 80058ce:	62d3      	str	r3, [r2, #44]	; 0x2c
      return HAL_ERROR;                      
    
  }   

  
  return HAL_OK;
 80058d0:	2000      	movs	r0, #0
 80058d2:	4770      	bx	lr
 80058d4:	40010400 	.word	0x40010400

080058d8 <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR); 
 80058d8:	4a02      	ldr	r2, [pc, #8]	; (80058e4 <HAL_PWREx_EnableLowPowerRunMode+0xc>)
 80058da:	6813      	ldr	r3, [r2, #0]
 80058dc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80058e0:	6013      	str	r3, [r2, #0]
 80058e2:	4770      	bx	lr
 80058e4:	40007000 	.word	0x40007000

080058e8 <HAL_PWREx_DisableLowPowerRunMode>:
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index = 0;
  
  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR); 
 80058e8:	490e      	ldr	r1, [pc, #56]	; (8005924 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)

  /* Wait until REGLPF is reset */
  wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 80058ea:	4b0f      	ldr	r3, [pc, #60]	; (8005928 <HAL_PWREx_DisableLowPowerRunMode+0x40>)
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index = 0;
  
  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR); 
 80058ec:	6808      	ldr	r0, [r1, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 80058ee:	4a0f      	ldr	r2, [pc, #60]	; (800592c <HAL_PWREx_DisableLowPowerRunMode+0x44>)
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index = 0;
  
  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR); 
 80058f0:	f420 4080 	bic.w	r0, r0, #16384	; 0x4000
 80058f4:	6008      	str	r0, [r1, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 80058f6:	681b      	ldr	r3, [r3, #0]
 80058f8:	fba2 2303 	umull	r2, r3, r2, r3
 80058fc:	0c9a      	lsrs	r2, r3, #18
 80058fe:	2332      	movs	r3, #50	; 0x32
 8005900:	fb03 f302 	mul.w	r3, r3, r2
  while ((wait_loop_index != 0) && (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)))
 8005904:	b913      	cbnz	r3, 800590c <HAL_PWREx_DisableLowPowerRunMode+0x24>
 8005906:	e004      	b.n	8005912 <HAL_PWREx_DisableLowPowerRunMode+0x2a>
 8005908:	3b01      	subs	r3, #1
 800590a:	d002      	beq.n	8005912 <HAL_PWREx_DisableLowPowerRunMode+0x2a>
 800590c:	694a      	ldr	r2, [r1, #20]
 800590e:	0592      	lsls	r2, r2, #22
 8005910:	d4fa      	bmi.n	8005908 <HAL_PWREx_DisableLowPowerRunMode+0x20>
  {
    wait_loop_index--;
  }
  if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 8005912:	4b04      	ldr	r3, [pc, #16]	; (8005924 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 8005914:	695b      	ldr	r3, [r3, #20]
  {
    return HAL_TIMEOUT;
  }
  
  return HAL_OK;
 8005916:	f413 7f00 	tst.w	r3, #512	; 0x200
}
 800591a:	bf14      	ite	ne
 800591c:	2003      	movne	r0, #3
 800591e:	2000      	moveq	r0, #0
 8005920:	4770      	bx	lr
 8005922:	bf00      	nop
 8005924:	40007000 	.word	0x40007000
 8005928:	20000000 	.word	0x20000000
 800592c:	431bde83 	.word	0x431bde83

08005930 <HAL_PWREx_EnterSTOP1Mode>:
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* Stop 1 mode with Main Regulator */
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1MR);
 8005930:	4a0c      	ldr	r2, [pc, #48]	; (8005964 <HAL_PWREx_EnterSTOP1Mode+0x34>)
 8005932:	6813      	ldr	r3, [r2, #0]
 8005934:	f023 0307 	bic.w	r3, r3, #7
{
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    
  if (Regulator == PWR_MAINREGULATOR_ON)
 8005938:	b108      	cbz	r0, 800593e <HAL_PWREx_EnterSTOP1Mode+0xe>
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1MR);
  }
  else
  {
    /* Stop 1 mode with Low-Power Regulator */
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1LPR);
 800593a:	f043 0301 	orr.w	r3, r3, #1
 800593e:	6013      	str	r3, [r2, #0]
  }

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 8005940:	4a09      	ldr	r2, [pc, #36]	; (8005968 <HAL_PWREx_EnterSTOP1Mode+0x38>)
 8005942:	6913      	ldr	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 8005944:	2901      	cmp	r1, #1
    /* Stop 1 mode with Low-Power Regulator */
    MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1LPR);
  }

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 8005946:	f043 0304 	orr.w	r3, r3, #4
 800594a:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 800594c:	d008      	beq.n	8005960 <HAL_PWREx_EnterSTOP1Mode+0x30>

    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
{
  __ASM volatile ("sev");
 800594e:	bf40      	sev
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 8005950:	bf20      	wfe
 8005952:	bf20      	wfe
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 8005954:	4a04      	ldr	r2, [pc, #16]	; (8005968 <HAL_PWREx_EnterSTOP1Mode+0x38>)
 8005956:	6913      	ldr	r3, [r2, #16]
 8005958:	f023 0304 	bic.w	r3, r3, #4
 800595c:	6113      	str	r3, [r2, #16]
 800595e:	4770      	bx	lr
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8005960:	bf30      	wfi
 8005962:	e7f7      	b.n	8005954 <HAL_PWREx_EnterSTOP1Mode+0x24>
 8005964:	40007000 	.word	0x40007000
 8005968:	e000ed00 	.word	0xe000ed00

0800596c <HAL_PWREx_EnterSTOP2Mode>:
{
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);
 800596c:	490c      	ldr	r1, [pc, #48]	; (80059a0 <HAL_PWREx_EnterSTOP2Mode+0x34>)


  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 800596e:	4a0d      	ldr	r2, [pc, #52]	; (80059a4 <HAL_PWREx_EnterSTOP2Mode+0x38>)
{
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);
 8005970:	680b      	ldr	r3, [r1, #0]
 8005972:	f023 0307 	bic.w	r3, r3, #7
 8005976:	f043 0302 	orr.w	r3, r3, #2
 800597a:	600b      	str	r3, [r1, #0]


  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 800597c:	6913      	ldr	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 800597e:	2801      	cmp	r0, #1
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);


  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 8005980:	f043 0304 	orr.w	r3, r3, #4
 8005984:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 8005986:	d008      	beq.n	800599a <HAL_PWREx_EnterSTOP2Mode+0x2e>

    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
{
  __ASM volatile ("sev");
 8005988:	bf40      	sev
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 800598a:	bf20      	wfe
 800598c:	bf20      	wfe
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
 800598e:	4a05      	ldr	r2, [pc, #20]	; (80059a4 <HAL_PWREx_EnterSTOP2Mode+0x38>)
 8005990:	6913      	ldr	r3, [r2, #16]
 8005992:	f023 0304 	bic.w	r3, r3, #4
 8005996:	6113      	str	r3, [r2, #16]
 8005998:	4770      	bx	lr
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 800599a:	bf30      	wfi
 800599c:	e7f7      	b.n	800598e <HAL_PWREx_EnterSTOP2Mode+0x22>
 800599e:	bf00      	nop
 80059a0:	40007000 	.word	0x40007000
 80059a4:	e000ed00 	.word	0xe000ed00

080059a8 <HAL_PWREx_EnterSHUTDOWNMode>:
  */
void HAL_PWREx_EnterSHUTDOWNMode(void)
{
  
  /* Set Shutdown mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_SHUTDOWN);
 80059a8:	4906      	ldr	r1, [pc, #24]	; (80059c4 <HAL_PWREx_EnterSHUTDOWNMode+0x1c>)
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 80059aa:	4a07      	ldr	r2, [pc, #28]	; (80059c8 <HAL_PWREx_EnterSHUTDOWNMode+0x20>)
  */
void HAL_PWREx_EnterSHUTDOWNMode(void)
{
  
  /* Set Shutdown mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_SHUTDOWN);
 80059ac:	680b      	ldr	r3, [r1, #0]
 80059ae:	f023 0307 	bic.w	r3, r3, #7
 80059b2:	f043 0304 	orr.w	r3, r3, #4
 80059b6:	600b      	str	r3, [r1, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 80059b8:	6913      	ldr	r3, [r2, #16]
 80059ba:	f043 0304 	orr.w	r3, r3, #4
 80059be:	6113      	str	r3, [r2, #16]
 80059c0:	bf30      	wfi
 80059c2:	4770      	bx	lr
 80059c4:	40007000 	.word	0x40007000
 80059c8:	e000ed00 	.word	0xe000ed00

080059cc <HAL_PWREx_PVM1Callback>:
/**
  * @brief PWR PVM1 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM1Callback(void)
{
 80059cc:	4770      	bx	lr
 80059ce:	bf00      	nop

080059d0 <HAL_PWREx_PVM2Callback>:
/**
  * @brief PWR PVM2 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM2Callback(void)
{
 80059d0:	4770      	bx	lr
 80059d2:	bf00      	nop

080059d4 <HAL_PWREx_PVM3Callback>:
/**
  * @brief PWR PVM3 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM3Callback(void)
{
 80059d4:	4770      	bx	lr
 80059d6:	bf00      	nop

080059d8 <HAL_PWREx_PVM4Callback>:
/**
  * @brief PWR PVM4 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM4Callback(void)
{
 80059d8:	4770      	bx	lr
 80059da:	bf00      	nop

080059dc <HAL_PWREx_PVD_PVM_IRQHandler>:
  * @brief This function handles the PWR PVD/PVMx interrupt request.
  * @note This API should be called under the PVD_PVM_IRQHandler().  
  * @retval None
  */
void HAL_PWREx_PVD_PVM_IRQHandler(void)
{
 80059dc:	b510      	push	{r4, lr}
  /* Check PWR exti flag */
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 80059de:	4c17      	ldr	r4, [pc, #92]	; (8005a3c <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 80059e0:	6963      	ldr	r3, [r4, #20]
 80059e2:	03db      	lsls	r3, r3, #15
 80059e4:	d423      	bmi.n	8005a2e <HAL_PWREx_PVD_PVM_IRQHandler+0x52>
    /* Clear PVD exti pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
  }
  /* Next, successively check PVMx exti flags */
#if defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx)
  if(__HAL_PWR_PVM1_EXTI_GET_FLAG() != RESET) 
 80059e6:	4c15      	ldr	r4, [pc, #84]	; (8005a3c <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 80059e8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80059ea:	0718      	lsls	r0, r3, #28
 80059ec:	d41a      	bmi.n	8005a24 <HAL_PWREx_PVD_PVM_IRQHandler+0x48>
   
    /* Clear PVM1 exti pending bit */
    __HAL_PWR_PVM1_EXTI_CLEAR_FLAG();
  }
#endif /* defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) */
  if(__HAL_PWR_PVM2_EXTI_GET_FLAG() != RESET) 
 80059ee:	4c13      	ldr	r4, [pc, #76]	; (8005a3c <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 80059f0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80059f2:	06d9      	lsls	r1, r3, #27
 80059f4:	d411      	bmi.n	8005a1a <HAL_PWREx_PVD_PVM_IRQHandler+0x3e>
    HAL_PWREx_PVM2Callback();
   
    /* Clear PVM2 exti pending bit */
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
  }
  if(__HAL_PWR_PVM3_EXTI_GET_FLAG() != RESET) 
 80059f6:	4c11      	ldr	r4, [pc, #68]	; (8005a3c <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 80059f8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80059fa:	069a      	lsls	r2, r3, #26
 80059fc:	d408      	bmi.n	8005a10 <HAL_PWREx_PVD_PVM_IRQHandler+0x34>
    HAL_PWREx_PVM3Callback();
   
    /* Clear PVM3 exti pending bit */
    __HAL_PWR_PVM3_EXTI_CLEAR_FLAG();
  }
  if(__HAL_PWR_PVM4_EXTI_GET_FLAG() != RESET) 
 80059fe:	4c0f      	ldr	r4, [pc, #60]	; (8005a3c <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 8005a00:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005a02:	065b      	lsls	r3, r3, #25
 8005a04:	d503      	bpl.n	8005a0e <HAL_PWREx_PVD_PVM_IRQHandler+0x32>
  {
    /* PWR PVM4 interrupt user callback */
    HAL_PWREx_PVM4Callback();
 8005a06:	f7ff ffe7 	bl	80059d8 <HAL_PWREx_PVM4Callback>
   
    /* Clear PVM4 exti pending bit */
    __HAL_PWR_PVM4_EXTI_CLEAR_FLAG();
 8005a0a:	2340      	movs	r3, #64	; 0x40
 8005a0c:	6363      	str	r3, [r4, #52]	; 0x34
 8005a0e:	bd10      	pop	{r4, pc}
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
  }
  if(__HAL_PWR_PVM3_EXTI_GET_FLAG() != RESET) 
  {
    /* PWR PVM3 interrupt user callback */
    HAL_PWREx_PVM3Callback();
 8005a10:	f7ff ffe0 	bl	80059d4 <HAL_PWREx_PVM3Callback>
   
    /* Clear PVM3 exti pending bit */
    __HAL_PWR_PVM3_EXTI_CLEAR_FLAG();
 8005a14:	2320      	movs	r3, #32
 8005a16:	6363      	str	r3, [r4, #52]	; 0x34
 8005a18:	e7f1      	b.n	80059fe <HAL_PWREx_PVD_PVM_IRQHandler+0x22>
  }
#endif /* defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) */
  if(__HAL_PWR_PVM2_EXTI_GET_FLAG() != RESET) 
  {
    /* PWR PVM2 interrupt user callback */
    HAL_PWREx_PVM2Callback();
 8005a1a:	f7ff ffd9 	bl	80059d0 <HAL_PWREx_PVM2Callback>
   
    /* Clear PVM2 exti pending bit */
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
 8005a1e:	2310      	movs	r3, #16
 8005a20:	6363      	str	r3, [r4, #52]	; 0x34
 8005a22:	e7e8      	b.n	80059f6 <HAL_PWREx_PVD_PVM_IRQHandler+0x1a>
  /* Next, successively check PVMx exti flags */
#if defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx)
  if(__HAL_PWR_PVM1_EXTI_GET_FLAG() != RESET) 
  {
    /* PWR PVM1 interrupt user callback */
    HAL_PWREx_PVM1Callback();
 8005a24:	f7ff ffd2 	bl	80059cc <HAL_PWREx_PVM1Callback>
   
    /* Clear PVM1 exti pending bit */
    __HAL_PWR_PVM1_EXTI_CLEAR_FLAG();
 8005a28:	2308      	movs	r3, #8
 8005a2a:	6363      	str	r3, [r4, #52]	; 0x34
 8005a2c:	e7df      	b.n	80059ee <HAL_PWREx_PVD_PVM_IRQHandler+0x12>
{
  /* Check PWR exti flag */
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
  {
    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback();
 8005a2e:	f006 fbb7 	bl	800c1a0 <HAL_PWR_PVDCallback>

    /* Clear PVD exti pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 8005a32:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005a36:	6163      	str	r3, [r4, #20]
 8005a38:	e7d5      	b.n	80059e6 <HAL_PWREx_PVD_PVM_IRQHandler+0xa>
 8005a3a:	bf00      	nop
 8005a3c:	40010400 	.word	0x40010400

08005a40 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8005a40:	b530      	push	{r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8005a42:	4d20      	ldr	r5, [pc, #128]	; (8005ac4 <RCC_SetFlashLatencyFromMSIRange+0x84>)
 8005a44:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8005a46:	00db      	lsls	r3, r3, #3
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8005a48:	b083      	sub	sp, #12
 8005a4a:	4604      	mov	r4, r0
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8005a4c:	d51a      	bpl.n	8005a84 <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8005a4e:	f7ff fc23 	bl	8005298 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8005a52:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8005a56:	d027      	beq.n	8005aa8 <RCC_SetFlashLatencyFromMSIRange+0x68>
    }
    /* else MSI <= 16Mhz default FLASH_LATENCY_0 0WS */
  }
  else
  {
    if(msirange > RCC_MSIRANGE_8)
 8005a58:	2c80      	cmp	r4, #128	; 0x80
 8005a5a:	d82c      	bhi.n	8005ab6 <RCC_SetFlashLatencyFromMSIRange+0x76>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 8005a5c:	d02f      	beq.n	8005abe <RCC_SetFlashLatencyFromMSIRange+0x7e>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else if(msirange == RCC_MSIRANGE_7) 
 8005a5e:	f1a4 0270 	sub.w	r2, r4, #112	; 0x70
 8005a62:	fab2 f282 	clz	r2, r2
 8005a66:	0952      	lsrs	r2, r2, #5
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
  }
       
  __HAL_FLASH_SET_LATENCY(latency);
 8005a68:	4917      	ldr	r1, [pc, #92]	; (8005ac8 <RCC_SetFlashLatencyFromMSIRange+0x88>)
 8005a6a:	680b      	ldr	r3, [r1, #0]
 8005a6c:	f023 0307 	bic.w	r3, r3, #7
 8005a70:	4313      	orrs	r3, r2
 8005a72:	600b      	str	r3, [r1, #0]
  
  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 8005a74:	6808      	ldr	r0, [r1, #0]
 8005a76:	f000 0007 	and.w	r0, r0, #7
  {
    return HAL_ERROR;
  }
  
  return HAL_OK;
}
 8005a7a:	1a10      	subs	r0, r2, r0
 8005a7c:	bf18      	it	ne
 8005a7e:	2001      	movne	r0, #1
 8005a80:	b003      	add	sp, #12
 8005a82:	bd30      	pop	{r4, r5, pc}
  {
    vos = HAL_PWREx_GetVoltageRange();
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8005a84:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8005a86:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005a8a:	65ab      	str	r3, [r5, #88]	; 0x58
 8005a8c:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8005a8e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8005a92:	9301      	str	r3, [sp, #4]
 8005a94:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 8005a96:	f7ff fbff 	bl	8005298 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8005a9a:	6dab      	ldr	r3, [r5, #88]	; 0x58
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8005a9c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
 8005aa0:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8005aa4:	65ab      	str	r3, [r5, #88]	; 0x58
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8005aa6:	d1d7      	bne.n	8005a58 <RCC_SetFlashLatencyFromMSIRange+0x18>
  {
    if(msirange > RCC_MSIRANGE_8)
 8005aa8:	2c80      	cmp	r4, #128	; 0x80
 8005aaa:	d906      	bls.n	8005aba <RCC_SetFlashLatencyFromMSIRange+0x7a>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 8005aac:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 8005aae:	bf8c      	ite	hi
 8005ab0:	2202      	movhi	r2, #2
 8005ab2:	2201      	movls	r2, #1
 8005ab4:	e7d8      	b.n	8005a68 <RCC_SetFlashLatencyFromMSIRange+0x28>
  else
  {
    if(msirange > RCC_MSIRANGE_8)
    {
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
 8005ab6:	2203      	movs	r2, #3
 8005ab8:	e7d6      	b.n	8005a68 <RCC_SetFlashLatencyFromMSIRange+0x28>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8005aba:	2200      	movs	r2, #0
 8005abc:	e7d4      	b.n	8005a68 <RCC_SetFlashLatencyFromMSIRange+0x28>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 8005abe:	2202      	movs	r2, #2
 8005ac0:	e7d2      	b.n	8005a68 <RCC_SetFlashLatencyFromMSIRange+0x28>
 8005ac2:	bf00      	nop
 8005ac4:	40021000 	.word	0x40021000
 8005ac8:	40022000 	.word	0x40022000

08005acc <HAL_RCC_DeInit>:
  * @retval None
  */
void HAL_RCC_DeInit(void)
{
  /* Set MSION bit */
  SET_BIT(RCC->CR, RCC_CR_MSION);
 8005acc:	4a16      	ldr	r2, [pc, #88]	; (8005b28 <HAL_RCC_DeInit+0x5c>)
 8005ace:	6813      	ldr	r3, [r2, #0]
 8005ad0:	f043 0301 	orr.w	r3, r3, #1
 8005ad4:	6013      	str	r3, [r2, #0]

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET) { __NOP(); }
 8005ad6:	6813      	ldr	r3, [r2, #0]
 8005ad8:	0799      	lsls	r1, r3, #30
 8005ada:	d403      	bmi.n	8005ae4 <HAL_RCC_DeInit+0x18>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 8005adc:	bf00      	nop
 8005ade:	6813      	ldr	r3, [r2, #0]
 8005ae0:	079b      	lsls	r3, r3, #30
 8005ae2:	d5fb      	bpl.n	8005adc <HAL_RCC_DeInit+0x10>
  
  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 8005ae4:	4b10      	ldr	r3, [pc, #64]	; (8005b28 <HAL_RCC_DeInit+0x5c>)
  
  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
 8005ae6:	4811      	ldr	r0, [pc, #68]	; (8005b2c <HAL_RCC_DeInit+0x60>)

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET) { __NOP(); }
  
  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 8005ae8:	6819      	ldr	r1, [r3, #0]
 8005aea:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  
  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);
 8005aee:	2200      	movs	r2, #0

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET) { __NOP(); }
  
  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 8005af0:	f041 0160 	orr.w	r1, r1, #96	; 0x60
 8005af4:	6019      	str	r1, [r3, #0]
  
  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);
 8005af6:	609a      	str	r2, [r3, #8]

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
 8005af8:	6819      	ldr	r1, [r3, #0]
 8005afa:	4008      	ands	r0, r1
 8005afc:	6018      	str	r0, [r3, #0]

  /* Reset PLLCFGR register */
  CLEAR_REG(RCC->PLLCFGR);
 8005afe:	60da      	str	r2, [r3, #12]
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN_4 );
 8005b00:	68d9      	ldr	r1, [r3, #12]
 8005b02:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8005b06:	60d9      	str	r1, [r3, #12]

  /* Reset PLLSAI1CFGR register */
  CLEAR_REG(RCC->PLLSAI1CFGR);
 8005b08:	611a      	str	r2, [r3, #16]
  SET_BIT(RCC->PLLSAI1CFGR,  RCC_PLLSAI1CFGR_PLLSAI1N_4 );
 8005b0a:	6919      	ldr	r1, [r3, #16]
 8005b0c:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8005b10:	6119      	str	r1, [r3, #16]

  /* Reset PLLSAI2CFGR register */
  CLEAR_REG(RCC->PLLSAI2CFGR);
 8005b12:	615a      	str	r2, [r3, #20]
  SET_BIT(RCC->PLLSAI2CFGR,  RCC_PLLSAI2CFGR_PLLSAI2N_4 );
 8005b14:	6959      	ldr	r1, [r3, #20]
 8005b16:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8005b1a:	6159      	str	r1, [r3, #20]

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 8005b1c:	6819      	ldr	r1, [r3, #0]
 8005b1e:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8005b22:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
 8005b24:	619a      	str	r2, [r3, #24]
 8005b26:	4770      	bx	lr
 8005b28:	40021000 	.word	0x40021000
 8005b2c:	eaf6f4ff 	.word	0xeaf6f4ff

08005b30 <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8005b30:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8005b34:	6803      	ldr	r3, [r0, #0]
 8005b36:	06dd      	lsls	r5, r3, #27
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8005b38:	b083      	sub	sp, #12
 8005b3a:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8005b3c:	d53f      	bpl.n	8005bbe <HAL_RCC_OscConfig+0x8e>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 8005b3e:	4bc4      	ldr	r3, [pc, #784]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
 8005b40:	689a      	ldr	r2, [r3, #8]
 8005b42:	f012 0f0c 	tst.w	r2, #12
 8005b46:	f040 8174 	bne.w	8005e32 <HAL_RCC_OscConfig+0x302>
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005b4a:	2202      	movs	r2, #2
 8005b4c:	fa92 f1a2 	rbit	r1, r2
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8005b50:	681b      	ldr	r3, [r3, #0]
 8005b52:	fa92 f2a2 	rbit	r2, r2
 8005b56:	fab2 f282 	clz	r2, r2
 8005b5a:	f002 021f 	and.w	r2, r2, #31
 8005b5e:	40d3      	lsrs	r3, r2
 8005b60:	07d8      	lsls	r0, r3, #31
 8005b62:	d503      	bpl.n	8005b6c <HAL_RCC_OscConfig+0x3c>
 8005b64:	69a3      	ldr	r3, [r4, #24]
 8005b66:	2b00      	cmp	r3, #0
 8005b68:	f000 81f9 	beq.w	8005f5e <HAL_RCC_OscConfig+0x42e>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8005b6c:	4bb8      	ldr	r3, [pc, #736]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
 8005b6e:	6a20      	ldr	r0, [r4, #32]
 8005b70:	681a      	ldr	r2, [r3, #0]
 8005b72:	0711      	lsls	r1, r2, #28
 8005b74:	f100 8239 	bmi.w	8005fea <HAL_RCC_OscConfig+0x4ba>
 8005b78:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8005b7c:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8005b80:	091b      	lsrs	r3, r3, #4
 8005b82:	4283      	cmp	r3, r0
 8005b84:	f080 8237 	bcs.w	8005ff6 <HAL_RCC_OscConfig+0x4c6>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8005b88:	f7ff ff5a 	bl	8005a40 <RCC_SetFlashLatencyFromMSIRange>
 8005b8c:	2800      	cmp	r0, #0
 8005b8e:	f040 81e6 	bne.w	8005f5e <HAL_RCC_OscConfig+0x42e>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8005b92:	4baf      	ldr	r3, [pc, #700]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
 8005b94:	681a      	ldr	r2, [r3, #0]
 8005b96:	f042 0208 	orr.w	r2, r2, #8
 8005b9a:	601a      	str	r2, [r3, #0]
 8005b9c:	6819      	ldr	r1, [r3, #0]
 8005b9e:	6a22      	ldr	r2, [r4, #32]
 8005ba0:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8005ba4:	430a      	orrs	r2, r1
 8005ba6:	601a      	str	r2, [r3, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8005ba8:	685a      	ldr	r2, [r3, #4]
 8005baa:	69e1      	ldr	r1, [r4, #28]
 8005bac:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8005bb0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8005bb4:	605a      	str	r2, [r3, #4]
            return HAL_ERROR;
          }          
        }

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8005bb6:	2000      	movs	r0, #0
 8005bb8:	f7fa ff78 	bl	8000aac <HAL_InitTick>
 8005bbc:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8005bbe:	07de      	lsls	r6, r3, #31
 8005bc0:	d563      	bpl.n	8005c8a <HAL_RCC_OscConfig+0x15a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
 8005bc2:	49a3      	ldr	r1, [pc, #652]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
 8005bc4:	688a      	ldr	r2, [r1, #8]
 8005bc6:	f002 020c 	and.w	r2, r2, #12
 8005bca:	2a08      	cmp	r2, #8
 8005bcc:	f000 81b2 	beq.w	8005f34 <HAL_RCC_OscConfig+0x404>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8005bd0:	688a      	ldr	r2, [r1, #8]
 8005bd2:	f002 020c 	and.w	r2, r2, #12
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
 8005bd6:	2a0c      	cmp	r2, #12
 8005bd8:	f000 81a6 	beq.w	8005f28 <HAL_RCC_OscConfig+0x3f8>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8005bdc:	4d9c      	ldr	r5, [pc, #624]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
 8005bde:	682b      	ldr	r3, [r5, #0]
 8005be0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8005be4:	602b      	str	r3, [r5, #0]
 8005be6:	682b      	ldr	r3, [r5, #0]
 8005be8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8005bec:	602b      	str	r3, [r5, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8005bee:	f7fa ff8b 	bl	8000b08 <HAL_GetTick>
 8005bf2:	f44f 3800 	mov.w	r8, #131072	; 0x20000
 8005bf6:	4607      	mov	r7, r0

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8005bf8:	f241 3688 	movw	r6, #5000	; 0x1388

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8005bfc:	e005      	b.n	8005c0a <HAL_RCC_OscConfig+0xda>
      {
        if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8005bfe:	f7fa ff83 	bl	8000b08 <HAL_GetTick>
 8005c02:	1bc0      	subs	r0, r0, r7
 8005c04:	42b0      	cmp	r0, r6
 8005c06:	f200 814d 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 8005c0a:	fa98 f3a8 	rbit	r3, r8

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8005c0e:	4990      	ldr	r1, [pc, #576]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
 8005c10:	682a      	ldr	r2, [r5, #0]
 8005c12:	fa98 f3a8 	rbit	r3, r8
 8005c16:	fab3 f383 	clz	r3, r3
 8005c1a:	f003 031f 	and.w	r3, r3, #31
 8005c1e:	fa22 f303 	lsr.w	r3, r2, r3
 8005c22:	07d8      	lsls	r0, r3, #31
 8005c24:	d4eb      	bmi.n	8005bfe <HAL_RCC_OscConfig+0xce>
          return HAL_TIMEOUT;
        }
      }

      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8005c26:	6863      	ldr	r3, [r4, #4]
 8005c28:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005c2c:	f000 82b7 	beq.w	800619e <HAL_RCC_OscConfig+0x66e>
 8005c30:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8005c34:	680b      	ldr	r3, [r1, #0]
 8005c36:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8005c3a:	600b      	str	r3, [r1, #0]
 8005c3c:	680b      	ldr	r3, [r1, #0]
 8005c3e:	f000 82ab 	beq.w	8006198 <HAL_RCC_OscConfig+0x668>
 8005c42:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8005c46:	600b      	str	r3, [r1, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8005c48:	6863      	ldr	r3, [r4, #4]
 8005c4a:	2b00      	cmp	r3, #0
 8005c4c:	f000 8284 	beq.w	8006158 <HAL_RCC_OscConfig+0x628>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005c50:	f7fa ff5a 	bl	8000b08 <HAL_GetTick>
 8005c54:	f44f 3800 	mov.w	r8, #131072	; 0x20000
 8005c58:	4607      	mov	r7, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8005c5a:	4d7d      	ldr	r5, [pc, #500]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8005c5c:	f241 3688 	movw	r6, #5000	; 0x1388
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8005c60:	e005      	b.n	8005c6e <HAL_RCC_OscConfig+0x13e>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8005c62:	f7fa ff51 	bl	8000b08 <HAL_GetTick>
 8005c66:	1bc0      	subs	r0, r0, r7
 8005c68:	42b0      	cmp	r0, r6
 8005c6a:	f200 811b 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 8005c6e:	fa98 f3a8 	rbit	r3, r8
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8005c72:	682a      	ldr	r2, [r5, #0]
 8005c74:	fa98 f3a8 	rbit	r3, r8
 8005c78:	fab3 f383 	clz	r3, r3
 8005c7c:	f003 031f 	and.w	r3, r3, #31
 8005c80:	fa22 f303 	lsr.w	r3, r2, r3
 8005c84:	07da      	lsls	r2, r3, #31
 8005c86:	d5ec      	bpl.n	8005c62 <HAL_RCC_OscConfig+0x132>
 8005c88:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8005c8a:	0798      	lsls	r0, r3, #30
 8005c8c:	f100 8093 	bmi.w	8005db6 <HAL_RCC_OscConfig+0x286>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8005c90:	0718      	lsls	r0, r3, #28
 8005c92:	d528      	bpl.n	8005ce6 <HAL_RCC_OscConfig+0x1b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8005c94:	6963      	ldr	r3, [r4, #20]
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8005c96:	4e6e      	ldr	r6, [pc, #440]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8005c98:	2b00      	cmp	r3, #0
 8005c9a:	f000 8182 	beq.w	8005fa2 <HAL_RCC_OscConfig+0x472>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8005c9e:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8005ca2:	f043 0301 	orr.w	r3, r3, #1
 8005ca6:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8005caa:	f7fa ff2d 	bl	8000b08 <HAL_GetTick>
 8005cae:	2502      	movs	r5, #2
 8005cb0:	4607      	mov	r7, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8005cb2:	e005      	b.n	8005cc0 <HAL_RCC_OscConfig+0x190>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8005cb4:	f7fa ff28 	bl	8000b08 <HAL_GetTick>
 8005cb8:	1bc0      	subs	r0, r0, r7
 8005cba:	2864      	cmp	r0, #100	; 0x64
 8005cbc:	f200 80f2 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 8005cc0:	fa95 f3a5 	rbit	r3, r5
 8005cc4:	fa95 f3a5 	rbit	r3, r5
 8005cc8:	fa95 f3a5 	rbit	r3, r5

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8005ccc:	f8d6 2094 	ldr.w	r2, [r6, #148]	; 0x94
 8005cd0:	fa95 f3a5 	rbit	r3, r5
 8005cd4:	fab3 f383 	clz	r3, r3
 8005cd8:	f003 031f 	and.w	r3, r3, #31
 8005cdc:	fa22 f303 	lsr.w	r3, r2, r3
 8005ce0:	07d9      	lsls	r1, r3, #31
 8005ce2:	d5e7      	bpl.n	8005cb4 <HAL_RCC_OscConfig+0x184>
 8005ce4:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8005ce6:	075b      	lsls	r3, r3, #29
 8005ce8:	f140 80e8 	bpl.w	8005ebc <HAL_RCC_OscConfig+0x38c>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8005cec:	4b58      	ldr	r3, [pc, #352]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
 8005cee:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8005cf0:	00d7      	lsls	r7, r2, #3
 8005cf2:	f100 81e1 	bmi.w	80060b8 <HAL_RCC_OscConfig+0x588>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8005cf6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8005cf8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8005cfc:	659a      	str	r2, [r3, #88]	; 0x58
 8005cfe:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005d00:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8005d04:	9301      	str	r3, [sp, #4]
 8005d06:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8005d08:	f04f 0801 	mov.w	r8, #1
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8005d0c:	4d51      	ldr	r5, [pc, #324]	; (8005e54 <HAL_RCC_OscConfig+0x324>)
 8005d0e:	682b      	ldr	r3, [r5, #0]
 8005d10:	05de      	lsls	r6, r3, #23
 8005d12:	d410      	bmi.n	8005d36 <HAL_RCC_OscConfig+0x206>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8005d14:	682b      	ldr	r3, [r5, #0]
 8005d16:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005d1a:	602b      	str	r3, [r5, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8005d1c:	f7fa fef4 	bl	8000b08 <HAL_GetTick>
 8005d20:	4606      	mov	r6, r0

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8005d22:	e005      	b.n	8005d30 <HAL_RCC_OscConfig+0x200>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8005d24:	f7fa fef0 	bl	8000b08 <HAL_GetTick>
 8005d28:	1b80      	subs	r0, r0, r6
 8005d2a:	2864      	cmp	r0, #100	; 0x64
 8005d2c:	f200 80ba 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8005d30:	682b      	ldr	r3, [r5, #0]
 8005d32:	05d8      	lsls	r0, r3, #23
 8005d34:	d5f6      	bpl.n	8005d24 <HAL_RCC_OscConfig+0x1f4>
        }
      }
    }

    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8005d36:	4d46      	ldr	r5, [pc, #280]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
 8005d38:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8005d3c:	f023 0301 	bic.w	r3, r3, #1
 8005d40:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
 8005d44:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8005d48:	f023 0304 	bic.w	r3, r3, #4
 8005d4c:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8005d50:	f7fa feda 	bl	8000b08 <HAL_GetTick>
 8005d54:	f04f 0902 	mov.w	r9, #2
 8005d58:	4607      	mov	r7, r0

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    {
      if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8005d5a:	f241 3688 	movw	r6, #5000	; 0x1388

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8005d5e:	e01c      	b.n	8005d9a <HAL_RCC_OscConfig+0x26a>
 8005d60:	fa99 f3a9 	rbit	r3, r9
 8005d64:	fab3 f383 	clz	r3, r3
 8005d68:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005d6c:	095b      	lsrs	r3, r3, #5
 8005d6e:	2b03      	cmp	r3, #3
 8005d70:	bf0c      	ite	eq
 8005d72:	f8d5 2094 	ldreq.w	r2, [r5, #148]	; 0x94
 8005d76:	69ea      	ldrne	r2, [r5, #28]
 8005d78:	fa99 f3a9 	rbit	r3, r9
 8005d7c:	fab3 f383 	clz	r3, r3
 8005d80:	f003 031f 	and.w	r3, r3, #31
 8005d84:	fa22 f303 	lsr.w	r3, r2, r3
 8005d88:	07d9      	lsls	r1, r3, #31
 8005d8a:	f140 8198 	bpl.w	80060be <HAL_RCC_OscConfig+0x58e>
    {
      if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8005d8e:	f7fa febb 	bl	8000b08 <HAL_GetTick>
 8005d92:	1bc0      	subs	r0, r0, r7
 8005d94:	42b0      	cmp	r0, r6
 8005d96:	f200 8085 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 8005d9a:	fa99 f3a9 	rbit	r3, r9
 8005d9e:	fa99 f3a9 	rbit	r3, r9

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till LSE is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8005da2:	fab3 f383 	clz	r3, r3
 8005da6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005daa:	095b      	lsrs	r3, r3, #5
 8005dac:	2b02      	cmp	r3, #2
 8005dae:	d1d7      	bne.n	8005d60 <HAL_RCC_OscConfig+0x230>
 8005db0:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8005db4:	e7e0      	b.n	8005d78 <HAL_RCC_OscConfig+0x248>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 8005db6:	4a26      	ldr	r2, [pc, #152]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
 8005db8:	6893      	ldr	r3, [r2, #8]
 8005dba:	f003 030c 	and.w	r3, r3, #12
 8005dbe:	2b04      	cmp	r3, #4
 8005dc0:	f000 8138 	beq.w	8006034 <HAL_RCC_OscConfig+0x504>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8005dc4:	6893      	ldr	r3, [r2, #8]
 8005dc6:	f003 030c 	and.w	r3, r3, #12
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 8005dca:	2b0c      	cmp	r3, #12
 8005dcc:	f000 812c 	beq.w	8006028 <HAL_RCC_OscConfig+0x4f8>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8005dd0:	68e3      	ldr	r3, [r4, #12]
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8005dd2:	4d1f      	ldr	r5, [pc, #124]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8005dd4:	2b00      	cmp	r3, #0
 8005dd6:	f000 8150 	beq.w	800607a <HAL_RCC_OscConfig+0x54a>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8005dda:	682b      	ldr	r3, [r5, #0]
 8005ddc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005de0:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005de2:	f7fa fe91 	bl	8000b08 <HAL_GetTick>
 8005de6:	f44f 6780 	mov.w	r7, #1024	; 0x400
 8005dea:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8005dec:	e004      	b.n	8005df8 <HAL_RCC_OscConfig+0x2c8>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8005dee:	f7fa fe8b 	bl	8000b08 <HAL_GetTick>
 8005df2:	1b80      	subs	r0, r0, r6
 8005df4:	2864      	cmp	r0, #100	; 0x64
 8005df6:	d855      	bhi.n	8005ea4 <HAL_RCC_OscConfig+0x374>
 8005df8:	fa97 f3a7 	rbit	r3, r7

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8005dfc:	4914      	ldr	r1, [pc, #80]	; (8005e50 <HAL_RCC_OscConfig+0x320>)
 8005dfe:	682a      	ldr	r2, [r5, #0]
 8005e00:	fa97 f3a7 	rbit	r3, r7
 8005e04:	fab3 f383 	clz	r3, r3
 8005e08:	f003 031f 	and.w	r3, r3, #31
 8005e0c:	fa22 f303 	lsr.w	r3, r2, r3
 8005e10:	07da      	lsls	r2, r3, #31
 8005e12:	d5ec      	bpl.n	8005dee <HAL_RCC_OscConfig+0x2be>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8005e14:	684a      	ldr	r2, [r1, #4]
 8005e16:	f04f 50f8 	mov.w	r0, #520093696	; 0x1f000000
 8005e1a:	fa90 f0a0 	rbit	r0, r0
 8005e1e:	6923      	ldr	r3, [r4, #16]
 8005e20:	fab0 f080 	clz	r0, r0
 8005e24:	f022 52f8 	bic.w	r2, r2, #520093696	; 0x1f000000
 8005e28:	4083      	lsls	r3, r0
 8005e2a:	4313      	orrs	r3, r2
 8005e2c:	604b      	str	r3, [r1, #4]
 8005e2e:	6823      	ldr	r3, [r4, #0]
 8005e30:	e72e      	b.n	8005c90 <HAL_RCC_OscConfig+0x160>
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8005e32:	6982      	ldr	r2, [r0, #24]
 8005e34:	2a00      	cmp	r2, #0
 8005e36:	f000 8096 	beq.w	8005f66 <HAL_RCC_OscConfig+0x436>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8005e3a:	681a      	ldr	r2, [r3, #0]
 8005e3c:	f042 0201 	orr.w	r2, r2, #1
 8005e40:	601a      	str	r2, [r3, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8005e42:	461d      	mov	r5, r3
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();

        /* Get timeout */
        tickstart = HAL_GetTick();
 8005e44:	f7fa fe60 	bl	8000b08 <HAL_GetTick>
 8005e48:	2702      	movs	r7, #2
 8005e4a:	4606      	mov	r6, r0

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8005e4c:	e009      	b.n	8005e62 <HAL_RCC_OscConfig+0x332>
 8005e4e:	bf00      	nop
 8005e50:	40021000 	.word	0x40021000
 8005e54:	40007000 	.word	0x40007000
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8005e58:	f7fa fe56 	bl	8000b08 <HAL_GetTick>
 8005e5c:	1b80      	subs	r0, r0, r6
 8005e5e:	2864      	cmp	r0, #100	; 0x64
 8005e60:	d820      	bhi.n	8005ea4 <HAL_RCC_OscConfig+0x374>
 8005e62:	fa97 f3a7 	rbit	r3, r7

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8005e66:	49c1      	ldr	r1, [pc, #772]	; (800616c <HAL_RCC_OscConfig+0x63c>)
 8005e68:	682a      	ldr	r2, [r5, #0]
 8005e6a:	fa97 f3a7 	rbit	r3, r7
 8005e6e:	fab3 f383 	clz	r3, r3
 8005e72:	f003 031f 	and.w	r3, r3, #31
 8005e76:	fa22 f303 	lsr.w	r3, r2, r3
 8005e7a:	07da      	lsls	r2, r3, #31
 8005e7c:	d5ec      	bpl.n	8005e58 <HAL_RCC_OscConfig+0x328>
          {
            return HAL_TIMEOUT;
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8005e7e:	680b      	ldr	r3, [r1, #0]
 8005e80:	f043 0308 	orr.w	r3, r3, #8
 8005e84:	600b      	str	r3, [r1, #0]
 8005e86:	680a      	ldr	r2, [r1, #0]
 8005e88:	6a23      	ldr	r3, [r4, #32]
 8005e8a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8005e8e:	4313      	orrs	r3, r2
 8005e90:	600b      	str	r3, [r1, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8005e92:	684b      	ldr	r3, [r1, #4]
 8005e94:	69e2      	ldr	r2, [r4, #28]
 8005e96:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8005e9a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005e9e:	604b      	str	r3, [r1, #4]
 8005ea0:	6823      	ldr	r3, [r4, #0]
 8005ea2:	e68c      	b.n	8005bbe <HAL_RCC_OscConfig+0x8e>
        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8005ea4:	2003      	movs	r0, #3
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8005ea6:	b003      	add	sp, #12
 8005ea8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8005eac:	f1b8 0f00 	cmp.w	r8, #0
 8005eb0:	d004      	beq.n	8005ebc <HAL_RCC_OscConfig+0x38c>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8005eb2:	4aae      	ldr	r2, [pc, #696]	; (800616c <HAL_RCC_OscConfig+0x63c>)
 8005eb4:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8005eb6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8005eba:	6593      	str	r3, [r2, #88]	; 0x58
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8005ebc:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8005ebe:	b37a      	cbz	r2, 8005f20 <HAL_RCC_OscConfig+0x3f0>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8005ec0:	4baa      	ldr	r3, [pc, #680]	; (800616c <HAL_RCC_OscConfig+0x63c>)
 8005ec2:	6899      	ldr	r1, [r3, #8]
 8005ec4:	f001 010c 	and.w	r1, r1, #12
 8005ec8:	290c      	cmp	r1, #12
 8005eca:	d048      	beq.n	8005f5e <HAL_RCC_OscConfig+0x42e>
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8005ecc:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8005ece:	681a      	ldr	r2, [r3, #0]
 8005ed0:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8005ed4:	601a      	str	r2, [r3, #0]
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8005ed6:	f000 81a3 	beq.w	8006220 <HAL_RCC_OscConfig+0x6f0>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Disable all PLL outputs to save power */
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 8005eda:	68da      	ldr	r2, [r3, #12]
 8005edc:	f022 0203 	bic.w	r2, r2, #3
 8005ee0:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 8005ee2:	68da      	ldr	r2, [r3, #12]
 8005ee4:	f022 7288 	bic.w	r2, r2, #17825792	; 0x1100000
 8005ee8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8005eec:	60da      	str	r2, [r3, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8005eee:	461c      	mov	r4, r3
        /* Disable all PLL outputs to save power */
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005ef0:	f7fa fe0a 	bl	8000b08 <HAL_GetTick>
 8005ef4:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
 8005ef8:	4606      	mov	r6, r0

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8005efa:	e004      	b.n	8005f06 <HAL_RCC_OscConfig+0x3d6>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8005efc:	f7fa fe04 	bl	8000b08 <HAL_GetTick>
 8005f00:	1b80      	subs	r0, r0, r6
 8005f02:	2864      	cmp	r0, #100	; 0x64
 8005f04:	d8ce      	bhi.n	8005ea4 <HAL_RCC_OscConfig+0x374>
 8005f06:	fa95 f3a5 	rbit	r3, r5

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8005f0a:	6822      	ldr	r2, [r4, #0]
 8005f0c:	fa95 f3a5 	rbit	r3, r5
 8005f10:	fab3 f383 	clz	r3, r3
 8005f14:	f003 031f 	and.w	r3, r3, #31
 8005f18:	fa22 f303 	lsr.w	r3, r2, r3
 8005f1c:	07db      	lsls	r3, r3, #31
 8005f1e:	d4ed      	bmi.n	8005efc <HAL_RCC_OscConfig+0x3cc>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8005f20:	2000      	movs	r0, #0
}
 8005f22:	b003      	add	sp, #12
 8005f24:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8005f28:	68ca      	ldr	r2, [r1, #12]
 8005f2a:	f002 0203 	and.w	r2, r2, #3
 8005f2e:	2a03      	cmp	r2, #3
 8005f30:	f47f ae54 	bne.w	8005bdc <HAL_RCC_OscConfig+0xac>
 8005f34:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8005f38:	fa92 f1a2 	rbit	r1, r2
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8005f3c:	498b      	ldr	r1, [pc, #556]	; (800616c <HAL_RCC_OscConfig+0x63c>)
 8005f3e:	6809      	ldr	r1, [r1, #0]
 8005f40:	fa92 f2a2 	rbit	r2, r2
 8005f44:	fab2 f282 	clz	r2, r2
 8005f48:	f002 021f 	and.w	r2, r2, #31
 8005f4c:	fa21 f202 	lsr.w	r2, r1, r2
 8005f50:	07d5      	lsls	r5, r2, #31
 8005f52:	f57f ae9a 	bpl.w	8005c8a <HAL_RCC_OscConfig+0x15a>
 8005f56:	6862      	ldr	r2, [r4, #4]
 8005f58:	2a00      	cmp	r2, #0
 8005f5a:	f47f ae96 	bne.w	8005c8a <HAL_RCC_OscConfig+0x15a>
    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
      {
        return HAL_ERROR;
 8005f5e:	2001      	movs	r0, #1
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8005f60:	b003      	add	sp, #12
 8005f62:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8005f66:	681a      	ldr	r2, [r3, #0]
 8005f68:	f022 0201 	bic.w	r2, r2, #1
 8005f6c:	601a      	str	r2, [r3, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 8005f6e:	461d      	mov	r5, r3
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();

        /* Get timeout */
        tickstart = HAL_GetTick();
 8005f70:	f7fa fdca 	bl	8000b08 <HAL_GetTick>
 8005f74:	2702      	movs	r7, #2
 8005f76:	4606      	mov	r6, r0

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 8005f78:	e004      	b.n	8005f84 <HAL_RCC_OscConfig+0x454>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8005f7a:	f7fa fdc5 	bl	8000b08 <HAL_GetTick>
 8005f7e:	1b80      	subs	r0, r0, r6
 8005f80:	2864      	cmp	r0, #100	; 0x64
 8005f82:	d88f      	bhi.n	8005ea4 <HAL_RCC_OscConfig+0x374>
 8005f84:	fa97 f3a7 	rbit	r3, r7

        /* Get timeout */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 8005f88:	682a      	ldr	r2, [r5, #0]
 8005f8a:	fa97 f3a7 	rbit	r3, r7
 8005f8e:	fab3 f383 	clz	r3, r3
 8005f92:	f003 031f 	and.w	r3, r3, #31
 8005f96:	fa22 f303 	lsr.w	r3, r2, r3
 8005f9a:	07db      	lsls	r3, r3, #31
 8005f9c:	d4ed      	bmi.n	8005f7a <HAL_RCC_OscConfig+0x44a>
 8005f9e:	6823      	ldr	r3, [r4, #0]
 8005fa0:	e60d      	b.n	8005bbe <HAL_RCC_OscConfig+0x8e>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8005fa2:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8005fa6:	f023 0301 	bic.w	r3, r3, #1
 8005faa:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8005fae:	f7fa fdab 	bl	8000b08 <HAL_GetTick>
 8005fb2:	2502      	movs	r5, #2
 8005fb4:	4607      	mov	r7, r0

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8005fb6:	e005      	b.n	8005fc4 <HAL_RCC_OscConfig+0x494>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8005fb8:	f7fa fda6 	bl	8000b08 <HAL_GetTick>
 8005fbc:	1bc0      	subs	r0, r0, r7
 8005fbe:	2864      	cmp	r0, #100	; 0x64
 8005fc0:	f63f af70 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 8005fc4:	fa95 f3a5 	rbit	r3, r5
 8005fc8:	fa95 f3a5 	rbit	r3, r5
 8005fcc:	fa95 f3a5 	rbit	r3, r5

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8005fd0:	f8d6 2094 	ldr.w	r2, [r6, #148]	; 0x94
 8005fd4:	fa95 f3a5 	rbit	r3, r5
 8005fd8:	fab3 f383 	clz	r3, r3
 8005fdc:	f003 031f 	and.w	r3, r3, #31
 8005fe0:	fa22 f303 	lsr.w	r3, r2, r3
 8005fe4:	07da      	lsls	r2, r3, #31
 8005fe6:	d4e7      	bmi.n	8005fb8 <HAL_RCC_OscConfig+0x488>
 8005fe8:	e67c      	b.n	8005ce4 <HAL_RCC_OscConfig+0x1b4>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8005fea:	681b      	ldr	r3, [r3, #0]
 8005fec:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8005ff0:	4283      	cmp	r3, r0
 8005ff2:	f4ff adc9 	bcc.w	8005b88 <HAL_RCC_OscConfig+0x58>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8005ff6:	4b5d      	ldr	r3, [pc, #372]	; (800616c <HAL_RCC_OscConfig+0x63c>)
 8005ff8:	681a      	ldr	r2, [r3, #0]
 8005ffa:	f042 0208 	orr.w	r2, r2, #8
 8005ffe:	601a      	str	r2, [r3, #0]
 8006000:	6819      	ldr	r1, [r3, #0]
 8006002:	6a22      	ldr	r2, [r4, #32]
 8006004:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8006008:	430a      	orrs	r2, r1
 800600a:	601a      	str	r2, [r3, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800600c:	685a      	ldr	r2, [r3, #4]
 800600e:	69e1      	ldr	r1, [r4, #28]
 8006010:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8006014:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8006018:	605a      	str	r2, [r3, #4]

          /* Decrease number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800601a:	6a20      	ldr	r0, [r4, #32]
 800601c:	f7ff fd10 	bl	8005a40 <RCC_SetFlashLatencyFromMSIRange>
 8006020:	2800      	cmp	r0, #0
 8006022:	f43f adc8 	beq.w	8005bb6 <HAL_RCC_OscConfig+0x86>
 8006026:	e79a      	b.n	8005f5e <HAL_RCC_OscConfig+0x42e>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8006028:	68d3      	ldr	r3, [r2, #12]
 800602a:	f003 0303 	and.w	r3, r3, #3
 800602e:	2b02      	cmp	r3, #2
 8006030:	f47f aece 	bne.w	8005dd0 <HAL_RCC_OscConfig+0x2a0>
 8006034:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006038:	fa93 f2a3 	rbit	r2, r3
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800603c:	4a4b      	ldr	r2, [pc, #300]	; (800616c <HAL_RCC_OscConfig+0x63c>)
 800603e:	6812      	ldr	r2, [r2, #0]
 8006040:	fa93 f3a3 	rbit	r3, r3
 8006044:	fab3 f383 	clz	r3, r3
 8006048:	f003 031f 	and.w	r3, r3, #31
 800604c:	fa22 f303 	lsr.w	r3, r2, r3
 8006050:	07d9      	lsls	r1, r3, #31
 8006052:	d502      	bpl.n	800605a <HAL_RCC_OscConfig+0x52a>
 8006054:	68e3      	ldr	r3, [r4, #12]
 8006056:	2b00      	cmp	r3, #0
 8006058:	d081      	beq.n	8005f5e <HAL_RCC_OscConfig+0x42e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800605a:	4844      	ldr	r0, [pc, #272]	; (800616c <HAL_RCC_OscConfig+0x63c>)
 800605c:	f04f 51f8 	mov.w	r1, #520093696	; 0x1f000000
 8006060:	6842      	ldr	r2, [r0, #4]
 8006062:	fa91 f1a1 	rbit	r1, r1
 8006066:	6923      	ldr	r3, [r4, #16]
 8006068:	fab1 f181 	clz	r1, r1
 800606c:	f022 52f8 	bic.w	r2, r2, #520093696	; 0x1f000000
 8006070:	408b      	lsls	r3, r1
 8006072:	4313      	orrs	r3, r2
 8006074:	6043      	str	r3, [r0, #4]
 8006076:	6823      	ldr	r3, [r4, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8006078:	e60a      	b.n	8005c90 <HAL_RCC_OscConfig+0x160>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800607a:	682b      	ldr	r3, [r5, #0]
 800607c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8006080:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006082:	f7fa fd41 	bl	8000b08 <HAL_GetTick>
 8006086:	f44f 6780 	mov.w	r7, #1024	; 0x400
 800608a:	4606      	mov	r6, r0

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800608c:	e005      	b.n	800609a <HAL_RCC_OscConfig+0x56a>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800608e:	f7fa fd3b 	bl	8000b08 <HAL_GetTick>
 8006092:	1b80      	subs	r0, r0, r6
 8006094:	2864      	cmp	r0, #100	; 0x64
 8006096:	f63f af05 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 800609a:	fa97 f3a7 	rbit	r3, r7

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800609e:	682a      	ldr	r2, [r5, #0]
 80060a0:	fa97 f3a7 	rbit	r3, r7
 80060a4:	fab3 f383 	clz	r3, r3
 80060a8:	f003 031f 	and.w	r3, r3, #31
 80060ac:	fa22 f303 	lsr.w	r3, r2, r3
 80060b0:	07db      	lsls	r3, r3, #31
 80060b2:	d4ec      	bmi.n	800608e <HAL_RCC_OscConfig+0x55e>
 80060b4:	6823      	ldr	r3, [r4, #0]
 80060b6:	e5eb      	b.n	8005c90 <HAL_RCC_OscConfig+0x160>
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 80060b8:	f04f 0800 	mov.w	r8, #0
 80060bc:	e626      	b.n	8005d0c <HAL_RCC_OscConfig+0x1dc>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80060be:	68a3      	ldr	r3, [r4, #8]
 80060c0:	2b01      	cmp	r3, #1
 80060c2:	d071      	beq.n	80061a8 <HAL_RCC_OscConfig+0x678>
 80060c4:	2b00      	cmp	r3, #0
 80060c6:	f040 8100 	bne.w	80062ca <HAL_RCC_OscConfig+0x79a>
 80060ca:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80060ce:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80060d2:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80060d6:	f022 0201 	bic.w	r2, r2, #1
 80060da:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 80060de:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80060e2:	f022 0204 	bic.w	r2, r2, #4
 80060e6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80060ea:	68a3      	ldr	r3, [r4, #8]
 80060ec:	2b00      	cmp	r3, #0
 80060ee:	d063      	beq.n	80061b8 <HAL_RCC_OscConfig+0x688>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80060f0:	f7fa fd0a 	bl	8000b08 <HAL_GetTick>
 80060f4:	f04f 0902 	mov.w	r9, #2
 80060f8:	4607      	mov	r7, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80060fa:	4d1c      	ldr	r5, [pc, #112]	; (800616c <HAL_RCC_OscConfig+0x63c>)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80060fc:	f241 3688 	movw	r6, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8006100:	e01c      	b.n	800613c <HAL_RCC_OscConfig+0x60c>
 8006102:	fa99 f3a9 	rbit	r3, r9
 8006106:	fab3 f383 	clz	r3, r3
 800610a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800610e:	095b      	lsrs	r3, r3, #5
 8006110:	2b03      	cmp	r3, #3
 8006112:	bf0c      	ite	eq
 8006114:	f8d5 2094 	ldreq.w	r2, [r5, #148]	; 0x94
 8006118:	69ea      	ldrne	r2, [r5, #28]
 800611a:	fa99 f3a9 	rbit	r3, r9
 800611e:	fab3 f383 	clz	r3, r3
 8006122:	f003 031f 	and.w	r3, r3, #31
 8006126:	fa22 f303 	lsr.w	r3, r2, r3
 800612a:	07da      	lsls	r2, r3, #31
 800612c:	f53f aebe 	bmi.w	8005eac <HAL_RCC_OscConfig+0x37c>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006130:	f7fa fcea 	bl	8000b08 <HAL_GetTick>
 8006134:	1bc0      	subs	r0, r0, r7
 8006136:	42b0      	cmp	r0, r6
 8006138:	f63f aeb4 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 800613c:	fa99 f3a9 	rbit	r3, r9
 8006140:	fa99 f3a9 	rbit	r3, r9
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8006144:	fab3 f383 	clz	r3, r3
 8006148:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800614c:	095b      	lsrs	r3, r3, #5
 800614e:	2b02      	cmp	r3, #2
 8006150:	d1d7      	bne.n	8006102 <HAL_RCC_OscConfig+0x5d2>
 8006152:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8006156:	e7e0      	b.n	800611a <HAL_RCC_OscConfig+0x5ea>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006158:	f7fa fcd6 	bl	8000b08 <HAL_GetTick>
 800615c:	f44f 3800 	mov.w	r8, #131072	; 0x20000
 8006160:	4607      	mov	r7, r0

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8006162:	4d02      	ldr	r5, [pc, #8]	; (800616c <HAL_RCC_OscConfig+0x63c>)
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8006164:	f241 3688 	movw	r6, #5000	; 0x1388
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8006168:	e008      	b.n	800617c <HAL_RCC_OscConfig+0x64c>
 800616a:	bf00      	nop
 800616c:	40021000 	.word	0x40021000
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8006170:	f7fa fcca 	bl	8000b08 <HAL_GetTick>
 8006174:	1bc0      	subs	r0, r0, r7
 8006176:	42b0      	cmp	r0, r6
 8006178:	f63f ae94 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 800617c:	fa98 f3a8 	rbit	r3, r8
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8006180:	682a      	ldr	r2, [r5, #0]
 8006182:	fa98 f3a8 	rbit	r3, r8
 8006186:	fab3 f383 	clz	r3, r3
 800618a:	f003 031f 	and.w	r3, r3, #31
 800618e:	fa22 f303 	lsr.w	r3, r2, r3
 8006192:	07db      	lsls	r3, r3, #31
 8006194:	d4ec      	bmi.n	8006170 <HAL_RCC_OscConfig+0x640>
 8006196:	e577      	b.n	8005c88 <HAL_RCC_OscConfig+0x158>
          return HAL_TIMEOUT;
        }
      }

      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8006198:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800619c:	600b      	str	r3, [r1, #0]
 800619e:	680b      	ldr	r3, [r1, #0]
 80061a0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80061a4:	600b      	str	r3, [r1, #0]
 80061a6:	e54f      	b.n	8005c48 <HAL_RCC_OscConfig+0x118>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80061a8:	4a55      	ldr	r2, [pc, #340]	; (8006300 <HAL_RCC_OscConfig+0x7d0>)
 80061aa:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80061ae:	f043 0301 	orr.w	r3, r3, #1
 80061b2:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 80061b6:	e798      	b.n	80060ea <HAL_RCC_OscConfig+0x5ba>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80061b8:	f7fa fca6 	bl	8000b08 <HAL_GetTick>
 80061bc:	f04f 0902 	mov.w	r9, #2
 80061c0:	4607      	mov	r7, r0

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80061c2:	4d4f      	ldr	r5, [pc, #316]	; (8006300 <HAL_RCC_OscConfig+0x7d0>)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80061c4:	f241 3688 	movw	r6, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80061c8:	e01c      	b.n	8006204 <HAL_RCC_OscConfig+0x6d4>
 80061ca:	fa99 f3a9 	rbit	r3, r9
 80061ce:	fab3 f383 	clz	r3, r3
 80061d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80061d6:	095b      	lsrs	r3, r3, #5
 80061d8:	2b03      	cmp	r3, #3
 80061da:	bf0c      	ite	eq
 80061dc:	f8d5 2094 	ldreq.w	r2, [r5, #148]	; 0x94
 80061e0:	69ea      	ldrne	r2, [r5, #28]
 80061e2:	fa99 f3a9 	rbit	r3, r9
 80061e6:	fab3 f383 	clz	r3, r3
 80061ea:	f003 031f 	and.w	r3, r3, #31
 80061ee:	fa22 f303 	lsr.w	r3, r2, r3
 80061f2:	07db      	lsls	r3, r3, #31
 80061f4:	f57f ae5a 	bpl.w	8005eac <HAL_RCC_OscConfig+0x37c>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80061f8:	f7fa fc86 	bl	8000b08 <HAL_GetTick>
 80061fc:	1bc0      	subs	r0, r0, r7
 80061fe:	42b0      	cmp	r0, r6
 8006200:	f63f ae50 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 8006204:	fa99 f3a9 	rbit	r3, r9
 8006208:	fa99 f3a9 	rbit	r3, r9
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800620c:	fab3 f383 	clz	r3, r3
 8006210:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006214:	095b      	lsrs	r3, r3, #5
 8006216:	2b02      	cmp	r3, #2
 8006218:	d1d7      	bne.n	80061ca <HAL_RCC_OscConfig+0x69a>
 800621a:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 800621e:	e7e0      	b.n	80061e2 <HAL_RCC_OscConfig+0x6b2>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8006220:	461d      	mov	r5, r3

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006222:	f7fa fc71 	bl	8000b08 <HAL_GetTick>
 8006226:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
 800622a:	4606      	mov	r6, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800622c:	e005      	b.n	800623a <HAL_RCC_OscConfig+0x70a>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800622e:	f7fa fc6b 	bl	8000b08 <HAL_GetTick>
 8006232:	1b80      	subs	r0, r0, r6
 8006234:	2864      	cmp	r0, #100	; 0x64
 8006236:	f63f ae35 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 800623a:	fa97 f3a7 	rbit	r3, r7

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800623e:	4930      	ldr	r1, [pc, #192]	; (8006300 <HAL_RCC_OscConfig+0x7d0>)
 8006240:	682a      	ldr	r2, [r5, #0]
 8006242:	fa97 f3a7 	rbit	r3, r7
 8006246:	fab3 f383 	clz	r3, r3
 800624a:	f003 031f 	and.w	r3, r3, #31
 800624e:	fa22 f303 	lsr.w	r3, r2, r3
 8006252:	07d8      	lsls	r0, r3, #31
 8006254:	d4eb      	bmi.n	800622e <HAL_RCC_OscConfig+0x6fe>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8006256:	f104 0328 	add.w	r3, r4, #40	; 0x28
 800625a:	cbc8      	ldmia	r3, {r3, r6, r7}
 800625c:	6b65      	ldr	r5, [r4, #52]	; 0x34
 800625e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8006260:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8006262:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
 8006266:	1e74      	subs	r4, r6, #1
 8006268:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 800626c:	0840      	lsrs	r0, r0, #1
 800626e:	092c      	lsrs	r4, r5, #4
 8006270:	ea43 4344 	orr.w	r3, r3, r4, lsl #17
 8006274:	3801      	subs	r0, #1
 8006276:	0852      	lsrs	r2, r2, #1
 8006278:	ea43 5340 	orr.w	r3, r3, r0, lsl #21
 800627c:	3a01      	subs	r2, #1
 800627e:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8006282:	60cb      	str	r3, [r1, #12]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8006284:	680b      	ldr	r3, [r1, #0]
 8006286:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800628a:	600b      	str	r3, [r1, #0]

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 800628c:	68cb      	ldr	r3, [r1, #12]
 800628e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8006292:	60cb      	str	r3, [r1, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8006294:	460c      	mov	r4, r1

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006296:	f7fa fc37 	bl	8000b08 <HAL_GetTick>
 800629a:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
 800629e:	4606      	mov	r6, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80062a0:	e005      	b.n	80062ae <HAL_RCC_OscConfig+0x77e>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80062a2:	f7fa fc31 	bl	8000b08 <HAL_GetTick>
 80062a6:	1b80      	subs	r0, r0, r6
 80062a8:	2864      	cmp	r0, #100	; 0x64
 80062aa:	f63f adfb 	bhi.w	8005ea4 <HAL_RCC_OscConfig+0x374>
 80062ae:	fa95 f3a5 	rbit	r3, r5

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80062b2:	6822      	ldr	r2, [r4, #0]
 80062b4:	fa95 f3a5 	rbit	r3, r5
 80062b8:	fab3 f383 	clz	r3, r3
 80062bc:	f003 031f 	and.w	r3, r3, #31
 80062c0:	fa22 f303 	lsr.w	r3, r2, r3
 80062c4:	07da      	lsls	r2, r3, #31
 80062c6:	d5ec      	bpl.n	80062a2 <HAL_RCC_OscConfig+0x772>
 80062c8:	e62a      	b.n	8005f20 <HAL_RCC_OscConfig+0x3f0>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80062ca:	2b05      	cmp	r3, #5
 80062cc:	4b0c      	ldr	r3, [pc, #48]	; (8006300 <HAL_RCC_OscConfig+0x7d0>)
 80062ce:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80062d2:	f022 0201 	bic.w	r2, r2, #1
 80062d6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 80062da:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80062de:	d004      	beq.n	80062ea <HAL_RCC_OscConfig+0x7ba>
 80062e0:	f022 0204 	bic.w	r2, r2, #4
 80062e4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 80062e8:	e6ff      	b.n	80060ea <HAL_RCC_OscConfig+0x5ba>
 80062ea:	f042 0204 	orr.w	r2, r2, #4
 80062ee:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 80062f2:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80062f6:	f042 0201 	orr.w	r2, r2, #1
 80062fa:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 80062fe:	e6f4      	b.n	80060ea <HAL_RCC_OscConfig+0x5ba>
 8006300:	40021000 	.word	0x40021000

08006304 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8006304:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8006308:	4a93      	ldr	r2, [pc, #588]	; (8006558 <HAL_RCC_ClockConfig+0x254>)
 800630a:	6813      	ldr	r3, [r2, #0]
 800630c:	f003 0307 	and.w	r3, r3, #7
 8006310:	428b      	cmp	r3, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8006312:	460c      	mov	r4, r1
 8006314:	4605      	mov	r5, r0
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8006316:	d20f      	bcs.n	8006338 <HAL_RCC_ClockConfig+0x34>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8006318:	6813      	ldr	r3, [r2, #0]
 800631a:	4a8f      	ldr	r2, [pc, #572]	; (8006558 <HAL_RCC_ClockConfig+0x254>)
 800631c:	2904      	cmp	r1, #4
 800631e:	bf9c      	itt	ls
 8006320:	f023 0307 	bicls.w	r3, r3, #7
 8006324:	430b      	orrls	r3, r1
 8006326:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8006328:	6813      	ldr	r3, [r2, #0]
 800632a:	f003 0307 	and.w	r3, r3, #7
 800632e:	428b      	cmp	r3, r1
 8006330:	d06a      	beq.n	8006408 <HAL_RCC_ClockConfig+0x104>
    {
      return HAL_ERROR;
 8006332:	2001      	movs	r0, #1
 8006334:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8006338:	6803      	ldr	r3, [r0, #0]
 800633a:	079e      	lsls	r6, r3, #30
 800633c:	d507      	bpl.n	800634e <HAL_RCC_ClockConfig+0x4a>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800633e:	4987      	ldr	r1, [pc, #540]	; (800655c <HAL_RCC_ClockConfig+0x258>)
 8006340:	6883      	ldr	r3, [r0, #8]
 8006342:	688a      	ldr	r2, [r1, #8]
 8006344:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8006348:	4313      	orrs	r3, r2
 800634a:	608b      	str	r3, [r1, #8]
 800634c:	6803      	ldr	r3, [r0, #0]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800634e:	07d8      	lsls	r0, r3, #31
 8006350:	d534      	bpl.n	80063bc <HAL_RCC_ClockConfig+0xb8>
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006352:	686b      	ldr	r3, [r5, #4]
 8006354:	2b02      	cmp	r3, #2
 8006356:	f000 80a0 	beq.w	800649a <HAL_RCC_ClockConfig+0x196>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800635a:	2b00      	cmp	r3, #0
 800635c:	f040 80a0 	bne.w	80064a0 <HAL_RCC_ClockConfig+0x19c>
 8006360:	2202      	movs	r2, #2
 8006362:	fa92 f1a2 	rbit	r1, r2
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8006366:	497d      	ldr	r1, [pc, #500]	; (800655c <HAL_RCC_ClockConfig+0x258>)
 8006368:	6809      	ldr	r1, [r1, #0]
 800636a:	fa92 f2a2 	rbit	r2, r2
 800636e:	fab2 f282 	clz	r2, r2
 8006372:	f002 021f 	and.w	r2, r2, #31
 8006376:	fa21 f202 	lsr.w	r2, r1, r2
 800637a:	07d1      	lsls	r1, r2, #31
 800637c:	d5d9      	bpl.n	8006332 <HAL_RCC_ClockConfig+0x2e>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800637e:	4e77      	ldr	r6, [pc, #476]	; (800655c <HAL_RCC_ClockConfig+0x258>)
 8006380:	68b2      	ldr	r2, [r6, #8]
 8006382:	f022 0203 	bic.w	r2, r2, #3
 8006386:	4313      	orrs	r3, r2
 8006388:	60b3      	str	r3, [r6, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800638a:	f7fa fbbd 	bl	8000b08 <HAL_GetTick>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800638e:	686b      	ldr	r3, [r5, #4]
 8006390:	2b02      	cmp	r3, #2
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006392:	4607      	mov	r7, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006394:	f000 80be 	beq.w	8006514 <HAL_RCC_ClockConfig+0x210>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8006398:	2b03      	cmp	r3, #3
 800639a:	f000 80c9 	beq.w	8006530 <HAL_RCC_ClockConfig+0x22c>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800639e:	2b00      	cmp	r3, #0
 80063a0:	f040 80a7 	bne.w	80064f2 <HAL_RCC_ClockConfig+0x1ee>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
        {
          if((HAL_GetTick() - tickstart) >= CLOCKSWITCH_TIMEOUT_VALUE)
 80063a4:	f241 3887 	movw	r8, #4999	; 0x1387
 80063a8:	e004      	b.n	80063b4 <HAL_RCC_ClockConfig+0xb0>
 80063aa:	f7fa fbad 	bl	8000b08 <HAL_GetTick>
 80063ae:	1bc0      	subs	r0, r0, r7
 80063b0:	4540      	cmp	r0, r8
 80063b2:	d869      	bhi.n	8006488 <HAL_RCC_ClockConfig+0x184>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 80063b4:	68b3      	ldr	r3, [r6, #8]
 80063b6:	f013 0f0c 	tst.w	r3, #12
 80063ba:	d1f6      	bne.n	80063aa <HAL_RCC_ClockConfig+0xa6>
        }
      }
    }

    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80063bc:	2c04      	cmp	r4, #4
 80063be:	d966      	bls.n	800648e <HAL_RCC_ClockConfig+0x18a>
 80063c0:	4b65      	ldr	r3, [pc, #404]	; (8006558 <HAL_RCC_ClockConfig+0x254>)
 80063c2:	681b      	ldr	r3, [r3, #0]
 80063c4:	4a64      	ldr	r2, [pc, #400]	; (8006558 <HAL_RCC_ClockConfig+0x254>)
 80063c6:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80063c8:	6813      	ldr	r3, [r2, #0]
 80063ca:	f003 0307 	and.w	r3, r3, #7
 80063ce:	42a3      	cmp	r3, r4
 80063d0:	d1af      	bne.n	8006332 <HAL_RCC_ClockConfig+0x2e>
 80063d2:	682b      	ldr	r3, [r5, #0]
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80063d4:	075a      	lsls	r2, r3, #29
 80063d6:	d507      	bpl.n	80063e8 <HAL_RCC_ClockConfig+0xe4>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80063d8:	4960      	ldr	r1, [pc, #384]	; (800655c <HAL_RCC_ClockConfig+0x258>)
 80063da:	68eb      	ldr	r3, [r5, #12]
 80063dc:	688a      	ldr	r2, [r1, #8]
 80063de:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 80063e2:	4313      	orrs	r3, r2
 80063e4:	608b      	str	r3, [r1, #8]
 80063e6:	682b      	ldr	r3, [r5, #0]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80063e8:	071b      	lsls	r3, r3, #28
 80063ea:	d507      	bpl.n	80063fc <HAL_RCC_ClockConfig+0xf8>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 80063ec:	4a5b      	ldr	r2, [pc, #364]	; (800655c <HAL_RCC_ClockConfig+0x258>)
 80063ee:	6929      	ldr	r1, [r5, #16]
 80063f0:	6893      	ldr	r3, [r2, #8]
 80063f2:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 80063f6:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80063fa:	6093      	str	r3, [r2, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 80063fc:	2000      	movs	r0, #0
 80063fe:	f7fa fb55 	bl	8000aac <HAL_InitTick>

  return HAL_OK;
 8006402:	2000      	movs	r0, #0
}
 8006404:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    {
      return HAL_ERROR;
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8006408:	6803      	ldr	r3, [r0, #0]
 800640a:	0799      	lsls	r1, r3, #30
 800640c:	d507      	bpl.n	800641e <HAL_RCC_ClockConfig+0x11a>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800640e:	4953      	ldr	r1, [pc, #332]	; (800655c <HAL_RCC_ClockConfig+0x258>)
 8006410:	6883      	ldr	r3, [r0, #8]
 8006412:	688a      	ldr	r2, [r1, #8]
 8006414:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8006418:	4313      	orrs	r3, r2
 800641a:	608b      	str	r3, [r1, #8]
 800641c:	6803      	ldr	r3, [r0, #0]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800641e:	07da      	lsls	r2, r3, #31
 8006420:	d5d8      	bpl.n	80063d4 <HAL_RCC_ClockConfig+0xd0>
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006422:	686b      	ldr	r3, [r5, #4]
 8006424:	2b02      	cmp	r3, #2
 8006426:	f000 8091 	beq.w	800654c <HAL_RCC_ClockConfig+0x248>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800642a:	2b03      	cmp	r3, #3
 800642c:	d06f      	beq.n	800650e <HAL_RCC_ClockConfig+0x20a>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800642e:	2b00      	cmp	r3, #0
 8006430:	f040 808f 	bne.w	8006552 <HAL_RCC_ClockConfig+0x24e>
 8006434:	2202      	movs	r2, #2
 8006436:	fa92 f1a2 	rbit	r1, r2
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800643a:	4948      	ldr	r1, [pc, #288]	; (800655c <HAL_RCC_ClockConfig+0x258>)
 800643c:	6809      	ldr	r1, [r1, #0]
 800643e:	fa92 f2a2 	rbit	r2, r2
 8006442:	fab2 f282 	clz	r2, r2
 8006446:	f002 021f 	and.w	r2, r2, #31
 800644a:	fa21 f202 	lsr.w	r2, r1, r2
 800644e:	07d7      	lsls	r7, r2, #31
 8006450:	f57f af6f 	bpl.w	8006332 <HAL_RCC_ClockConfig+0x2e>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8006454:	4c41      	ldr	r4, [pc, #260]	; (800655c <HAL_RCC_ClockConfig+0x258>)
 8006456:	68a2      	ldr	r2, [r4, #8]
 8006458:	f022 0203 	bic.w	r2, r2, #3
 800645c:	4313      	orrs	r3, r2
 800645e:	60a3      	str	r3, [r4, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006460:	f7fa fb52 	bl	8000b08 <HAL_GetTick>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006464:	686b      	ldr	r3, [r5, #4]
 8006466:	2b02      	cmp	r3, #2
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006468:	4606      	mov	r6, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800646a:	f241 3788 	movw	r7, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800646e:	d01e      	beq.n	80064ae <HAL_RCC_ClockConfig+0x1aa>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8006470:	2b03      	cmp	r3, #3
 8006472:	d032      	beq.n	80064da <HAL_RCC_ClockConfig+0x1d6>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8006474:	bb33      	cbnz	r3, 80064c4 <HAL_RCC_ClockConfig+0x1c0>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 8006476:	68a3      	ldr	r3, [r4, #8]
 8006478:	f013 0f0c 	tst.w	r3, #12
 800647c:	d0a9      	beq.n	80063d2 <HAL_RCC_ClockConfig+0xce>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800647e:	f7fa fb43 	bl	8000b08 <HAL_GetTick>
 8006482:	1b80      	subs	r0, r0, r6
 8006484:	42b8      	cmp	r0, r7
 8006486:	d9f6      	bls.n	8006476 <HAL_RCC_ClockConfig+0x172>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8006488:	2003      	movs	r0, #3
 800648a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }

    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800648e:	4b32      	ldr	r3, [pc, #200]	; (8006558 <HAL_RCC_ClockConfig+0x254>)
 8006490:	681b      	ldr	r3, [r3, #0]
 8006492:	f023 0307 	bic.w	r3, r3, #7
 8006496:	4323      	orrs	r3, r4
 8006498:	e794      	b.n	80063c4 <HAL_RCC_ClockConfig+0xc0>
 800649a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800649e:	e760      	b.n	8006362 <HAL_RCC_ClockConfig+0x5e>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80064a0:	2b03      	cmp	r3, #3
 80064a2:	bf0c      	ite	eq
 80064a4:	f04f 7200 	moveq.w	r2, #33554432	; 0x2000000
 80064a8:	f44f 6280 	movne.w	r2, #1024	; 0x400
 80064ac:	e759      	b.n	8006362 <HAL_RCC_ClockConfig+0x5e>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 80064ae:	68a3      	ldr	r3, [r4, #8]
 80064b0:	f003 030c 	and.w	r3, r3, #12
 80064b4:	2b08      	cmp	r3, #8
 80064b6:	d08c      	beq.n	80063d2 <HAL_RCC_ClockConfig+0xce>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80064b8:	f7fa fb26 	bl	8000b08 <HAL_GetTick>
 80064bc:	1b80      	subs	r0, r0, r6
 80064be:	42b8      	cmp	r0, r7
 80064c0:	d9f5      	bls.n	80064ae <HAL_RCC_ClockConfig+0x1aa>
 80064c2:	e7e1      	b.n	8006488 <HAL_RCC_ClockConfig+0x184>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80064c4:	68a3      	ldr	r3, [r4, #8]
 80064c6:	f003 030c 	and.w	r3, r3, #12
 80064ca:	2b04      	cmp	r3, #4
 80064cc:	d081      	beq.n	80063d2 <HAL_RCC_ClockConfig+0xce>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80064ce:	f7fa fb1b 	bl	8000b08 <HAL_GetTick>
 80064d2:	1b80      	subs	r0, r0, r6
 80064d4:	42b8      	cmp	r0, r7
 80064d6:	d9f5      	bls.n	80064c4 <HAL_RCC_ClockConfig+0x1c0>
 80064d8:	e7d6      	b.n	8006488 <HAL_RCC_ClockConfig+0x184>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80064da:	68a3      	ldr	r3, [r4, #8]
 80064dc:	f003 030c 	and.w	r3, r3, #12
 80064e0:	2b0c      	cmp	r3, #12
 80064e2:	f43f af76 	beq.w	80063d2 <HAL_RCC_ClockConfig+0xce>
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80064e6:	f7fa fb0f 	bl	8000b08 <HAL_GetTick>
 80064ea:	1b80      	subs	r0, r0, r6
 80064ec:	42b8      	cmp	r0, r7
 80064ee:	d9f4      	bls.n	80064da <HAL_RCC_ClockConfig+0x1d6>
 80064f0:	e7ca      	b.n	8006488 <HAL_RCC_ClockConfig+0x184>
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80064f2:	f241 3888 	movw	r8, #5000	; 0x1388
 80064f6:	e004      	b.n	8006502 <HAL_RCC_ClockConfig+0x1fe>
 80064f8:	f7fa fb06 	bl	8000b08 <HAL_GetTick>
 80064fc:	1bc0      	subs	r0, r0, r7
 80064fe:	4540      	cmp	r0, r8
 8006500:	d8c2      	bhi.n	8006488 <HAL_RCC_ClockConfig+0x184>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 8006502:	68b3      	ldr	r3, [r6, #8]
 8006504:	f003 030c 	and.w	r3, r3, #12
 8006508:	2b04      	cmp	r3, #4
 800650a:	d1f5      	bne.n	80064f8 <HAL_RCC_ClockConfig+0x1f4>
 800650c:	e756      	b.n	80063bc <HAL_RCC_ClockConfig+0xb8>
 800650e:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8006512:	e790      	b.n	8006436 <HAL_RCC_ClockConfig+0x132>

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006514:	f241 3888 	movw	r8, #5000	; 0x1388
 8006518:	e004      	b.n	8006524 <HAL_RCC_ClockConfig+0x220>
 800651a:	f7fa faf5 	bl	8000b08 <HAL_GetTick>
 800651e:	1bc0      	subs	r0, r0, r7
 8006520:	4540      	cmp	r0, r8
 8006522:	d8b1      	bhi.n	8006488 <HAL_RCC_ClockConfig+0x184>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8006524:	68b3      	ldr	r3, [r6, #8]
 8006526:	f003 030c 	and.w	r3, r3, #12
 800652a:	2b08      	cmp	r3, #8
 800652c:	d1f5      	bne.n	800651a <HAL_RCC_ClockConfig+0x216>
 800652e:	e745      	b.n	80063bc <HAL_RCC_ClockConfig+0xb8>
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
        {
          if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006530:	f241 3888 	movw	r8, #5000	; 0x1388
 8006534:	e004      	b.n	8006540 <HAL_RCC_ClockConfig+0x23c>
 8006536:	f7fa fae7 	bl	8000b08 <HAL_GetTick>
 800653a:	1bc0      	subs	r0, r0, r7
 800653c:	4540      	cmp	r0, r8
 800653e:	d8a3      	bhi.n	8006488 <HAL_RCC_ClockConfig+0x184>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8006540:	68b3      	ldr	r3, [r6, #8]
 8006542:	f003 030c 	and.w	r3, r3, #12
 8006546:	2b0c      	cmp	r3, #12
 8006548:	d1f5      	bne.n	8006536 <HAL_RCC_ClockConfig+0x232>
 800654a:	e737      	b.n	80063bc <HAL_RCC_ClockConfig+0xb8>
 800654c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8006550:	e771      	b.n	8006436 <HAL_RCC_ClockConfig+0x132>
 8006552:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8006556:	e76e      	b.n	8006436 <HAL_RCC_ClockConfig+0x132>
 8006558:	40022000 	.word	0x40022000
 800655c:	40021000 	.word	0x40021000

08006560 <HAL_RCC_MCOConfig>:
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8006560:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 8006562:	4c12      	ldr	r4, [pc, #72]	; (80065ac <HAL_RCC_MCOConfig+0x4c>)
 8006564:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8006566:	f043 0301 	orr.w	r3, r3, #1
 800656a:	64e3      	str	r3, [r4, #76]	; 0x4c
 800656c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 800656e:	b087      	sub	sp, #28
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 8006570:	f003 0301 	and.w	r3, r3, #1
 8006574:	9300      	str	r3, [sp, #0]
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8006576:	460d      	mov	r5, r1

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006578:	2300      	movs	r3, #0

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
 800657a:	f44f 7e80 	mov.w	lr, #256	; 0x100
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800657e:	2602      	movs	r6, #2
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8006580:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8006584:	a901      	add	r1, sp, #4
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8006586:	4617      	mov	r7, r2

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006588:	9303      	str	r3, [sp, #12]
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 800658a:	9a00      	ldr	r2, [sp, #0]
  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 800658c:	9305      	str	r3, [sp, #20]

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
 800658e:	f8cd e004 	str.w	lr, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006592:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8006594:	9604      	str	r6, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8006596:	f7fb fcf3 	bl	8001f80 <HAL_GPIO_Init>

  /* Mask MCOSEL[] and MCOPRE[] bits then set MCO1 clock source and prescaler */
  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCO_PRE), (RCC_MCOSource | RCC_MCODiv ));
 800659a:	68a3      	ldr	r3, [r4, #8]
 800659c:	f023 43ee 	bic.w	r3, r3, #1996488704	; 0x77000000
 80065a0:	ea47 0203 	orr.w	r2, r7, r3
 80065a4:	432a      	orrs	r2, r5
 80065a6:	60a2      	str	r2, [r4, #8]
}
 80065a8:	b007      	add	sp, #28
 80065aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80065ac:	40021000 	.word	0x40021000

080065b0 <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
  uint32_t sysclockfreq = 0;

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 80065b0:	4a39      	ldr	r2, [pc, #228]	; (8006698 <HAL_RCC_GetSysClockFreq+0xe8>)
 80065b2:	6893      	ldr	r3, [r2, #8]
 80065b4:	f003 030c 	and.w	r3, r3, #12
 80065b8:	2b04      	cmp	r3, #4
 80065ba:	d04e      	beq.n	800665a <HAL_RCC_GetSysClockFreq+0xaa>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 80065bc:	6893      	ldr	r3, [r2, #8]
 80065be:	f003 030c 	and.w	r3, r3, #12
 80065c2:	2b08      	cmp	r3, #8
 80065c4:	d04c      	beq.n	8006660 <HAL_RCC_GetSysClockFreq+0xb0>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 80065c6:	6893      	ldr	r3, [r2, #8]
 80065c8:	f013 0f0c 	tst.w	r3, #12
 80065cc:	d11c      	bne.n	8006608 <HAL_RCC_GetSysClockFreq+0x58>
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 80065ce:	4b32      	ldr	r3, [pc, #200]	; (8006698 <HAL_RCC_GetSysClockFreq+0xe8>)
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 80065d0:	4932      	ldr	r1, [pc, #200]	; (800669c <HAL_RCC_GetSysClockFreq+0xec>)
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 80065d2:	681a      	ldr	r2, [r3, #0]
 80065d4:	0712      	lsls	r2, r2, #28
    { /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 80065d6:	bf54      	ite	pl
 80065d8:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 80065dc:	681b      	ldrmi	r3, [r3, #0]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 80065de:	4a2e      	ldr	r2, [pc, #184]	; (8006698 <HAL_RCC_GetSysClockFreq+0xe8>)
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
    { /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8;
 80065e0:	bf54      	ite	pl
 80065e2:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
 80065e6:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 80065ea:	6892      	ldr	r2, [r2, #8]
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 80065ec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 80065f0:	f012 0f0c 	tst.w	r2, #12
 80065f4:	bf0c      	ite	eq
 80065f6:	4618      	moveq	r0, r3
 80065f8:	2000      	movne	r0, #0
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 80065fa:	4927      	ldr	r1, [pc, #156]	; (8006698 <HAL_RCC_GetSysClockFreq+0xe8>)
 80065fc:	688a      	ldr	r2, [r1, #8]
 80065fe:	f002 020c 	and.w	r2, r2, #12
 8006602:	2a0c      	cmp	r2, #12
 8006604:	d00d      	beq.n	8006622 <HAL_RCC_GetSysClockFreq+0x72>
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>25) + 1 ) *2;
    sysclockfreq = pllvco/pllr;
  }

  return sysclockfreq;
}
 8006606:	4770      	bx	lr
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8006608:	6893      	ldr	r3, [r2, #8]
 800660a:	f003 030c 	and.w	r3, r3, #12
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 800660e:	2b0c      	cmp	r3, #12
 8006610:	d032      	beq.n	8006678 <HAL_RCC_GetSysClockFreq+0xc8>
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8006612:	4921      	ldr	r1, [pc, #132]	; (8006698 <HAL_RCC_GetSysClockFreq+0xe8>)
 8006614:	688a      	ldr	r2, [r1, #8]
 8006616:	f002 020c 	and.w	r2, r2, #12
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
  uint32_t sysclockfreq = 0;
 800661a:	2000      	movs	r0, #0
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 800661c:	2a0c      	cmp	r2, #12
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
 800661e:	4603      	mov	r3, r0
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8006620:	d1f1      	bne.n	8006606 <HAL_RCC_GetSysClockFreq+0x56>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8006622:	68ca      	ldr	r2, [r1, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
 8006624:	68c8      	ldr	r0, [r1, #12]
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8006626:	f002 0203 	and.w	r2, r2, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
 800662a:	f3c0 1002 	ubfx	r0, r0, #4, #3

    switch (pllsource)
 800662e:	2a02      	cmp	r2, #2

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;
 8006630:	f100 0001 	add.w	r0, r0, #1

    switch (pllsource)
 8006634:	d026      	beq.n	8006684 <HAL_RCC_GetSysClockFreq+0xd4>
 8006636:	2a03      	cmp	r2, #3
 8006638:	d015      	beq.n	8006666 <HAL_RCC_GetSysClockFreq+0xb6>
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
      break;

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 800663a:	fbb3 f3f0 	udiv	r3, r3, r0
 800663e:	68ca      	ldr	r2, [r1, #12]
 8006640:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8006644:	fb02 f303 	mul.w	r3, r2, r3
      break;
    }
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>25) + 1 ) *2;
 8006648:	4a13      	ldr	r2, [pc, #76]	; (8006698 <HAL_RCC_GetSysClockFreq+0xe8>)
 800664a:	68d0      	ldr	r0, [r2, #12]
 800664c:	f3c0 6041 	ubfx	r0, r0, #25, #2
 8006650:	3001      	adds	r0, #1
 8006652:	0040      	lsls	r0, r0, #1
    sysclockfreq = pllvco/pllr;
 8006654:	fbb3 f0f0 	udiv	r0, r3, r0
  }

  return sysclockfreq;
}
 8006658:	4770      	bx	lr
  uint32_t sysclockfreq = 0;

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 800665a:	4811      	ldr	r0, [pc, #68]	; (80066a0 <HAL_RCC_GetSysClockFreq+0xf0>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
 800665c:	2300      	movs	r3, #0
 800665e:	e7cc      	b.n	80065fa <HAL_RCC_GetSysClockFreq+0x4a>
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 8006660:	4810      	ldr	r0, [pc, #64]	; (80066a4 <HAL_RCC_GetSysClockFreq+0xf4>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0, pllvco = 0, pllr = 2, pllsource = 0, pllm = 2;
 8006662:	2300      	movs	r3, #0
 8006664:	e7c9      	b.n	80065fa <HAL_RCC_GetSysClockFreq+0x4a>
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 8006666:	68ca      	ldr	r2, [r1, #12]
 8006668:	4b0e      	ldr	r3, [pc, #56]	; (80066a4 <HAL_RCC_GetSysClockFreq+0xf4>)
 800666a:	fbb3 f0f0 	udiv	r0, r3, r0
 800666e:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8006672:	fb02 f300 	mul.w	r3, r2, r0
      break;
 8006676:	e7e7      	b.n	8006648 <HAL_RCC_GetSysClockFreq+0x98>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
          ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8006678:	68d3      	ldr	r3, [r2, #12]
 800667a:	f003 0303 	and.w	r3, r3, #3
 800667e:	2b01      	cmp	r3, #1
 8006680:	d1c7      	bne.n	8006612 <HAL_RCC_GetSysClockFreq+0x62>
 8006682:	e7a4      	b.n	80065ce <HAL_RCC_GetSysClockFreq+0x1e>
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM)>> 4) + 1 ;

    switch (pllsource)
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 8006684:	68cb      	ldr	r3, [r1, #12]
 8006686:	4a06      	ldr	r2, [pc, #24]	; (80066a0 <HAL_RCC_GetSysClockFreq+0xf0>)
 8006688:	fbb2 f0f0 	udiv	r0, r2, r0
 800668c:	f3c3 2306 	ubfx	r3, r3, #8, #7
 8006690:	fb03 f300 	mul.w	r3, r3, r0
      break;
 8006694:	e7d8      	b.n	8006648 <HAL_RCC_GetSysClockFreq+0x98>
 8006696:	bf00      	nop
 8006698:	40021000 	.word	0x40021000
 800669c:	0800c468 	.word	0x0800c468
 80066a0:	00f42400 	.word	0x00f42400
 80066a4:	007a1200 	.word	0x007a1200

080066a8 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80066a8:	b510      	push	{r4, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 80066aa:	f7ff ff81 	bl	80065b0 <HAL_RCC_GetSysClockFreq>
 80066ae:	4b08      	ldr	r3, [pc, #32]	; (80066d0 <HAL_RCC_GetHCLKFreq+0x28>)
 80066b0:	22f0      	movs	r2, #240	; 0xf0
 80066b2:	689b      	ldr	r3, [r3, #8]
 80066b4:	fa92 f2a2 	rbit	r2, r2
 80066b8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80066bc:	fab2 f282 	clz	r2, r2
 80066c0:	4c04      	ldr	r4, [pc, #16]	; (80066d4 <HAL_RCC_GetHCLKFreq+0x2c>)
 80066c2:	4905      	ldr	r1, [pc, #20]	; (80066d8 <HAL_RCC_GetHCLKFreq+0x30>)
 80066c4:	40d3      	lsrs	r3, r2
 80066c6:	5ce3      	ldrb	r3, [r4, r3]
 80066c8:	40d8      	lsrs	r0, r3
 80066ca:	6008      	str	r0, [r1, #0]
  return SystemCoreClock;
}
 80066cc:	bd10      	pop	{r4, pc}
 80066ce:	bf00      	nop
 80066d0:	40021000 	.word	0x40021000
 80066d4:	0800c498 	.word	0x0800c498
 80066d8:	20000000 	.word	0x20000000

080066dc <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 80066dc:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 80066de:	f7ff ffe3 	bl	80066a8 <HAL_RCC_GetHCLKFreq>
 80066e2:	4b07      	ldr	r3, [pc, #28]	; (8006700 <HAL_RCC_GetPCLK1Freq+0x24>)
 80066e4:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 80066e8:	689b      	ldr	r3, [r3, #8]
 80066ea:	fa92 f2a2 	rbit	r2, r2
 80066ee:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80066f2:	fab2 f282 	clz	r2, r2
 80066f6:	4903      	ldr	r1, [pc, #12]	; (8006704 <HAL_RCC_GetPCLK1Freq+0x28>)
 80066f8:	40d3      	lsrs	r3, r2
 80066fa:	5ccb      	ldrb	r3, [r1, r3]
}
 80066fc:	40d8      	lsrs	r0, r3
 80066fe:	bd08      	pop	{r3, pc}
 8006700:	40021000 	.word	0x40021000
 8006704:	0800c4a8 	.word	0x0800c4a8

08006708 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8006708:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 800670a:	f7ff ffcd 	bl	80066a8 <HAL_RCC_GetHCLKFreq>
 800670e:	4b07      	ldr	r3, [pc, #28]	; (800672c <HAL_RCC_GetPCLK2Freq+0x24>)
 8006710:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006714:	689b      	ldr	r3, [r3, #8]
 8006716:	fa92 f2a2 	rbit	r2, r2
 800671a:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 800671e:	fab2 f282 	clz	r2, r2
 8006722:	4903      	ldr	r1, [pc, #12]	; (8006730 <HAL_RCC_GetPCLK2Freq+0x28>)
 8006724:	40d3      	lsrs	r3, r2
 8006726:	5ccb      	ldrb	r3, [r1, r3]
}
 8006728:	40d8      	lsrs	r0, r3
 800672a:	bd08      	pop	{r3, pc}
 800672c:	40021000 	.word	0x40021000
 8006730:	0800c4a8 	.word	0x0800c4a8

08006734 <HAL_RCC_GetOscConfig>:
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
 8006734:	221f      	movs	r2, #31
                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;

  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 8006736:	4b49      	ldr	r3, [pc, #292]	; (800685c <HAL_RCC_GetOscConfig+0x128>)
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
 8006738:	6002      	str	r2, [r0, #0]
                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;

  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 800673a:	681a      	ldr	r2, [r3, #0]
 800673c:	0352      	lsls	r2, r2, #13
 800673e:	d57d      	bpl.n	800683c <HAL_RCC_GetOscConfig+0x108>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
 8006740:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
 8006744:	6043      	str	r3, [r0, #4]
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }

   /* Get the MSI configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_MSION) == RCC_CR_MSION)
 8006746:	4b45      	ldr	r3, [pc, #276]	; (800685c <HAL_RCC_GetOscConfig+0x128>)
  else
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
  }

  RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->CR & RCC_ICSCR_MSITRIM) >> POSITION_VAL(RCC_ICSCR_MSITRIM));
 8006748:	4944      	ldr	r1, [pc, #272]	; (800685c <HAL_RCC_GetOscConfig+0x128>)
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }

   /* Get the MSI configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_MSION) == RCC_CR_MSION)
 800674a:	681b      	ldr	r3, [r3, #0]
 800674c:	f013 0301 	ands.w	r3, r3, #1
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_ON;
 8006750:	bf18      	it	ne
 8006752:	2301      	movne	r3, #1
  }
  else
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
 8006754:	6183      	str	r3, [r0, #24]
 8006756:	f44f 427f 	mov.w	r2, #65280	; 0xff00
  }

  RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->CR & RCC_ICSCR_MSITRIM) >> POSITION_VAL(RCC_ICSCR_MSITRIM));
 800675a:	680b      	ldr	r3, [r1, #0]
 800675c:	fa92 f2a2 	rbit	r2, r2
 8006760:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006764:	fab2 f282 	clz	r2, r2
 8006768:	40d3      	lsrs	r3, r2
 800676a:	61c3      	str	r3, [r0, #28]
  RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->CR & RCC_CR_MSIRANGE) );
 800676c:	680b      	ldr	r3, [r1, #0]
 800676e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8006772:	6203      	str	r3, [r0, #32]

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSION) == RCC_CR_HSION)
 8006774:	680b      	ldr	r3, [r1, #0]
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
  }

  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_HSITRIM) >> POSITION_VAL(RCC_ICSCR_HSITRIM));
 8006776:	4939      	ldr	r1, [pc, #228]	; (800685c <HAL_RCC_GetOscConfig+0x128>)

  RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->CR & RCC_ICSCR_MSITRIM) >> POSITION_VAL(RCC_ICSCR_MSITRIM));
  RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->CR & RCC_CR_MSIRANGE) );

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSION) == RCC_CR_HSION)
 8006778:	f413 7380 	ands.w	r3, r3, #256	; 0x100
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
 800677c:	bf18      	it	ne
 800677e:	f44f 7380 	movne.w	r3, #256	; 0x100
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
 8006782:	60c3      	str	r3, [r0, #12]
 8006784:	f04f 52f8 	mov.w	r2, #520093696	; 0x1f000000
  }

  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_HSITRIM) >> POSITION_VAL(RCC_ICSCR_HSITRIM));
 8006788:	684b      	ldr	r3, [r1, #4]
 800678a:	fa92 f2a2 	rbit	r2, r2
 800678e:	f003 53f8 	and.w	r3, r3, #520093696	; 0x1f000000
 8006792:	fab2 f282 	clz	r2, r2
 8006796:	40d3      	lsrs	r3, r2
 8006798:	6103      	str	r3, [r0, #16]

  /* Get the LSE configuration -----------------------------------------------*/
  if((RCC->BDCR & RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
 800679a:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
 800679e:	075b      	lsls	r3, r3, #29
 80067a0:	d554      	bpl.n	800684c <HAL_RCC_GetOscConfig+0x118>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
 80067a2:	2305      	movs	r3, #5
 80067a4:	6083      	str	r3, [r0, #8]
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
  }

  /* Get the LSI configuration -----------------------------------------------*/
  if((RCC->CSR & RCC_CSR_LSION) == RCC_CSR_LSION)
 80067a6:	4b2d      	ldr	r3, [pc, #180]	; (800685c <HAL_RCC_GetOscConfig+0x128>)
 80067a8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80067ac:	f013 0301 	ands.w	r3, r3, #1
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
 80067b0:	bf18      	it	ne
 80067b2:	2301      	movne	r3, #1
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
 80067b4:	6143      	str	r3, [r0, #20]
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_PLLON) == RCC_CR_PLLON)
 80067b6:	4b29      	ldr	r3, [pc, #164]	; (800685c <HAL_RCC_GetOscConfig+0x128>)
 80067b8:	681b      	ldr	r3, [r3, #0]
 80067ba:	01da      	lsls	r2, r3, #7
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
 80067bc:	bf4c      	ite	mi
 80067be:	2302      	movmi	r3, #2
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
 80067c0:	2301      	movpl	r3, #1
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80067c2:	4a26      	ldr	r2, [pc, #152]	; (800685c <HAL_RCC_GetOscConfig+0x128>)
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
 80067c4:	6243      	str	r3, [r0, #36]	; 0x24
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80067c6:	68d3      	ldr	r3, [r2, #12]
 80067c8:	f003 0303 	and.w	r3, r3, #3
 80067cc:	6283      	str	r3, [r0, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)(((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1);
 80067ce:	68d3      	ldr	r3, [r2, #12]
 80067d0:	2170      	movs	r1, #112	; 0x70
 80067d2:	fa91 f1a1 	rbit	r1, r1
 80067d6:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80067da:	fab1 f181 	clz	r1, r1
 80067de:	40cb      	lsrs	r3, r1
 80067e0:	3301      	adds	r3, #1
 80067e2:	62c3      	str	r3, [r0, #44]	; 0x2c
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 80067e4:	68d3      	ldr	r3, [r2, #12]
 80067e6:	f44f 41fe 	mov.w	r1, #32512	; 0x7f00
 80067ea:	fa91 f1a1 	rbit	r1, r1
 80067ee:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 80067f2:	fab1 f181 	clz	r1, r1
 80067f6:	40cb      	lsrs	r3, r1
 80067f8:	6303      	str	r3, [r0, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> POSITION_VAL(RCC_PLLCFGR_PLLQ)) + 1) << 1U);
 80067fa:	68d3      	ldr	r3, [r2, #12]
 80067fc:	f44f 01c0 	mov.w	r1, #6291456	; 0x600000
 8006800:	fa91 f1a1 	rbit	r1, r1
 8006804:	f403 03c0 	and.w	r3, r3, #6291456	; 0x600000
 8006808:	fab1 f181 	clz	r1, r1
 800680c:	40cb      	lsrs	r3, r1
 800680e:	3301      	adds	r3, #1
 8006810:	005b      	lsls	r3, r3, #1
 8006812:	6383      	str	r3, [r0, #56]	; 0x38
  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> POSITION_VAL(RCC_PLLCFGR_PLLR)) + 1) << 1U);
 8006814:	68d3      	ldr	r3, [r2, #12]
 8006816:	f04f 61c0 	mov.w	r1, #100663296	; 0x6000000
 800681a:	fa91 f1a1 	rbit	r1, r1
 800681e:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 8006822:	fab1 f181 	clz	r1, r1
 8006826:	40cb      	lsrs	r3, r1
 8006828:	3301      	adds	r3, #1
 800682a:	005b      	lsls	r3, r3, #1
 800682c:	63c3      	str	r3, [r0, #60]	; 0x3c
  if((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) != RESET)
 800682e:	68d3      	ldr	r3, [r2, #12]
 8006830:	039b      	lsls	r3, r3, #14
  {
    RCC_OscInitStruct->PLL.PLLP = RCC_PLLP_DIV17;
 8006832:	bf4c      	ite	mi
 8006834:	2311      	movmi	r3, #17
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLP = RCC_PLLP_DIV7;
 8006836:	2307      	movpl	r3, #7
 8006838:	6343      	str	r3, [r0, #52]	; 0x34
 800683a:	4770      	bx	lr
  /* Get the HSE configuration -----------------------------------------------*/
  if((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
  }
  else if((RCC->CR & RCC_CR_HSEON) == RCC_CR_HSEON)
 800683c:	681b      	ldr	r3, [r3, #0]
 800683e:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
 8006842:	bf18      	it	ne
 8006844:	f44f 3380 	movne.w	r3, #65536	; 0x10000
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
 8006848:	6043      	str	r3, [r0, #4]
 800684a:	e77c      	b.n	8006746 <HAL_RCC_GetOscConfig+0x12>
  /* Get the LSE configuration -----------------------------------------------*/
  if((RCC->BDCR & RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
  }
  else if((RCC->BDCR & RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
 800684c:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
 8006850:	f013 0301 	ands.w	r3, r3, #1
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
 8006854:	bf18      	it	ne
 8006856:	2301      	movne	r3, #1
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
 8006858:	6083      	str	r3, [r0, #8]
 800685a:	e7a4      	b.n	80067a6 <HAL_RCC_GetOscConfig+0x72>
 800685c:	40021000 	.word	0x40021000

08006860 <HAL_RCC_GetClockConfig>:
  *         will be configured.
  * @param  pFLatency  Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8006860:	b410      	push	{r4}

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8006862:	4b0e      	ldr	r3, [pc, #56]	; (800689c <HAL_RCC_GetClockConfig+0x3c>)

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8006864:	4c0e      	ldr	r4, [pc, #56]	; (80068a0 <HAL_RCC_GetClockConfig+0x40>)
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != NULL);
  assert_param(pFLatency != NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8006866:	220f      	movs	r2, #15
 8006868:	6002      	str	r2, [r0, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 800686a:	689a      	ldr	r2, [r3, #8]
 800686c:	f002 0203 	and.w	r2, r2, #3
 8006870:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8006872:	689a      	ldr	r2, [r3, #8]
 8006874:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8006878:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 800687a:	689a      	ldr	r2, [r3, #8]
 800687c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8006880:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8006882:	689b      	ldr	r3, [r3, #8]
 8006884:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 8006888:	08db      	lsrs	r3, r3, #3
 800688a:	6103      	str	r3, [r0, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800688c:	6823      	ldr	r3, [r4, #0]
}
 800688e:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8006892:	f003 0307 	and.w	r3, r3, #7
 8006896:	600b      	str	r3, [r1, #0]
}
 8006898:	4770      	bx	lr
 800689a:	bf00      	nop
 800689c:	40021000 	.word	0x40021000
 80068a0:	40022000 	.word	0x40022000

080068a4 <HAL_RCC_EnableCSS>:
  * @note   The Clock Security System can only be cleared by reset.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
  SET_BIT(RCC->CR, RCC_CR_CSSON) ;
 80068a4:	4a02      	ldr	r2, [pc, #8]	; (80068b0 <HAL_RCC_EnableCSS+0xc>)
 80068a6:	6813      	ldr	r3, [r2, #0]
 80068a8:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80068ac:	6013      	str	r3, [r2, #0]
 80068ae:	4770      	bx	lr
 80068b0:	40021000 	.word	0x40021000

080068b4 <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCC_CSSCallback(void)
{
 80068b4:	4770      	bx	lr
 80068b6:	bf00      	nop

080068b8 <HAL_RCC_NMI_IRQHandler>:
  * @brief Handle the RCC Clock Security System interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
 80068b8:	b510      	push	{r4, lr}
  /* Check RCC CSSF interrupt flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
 80068ba:	4c05      	ldr	r4, [pc, #20]	; (80068d0 <HAL_RCC_NMI_IRQHandler+0x18>)
 80068bc:	69e3      	ldr	r3, [r4, #28]
 80068be:	05db      	lsls	r3, r3, #23
 80068c0:	d504      	bpl.n	80068cc <HAL_RCC_NMI_IRQHandler+0x14>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CSSCallback();
 80068c2:	f7ff fff7 	bl	80068b4 <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 80068c6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80068ca:	6223      	str	r3, [r4, #32]
 80068cc:	bd10      	pop	{r4, pc}
 80068ce:	bf00      	nop
 80068d0:	40021000 	.word	0x40021000

080068d4 <RCCEx_PLLSAI1_ConfigNP>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNP(RCC_PLLSAI1InitTypeDef *PllSai1)
{
 80068d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1P_VALUE(PllSai1->PLLSAI1P));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 80068d6:	4d2b      	ldr	r5, [pc, #172]	; (8006984 <RCCEx_PLLSAI1_ConfigNP+0xb0>)
 80068d8:	682b      	ldr	r3, [r5, #0]
 80068da:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80068de:	602b      	str	r3, [r5, #0]
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNP(RCC_PLLSAI1InitTypeDef *PllSai1)
{
 80068e0:	4604      	mov	r4, r0

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80068e2:	f7fa f911 	bl	8000b08 <HAL_GetTick>
 80068e6:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
 80068ea:	4606      	mov	r6, r0

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
 80068ec:	e005      	b.n	80068fa <RCCEx_PLLSAI1_ConfigNP+0x26>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80068ee:	f7fa f90b 	bl	8000b08 <HAL_GetTick>
 80068f2:	1b80      	subs	r0, r0, r6
 80068f4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80068f8:	d841      	bhi.n	800697e <RCCEx_PLLSAI1_ConfigNP+0xaa>
 80068fa:	fa97 f3a7 	rbit	r3, r7

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
 80068fe:	4921      	ldr	r1, [pc, #132]	; (8006984 <RCCEx_PLLSAI1_ConfigNP+0xb0>)
 8006900:	682a      	ldr	r2, [r5, #0]
 8006902:	fa97 f3a7 	rbit	r3, r7
 8006906:	fab3 f383 	clz	r3, r3
 800690a:	f003 031f 	and.w	r3, r3, #31
 800690e:	fa22 f303 	lsr.w	r3, r2, r3
 8006912:	07da      	lsls	r2, r3, #31
 8006914:	d4eb      	bmi.n	80068ee <RCCEx_PLLSAI1_ConfigNP+0x1a>
  }

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PllSai1->PLLSAI1N);
 8006916:	690b      	ldr	r3, [r1, #16]
 8006918:	6822      	ldr	r2, [r4, #0]
 800691a:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800691e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006922:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor P */
    __HAL_RCC_PLLSAI1_DIVP_CONFIG(PllSai1->PLLSAI1P);
 8006924:	690b      	ldr	r3, [r1, #16]
 8006926:	6860      	ldr	r0, [r4, #4]
 8006928:	f423 3200 	bic.w	r2, r3, #131072	; 0x20000
 800692c:	0903      	lsrs	r3, r0, #4
 800692e:	ea42 4343 	orr.w	r3, r2, r3, lsl #17
 8006932:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 8006934:	680b      	ldr	r3, [r1, #0]
 8006936:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800693a:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 800693c:	460d      	mov	r5, r1

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800693e:	f7fa f8e3 	bl	8000b08 <HAL_GetTick>
 8006942:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
 8006946:	4606      	mov	r6, r0

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 8006948:	e005      	b.n	8006956 <RCCEx_PLLSAI1_ConfigNP+0x82>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800694a:	f7fa f8dd 	bl	8000b08 <HAL_GetTick>
 800694e:	1b80      	subs	r0, r0, r6
 8006950:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8006954:	d813      	bhi.n	800697e <RCCEx_PLLSAI1_ConfigNP+0xaa>
 8006956:	fa97 f3a7 	rbit	r3, r7

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 800695a:	490a      	ldr	r1, [pc, #40]	; (8006984 <RCCEx_PLLSAI1_ConfigNP+0xb0>)
 800695c:	682a      	ldr	r2, [r5, #0]
 800695e:	fa97 f3a7 	rbit	r3, r7
 8006962:	fab3 f383 	clz	r3, r3
 8006966:	f003 031f 	and.w	r3, r3, #31
 800696a:	fa22 f303 	lsr.w	r3, r2, r3
 800696e:	07db      	lsls	r3, r3, #31
 8006970:	d5eb      	bpl.n	800694a <RCCEx_PLLSAI1_ConfigNP+0x76>
    }

    if(status == HAL_OK)    
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8006972:	6923      	ldr	r3, [r4, #16]
 8006974:	690a      	ldr	r2, [r1, #16]
 8006976:	4313      	orrs	r3, r2
 8006978:	610b      	str	r3, [r1, #16]
 800697a:	2000      	movs	r0, #0
    }
  }
  
  return status;
}
 800697c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
    {
      status = HAL_TIMEOUT;
 800697e:	2003      	movs	r0, #3
 8006980:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006982:	bf00      	nop
 8006984:	40021000 	.word	0x40021000

08006988 <RCCEx_PLLSAI2_ConfigNP>:
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_ConfigNP(RCC_PLLSAI2InitTypeDef *PllSai2)
{
 8006988:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2P_VALUE(PllSai2->PLLSAI2P));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();
 800698a:	4d2b      	ldr	r5, [pc, #172]	; (8006a38 <RCCEx_PLLSAI2_ConfigNP+0xb0>)
 800698c:	682b      	ldr	r3, [r5, #0]
 800698e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8006992:	602b      	str	r3, [r5, #0]
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_ConfigNP(RCC_PLLSAI2InitTypeDef *PllSai2)
{
 8006994:	4604      	mov	r4, r0

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8006996:	f7fa f8b7 	bl	8000b08 <HAL_GetTick>
 800699a:	f04f 5700 	mov.w	r7, #536870912	; 0x20000000
 800699e:	4606      	mov	r6, r0

  /* Wait till PLLSAI2 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
 80069a0:	e005      	b.n	80069ae <RCCEx_PLLSAI2_ConfigNP+0x26>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 80069a2:	f7fa f8b1 	bl	8000b08 <HAL_GetTick>
 80069a6:	1b80      	subs	r0, r0, r6
 80069a8:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80069ac:	d841      	bhi.n	8006a32 <RCCEx_PLLSAI2_ConfigNP+0xaa>
 80069ae:	fa97 f3a7 	rbit	r3, r7

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till PLLSAI2 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
 80069b2:	4921      	ldr	r1, [pc, #132]	; (8006a38 <RCCEx_PLLSAI2_ConfigNP+0xb0>)
 80069b4:	682a      	ldr	r2, [r5, #0]
 80069b6:	fa97 f3a7 	rbit	r3, r7
 80069ba:	fab3 f383 	clz	r3, r3
 80069be:	f003 031f 	and.w	r3, r3, #31
 80069c2:	fa22 f303 	lsr.w	r3, r2, r3
 80069c6:	07da      	lsls	r2, r3, #31
 80069c8:	d4eb      	bmi.n	80069a2 <RCCEx_PLLSAI2_ConfigNP+0x1a>
  }

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI2 Multiplication factor N */
    __HAL_RCC_PLLSAI2_MULN_CONFIG(PllSai2->PLLSAI2N);
 80069ca:	694b      	ldr	r3, [r1, #20]
 80069cc:	6822      	ldr	r2, [r4, #0]
 80069ce:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 80069d2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80069d6:	614b      	str	r3, [r1, #20]
    /* Configure the PLLSAI2 Division factor P */
    __HAL_RCC_PLLSAI2_DIVP_CONFIG(PllSai2->PLLSAI2P);
 80069d8:	694b      	ldr	r3, [r1, #20]
 80069da:	6860      	ldr	r0, [r4, #4]
 80069dc:	f423 3200 	bic.w	r2, r3, #131072	; 0x20000
 80069e0:	0903      	lsrs	r3, r0, #4
 80069e2:	ea42 4343 	orr.w	r3, r2, r3, lsl #17
 80069e6:	614b      	str	r3, [r1, #20]

    /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
    __HAL_RCC_PLLSAI2_ENABLE();
 80069e8:	680b      	ldr	r3, [r1, #0]
 80069ea:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80069ee:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
 80069f0:	460d      	mov	r5, r1

    /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
    __HAL_RCC_PLLSAI2_ENABLE();

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80069f2:	f7fa f889 	bl	8000b08 <HAL_GetTick>
 80069f6:	f04f 5700 	mov.w	r7, #536870912	; 0x20000000
 80069fa:	4606      	mov	r6, r0

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
 80069fc:	e005      	b.n	8006a0a <RCCEx_PLLSAI2_ConfigNP+0x82>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 80069fe:	f7fa f883 	bl	8000b08 <HAL_GetTick>
 8006a02:	1b80      	subs	r0, r0, r6
 8006a04:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8006a08:	d813      	bhi.n	8006a32 <RCCEx_PLLSAI2_ConfigNP+0xaa>
 8006a0a:	fa97 f3a7 	rbit	r3, r7

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
 8006a0e:	490a      	ldr	r1, [pc, #40]	; (8006a38 <RCCEx_PLLSAI2_ConfigNP+0xb0>)
 8006a10:	682a      	ldr	r2, [r5, #0]
 8006a12:	fa97 f3a7 	rbit	r3, r7
 8006a16:	fab3 f383 	clz	r3, r3
 8006a1a:	f003 031f 	and.w	r3, r3, #31
 8006a1e:	fa22 f303 	lsr.w	r3, r2, r3
 8006a22:	07db      	lsls	r3, r3, #31
 8006a24:	d5eb      	bpl.n	80069fe <RCCEx_PLLSAI2_ConfigNP+0x76>
    }
    
    if(status == HAL_OK)
    {
      /* Configure the PLLSAI2 Clock output(s) */
      __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 8006a26:	68e3      	ldr	r3, [r4, #12]
 8006a28:	694a      	ldr	r2, [r1, #20]
 8006a2a:	4313      	orrs	r3, r2
 8006a2c:	614b      	str	r3, [r1, #20]
 8006a2e:	2000      	movs	r0, #0
    }
  }
  
  return status;
}
 8006a30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* Wait till PLLSAI2 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
    {
      status = HAL_TIMEOUT;
 8006a32:	2003      	movs	r0, #3
 8006a34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006a36:	bf00      	nop
 8006a38:	40021000 	.word	0x40021000

08006a3c <RCCEx_PLLSAI1_ConfigNQ>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNQ(RCC_PLLSAI1InitTypeDef *PllSai1)
{
 8006a3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8006a3e:	4d2b      	ldr	r5, [pc, #172]	; (8006aec <RCCEx_PLLSAI1_ConfigNQ+0xb0>)
 8006a40:	682b      	ldr	r3, [r5, #0]
 8006a42:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8006a46:	602b      	str	r3, [r5, #0]
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNQ(RCC_PLLSAI1InitTypeDef *PllSai1)
{
 8006a48:	4604      	mov	r4, r0

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8006a4a:	f7fa f85d 	bl	8000b08 <HAL_GetTick>
 8006a4e:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
 8006a52:	4606      	mov	r6, r0

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
 8006a54:	e005      	b.n	8006a62 <RCCEx_PLLSAI1_ConfigNQ+0x26>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8006a56:	f7fa f857 	bl	8000b08 <HAL_GetTick>
 8006a5a:	1b80      	subs	r0, r0, r6
 8006a5c:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8006a60:	d842      	bhi.n	8006ae8 <RCCEx_PLLSAI1_ConfigNQ+0xac>
 8006a62:	fa97 f3a7 	rbit	r3, r7

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
 8006a66:	4921      	ldr	r1, [pc, #132]	; (8006aec <RCCEx_PLLSAI1_ConfigNQ+0xb0>)
 8006a68:	682a      	ldr	r2, [r5, #0]
 8006a6a:	fa97 f3a7 	rbit	r3, r7
 8006a6e:	fab3 f383 	clz	r3, r3
 8006a72:	f003 031f 	and.w	r3, r3, #31
 8006a76:	fa22 f303 	lsr.w	r3, r2, r3
 8006a7a:	07da      	lsls	r2, r3, #31
 8006a7c:	d4eb      	bmi.n	8006a56 <RCCEx_PLLSAI1_ConfigNQ+0x1a>
  }

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PllSai1->PLLSAI1N);
 8006a7e:	690b      	ldr	r3, [r1, #16]
 8006a80:	6822      	ldr	r2, [r4, #0]
 8006a82:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8006a86:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006a8a:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor Q */
    __HAL_RCC_PLLSAI1_DIVQ_CONFIG(PllSai1->PLLSAI1Q);
 8006a8c:	68a2      	ldr	r2, [r4, #8]
 8006a8e:	690b      	ldr	r3, [r1, #16]
 8006a90:	0852      	lsrs	r2, r2, #1
 8006a92:	3a01      	subs	r2, #1
 8006a94:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
 8006a98:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 8006a9c:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 8006a9e:	680b      	ldr	r3, [r1, #0]
 8006aa0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8006aa4:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 8006aa6:	460d      	mov	r5, r1

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8006aa8:	f7fa f82e 	bl	8000b08 <HAL_GetTick>
 8006aac:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
 8006ab0:	4606      	mov	r6, r0

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 8006ab2:	e005      	b.n	8006ac0 <RCCEx_PLLSAI1_ConfigNQ+0x84>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8006ab4:	f7fa f828 	bl	8000b08 <HAL_GetTick>
 8006ab8:	1b80      	subs	r0, r0, r6
 8006aba:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8006abe:	d813      	bhi.n	8006ae8 <RCCEx_PLLSAI1_ConfigNQ+0xac>
 8006ac0:	fa97 f3a7 	rbit	r3, r7

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 8006ac4:	4909      	ldr	r1, [pc, #36]	; (8006aec <RCCEx_PLLSAI1_ConfigNQ+0xb0>)
 8006ac6:	682a      	ldr	r2, [r5, #0]
 8006ac8:	fa97 f3a7 	rbit	r3, r7
 8006acc:	fab3 f383 	clz	r3, r3
 8006ad0:	f003 031f 	and.w	r3, r3, #31
 8006ad4:	fa22 f303 	lsr.w	r3, r2, r3
 8006ad8:	07db      	lsls	r3, r3, #31
 8006ada:	d5eb      	bpl.n	8006ab4 <RCCEx_PLLSAI1_ConfigNQ+0x78>
    }

    if(status == HAL_OK)
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8006adc:	6923      	ldr	r3, [r4, #16]
 8006ade:	690a      	ldr	r2, [r1, #16]
 8006ae0:	4313      	orrs	r3, r2
 8006ae2:	610b      	str	r3, [r1, #16]
 8006ae4:	2000      	movs	r0, #0
    }
  }
  
  return status;
}
 8006ae6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
    {
      status = HAL_TIMEOUT;
 8006ae8:	2003      	movs	r0, #3
 8006aea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006aec:	40021000 	.word	0x40021000

08006af0 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8006af0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8006af4:	6803      	ldr	r3, [r0, #0]
 8006af6:	f413 6600 	ands.w	r6, r3, #2048	; 0x800
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8006afa:	b082      	sub	sp, #8
 8006afc:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8006afe:	d018      	beq.n	8006b32 <HAL_RCCEx_PeriphCLKConfig+0x42>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch(PeriphClkInit->Sai1ClockSelection)
 8006b00:	6d42      	ldr	r2, [r0, #84]	; 0x54
 8006b02:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 8006b06:	f000 81ba 	beq.w	8006e7e <HAL_RCCEx_PeriphCLKConfig+0x38e>
 8006b0a:	f240 8213 	bls.w	8006f34 <HAL_RCCEx_PeriphCLKConfig+0x444>
 8006b0e:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 8006b12:	f000 819b 	beq.w	8006e4c <HAL_RCCEx_PeriphCLKConfig+0x35c>
 8006b16:	f5b2 0f40 	cmp.w	r2, #12582912	; 0xc00000
 8006b1a:	f040 8219 	bne.w	8006f50 <HAL_RCCEx_PeriphCLKConfig+0x460>
    }

    if(ret == HAL_OK)
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8006b1e:	49bb      	ldr	r1, [pc, #748]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006b20:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8006b24:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8006b28:	431a      	orrs	r2, r3
 8006b2a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
 8006b2e:	6823      	ldr	r3, [r4, #0]
 8006b30:	2600      	movs	r6, #0
      status = ret;
    }
  }

  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8006b32:	04df      	lsls	r7, r3, #19
 8006b34:	f140 8114 	bpl.w	8006d60 <HAL_RCCEx_PeriphCLKConfig+0x270>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch(PeriphClkInit->Sai2ClockSelection)
 8006b38:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8006b3a:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
 8006b3e:	f000 8198 	beq.w	8006e72 <HAL_RCCEx_PeriphCLKConfig+0x382>
 8006b42:	f240 81fd 	bls.w	8006f40 <HAL_RCCEx_PeriphCLKConfig+0x450>
 8006b46:	f1b2 7f00 	cmp.w	r2, #33554432	; 0x2000000
 8006b4a:	f000 8186 	beq.w	8006e5a <HAL_RCCEx_PeriphCLKConfig+0x36a>
 8006b4e:	f1b2 7f40 	cmp.w	r2, #50331648	; 0x3000000
 8006b52:	f040 8104 	bne.w	8006d5e <HAL_RCCEx_PeriphCLKConfig+0x26e>
 8006b56:	4637      	mov	r7, r6
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
 8006b58:	2f00      	cmp	r7, #0
 8006b5a:	f040 8187 	bne.w	8006e6c <HAL_RCCEx_PeriphCLKConfig+0x37c>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8006b5e:	49ab      	ldr	r1, [pc, #684]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006b60:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8006b62:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006b66:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8006b6a:	4313      	orrs	r3, r2
 8006b6c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006b70:	6823      	ldr	r3, [r4, #0]
      status = ret;
    }
  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8006b72:	039d      	lsls	r5, r3, #14
 8006b74:	f100 80f8 	bmi.w	8006d68 <HAL_RCCEx_PeriphCLKConfig+0x278>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8006b78:	07d8      	lsls	r0, r3, #31
 8006b7a:	d509      	bpl.n	8006b90 <HAL_RCCEx_PeriphCLKConfig+0xa0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8006b7c:	49a3      	ldr	r1, [pc, #652]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006b7e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8006b80:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006b84:	f022 0203 	bic.w	r2, r2, #3
 8006b88:	4313      	orrs	r3, r2
 8006b8a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006b8e:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8006b90:	0799      	lsls	r1, r3, #30
 8006b92:	d509      	bpl.n	8006ba8 <HAL_RCCEx_PeriphCLKConfig+0xb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8006b94:	499d      	ldr	r1, [pc, #628]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006b96:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006b98:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006b9c:	f022 020c 	bic.w	r2, r2, #12
 8006ba0:	4313      	orrs	r3, r2
 8006ba2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006ba6:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8006ba8:	075a      	lsls	r2, r3, #29
 8006baa:	d509      	bpl.n	8006bc0 <HAL_RCCEx_PeriphCLKConfig+0xd0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8006bac:	4997      	ldr	r1, [pc, #604]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006bae:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8006bb0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006bb4:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8006bb8:	4313      	orrs	r3, r2
 8006bba:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006bbe:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8006bc0:	071f      	lsls	r7, r3, #28
 8006bc2:	d509      	bpl.n	8006bd8 <HAL_RCCEx_PeriphCLKConfig+0xe8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8006bc4:	4991      	ldr	r1, [pc, #580]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006bc6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8006bc8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006bcc:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8006bd0:	4313      	orrs	r3, r2
 8006bd2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006bd6:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8006bd8:	06dd      	lsls	r5, r3, #27
 8006bda:	d509      	bpl.n	8006bf0 <HAL_RCCEx_PeriphCLKConfig+0x100>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8006bdc:	498b      	ldr	r1, [pc, #556]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006bde:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006be0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006be4:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8006be8:	4313      	orrs	r3, r2
 8006bea:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006bee:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8006bf0:	0698      	lsls	r0, r3, #26
 8006bf2:	d509      	bpl.n	8006c08 <HAL_RCCEx_PeriphCLKConfig+0x118>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8006bf4:	4985      	ldr	r1, [pc, #532]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006bf6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8006bf8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006bfc:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8006c00:	4313      	orrs	r3, r2
 8006c02:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006c06:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8006c08:	0599      	lsls	r1, r3, #22
 8006c0a:	d509      	bpl.n	8006c20 <HAL_RCCEx_PeriphCLKConfig+0x130>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8006c0c:	497f      	ldr	r1, [pc, #508]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006c0e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8006c10:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006c14:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8006c18:	4313      	orrs	r3, r2
 8006c1a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006c1e:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8006c20:	055a      	lsls	r2, r3, #21
 8006c22:	d509      	bpl.n	8006c38 <HAL_RCCEx_PeriphCLKConfig+0x148>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8006c24:	4979      	ldr	r1, [pc, #484]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006c26:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8006c28:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006c2c:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8006c30:	4313      	orrs	r3, r2
 8006c32:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006c36:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8006c38:	065f      	lsls	r7, r3, #25
 8006c3a:	d509      	bpl.n	8006c50 <HAL_RCCEx_PeriphCLKConfig+0x160>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8006c3c:	4973      	ldr	r1, [pc, #460]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006c3e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8006c40:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006c44:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8006c48:	4313      	orrs	r3, r2
 8006c4a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006c4e:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8006c50:	061d      	lsls	r5, r3, #24
 8006c52:	d509      	bpl.n	8006c68 <HAL_RCCEx_PeriphCLKConfig+0x178>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8006c54:	496d      	ldr	r1, [pc, #436]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006c56:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8006c58:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006c5c:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8006c60:	4313      	orrs	r3, r2
 8006c62:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006c66:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8006c68:	05d8      	lsls	r0, r3, #23
 8006c6a:	d509      	bpl.n	8006c80 <HAL_RCCEx_PeriphCLKConfig+0x190>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8006c6c:	4967      	ldr	r1, [pc, #412]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006c6e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8006c70:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006c74:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8006c78:	4313      	orrs	r3, r2
 8006c7a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006c7e:	6823      	ldr	r3, [r4, #0]
  }

#if defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)
  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8006c80:	0499      	lsls	r1, r3, #18
 8006c82:	d512      	bpl.n	8006caa <HAL_RCCEx_PeriphCLKConfig+0x1ba>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8006c84:	4961      	ldr	r1, [pc, #388]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006c86:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8006c88:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006c8c:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 8006c90:	4313      	orrs	r3, r2
 8006c92:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8006c96:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8006c98:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8006c9c:	f000 80d0 	beq.w	8006e40 <HAL_RCCEx_PeriphCLKConfig+0x350>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
    else if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8006ca0:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8006ca4:	f000 81f3 	beq.w	800708e <HAL_RCCEx_PeriphCLKConfig+0x59e>
 8006ca8:	6823      	ldr	r3, [r4, #0]
    }
  }
#endif /* STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8006caa:	031a      	lsls	r2, r3, #12
 8006cac:	d512      	bpl.n	8006cd4 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8006cae:	4957      	ldr	r1, [pc, #348]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006cb0:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8006cb2:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006cb6:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 8006cba:	4313      	orrs	r3, r2
 8006cbc:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)
 8006cc0:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8006cc2:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8006cc6:	f000 80b5 	beq.w	8006e34 <HAL_RCCEx_PeriphCLKConfig+0x344>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 8006cca:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8006cce:	f000 81d5 	beq.w	800707c <HAL_RCCEx_PeriphCLKConfig+0x58c>
 8006cd2:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8006cd4:	035f      	lsls	r7, r3, #13
 8006cd6:	d512      	bpl.n	8006cfe <HAL_RCCEx_PeriphCLKConfig+0x20e>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8006cd8:	494c      	ldr	r1, [pc, #304]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006cda:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8006cdc:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006ce0:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 8006ce4:	4313      	orrs	r3, r2
 8006ce6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8006cea:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8006cec:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8006cf0:	f000 809a 	beq.w	8006e28 <HAL_RCCEx_PeriphCLKConfig+0x338>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8006cf4:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8006cf8:	f000 81b7 	beq.w	800706a <HAL_RCCEx_PeriphCLKConfig+0x57a>
 8006cfc:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8006cfe:	045d      	lsls	r5, r3, #17
 8006d00:	d512      	bpl.n	8006d28 <HAL_RCCEx_PeriphCLKConfig+0x238>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8006d02:	4d42      	ldr	r5, [pc, #264]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006d04:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8006d06:	f8d5 2088 	ldr.w	r2, [r5, #136]	; 0x88
 8006d0a:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8006d0e:	4313      	orrs	r3, r2
 8006d10:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
    
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8006d14:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8006d16:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8006d1a:	f000 80b9 	beq.w	8006e90 <HAL_RCCEx_PeriphCLKConfig+0x3a0>
      {
        /* set overall return value */
        status = ret;
      }
    }
    else if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI2)
 8006d1e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8006d22:	f000 814e 	beq.w	8006fc2 <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 8006d26:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /*-------------------------- SWPMI1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8006d28:	041a      	lsls	r2, r3, #16
 8006d2a:	d509      	bpl.n	8006d40 <HAL_RCCEx_PeriphCLKConfig+0x250>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 8006d2c:	4937      	ldr	r1, [pc, #220]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006d2e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006d30:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8006d34:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8006d38:	4313      	orrs	r3, r2
 8006d3a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8006d3e:	6823      	ldr	r3, [r4, #0]
  }

  /*-------------------------- DFSDM clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM) == RCC_PERIPHCLK_DFSDM)
 8006d40:	03db      	lsls	r3, r3, #15
 8006d42:	d508      	bpl.n	8006d56 <HAL_RCCEx_PeriphCLKConfig+0x266>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDMCLKSOURCE(PeriphClkInit->DfsdmClockSelection));

    /* Configure the DFSDM interface clock source */
    __HAL_RCC_DFSDM_CONFIG(PeriphClkInit->DfsdmClockSelection);
 8006d44:	4931      	ldr	r1, [pc, #196]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006d46:	6f22      	ldr	r2, [r4, #112]	; 0x70
 8006d48:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8006d4c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8006d50:	4313      	orrs	r3, r2
 8006d52:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  return status;
}
 8006d56:	4630      	mov	r0, r6
 8006d58:	b002      	add	sp, #8
 8006d5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    case RCC_SAI2CLKSOURCE_PIN:      /* External clock is used as source of SAI2 clock*/
      /* SAI2 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8006d5e:	2601      	movs	r6, #1
 8006d60:	4637      	mov	r7, r6
      status = ret;
    }
  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8006d62:	039d      	lsls	r5, r3, #14
 8006d64:	f57f af08 	bpl.w	8006b78 <HAL_RCCEx_PeriphCLKConfig+0x88>
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8006d68:	4b28      	ldr	r3, [pc, #160]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006d6a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8006d6c:	00d0      	lsls	r0, r2, #3
 8006d6e:	d541      	bpl.n	8006df4 <HAL_RCCEx_PeriphCLKConfig+0x304>
  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
  {
    FlagStatus       pwrclkchanged = RESET;
 8006d70:	f04f 0800 	mov.w	r8, #0
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
      
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8006d74:	4d26      	ldr	r5, [pc, #152]	; (8006e10 <HAL_RCCEx_PeriphCLKConfig+0x320>)
 8006d76:	682b      	ldr	r3, [r5, #0]
 8006d78:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006d7c:	602b      	str	r3, [r5, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8006d7e:	f7f9 fec3 	bl	8000b08 <HAL_GetTick>
 8006d82:	4681      	mov	r9, r0

    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8006d84:	e005      	b.n	8006d92 <HAL_RCCEx_PeriphCLKConfig+0x2a2>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8006d86:	f7f9 febf 	bl	8000b08 <HAL_GetTick>
 8006d8a:	ebc9 0000 	rsb	r0, r9, r0
 8006d8e:	2864      	cmp	r0, #100	; 0x64
 8006d90:	d840      	bhi.n	8006e14 <HAL_RCCEx_PeriphCLKConfig+0x324>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();

    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8006d92:	682b      	ldr	r3, [r5, #0]
 8006d94:	05d9      	lsls	r1, r3, #23
 8006d96:	d5f6      	bpl.n	8006d86 <HAL_RCCEx_PeriphCLKConfig+0x296>
        ret = HAL_TIMEOUT;
        break;
      }
    }

    if(ret == HAL_OK)
 8006d98:	2f00      	cmp	r7, #0
 8006d9a:	f040 8181 	bne.w	80070a0 <HAL_RCCEx_PeriphCLKConfig+0x5b0>
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL) != PeriphClkInit->RTCClockSelection)
 8006d9e:	4d1b      	ldr	r5, [pc, #108]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006da0:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8006da2:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8006da6:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8006daa:	4293      	cmp	r3, r2
 8006dac:	d015      	beq.n	8006dda <HAL_RCCEx_PeriphCLKConfig+0x2ea>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8006dae:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8006db2:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8006db6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006dba:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8006dbe:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL) != PeriphClkInit->RTCClockSelection)
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8006dc2:	f422 7140 	bic.w	r1, r2, #768	; 0x300
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
        __HAL_RCC_BACKUPRESET_RELEASE();
 8006dc6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 8006dca:	0792      	lsls	r2, r2, #30
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
        __HAL_RCC_BACKUPRESET_RELEASE();
 8006dcc:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8006dd0:	f8c5 1090 	str.w	r1, [r5, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 8006dd4:	f100 80c1 	bmi.w	8006f5a <HAL_RCCEx_PeriphCLKConfig+0x46a>
 8006dd8:	6f62      	ldr	r2, [r4, #116]	; 0x74
      }
      
      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8006dda:	490c      	ldr	r1, [pc, #48]	; (8006e0c <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8006ddc:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
 8006de0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8006de4:	431a      	orrs	r2, r3
 8006de6:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
      /* set overall return value */
      status = ret;
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8006dea:	f1b8 0f00 	cmp.w	r8, #0
 8006dee:	d115      	bne.n	8006e1c <HAL_RCCEx_PeriphCLKConfig+0x32c>
 8006df0:	6823      	ldr	r3, [r4, #0]
 8006df2:	e6c1      	b.n	8006b78 <HAL_RCCEx_PeriphCLKConfig+0x88>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8006df4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8006df6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8006dfa:	659a      	str	r2, [r3, #88]	; 0x58
 8006dfc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8006dfe:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8006e02:	9301      	str	r3, [sp, #4]
 8006e04:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8006e06:	f04f 0801 	mov.w	r8, #1
 8006e0a:	e7b3      	b.n	8006d74 <HAL_RCCEx_PeriphCLKConfig+0x284>
 8006e0c:	40021000 	.word	0x40021000
 8006e10:	40007000 	.word	0x40007000

    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
      {
        ret = HAL_TIMEOUT;
 8006e14:	2603      	movs	r6, #3
      /* set overall return value */
      status = ret;
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8006e16:	f1b8 0f00 	cmp.w	r8, #0
 8006e1a:	d0e9      	beq.n	8006df0 <HAL_RCCEx_PeriphCLKConfig+0x300>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8006e1c:	4aa1      	ldr	r2, [pc, #644]	; (80070a4 <HAL_RCCEx_PeriphCLKConfig+0x5b4>)
 8006e1e:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8006e20:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8006e24:	6593      	str	r3, [r2, #88]	; 0x58
 8006e26:	e7e3      	b.n	8006df0 <HAL_RCCEx_PeriphCLKConfig+0x300>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8006e28:	68cb      	ldr	r3, [r1, #12]
 8006e2a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8006e2e:	60cb      	str	r3, [r1, #12]
 8006e30:	6823      	ldr	r3, [r4, #0]
 8006e32:	e764      	b.n	8006cfe <HAL_RCCEx_PeriphCLKConfig+0x20e>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
    
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8006e34:	68cb      	ldr	r3, [r1, #12]
 8006e36:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8006e3a:	60cb      	str	r3, [r1, #12]
 8006e3c:	6823      	ldr	r3, [r4, #0]
 8006e3e:	e749      	b.n	8006cd4 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8006e40:	68cb      	ldr	r3, [r1, #12]
 8006e42:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8006e46:	60cb      	str	r3, [r1, #12]
 8006e48:	6823      	ldr	r3, [r4, #0]
 8006e4a:	e72e      	b.n	8006caa <HAL_RCCEx_PeriphCLKConfig+0x1ba>

    switch(PeriphClkInit->Sai1ClockSelection)
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8006e4c:	4a95      	ldr	r2, [pc, #596]	; (80070a4 <HAL_RCCEx_PeriphCLKConfig+0x5b4>)
 8006e4e:	68d3      	ldr	r3, [r2, #12]
 8006e50:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006e54:	60d3      	str	r3, [r2, #12]
 8006e56:	6d42      	ldr	r2, [r0, #84]	; 0x54
      /* SAI1 clock source config set later after clock selection check */
      break;
 8006e58:	e661      	b.n	8006b1e <HAL_RCCEx_PeriphCLKConfig+0x2e>

    switch(PeriphClkInit->Sai2ClockSelection)
    {
    case RCC_SAI2CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8006e5a:	4a92      	ldr	r2, [pc, #584]	; (80070a4 <HAL_RCCEx_PeriphCLKConfig+0x5b4>)
 8006e5c:	68d3      	ldr	r3, [r2, #12]
      /* SAI2 clock source config set later after clock selection check */
      break;
 8006e5e:	4637      	mov	r7, r6

    switch(PeriphClkInit->Sai2ClockSelection)
    {
    case RCC_SAI2CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8006e60:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006e64:	60d3      	str	r3, [r2, #12]
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
 8006e66:	2f00      	cmp	r7, #0
 8006e68:	f43f ae79 	beq.w	8006b5e <HAL_RCCEx_PeriphCLKConfig+0x6e>
 8006e6c:	6823      	ldr	r3, [r4, #0]
 8006e6e:	463e      	mov	r6, r7
 8006e70:	e777      	b.n	8006d62 <HAL_RCCEx_PeriphCLKConfig+0x272>
      /* SAI2 clock source config set later after clock selection check */
      break;

    case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
      /* PLLSAI2 parameters N & P configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_ConfigNP(&(PeriphClkInit->PLLSAI2));
 8006e72:	f104 0018 	add.w	r0, r4, #24
 8006e76:	f7ff fd87 	bl	8006988 <RCCEx_PLLSAI2_ConfigNP>
 8006e7a:	4607      	mov	r7, r0
      /* SAI2 clock source config set later after clock selection check */
      break;
 8006e7c:	e66c      	b.n	8006b58 <HAL_RCCEx_PeriphCLKConfig+0x68>
      /* SAI1 clock source config set later after clock selection check */
      break;

    case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
      /* PLLSAI2 parameters N & P configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_ConfigNP(&(PeriphClkInit->PLLSAI2));
 8006e7e:	3018      	adds	r0, #24
 8006e80:	f7ff fd82 	bl	8006988 <RCCEx_PLLSAI2_ConfigNP>
 8006e84:	4606      	mov	r6, r0
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
 8006e86:	2e00      	cmp	r6, #0
 8006e88:	f000 80ed 	beq.w	8007066 <HAL_RCCEx_PeriphCLKConfig+0x576>
 8006e8c:	6823      	ldr	r3, [r4, #0]
 8006e8e:	e650      	b.n	8006b32 <HAL_RCCEx_PeriphCLKConfig+0x42>
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8006e90:	682b      	ldr	r3, [r5, #0]
 8006e92:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8006e96:	602b      	str	r3, [r5, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8006e98:	f7f9 fe36 	bl	8000b08 <HAL_GetTick>
 8006e9c:	f04f 6800 	mov.w	r8, #134217728	; 0x8000000
 8006ea0:	4607      	mov	r7, r0
 8006ea2:	e005      	b.n	8006eb0 <HAL_RCCEx_PeriphCLKConfig+0x3c0>

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8006ea4:	f7f9 fe30 	bl	8000b08 <HAL_GetTick>
 8006ea8:	1bc0      	subs	r0, r0, r7
 8006eaa:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8006eae:	d851      	bhi.n	8006f54 <HAL_RCCEx_PeriphCLKConfig+0x464>
 8006eb0:	fa98 f3a8 	rbit	r3, r8

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
 8006eb4:	497b      	ldr	r1, [pc, #492]	; (80070a4 <HAL_RCCEx_PeriphCLKConfig+0x5b4>)
 8006eb6:	682a      	ldr	r2, [r5, #0]
 8006eb8:	fa98 f3a8 	rbit	r3, r8
 8006ebc:	fab3 f383 	clz	r3, r3
 8006ec0:	f003 031f 	and.w	r3, r3, #31
 8006ec4:	fa22 f303 	lsr.w	r3, r2, r3
 8006ec8:	07d8      	lsls	r0, r3, #31
 8006eca:	d4eb      	bmi.n	8006ea4 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
  }

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PllSai1->PLLSAI1N);
 8006ecc:	690b      	ldr	r3, [r1, #16]
 8006ece:	6862      	ldr	r2, [r4, #4]
 8006ed0:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8006ed4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006ed8:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor R */
    __HAL_RCC_PLLSAI1_DIVR_CONFIG(PllSai1->PLLSAI1R);
 8006eda:	6922      	ldr	r2, [r4, #16]
 8006edc:	690b      	ldr	r3, [r1, #16]
 8006ede:	0852      	lsrs	r2, r2, #1
 8006ee0:	3a01      	subs	r2, #1
 8006ee2:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 8006ee6:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8006eea:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 8006eec:	680b      	ldr	r3, [r1, #0]
 8006eee:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8006ef2:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 8006ef4:	460d      	mov	r5, r1

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8006ef6:	f7f9 fe07 	bl	8000b08 <HAL_GetTick>
 8006efa:	f04f 6800 	mov.w	r8, #134217728	; 0x8000000
 8006efe:	4607      	mov	r7, r0
 8006f00:	e005      	b.n	8006f0e <HAL_RCCEx_PeriphCLKConfig+0x41e>

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8006f02:	f7f9 fe01 	bl	8000b08 <HAL_GetTick>
 8006f06:	1bc0      	subs	r0, r0, r7
 8006f08:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8006f0c:	d822      	bhi.n	8006f54 <HAL_RCCEx_PeriphCLKConfig+0x464>
 8006f0e:	fa98 f3a8 	rbit	r3, r8

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 8006f12:	4964      	ldr	r1, [pc, #400]	; (80070a4 <HAL_RCCEx_PeriphCLKConfig+0x5b4>)
 8006f14:	682a      	ldr	r2, [r5, #0]
 8006f16:	fa98 f3a8 	rbit	r3, r8
 8006f1a:	fab3 f383 	clz	r3, r3
 8006f1e:	f003 031f 	and.w	r3, r3, #31
 8006f22:	fa22 f303 	lsr.w	r3, r2, r3
 8006f26:	07da      	lsls	r2, r3, #31
 8006f28:	d5eb      	bpl.n	8006f02 <HAL_RCCEx_PeriphCLKConfig+0x412>
    }
    
    if(status == HAL_OK)
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8006f2a:	690a      	ldr	r2, [r1, #16]
 8006f2c:	6963      	ldr	r3, [r4, #20]
 8006f2e:	4313      	orrs	r3, r2
 8006f30:	610b      	str	r3, [r1, #16]
 8006f32:	e6f8      	b.n	8006d26 <HAL_RCCEx_PeriphCLKConfig+0x236>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch(PeriphClkInit->Sai1ClockSelection)
 8006f34:	b962      	cbnz	r2, 8006f50 <HAL_RCCEx_PeriphCLKConfig+0x460>
      /* SAI1 clock source config set later after clock selection check */
      break;

    case RCC_SAI1CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI1*/
      /* PLLSAI1 parameters N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNP(&(PeriphClkInit->PLLSAI1));
 8006f36:	3004      	adds	r0, #4
 8006f38:	f7ff fccc 	bl	80068d4 <RCCEx_PLLSAI1_ConfigNP>
 8006f3c:	4606      	mov	r6, r0
      /* SAI1 clock source config set later after clock selection check */
      break;
 8006f3e:	e7a2      	b.n	8006e86 <HAL_RCCEx_PeriphCLKConfig+0x396>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch(PeriphClkInit->Sai2ClockSelection)
 8006f40:	2a00      	cmp	r2, #0
 8006f42:	f47f af0c 	bne.w	8006d5e <HAL_RCCEx_PeriphCLKConfig+0x26e>
      /* SAI2 clock source config set later after clock selection check */
      break;

    case RCC_SAI2CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI2*/
      /* PLLSAI1 parameters N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNP(&(PeriphClkInit->PLLSAI1));
 8006f46:	1d20      	adds	r0, r4, #4
 8006f48:	f7ff fcc4 	bl	80068d4 <RCCEx_PLLSAI1_ConfigNP>
 8006f4c:	4607      	mov	r7, r0
      /* SAI2 clock source config set later after clock selection check */
      break;
 8006f4e:	e603      	b.n	8006b58 <HAL_RCCEx_PeriphCLKConfig+0x68>
    case RCC_SAI1CLKSOURCE_PIN:      /* External clock is used as source of SAI1 clock*/
      /* SAI1 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8006f50:	2601      	movs	r6, #1
 8006f52:	e5ee      	b.n	8006b32 <HAL_RCCEx_PeriphCLKConfig+0x42>
 8006f54:	6823      	ldr	r3, [r4, #0]
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
    {
      /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
      
      if(ret != HAL_OK)
 8006f56:	2603      	movs	r6, #3
 8006f58:	e6e6      	b.n	8006d28 <HAL_RCCEx_PeriphCLKConfig+0x238>

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006f5a:	f7f9 fdd5 	bl	8000b08 <HAL_GetTick>
 8006f5e:	f04f 0a02 	mov.w	sl, #2
 8006f62:	4681      	mov	r9, r0

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006f64:	f241 3788 	movw	r7, #5000	; 0x1388
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8006f68:	e01d      	b.n	8006fa6 <HAL_RCCEx_PeriphCLKConfig+0x4b6>
 8006f6a:	fa9a f3aa 	rbit	r3, sl
 8006f6e:	fab3 f383 	clz	r3, r3
 8006f72:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006f76:	095b      	lsrs	r3, r3, #5
 8006f78:	2b03      	cmp	r3, #3
 8006f7a:	bf0c      	ite	eq
 8006f7c:	f8d5 2094 	ldreq.w	r2, [r5, #148]	; 0x94
 8006f80:	69ea      	ldrne	r2, [r5, #28]
 8006f82:	fa9a f3aa 	rbit	r3, sl
 8006f86:	fab3 f383 	clz	r3, r3
 8006f8a:	f003 031f 	and.w	r3, r3, #31
 8006f8e:	fa22 f303 	lsr.w	r3, r2, r3
 8006f92:	07db      	lsls	r3, r3, #31
 8006f94:	f53f af20 	bmi.w	8006dd8 <HAL_RCCEx_PeriphCLKConfig+0x2e8>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006f98:	f7f9 fdb6 	bl	8000b08 <HAL_GetTick>
 8006f9c:	ebc9 0000 	rsb	r0, r9, r0
 8006fa0:	42b8      	cmp	r0, r7
 8006fa2:	f63f af37 	bhi.w	8006e14 <HAL_RCCEx_PeriphCLKConfig+0x324>
 8006fa6:	fa9a f3aa 	rbit	r3, sl
 8006faa:	fa9a f3aa 	rbit	r3, sl
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8006fae:	fab3 f383 	clz	r3, r3
 8006fb2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006fb6:	095b      	lsrs	r3, r3, #5
 8006fb8:	2b02      	cmp	r3, #2
 8006fba:	d1d6      	bne.n	8006f6a <HAL_RCCEx_PeriphCLKConfig+0x47a>
 8006fbc:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8006fc0:	e7df      	b.n	8006f82 <HAL_RCCEx_PeriphCLKConfig+0x492>
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2R_VALUE(PllSai2->PLLSAI2R));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();
 8006fc2:	682a      	ldr	r2, [r5, #0]
 8006fc4:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8006fc8:	602a      	str	r2, [r5, #0]
 8006fca:	4698      	mov	r8, r3

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8006fcc:	f7f9 fd9c 	bl	8000b08 <HAL_GetTick>
 8006fd0:	4607      	mov	r7, r0
 8006fd2:	e005      	b.n	8006fe0 <HAL_RCCEx_PeriphCLKConfig+0x4f0>

  /* Wait till PLLSAI2 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8006fd4:	f7f9 fd98 	bl	8000b08 <HAL_GetTick>
 8006fd8:	1bc0      	subs	r0, r0, r7
 8006fda:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8006fde:	d8b9      	bhi.n	8006f54 <HAL_RCCEx_PeriphCLKConfig+0x464>
 8006fe0:	fa98 f3a8 	rbit	r3, r8

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till PLLSAI2 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
 8006fe4:	492f      	ldr	r1, [pc, #188]	; (80070a4 <HAL_RCCEx_PeriphCLKConfig+0x5b4>)
 8006fe6:	682a      	ldr	r2, [r5, #0]
 8006fe8:	fa98 f3a8 	rbit	r3, r8
 8006fec:	fab3 f383 	clz	r3, r3
 8006ff0:	f003 031f 	and.w	r3, r3, #31
 8006ff4:	fa22 f303 	lsr.w	r3, r2, r3
 8006ff8:	07db      	lsls	r3, r3, #31
 8006ffa:	d4eb      	bmi.n	8006fd4 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
  }

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI2 Multiplication factor N */
    __HAL_RCC_PLLSAI2_MULN_CONFIG(PllSai2->PLLSAI2N);
 8006ffc:	694b      	ldr	r3, [r1, #20]
 8006ffe:	69a2      	ldr	r2, [r4, #24]
 8007000:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8007004:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007008:	614b      	str	r3, [r1, #20]
    /* Configure the PLLSAI2 Division factor R */
    __HAL_RCC_PLLSAI2_DIVR_CONFIG(PllSai2->PLLSAI2R);
 800700a:	6a22      	ldr	r2, [r4, #32]
 800700c:	694b      	ldr	r3, [r1, #20]
 800700e:	0852      	lsrs	r2, r2, #1
 8007010:	3a01      	subs	r2, #1
 8007012:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 8007016:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 800701a:	614b      	str	r3, [r1, #20]

    /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
    __HAL_RCC_PLLSAI2_ENABLE();
 800701c:	680b      	ldr	r3, [r1, #0]
 800701e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8007022:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
 8007024:	460d      	mov	r5, r1

    /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
    __HAL_RCC_PLLSAI2_ENABLE();

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8007026:	f7f9 fd6f 	bl	8000b08 <HAL_GetTick>
 800702a:	f04f 5800 	mov.w	r8, #536870912	; 0x20000000
 800702e:	4607      	mov	r7, r0
 8007030:	e005      	b.n	800703e <HAL_RCCEx_PeriphCLKConfig+0x54e>

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8007032:	f7f9 fd69 	bl	8000b08 <HAL_GetTick>
 8007036:	1bc0      	subs	r0, r0, r7
 8007038:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800703c:	d88a      	bhi.n	8006f54 <HAL_RCCEx_PeriphCLKConfig+0x464>
 800703e:	fa98 f3a8 	rbit	r3, r8

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
 8007042:	4918      	ldr	r1, [pc, #96]	; (80070a4 <HAL_RCCEx_PeriphCLKConfig+0x5b4>)
 8007044:	682a      	ldr	r2, [r5, #0]
 8007046:	fa98 f3a8 	rbit	r3, r8
 800704a:	fab3 f383 	clz	r3, r3
 800704e:	f003 031f 	and.w	r3, r3, #31
 8007052:	fa22 f303 	lsr.w	r3, r2, r3
 8007056:	07d8      	lsls	r0, r3, #31
 8007058:	d5eb      	bpl.n	8007032 <HAL_RCCEx_PeriphCLKConfig+0x542>
    }
    
    if(status == HAL_OK)
    {
      /* Configure the PLLSAI2 Clock output(s) */
      __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 800705a:	694a      	ldr	r2, [r1, #20]
 800705c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800705e:	4313      	orrs	r3, r2
 8007060:	614b      	str	r3, [r1, #20]
 8007062:	6823      	ldr	r3, [r4, #0]
 8007064:	e660      	b.n	8006d28 <HAL_RCCEx_PeriphCLKConfig+0x238>
 8007066:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8007068:	e559      	b.n	8006b1e <HAL_RCCEx_PeriphCLKConfig+0x2e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
    {
      /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
 800706a:	1d20      	adds	r0, r4, #4
 800706c:	f7ff fce6 	bl	8006a3c <RCCEx_PLLSAI1_ConfigNQ>
      
      if(ret != HAL_OK)
 8007070:	2800      	cmp	r0, #0
 8007072:	f43f ae43 	beq.w	8006cfc <HAL_RCCEx_PeriphCLKConfig+0x20c>
 8007076:	4606      	mov	r6, r0
 8007078:	6823      	ldr	r3, [r4, #0]
 800707a:	e640      	b.n	8006cfe <HAL_RCCEx_PeriphCLKConfig+0x20e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
    {
      /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
 800707c:	1d20      	adds	r0, r4, #4
 800707e:	f7ff fcdd 	bl	8006a3c <RCCEx_PLLSAI1_ConfigNQ>
      
      if(ret != HAL_OK)
 8007082:	2800      	cmp	r0, #0
 8007084:	f43f ae25 	beq.w	8006cd2 <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 8007088:	4606      	mov	r6, r0
 800708a:	6823      	ldr	r3, [r4, #0]
 800708c:	e622      	b.n	8006cd4 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
    else if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
    {
      /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
 800708e:	1d20      	adds	r0, r4, #4
 8007090:	f7ff fcd4 	bl	8006a3c <RCCEx_PLLSAI1_ConfigNQ>
      
      if(ret != HAL_OK)
 8007094:	2800      	cmp	r0, #0
 8007096:	f43f ae07 	beq.w	8006ca8 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
 800709a:	4606      	mov	r6, r0
 800709c:	6823      	ldr	r3, [r4, #0]
 800709e:	e604      	b.n	8006caa <HAL_RCCEx_PeriphCLKConfig+0x1ba>
 80070a0:	463e      	mov	r6, r7
 80070a2:	e6a2      	b.n	8006dea <HAL_RCCEx_PeriphCLKConfig+0x2fa>
 80070a4:	40021000 	.word	0x40021000

080070a8 <HAL_RCCEx_GetPeriphCLKConfig>:
  *         clocks(SAI1, SAI2, LPTIM1, LPTIM2, I2C1, I2C2, I2C3, LPUART,
  *         USART1, USART2, USART3, UART4, UART5, RTC, ADCx, DFSDMx, SWPMI1, USB, SDMMC1 and RNG).
  * @retval None
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80070a8:	b470      	push	{r4, r5, r6}
                                        RCC_PERIPHCLK_LPTIM2  | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2                         | RCC_PERIPHCLK_SDMMC1 | \
                                        RCC_PERIPHCLK_RNG     | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM | RCC_PERIPHCLK_RTC ;
  
#else /* defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx) */

  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4 | RCC_PERIPHCLK_UART5  | \
 80070aa:	4a5b      	ldr	r2, [pc, #364]	; (8007218 <HAL_RCCEx_GetPeriphCLKConfig+0x170>)
                                        RCC_PERIPHCLK_RNG     | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM | RCC_PERIPHCLK_RTC ;

#endif /* STM32L471xx */

  /* Get the PLLSAI1 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLSAI1.PLLSAI1N = (uint32_t)((RCC->PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1N) >> POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1N));
 80070ac:	4b5b      	ldr	r3, [pc, #364]	; (800721c <HAL_RCCEx_GetPeriphCLKConfig+0x174>)
                                        RCC_PERIPHCLK_LPTIM2  | RCC_PERIPHCLK_SAI1   | RCC_PERIPHCLK_SAI2                         | RCC_PERIPHCLK_SDMMC1 | \
                                        RCC_PERIPHCLK_RNG     | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM | RCC_PERIPHCLK_RTC ;
  
#else /* defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx) */

  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4 | RCC_PERIPHCLK_UART5  | \
 80070ae:	6002      	str	r2, [r0, #0]
                                        RCC_PERIPHCLK_RNG     | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM | RCC_PERIPHCLK_RTC ;

#endif /* STM32L471xx */

  /* Get the PLLSAI1 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLSAI1.PLLSAI1N = (uint32_t)((RCC->PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1N) >> POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1N));
 80070b0:	691a      	ldr	r2, [r3, #16]
 80070b2:	f44f 45fe 	mov.w	r5, #32512	; 0x7f00
 80070b6:	fa95 f1a5 	rbit	r1, r5
 80070ba:	402a      	ands	r2, r5
 80070bc:	fab1 f181 	clz	r1, r1
 80070c0:	40ca      	lsrs	r2, r1
 80070c2:	6042      	str	r2, [r0, #4]
  PeriphClkInit->PLLSAI1.PLLSAI1P = (uint32_t)(((RCC->PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1P) >> POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1P)) << 4)+7;
 80070c4:	691a      	ldr	r2, [r3, #16]
 80070c6:	f44f 3400 	mov.w	r4, #131072	; 0x20000
 80070ca:	fa94 f1a4 	rbit	r1, r4
 80070ce:	4022      	ands	r2, r4
 80070d0:	fab1 f181 	clz	r1, r1
 80070d4:	40ca      	lsrs	r2, r1
 80070d6:	0112      	lsls	r2, r2, #4
 80070d8:	3207      	adds	r2, #7
 80070da:	6082      	str	r2, [r0, #8]
  PeriphClkInit->PLLSAI1.PLLSAI1R = (uint32_t)(((RCC->PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1R) >> POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1R))+1)* 2;
 80070dc:	691a      	ldr	r2, [r3, #16]
 80070de:	f04f 61c0 	mov.w	r1, #100663296	; 0x6000000
 80070e2:	fa91 f6a1 	rbit	r6, r1
 80070e6:	400a      	ands	r2, r1
 80070e8:	fab6 f686 	clz	r6, r6
 80070ec:	40f2      	lsrs	r2, r6
 80070ee:	3201      	adds	r2, #1
 80070f0:	0052      	lsls	r2, r2, #1
 80070f2:	6102      	str	r2, [r0, #16]
  PeriphClkInit->PLLSAI1.PLLSAI1Q = (uint32_t)(((RCC->PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1Q) >> POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1Q))+1)* 2;
 80070f4:	691a      	ldr	r2, [r3, #16]
 80070f6:	f44f 06c0 	mov.w	r6, #6291456	; 0x600000
 80070fa:	fa96 f6a6 	rbit	r6, r6
 80070fe:	f402 02c0 	and.w	r2, r2, #6291456	; 0x600000
 8007102:	fab6 f686 	clz	r6, r6
 8007106:	40f2      	lsrs	r2, r6
 8007108:	3201      	adds	r2, #1
 800710a:	0052      	lsls	r2, r2, #1
 800710c:	60c2      	str	r2, [r0, #12]
   /* Get the PLLSAI2 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLSAI2.PLLSAI2N = (uint32_t)((RCC->PLLSAI2CFGR & RCC_PLLSAI2CFGR_PLLSAI2N) >> POSITION_VAL(RCC_PLLSAI2CFGR_PLLSAI2N));
 800710e:	695a      	ldr	r2, [r3, #20]
 8007110:	fa95 f5a5 	rbit	r5, r5
 8007114:	f402 42fe 	and.w	r2, r2, #32512	; 0x7f00
 8007118:	fab5 f585 	clz	r5, r5
 800711c:	40ea      	lsrs	r2, r5
 800711e:	6182      	str	r2, [r0, #24]
  PeriphClkInit->PLLSAI2.PLLSAI2P = (uint32_t)(((RCC->PLLSAI2CFGR & RCC_PLLSAI2CFGR_PLLSAI2P) >> POSITION_VAL(RCC_PLLSAI2CFGR_PLLSAI2P)) << 4)+7;
 8007120:	695a      	ldr	r2, [r3, #20]
 8007122:	fa94 f4a4 	rbit	r4, r4
 8007126:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 800712a:	fab4 f484 	clz	r4, r4
 800712e:	40e2      	lsrs	r2, r4
 8007130:	0112      	lsls	r2, r2, #4
 8007132:	3207      	adds	r2, #7
 8007134:	61c2      	str	r2, [r0, #28]
  PeriphClkInit->PLLSAI2.PLLSAI2R = (uint32_t)(((RCC->PLLSAI2CFGR & RCC_PLLSAI2CFGR_PLLSAI2R)>> POSITION_VAL(RCC_PLLSAI2CFGR_PLLSAI2R))+1)* 2;
 8007136:	695a      	ldr	r2, [r3, #20]
 8007138:	fa91 f1a1 	rbit	r1, r1
 800713c:	f002 62c0 	and.w	r2, r2, #100663296	; 0x6000000
 8007140:	fab1 f181 	clz	r1, r1
 8007144:	40ca      	lsrs	r2, r1
 8007146:	3201      	adds	r2, #1
 8007148:	0052      	lsls	r2, r2, #1
 800714a:	6202      	str	r2, [r0, #32]

  /* Get the USART1 clock source ---------------------------------------------*/
  PeriphClkInit->Usart1ClockSelection  = __HAL_RCC_GET_USART1_SOURCE();
 800714c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8007150:	f002 0203 	and.w	r2, r2, #3
 8007154:	6282      	str	r2, [r0, #40]	; 0x28
  /* Get the USART2 clock source ---------------------------------------------*/
  PeriphClkInit->Usart2ClockSelection  = __HAL_RCC_GET_USART2_SOURCE();
 8007156:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800715a:	f002 020c 	and.w	r2, r2, #12
 800715e:	62c2      	str	r2, [r0, #44]	; 0x2c
  /* Get the USART3 clock source ---------------------------------------------*/
  PeriphClkInit->Usart3ClockSelection  = __HAL_RCC_GET_USART3_SOURCE();
 8007160:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8007164:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8007168:	6302      	str	r2, [r0, #48]	; 0x30
  /* Get the UART4 clock source ----------------------------------------------*/
  PeriphClkInit->Uart4ClockSelection   = __HAL_RCC_GET_UART4_SOURCE();
 800716a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800716e:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 8007172:	6342      	str	r2, [r0, #52]	; 0x34
  /* Get the UART5 clock source ----------------------------------------------*/
  PeriphClkInit->Uart5ClockSelection   = __HAL_RCC_GET_UART5_SOURCE();
 8007174:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8007178:	f402 7240 	and.w	r2, r2, #768	; 0x300
 800717c:	6382      	str	r2, [r0, #56]	; 0x38
  /* Get the LPUART1 clock source --------------------------------------------*/
  PeriphClkInit->Lpuart1ClockSelection = __HAL_RCC_GET_LPUART1_SOURCE();
 800717e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8007182:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 8007186:	63c2      	str	r2, [r0, #60]	; 0x3c
  /* Get the I2C1 clock source -----------------------------------------------*/
  PeriphClkInit->I2c1ClockSelection    = __HAL_RCC_GET_I2C1_SOURCE();
 8007188:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800718c:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8007190:	6402      	str	r2, [r0, #64]	; 0x40
   /* Get the I2C2 clock source ----------------------------------------------*/
  PeriphClkInit->I2c2ClockSelection    = __HAL_RCC_GET_I2C2_SOURCE();
 8007192:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8007196:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 800719a:	6442      	str	r2, [r0, #68]	; 0x44
  /* Get the I2C3 clock source -----------------------------------------------*/
  PeriphClkInit->I2c3ClockSelection    = __HAL_RCC_GET_I2C3_SOURCE();
 800719c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80071a0:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 80071a4:	6482      	str	r2, [r0, #72]	; 0x48
  /* Get the LPTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection  = __HAL_RCC_GET_LPTIM1_SOURCE();
 80071a6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80071aa:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 80071ae:	64c2      	str	r2, [r0, #76]	; 0x4c
  /* Get the LPTIM2 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim2ClockSelection  = __HAL_RCC_GET_LPTIM2_SOURCE();
 80071b0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80071b4:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 80071b8:	6502      	str	r2, [r0, #80]	; 0x50
  /* Get the SAI1 clock source -----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection    = __HAL_RCC_GET_SAI1_SOURCE();
 80071ba:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80071be:	f402 0240 	and.w	r2, r2, #12582912	; 0xc00000
 80071c2:	6542      	str	r2, [r0, #84]	; 0x54
  /* Get the SAI2 clock source -----------------------------------------------*/
  PeriphClkInit->Sai2ClockSelection    = __HAL_RCC_GET_SAI2_SOURCE();
 80071c4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80071c8:	f002 7240 	and.w	r2, r2, #50331648	; 0x3000000
 80071cc:	6582      	str	r2, [r0, #88]	; 0x58
  /* Get the RTC clock source ------------------------------------------------*/
  PeriphClkInit->RTCClockSelection     = __HAL_RCC_GET_RTC_SOURCE();
 80071ce:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80071d2:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80071d6:	6742      	str	r2, [r0, #116]	; 0x74

#if defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)
  /* Get the USB clock source ------------------------------------------------*/
  PeriphClkInit->UsbClockSelection     = __HAL_RCC_GET_USB_SOURCE();
 80071d8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80071dc:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 80071e0:	65c2      	str	r2, [r0, #92]	; 0x5c
#endif /* STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */
  
  /* Get the SDMMC1 clock source ---------------------------------------------*/
  PeriphClkInit->Sdmmc1ClockSelection  = __HAL_RCC_GET_SDMMC1_SOURCE();
 80071e2:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80071e6:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 80071ea:	6602      	str	r2, [r0, #96]	; 0x60
  /* Get the RNG clock source ------------------------------------------------*/
  PeriphClkInit->RngClockSelection     = __HAL_RCC_GET_RNG_SOURCE();
 80071ec:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80071f0:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 80071f4:	6642      	str	r2, [r0, #100]	; 0x64
   /* Get the ADC clock source -----------------------------------------------*/
  PeriphClkInit->AdcClockSelection     = __HAL_RCC_GET_ADC_SOURCE();
 80071f6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80071fa:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
 80071fe:	6682      	str	r2, [r0, #104]	; 0x68
  /* Get the SWPMI1 clock source ----------------------------------------------*/
  PeriphClkInit->Swpmi1ClockSelection  = __HAL_RCC_GET_SWPMI1_SOURCE();
 8007200:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8007204:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
 8007208:	66c2      	str	r2, [r0, #108]	; 0x6c
  /* Get the DFSDM clock source -------------------------------------------*/
  PeriphClkInit->DfsdmClockSelection   = __HAL_RCC_GET_DFSDM_SOURCE();
 800720a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800720e:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8007212:	6703      	str	r3, [r0, #112]	; 0x70
}
 8007214:	bc70      	pop	{r4, r5, r6}
 8007216:	4770      	bx	lr
 8007218:	000fffff 	.word	0x000fffff
 800721c:	40021000 	.word	0x40021000

08007220 <HAL_RCCEx_GetPeriphCLKFreq>:
  uint32_t pllvco = 0, plln = 0, pllp = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  if(PeriphClk == RCC_PERIPHCLK_RTC)
 8007220:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
  {
    /* Get the current RTC source */
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8007224:	4ac6      	ldr	r2, [pc, #792]	; (8007540 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
  uint32_t pllvco = 0, plln = 0, pllp = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  if(PeriphClk == RCC_PERIPHCLK_RTC)
 8007226:	d043      	beq.n	80072b0 <HAL_RCCEx_GetPeriphCLKFreq+0x90>
  else
  {
    /* Other external peripheral clock source than RTC */
    
    /* Compute PLL clock input */
    if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)        /* MSI ? */
 8007228:	68d3      	ldr	r3, [r2, #12]
 800722a:	f003 0303 	and.w	r3, r3, #3
 800722e:	2b01      	cmp	r3, #1
 8007230:	d06a      	beq.n	8007308 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
    {
      pllvco = (1 << ((__HAL_RCC_GET_MSI_RANGE() >> 4) - 4)) * 1000000;
    }
    else if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)   /* HSI ? */
 8007232:	68d3      	ldr	r3, [r2, #12]
 8007234:	f003 0303 	and.w	r3, r3, #3
 8007238:	2b02      	cmp	r3, #2
 800723a:	f000 8087 	beq.w	800734c <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
    {
      pllvco = HSI_VALUE;
    }
    else if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)   /* HSE ? */
 800723e:	68d2      	ldr	r2, [r2, #12]
    {
      pllvco = HSE_VALUE;
    }
    else /* No source */
    {
      pllvco = 0;
 8007240:	4bc0      	ldr	r3, [pc, #768]	; (8007544 <HAL_RCCEx_GetPeriphCLKFreq+0x324>)
    }
    else if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)   /* HSI ? */
    {
      pllvco = HSI_VALUE;
    }
    else if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)   /* HSE ? */
 8007242:	f002 0203 	and.w	r2, r2, #3
    {
      pllvco = HSE_VALUE;
    }
    else /* No source */
    {
      pllvco = 0;
 8007246:	2a03      	cmp	r2, #3
 8007248:	bf0c      	ite	eq
 800724a:	461a      	moveq	r2, r3
 800724c:	2200      	movne	r2, #0
    }

    /* f(PLL Source) / PLLM */
    pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> 4) + 1));
 800724e:	49bc      	ldr	r1, [pc, #752]	; (8007540 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
 8007250:	68cb      	ldr	r3, [r1, #12]

    switch(PeriphClk)
 8007252:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    {
      pllvco = 0;
    }

    /* f(PLL Source) / PLLM */
    pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> 4) + 1));
 8007256:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800725a:	f103 0301 	add.w	r3, r3, #1
 800725e:	fbb2 f3f3 	udiv	r3, r2, r3

    switch(PeriphClk)
 8007262:	f000 8177 	beq.w	8007554 <HAL_RCCEx_GetPeriphCLKFreq+0x334>
 8007266:	d832      	bhi.n	80072ce <HAL_RCCEx_GetPeriphCLKFreq+0xae>
 8007268:	2810      	cmp	r0, #16
 800726a:	f000 8157 	beq.w	800751c <HAL_RCCEx_GetPeriphCLKFreq+0x2fc>
 800726e:	d956      	bls.n	800731e <HAL_RCCEx_GetPeriphCLKFreq+0xfe>
 8007270:	2840      	cmp	r0, #64	; 0x40
 8007272:	f000 8130 	beq.w	80074d6 <HAL_RCCEx_GetPeriphCLKFreq+0x2b6>
 8007276:	f240 80ff 	bls.w	8007478 <HAL_RCCEx_GetPeriphCLKFreq+0x258>
 800727a:	2880      	cmp	r0, #128	; 0x80
 800727c:	f000 80ba 	beq.w	80073f4 <HAL_RCCEx_GetPeriphCLKFreq+0x1d4>
 8007280:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8007284:	d121      	bne.n	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      }
      break;

    case RCC_PERIPHCLK_I2C3:
      /* Get the current I2C3 source */
      srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 8007286:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_I2C3CLKSOURCE_PCLK1)
 800728a:	f413 3340 	ands.w	r3, r3, #196608	; 0x30000
 800728e:	f000 80ef 	beq.w	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if(srcclk == RCC_I2C3CLKSOURCE_SYSCLK)
 8007292:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8007296:	f000 80ed 	beq.w	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_I2C3CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 800729a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800729e:	d114      	bne.n	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      }
      else if((srcclk == RCC_LPTIM2CLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
      {
        frequency = LSI_VALUE;
      }
      else if((srcclk == RCC_LPTIM2CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 80072a0:	4ba7      	ldr	r3, [pc, #668]	; (8007540 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
 80072a2:	681b      	ldr	r3, [r3, #0]
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_USART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
      {
        frequency = HSI_VALUE;
 80072a4:	48a8      	ldr	r0, [pc, #672]	; (8007548 <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
 80072a6:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80072aa:	bf08      	it	eq
 80072ac:	2000      	moveq	r0, #0
 80072ae:	4770      	bx	lr
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  if(PeriphClk == RCC_PERIPHCLK_RTC)
  {
    /* Get the current RTC source */
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 80072b0:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80072b4:	f403 7340 	and.w	r3, r3, #768	; 0x300

    /* Check if LSE is ready and if RTC clock selection is LSE */
    if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
 80072b8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80072bc:	d07c      	beq.n	80073b8 <HAL_RCCEx_GetPeriphCLKFreq+0x198>
    {
      frequency = LSE_VALUE;
    }
    /* Check if LSI is ready and if RTC clock selection is LSI */
    else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 80072be:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80072c2:	d070      	beq.n	80073a6 <HAL_RCCEx_GetPeriphCLKFreq+0x186>
    {
      frequency = LSI_VALUE;
    }
    /* Check if HSE is ready  and if RTC clock selection is HSI_DIV32*/
    else if ((srcclk == RCC_RTCCLKSOURCE_HSE_DIV32) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
 80072c4:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80072c8:	d07f      	beq.n	80073ca <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
      frequency = HSE_VALUE / 32;
    }
    /* Clock not enabled for RTC*/
    else
    {
      frequency = 0;
 80072ca:	2000      	movs	r0, #0
 80072cc:	4770      	bx	lr
    }

    /* f(PLL Source) / PLLM */
    pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> 4) + 1));

    switch(PeriphClk)
 80072ce:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
 80072d2:	f000 8150 	beq.w	8007576 <HAL_RCCEx_GetPeriphCLKFreq+0x356>
 80072d6:	d93b      	bls.n	8007350 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
 80072d8:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 80072dc:	f000 80c4 	beq.w	8007468 <HAL_RCCEx_GetPeriphCLKFreq+0x248>
 80072e0:	f200 80bb 	bhi.w	800745a <HAL_RCCEx_GetPeriphCLKFreq+0x23a>
 80072e4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80072e8:	d1ef      	bne.n	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      }
      break;

    case RCC_PERIPHCLK_SWPMI1:
      /* Get the current SWPMI1 source */
      srcclk = __HAL_RCC_GET_SWPMI1_SOURCE();
 80072ea:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_SWPMI1CLKSOURCE_PCLK)
 80072ee:	f013 4380 	ands.w	r3, r3, #1073741824	; 0x40000000
 80072f2:	f000 80bd 	beq.w	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if((srcclk == RCC_SWPMI1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 80072f6:	2b00      	cmp	r3, #0
 80072f8:	d0e7      	beq.n	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
 80072fa:	680b      	ldr	r3, [r1, #0]
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_USART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
      {
        frequency = HSI_VALUE;
 80072fc:	4892      	ldr	r0, [pc, #584]	; (8007548 <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
 80072fe:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8007302:	bf08      	it	eq
 8007304:	2000      	moveq	r0, #0
 8007306:	4770      	bx	lr
    /* Other external peripheral clock source than RTC */
    
    /* Compute PLL clock input */
    if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)        /* MSI ? */
    {
      pllvco = (1 << ((__HAL_RCC_GET_MSI_RANGE() >> 4) - 4)) * 1000000;
 8007308:	6813      	ldr	r3, [r2, #0]
 800730a:	071b      	lsls	r3, r3, #28
 800730c:	d542      	bpl.n	8007394 <HAL_RCCEx_GetPeriphCLKFreq+0x174>
 800730e:	6812      	ldr	r2, [r2, #0]
 8007310:	4b8e      	ldr	r3, [pc, #568]	; (800754c <HAL_RCCEx_GetPeriphCLKFreq+0x32c>)
 8007312:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8007316:	3a04      	subs	r2, #4
 8007318:	fa03 f202 	lsl.w	r2, r3, r2
 800731c:	e797      	b.n	800724e <HAL_RCCEx_GetPeriphCLKFreq+0x2e>
    }

    /* f(PLL Source) / PLLM */
    pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> 4) + 1));

    switch(PeriphClk)
 800731e:	2802      	cmp	r0, #2
 8007320:	f000 80e6 	beq.w	80074f0 <HAL_RCCEx_GetPeriphCLKFreq+0x2d0>
 8007324:	f240 80c8 	bls.w	80074b8 <HAL_RCCEx_GetPeriphCLKFreq+0x298>
 8007328:	2804      	cmp	r0, #4
 800732a:	d055      	beq.n	80073d8 <HAL_RCCEx_GetPeriphCLKFreq+0x1b8>
 800732c:	2808      	cmp	r0, #8
 800732e:	d1cc      	bne.n	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      }
      break;

    case RCC_PERIPHCLK_UART4:
      /* Get the current UART4 source */
      srcclk = __HAL_RCC_GET_UART4_SOURCE();
 8007330:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_UART4CLKSOURCE_PCLK1)
 8007334:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
 8007338:	f000 809a 	beq.w	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if(srcclk == RCC_UART4CLKSOURCE_SYSCLK)
 800733c:	2b40      	cmp	r3, #64	; 0x40
 800733e:	f000 8099 	beq.w	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_UART4CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 8007342:	2b80      	cmp	r3, #128	; 0x80
 8007344:	d0ac      	beq.n	80072a0 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
      {
        frequency = HSI_VALUE;
      }
      else if((srcclk == RCC_UART4CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
 8007346:	2bc0      	cmp	r3, #192	; 0xc0
 8007348:	d1bf      	bne.n	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
 800734a:	e019      	b.n	8007380 <HAL_RCCEx_GetPeriphCLKFreq+0x160>
    {
      pllvco = (1 << ((__HAL_RCC_GET_MSI_RANGE() >> 4) - 4)) * 1000000;
    }
    else if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)   /* HSI ? */
    {
      pllvco = HSI_VALUE;
 800734c:	4a7e      	ldr	r2, [pc, #504]	; (8007548 <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
 800734e:	e77e      	b.n	800724e <HAL_RCCEx_GetPeriphCLKFreq+0x2e>
    }

    /* f(PLL Source) / PLLM */
    pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> 4) + 1));

    switch(PeriphClk)
 8007350:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 8007354:	f000 8151 	beq.w	80075fa <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
 8007358:	d859      	bhi.n	800740e <HAL_RCCEx_GetPeriphCLKFreq+0x1ee>
 800735a:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 800735e:	d1b4      	bne.n	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      }
      break;

    case RCC_PERIPHCLK_LPTIM2:
      /* Get the current LPTIM2 source */
      srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
 8007360:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_LPTIM2CLKSOURCE_PCLK)
 8007364:	f413 1340 	ands.w	r3, r3, #3145728	; 0x300000
 8007368:	f000 8082 	beq.w	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if((srcclk == RCC_LPTIM2CLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 800736c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8007370:	f000 8155 	beq.w	800761e <HAL_RCCEx_GetPeriphCLKFreq+0x3fe>
      {
        frequency = LSI_VALUE;
      }
      else if((srcclk == RCC_LPTIM2CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 8007374:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8007378:	d092      	beq.n	80072a0 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
      {
        frequency = HSI_VALUE;
      }
      else if ((srcclk == RCC_LPTIM2CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
 800737a:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 800737e:	d1a4      	bne.n	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
 8007380:	4b6f      	ldr	r3, [pc, #444]	; (8007540 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
 8007382:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
      {
        frequency = HSI_VALUE;
      }
      else if((srcclk == RCC_USART1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
      {
        frequency = LSE_VALUE;
 8007386:	f013 0f02 	tst.w	r3, #2
 800738a:	bf0c      	ite	eq
 800738c:	2000      	moveq	r0, #0
 800738e:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 8007392:	4770      	bx	lr
    /* Other external peripheral clock source than RTC */
    
    /* Compute PLL clock input */
    if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)        /* MSI ? */
    {
      pllvco = (1 << ((__HAL_RCC_GET_MSI_RANGE() >> 4) - 4)) * 1000000;
 8007394:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 8007398:	4b6c      	ldr	r3, [pc, #432]	; (800754c <HAL_RCCEx_GetPeriphCLKFreq+0x32c>)
 800739a:	f3c2 2203 	ubfx	r2, r2, #8, #4
 800739e:	3a04      	subs	r2, #4
 80073a0:	fa03 f202 	lsl.w	r2, r3, r2
 80073a4:	e753      	b.n	800724e <HAL_RCCEx_GetPeriphCLKFreq+0x2e>
    if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
    {
      frequency = LSE_VALUE;
    }
    /* Check if LSI is ready and if RTC clock selection is LSI */
    else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 80073a6:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
    {
      frequency = LSI_VALUE;
 80073aa:	f013 0f02 	tst.w	r3, #2
 80073ae:	bf0c      	ite	eq
 80073b0:	2000      	moveq	r0, #0
 80073b2:	f44f 40fa 	movne.w	r0, #32000	; 0x7d00
 80073b6:	4770      	bx	lr
  {
    /* Get the current RTC source */
    srcclk = __HAL_RCC_GET_RTC_SOURCE();

    /* Check if LSE is ready and if RTC clock selection is LSE */
    if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
 80073b8:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
    {
      frequency = LSE_VALUE;
 80073bc:	f013 0f02 	tst.w	r3, #2
 80073c0:	bf0c      	ite	eq
 80073c2:	2000      	moveq	r0, #0
 80073c4:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 80073c8:	4770      	bx	lr
    else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
    {
      frequency = LSI_VALUE;
    }
    /* Check if HSE is ready  and if RTC clock selection is HSI_DIV32*/
    else if ((srcclk == RCC_RTCCLKSOURCE_HSE_DIV32) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
 80073ca:	6813      	ldr	r3, [r2, #0]
    {
      frequency = HSE_VALUE / 32;
 80073cc:	4860      	ldr	r0, [pc, #384]	; (8007550 <HAL_RCCEx_GetPeriphCLKFreq+0x330>)
 80073ce:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80073d2:	bf08      	it	eq
 80073d4:	2000      	moveq	r0, #0
 80073d6:	4770      	bx	lr
      }
      break;

    case RCC_PERIPHCLK_USART3:
      /* Get the current USART3 source */
      srcclk = __HAL_RCC_GET_USART3_SOURCE();
 80073d8:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_USART3CLKSOURCE_PCLK1)
 80073dc:	f013 0330 	ands.w	r3, r3, #48	; 0x30
 80073e0:	d046      	beq.n	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if(srcclk == RCC_USART3CLKSOURCE_SYSCLK)
 80073e2:	2b10      	cmp	r3, #16
 80073e4:	d046      	beq.n	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_USART3CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 80073e6:	2b20      	cmp	r3, #32
 80073e8:	f43f af5a 	beq.w	80072a0 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
      {
        frequency = HSI_VALUE;
      }
      else if((srcclk == RCC_USART3CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
 80073ec:	2b30      	cmp	r3, #48	; 0x30
 80073ee:	f47f af6c 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
 80073f2:	e7c5      	b.n	8007380 <HAL_RCCEx_GetPeriphCLKFreq+0x160>
      }
      break;

    case RCC_PERIPHCLK_I2C2:
      /* Get the current I2C2 source */
      srcclk = __HAL_RCC_GET_I2C2_SOURCE();
 80073f4:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_I2C2CLKSOURCE_PCLK1)
 80073f8:	f413 4340 	ands.w	r3, r3, #49152	; 0xc000
 80073fc:	d038      	beq.n	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if(srcclk == RCC_I2C2CLKSOURCE_SYSCLK)
 80073fe:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8007402:	d037      	beq.n	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_I2C2CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 8007404:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8007408:	f47f af5f 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
 800740c:	e748      	b.n	80072a0 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
    }

    /* f(PLL Source) / PLLM */
    pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> 4) + 1));

    switch(PeriphClk)
 800740e:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8007412:	f000 80d1 	beq.w	80075b8 <HAL_RCCEx_GetPeriphCLKFreq+0x398>
 8007416:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 800741a:	f47f af56 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
#endif /* STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

    case RCC_PERIPHCLK_RNG:
    case RCC_PERIPHCLK_SDMMC1:

      srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
 800741e:	4948      	ldr	r1, [pc, #288]	; (8007540 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
 8007420:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007424:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
      
      if(srcclk == RCC_CCIPR_CLK48SEL)   /* MSI ? */
 8007428:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
 800742c:	f000 8100 	beq.w	8007630 <HAL_RCCEx_GetPeriphCLKFreq+0x410>
      {
        frequency = (1 << ((__HAL_RCC_GET_MSI_RANGE() >> 4) - 4)) * 1000000;
      }
      else if(srcclk == RCC_CCIPR_CLK48SEL_1)  /* PLL ? */
 8007430:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 8007434:	f000 8120 	beq.w	8007678 <HAL_RCCEx_GetPeriphCLKFreq+0x458>
      {
        /* f(PLL48M1CLK) = f(VCO input) * PLLN / PLLQ */
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> 8;
        frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> 21) + 1) << 1);
      }
      else if(srcclk == RCC_CCIPR_CLK48SEL_0)  /* PLLSAI1 ? */
 8007438:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 800743c:	f47f af45 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      {
        /* f(PLL48M2CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1Q */
        plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> 8;
 8007440:	690a      	ldr	r2, [r1, #16]
        frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> 21) + 1) << 1);
 8007442:	6908      	ldr	r0, [r1, #16]
 8007444:	f3c0 5041 	ubfx	r0, r0, #21, #2
        frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> 21) + 1) << 1);
      }
      else if(srcclk == RCC_CCIPR_CLK48SEL_0)  /* PLLSAI1 ? */
      {
        /* f(PLL48M2CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1Q */
        plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> 8;
 8007448:	f3c2 2206 	ubfx	r2, r2, #8, #7
        frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> 21) + 1) << 1);
 800744c:	3001      	adds	r0, #1
 800744e:	fb02 f303 	mul.w	r3, r2, r3
 8007452:	0040      	lsls	r0, r0, #1
 8007454:	fbb3 f0f0 	udiv	r0, r3, r0
 8007458:	4770      	bx	lr
    }

    /* f(PLL Source) / PLLM */
    pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> 4) + 1));

    switch(PeriphClk)
 800745a:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 800745e:	d0de      	beq.n	800741e <HAL_RCCEx_GetPeriphCLKFreq+0x1fe>
 8007460:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 8007464:	d0db      	beq.n	800741e <HAL_RCCEx_GetPeriphCLKFreq+0x1fe>
 8007466:	e730      	b.n	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      }
      break;

    case RCC_PERIPHCLK_DFSDM:
      /* Get the current DFSDM source */
      srcclk = __HAL_RCC_GET_DFSDM_SOURCE();
 8007468:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_DFSDMCLKSOURCE_PCLK)
 800746c:	2b00      	cmp	r3, #0
 800746e:	db01      	blt.n	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      /* Get the current USART2 source */
      srcclk = __HAL_RCC_GET_USART2_SOURCE();
      
      if(srcclk == RCC_USART2CLKSOURCE_PCLK1)
      {
        frequency = HAL_RCC_GetPCLK1Freq();
 8007470:	f7ff b934 	b.w	80066dc <HAL_RCC_GetPCLK1Freq>
      {
        frequency = HAL_RCC_GetPCLK2Freq();
      }
      else if(srcclk == RCC_USART1CLKSOURCE_SYSCLK)
      {
        frequency = HAL_RCC_GetSysClockFreq();
 8007474:	f7ff b89c 	b.w	80065b0 <HAL_RCC_GetSysClockFreq>
    }

    /* f(PLL Source) / PLLM */
    pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> 4) + 1));

    switch(PeriphClk)
 8007478:	2820      	cmp	r0, #32
 800747a:	f47f af26 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      }
      break;

    case RCC_PERIPHCLK_LPUART1:
      /* Get the current LPUART1 source */
      srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 800747e:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_LPUART1CLKSOURCE_PCLK1)
 8007482:	f413 6340 	ands.w	r3, r3, #3072	; 0xc00
 8007486:	d0f3      	beq.n	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if(srcclk == RCC_LPUART1CLKSOURCE_SYSCLK)
 8007488:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800748c:	d0f2      	beq.n	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_LPUART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 800748e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8007492:	f43f af05 	beq.w	80072a0 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
      {
        frequency = HSI_VALUE;
      }
      else if((srcclk == RCC_LPUART1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
 8007496:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800749a:	f47f af16 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
 800749e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80074a2:	f503 3301 	add.w	r3, r3, #132096	; 0x20400
 80074a6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
      {
        frequency = HSI_VALUE;
      }
      else if((srcclk == RCC_USART1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
      {
        frequency = LSE_VALUE;
 80074aa:	f013 0f02 	tst.w	r3, #2
 80074ae:	bf0c      	ite	eq
 80074b0:	2000      	moveq	r0, #0
 80074b2:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 80074b6:	4770      	bx	lr
    }

    /* f(PLL Source) / PLLM */
    pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> 4) + 1));

    switch(PeriphClk)
 80074b8:	2801      	cmp	r0, #1
 80074ba:	f47f af06 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      }
      break;
      
    case RCC_PERIPHCLK_USART1:
      /* Get the current USART1 source */
      srcclk = __HAL_RCC_GET_USART1_SOURCE();
 80074be:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_USART1CLKSOURCE_PCLK2)
 80074c2:	f013 0303 	ands.w	r3, r3, #3
 80074c6:	f000 80c6 	beq.w	8007656 <HAL_RCCEx_GetPeriphCLKFreq+0x436>
      {
        frequency = HAL_RCC_GetPCLK2Freq();
      }
      else if(srcclk == RCC_USART1CLKSOURCE_SYSCLK)
 80074ca:	2b01      	cmp	r3, #1
 80074cc:	d0d2      	beq.n	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_USART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 80074ce:	2b02      	cmp	r3, #2
 80074d0:	4b1b      	ldr	r3, [pc, #108]	; (8007540 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
 80074d2:	d1e8      	bne.n	80074a6 <HAL_RCCEx_GetPeriphCLKFreq+0x286>
 80074d4:	e6e5      	b.n	80072a2 <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      }
      break;

    case RCC_PERIPHCLK_I2C1:
      /* Get the current I2C1 source */
      srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 80074d6:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_I2C1CLKSOURCE_PCLK1)
 80074da:	f413 5340 	ands.w	r3, r3, #12288	; 0x3000
 80074de:	d0c7      	beq.n	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if(srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
 80074e0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80074e4:	d0c6      	beq.n	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_I2C1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 80074e6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80074ea:	f47f aeee 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
 80074ee:	e704      	b.n	80072fa <HAL_RCCEx_GetPeriphCLKFreq+0xda>
      }
      break;

    case RCC_PERIPHCLK_USART2:
      /* Get the current USART2 source */
      srcclk = __HAL_RCC_GET_USART2_SOURCE();
 80074f0:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_USART2CLKSOURCE_PCLK1)
 80074f4:	f013 030c 	ands.w	r3, r3, #12
 80074f8:	d0ba      	beq.n	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if(srcclk == RCC_USART2CLKSOURCE_SYSCLK)
 80074fa:	2b04      	cmp	r3, #4
 80074fc:	d0ba      	beq.n	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_USART2CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 80074fe:	2b08      	cmp	r3, #8
 8007500:	f43f aefb 	beq.w	80072fa <HAL_RCCEx_GetPeriphCLKFreq+0xda>
      {
        frequency = HSI_VALUE;
      }
      else if((srcclk == RCC_USART2CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
 8007504:	2b0c      	cmp	r3, #12
 8007506:	f47f aee0 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      }
      else if((srcclk == RCC_LPTIM1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
      {
        frequency = HSI_VALUE;
      }
      else if ((srcclk == RCC_LPTIM1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
 800750a:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
      {
        frequency = HSI_VALUE;
      }
      else if((srcclk == RCC_USART1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
      {
        frequency = LSE_VALUE;
 800750e:	f013 0f02 	tst.w	r3, #2
 8007512:	bf0c      	ite	eq
 8007514:	2000      	moveq	r0, #0
 8007516:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 800751a:	4770      	bx	lr
      }
      break;

    case RCC_PERIPHCLK_UART5:
      /* Get the current UART5 source */
      srcclk = __HAL_RCC_GET_UART5_SOURCE();
 800751c:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_UART5CLKSOURCE_PCLK1)
 8007520:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8007524:	d0a4      	beq.n	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if(srcclk == RCC_UART5CLKSOURCE_SYSCLK)
 8007526:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800752a:	d0a3      	beq.n	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if((srcclk == RCC_UART5CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 800752c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007530:	f43f aee3 	beq.w	80072fa <HAL_RCCEx_GetPeriphCLKFreq+0xda>
      {
        frequency = HSI_VALUE;
      }
      else if((srcclk == RCC_UART5CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
 8007534:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8007538:	f47f aec7 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
 800753c:	e7e5      	b.n	800750a <HAL_RCCEx_GetPeriphCLKFreq+0x2ea>
 800753e:	bf00      	nop
 8007540:	40021000 	.word	0x40021000
 8007544:	007a1200 	.word	0x007a1200
 8007548:	00f42400 	.word	0x00f42400
 800754c:	000f4240 	.word	0x000f4240
 8007550:	0003d090 	.word	0x0003d090
      }
      break;

    case RCC_PERIPHCLK_LPTIM1:
      /* Get the current LPTIM1 source */
      srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
 8007554:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      
      if(srcclk == RCC_LPTIM1CLKSOURCE_PCLK)
 8007558:	f413 2340 	ands.w	r3, r3, #786432	; 0xc0000
 800755c:	d088      	beq.n	8007470 <HAL_RCCEx_GetPeriphCLKFreq+0x250>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if((srcclk == RCC_LPTIM1CLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 800755e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8007562:	d05c      	beq.n	800761e <HAL_RCCEx_GetPeriphCLKFreq+0x3fe>
      {
        frequency = LSI_VALUE;
      }
      else if((srcclk == RCC_LPTIM1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 8007564:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8007568:	f43f aec7 	beq.w	80072fa <HAL_RCCEx_GetPeriphCLKFreq+0xda>
      {
        frequency = HSI_VALUE;
      }
      else if ((srcclk == RCC_LPTIM1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
 800756c:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 8007570:	f47f aeab 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
 8007574:	e7c9      	b.n	800750a <HAL_RCCEx_GetPeriphCLKFreq+0x2ea>
      }
      break;

    case RCC_PERIPHCLK_ADC:
    
      srcclk = __HAL_RCC_GET_ADC_SOURCE();
 8007576:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800757a:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
      
      if(srcclk == RCC_ADCCLKSOURCE_SYSCLK)
 800757e:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
 8007582:	f43f af77 	beq.w	8007474 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if(srcclk == RCC_ADCCLKSOURCE_PLLSAI1)
 8007586:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800758a:	d05d      	beq.n	8007648 <HAL_RCCEx_GetPeriphCLKFreq+0x428>
          /* f(PLLADC1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1R */
          plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> 8;
          frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> 24) + 1) << 1);
        }
      }
      else if(srcclk == RCC_ADCCLKSOURCE_PLLSAI2)
 800758c:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 8007590:	f47f ae9b 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
      {
        if(__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_ADC2CLK) != RESET)
 8007594:	694a      	ldr	r2, [r1, #20]
 8007596:	f012 7080 	ands.w	r0, r2, #16777216	; 0x1000000
 800759a:	d00c      	beq.n	80075b6 <HAL_RCCEx_GetPeriphCLKFreq+0x396>
        {
          /* f(PLLADC2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2R */
          plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> 8;
 800759c:	694a      	ldr	r2, [r1, #20]
          frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R) >> 24) + 1) << 1);
 800759e:	6948      	ldr	r0, [r1, #20]
 80075a0:	f000 60c0 	and.w	r0, r0, #100663296	; 0x6000000
      else if(srcclk == RCC_ADCCLKSOURCE_PLLSAI2)
      {
        if(__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_ADC2CLK) != RESET)
        {
          /* f(PLLADC2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2R */
          plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> 8;
 80075a4:	f3c2 2206 	ubfx	r2, r2, #8, #7
          frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R) >> 24) + 1) << 1);
 80075a8:	0dc0      	lsrs	r0, r0, #23
 80075aa:	fb02 f303 	mul.w	r3, r2, r3
 80075ae:	3002      	adds	r0, #2
 80075b0:	fbb3 f0f0 	udiv	r0, r3, r0
 80075b4:	4770      	bx	lr
      break;
    }
  }

  return(frequency);
}
 80075b6:	4770      	bx	lr
        }
        /* Else, PLL clock output to check below */
      }
      else /* RCC_PERIPHCLK_SAI2 */
      {
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_SAI2SEL);
 80075b8:	f8d1 0088 	ldr.w	r0, [r1, #136]	; 0x88
 80075bc:	f000 7040 	and.w	r0, r0, #50331648	; 0x3000000
          
        if(srcclk == RCC_SAI2CLKSOURCE_PIN)
 80075c0:	f1b0 7f40 	cmp.w	r0, #50331648	; 0x3000000
 80075c4:	d03e      	beq.n	8007644 <HAL_RCCEx_GetPeriphCLKFreq+0x424>
        /* Else, PLL clock output to check below */
      }

      if(frequency == 0)
      {
        if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
 80075c6:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80075ca:	d020      	beq.n	800760e <HAL_RCCEx_GetPeriphCLKFreq+0x3ee>
 80075cc:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
 80075d0:	d01d      	beq.n	800760e <HAL_RCCEx_GetPeriphCLKFreq+0x3ee>
              pllp = 7;
            }
            frequency = (pllvco * plln) / pllp;
          }
        }
        else if(srcclk == 0)  /* RCC_SAI1CLKSOURCE_PLLSAI1 || RCC_SAI2CLKSOURCE_PLLSAI1 */
 80075d2:	2800      	cmp	r0, #0
 80075d4:	d141      	bne.n	800765a <HAL_RCCEx_GetPeriphCLKFreq+0x43a>
        {
          if(__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != RESET)
 80075d6:	4a2f      	ldr	r2, [pc, #188]	; (8007694 <HAL_RCCEx_GetPeriphCLKFreq+0x474>)
 80075d8:	6911      	ldr	r1, [r2, #16]
 80075da:	03c9      	lsls	r1, r1, #15
 80075dc:	d5eb      	bpl.n	80075b6 <HAL_RCCEx_GetPeriphCLKFreq+0x396>
          {
            /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
            plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> 8;
 80075de:	6910      	ldr	r0, [r2, #16]
            if(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) != RESET)
 80075e0:	6912      	ldr	r2, [r2, #16]
        else if(srcclk == 0)  /* RCC_SAI1CLKSOURCE_PLLSAI1 || RCC_SAI2CLKSOURCE_PLLSAI1 */
        {
          if(__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != RESET)
          {
            /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
            plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> 8;
 80075e2:	f3c0 2006 	ubfx	r0, r0, #8, #7
            {
              pllp = 17;
            }
            else
            {
              pllp = 7;
 80075e6:	f412 3f00 	tst.w	r2, #131072	; 0x20000
            }
            frequency = (pllvco * plln) / pllp;
 80075ea:	fb00 f303 	mul.w	r3, r0, r3
            {
              pllp = 17;
            }
            else
            {
              pllp = 7;
 80075ee:	bf14      	ite	ne
 80075f0:	2011      	movne	r0, #17
 80075f2:	2007      	moveq	r0, #7
            }
            frequency = (pllvco * plln) / pllp;
 80075f4:	fbb3 f0f0 	udiv	r0, r3, r0
 80075f8:	4770      	bx	lr
    case RCC_PERIPHCLK_SAI1:
    case RCC_PERIPHCLK_SAI2:

      if(PeriphClk == RCC_PERIPHCLK_SAI1)
      {
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_SAI1SEL);
 80075fa:	f8d1 0088 	ldr.w	r0, [r1, #136]	; 0x88
 80075fe:	f400 0040 	and.w	r0, r0, #12582912	; 0xc00000
          
        if(srcclk == RCC_SAI1CLKSOURCE_PIN)
 8007602:	f5b0 0f40 	cmp.w	r0, #12582912	; 0xc00000
 8007606:	d01d      	beq.n	8007644 <HAL_RCCEx_GetPeriphCLKFreq+0x424>
        /* Else, PLL clock output to check below */
      }

      if(frequency == 0)
      {
        if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
 8007608:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 800760c:	d1e1      	bne.n	80075d2 <HAL_RCCEx_GetPeriphCLKFreq+0x3b2>
        {
          if(__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI3CLK) != RESET)
 800760e:	4921      	ldr	r1, [pc, #132]	; (8007694 <HAL_RCCEx_GetPeriphCLKFreq+0x474>)
 8007610:	68ca      	ldr	r2, [r1, #12]
 8007612:	f412 3080 	ands.w	r0, r2, #65536	; 0x10000
 8007616:	d0ce      	beq.n	80075b6 <HAL_RCCEx_GetPeriphCLKFreq+0x396>
          {
            /* f(PLLSAI3CLK) = f(VCO input) * PLLN / PLLP */
            plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> 8;
 8007618:	68c8      	ldr	r0, [r1, #12]
            if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != RESET)
 800761a:	68ca      	ldr	r2, [r1, #12]
 800761c:	e7e1      	b.n	80075e2 <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
      
      if(srcclk == RCC_LPTIM2CLKSOURCE_PCLK)
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if((srcclk == RCC_LPTIM2CLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 800761e:	f8d1 3094 	ldr.w	r3, [r1, #148]	; 0x94
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      else if((srcclk == RCC_LPTIM1CLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
      {
        frequency = LSI_VALUE;
 8007622:	f013 0f02 	tst.w	r3, #2
 8007626:	bf0c      	ite	eq
 8007628:	2000      	moveq	r0, #0
 800762a:	f44f 40fa 	movne.w	r0, #32000	; 0x7d00
 800762e:	4770      	bx	lr

      srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
      
      if(srcclk == RCC_CCIPR_CLK48SEL)   /* MSI ? */
      {
        frequency = (1 << ((__HAL_RCC_GET_MSI_RANGE() >> 4) - 4)) * 1000000;
 8007630:	680b      	ldr	r3, [r1, #0]
 8007632:	071b      	lsls	r3, r3, #28
 8007634:	d523      	bpl.n	800767e <HAL_RCCEx_GetPeriphCLKFreq+0x45e>
 8007636:	680b      	ldr	r3, [r1, #0]
 8007638:	4817      	ldr	r0, [pc, #92]	; (8007698 <HAL_RCCEx_GetPeriphCLKFreq+0x478>)
 800763a:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800763e:	3b04      	subs	r3, #4
 8007640:	4098      	lsls	r0, r3
 8007642:	4770      	bx	lr
 8007644:	4815      	ldr	r0, [pc, #84]	; (800769c <HAL_RCCEx_GetPeriphCLKFreq+0x47c>)
 8007646:	4770      	bx	lr
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      else if(srcclk == RCC_ADCCLKSOURCE_PLLSAI1)
      {
        if(__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_ADC1CLK) != RESET)
 8007648:	690a      	ldr	r2, [r1, #16]
 800764a:	f012 7080 	ands.w	r0, r2, #16777216	; 0x1000000
 800764e:	d0b2      	beq.n	80075b6 <HAL_RCCEx_GetPeriphCLKFreq+0x396>
        {
          /* f(PLLADC1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1R */
          plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> 8;
 8007650:	690a      	ldr	r2, [r1, #16]
          frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> 24) + 1) << 1);
 8007652:	6908      	ldr	r0, [r1, #16]
 8007654:	e7a4      	b.n	80075a0 <HAL_RCCEx_GetPeriphCLKFreq+0x380>
      /* Get the current USART1 source */
      srcclk = __HAL_RCC_GET_USART1_SOURCE();
      
      if(srcclk == RCC_USART1CLKSOURCE_PCLK2)
      {
        frequency = HAL_RCC_GetPCLK2Freq();
 8007656:	f7ff b857 	b.w	8006708 <HAL_RCC_GetPCLK2Freq>
              pllp = 7;
            }
            frequency = (pllvco * plln) / pllp;
          }
        }
        else if((srcclk == RCC_SAI1CLKSOURCE_PLLSAI2) || (srcclk == RCC_SAI2CLKSOURCE_PLLSAI2))
 800765a:	f5b0 0f80 	cmp.w	r0, #4194304	; 0x400000
 800765e:	d003      	beq.n	8007668 <HAL_RCCEx_GetPeriphCLKFreq+0x448>
 8007660:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8007664:	f47f ae31 	bne.w	80072ca <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
        {
          if(__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_SAI2CLK) != RESET)
 8007668:	490a      	ldr	r1, [pc, #40]	; (8007694 <HAL_RCCEx_GetPeriphCLKFreq+0x474>)
 800766a:	694a      	ldr	r2, [r1, #20]
 800766c:	f412 3280 	ands.w	r2, r2, #65536	; 0x10000
 8007670:	d00d      	beq.n	800768e <HAL_RCCEx_GetPeriphCLKFreq+0x46e>
          {
            /* f(PLLSAI2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2P */
            plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> 8;
 8007672:	6948      	ldr	r0, [r1, #20]
            if(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) != RESET)
 8007674:	694a      	ldr	r2, [r1, #20]
 8007676:	e7b4      	b.n	80075e2 <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
        frequency = (1 << ((__HAL_RCC_GET_MSI_RANGE() >> 4) - 4)) * 1000000;
      }
      else if(srcclk == RCC_CCIPR_CLK48SEL_1)  /* PLL ? */
      {
        /* f(PLL48M1CLK) = f(VCO input) * PLLN / PLLQ */
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> 8;
 8007678:	68ca      	ldr	r2, [r1, #12]
        frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> 21) + 1) << 1);
 800767a:	68c8      	ldr	r0, [r1, #12]
 800767c:	e6e2      	b.n	8007444 <HAL_RCCEx_GetPeriphCLKFreq+0x224>

      srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
      
      if(srcclk == RCC_CCIPR_CLK48SEL)   /* MSI ? */
      {
        frequency = (1 << ((__HAL_RCC_GET_MSI_RANGE() >> 4) - 4)) * 1000000;
 800767e:	f8d1 3094 	ldr.w	r3, [r1, #148]	; 0x94
 8007682:	4805      	ldr	r0, [pc, #20]	; (8007698 <HAL_RCCEx_GetPeriphCLKFreq+0x478>)
 8007684:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8007688:	3b04      	subs	r3, #4
 800768a:	4098      	lsls	r0, r3
 800768c:	4770      	bx	lr
 800768e:	4610      	mov	r0, r2
 8007690:	4770      	bx	lr
 8007692:	bf00      	nop
 8007694:	40021000 	.word	0x40021000
 8007698:	000f4240 	.word	0x000f4240
 800769c:	001fff68 	.word	0x001fff68

080076a0 <HAL_RCCEx_EnablePLLSAI1>:
  * @param  PLLSAI1Init  pointer to an RCC_PLLSAI1InitTypeDef structure that
  *         contains the configuration information for the PLLSAI1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI1(RCC_PLLSAI1InitTypeDef  *PLLSAI1Init)
{
 80076a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1Q_VALUE(PLLSAI1Init->PLLSAI1Q));
  assert_param(IS_RCC_PLLSAI1R_VALUE(PLLSAI1Init->PLLSAI1R));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1Init->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 80076a2:	4c2b      	ldr	r4, [pc, #172]	; (8007750 <HAL_RCCEx_EnablePLLSAI1+0xb0>)
 80076a4:	6823      	ldr	r3, [r4, #0]
 80076a6:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80076aa:	6023      	str	r3, [r4, #0]
  * @param  PLLSAI1Init  pointer to an RCC_PLLSAI1InitTypeDef structure that
  *         contains the configuration information for the PLLSAI1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI1(RCC_PLLSAI1InitTypeDef  *PLLSAI1Init)
{
 80076ac:	4606      	mov	r6, r0

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80076ae:	f7f9 fa2b 	bl	8000b08 <HAL_GetTick>
 80076b2:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
 80076b6:	4605      	mov	r5, r0

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
 80076b8:	e005      	b.n	80076c6 <HAL_RCCEx_EnablePLLSAI1+0x26>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80076ba:	f7f9 fa25 	bl	8000b08 <HAL_GetTick>
 80076be:	1b40      	subs	r0, r0, r5
 80076c0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80076c4:	d842      	bhi.n	800774c <HAL_RCCEx_EnablePLLSAI1+0xac>
 80076c6:	fa97 f3a7 	rbit	r3, r7

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
 80076ca:	4921      	ldr	r1, [pc, #132]	; (8007750 <HAL_RCCEx_EnablePLLSAI1+0xb0>)
 80076cc:	6822      	ldr	r2, [r4, #0]
 80076ce:	fa97 f3a7 	rbit	r3, r7
 80076d2:	fab3 f383 	clz	r3, r3
 80076d6:	f003 031f 	and.w	r3, r3, #31
 80076da:	fa22 f303 	lsr.w	r3, r2, r3
 80076de:	07da      	lsls	r2, r3, #31
 80076e0:	d4eb      	bmi.n	80076ba <HAL_RCCEx_EnablePLLSAI1+0x1a>

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    /* Configure the PLLSAI1 Division factors P, Q and R */
    __HAL_RCC_PLLSAI1_CONFIG(PLLSAI1Init->PLLSAI1N, PLLSAI1Init->PLLSAI1P, PLLSAI1Init->PLLSAI1Q, PLLSAI1Init->PLLSAI1R);
 80076e2:	6872      	ldr	r2, [r6, #4]
 80076e4:	6833      	ldr	r3, [r6, #0]
 80076e6:	68b5      	ldr	r5, [r6, #8]
 80076e8:	68f4      	ldr	r4, [r6, #12]
 80076ea:	0912      	lsrs	r2, r2, #4
 80076ec:	021b      	lsls	r3, r3, #8
 80076ee:	086d      	lsrs	r5, r5, #1
 80076f0:	ea43 4042 	orr.w	r0, r3, r2, lsl #17
 80076f4:	0864      	lsrs	r4, r4, #1
 80076f6:	1e6b      	subs	r3, r5, #1
 80076f8:	ea40 5243 	orr.w	r2, r0, r3, lsl #21
 80076fc:	1e63      	subs	r3, r4, #1
 80076fe:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 8007702:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Clock output(s) */    
    __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1Init->PLLSAI1ClockOut);
 8007704:	6933      	ldr	r3, [r6, #16]
 8007706:	690a      	ldr	r2, [r1, #16]
 8007708:	4313      	orrs	r3, r2
 800770a:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 800770c:	680b      	ldr	r3, [r1, #0]
 800770e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8007712:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 8007714:	460c      	mov	r4, r1

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8007716:	f7f9 f9f7 	bl	8000b08 <HAL_GetTick>
 800771a:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
 800771e:	4606      	mov	r6, r0

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 8007720:	e005      	b.n	800772e <HAL_RCCEx_EnablePLLSAI1+0x8e>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8007722:	f7f9 f9f1 	bl	8000b08 <HAL_GetTick>
 8007726:	1b80      	subs	r0, r0, r6
 8007728:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800772c:	d80e      	bhi.n	800774c <HAL_RCCEx_EnablePLLSAI1+0xac>
 800772e:	fa95 f3a5 	rbit	r3, r5

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI1 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) == RESET)
 8007732:	6822      	ldr	r2, [r4, #0]
 8007734:	fa95 f3a5 	rbit	r3, r5
 8007738:	fab3 f383 	clz	r3, r3
 800773c:	f003 031f 	and.w	r3, r3, #31
 8007740:	fa22 f303 	lsr.w	r3, r2, r3
 8007744:	07db      	lsls	r3, r3, #31
 8007746:	d5ec      	bpl.n	8007722 <HAL_RCCEx_EnablePLLSAI1+0x82>
 8007748:	2000      	movs	r0, #0
 800774a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* Wait till PLLSAI1 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
    {
      status = HAL_TIMEOUT;
 800774c:	2003      	movs	r0, #3
 800774e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007750:	40021000 	.word	0x40021000

08007754 <HAL_RCCEx_DisablePLLSAI1>:
/**
  * @brief  Disable PLLSAI1.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI1(void)
{
 8007754:	b570      	push	{r4, r5, r6, lr}
  uint32_t tickstart = 0;
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8007756:	4c14      	ldr	r4, [pc, #80]	; (80077a8 <HAL_RCCEx_DisablePLLSAI1+0x54>)
 8007758:	6823      	ldr	r3, [r4, #0]
 800775a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800775e:	6023      	str	r3, [r4, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8007760:	f7f9 f9d2 	bl	8000b08 <HAL_GetTick>
 8007764:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
 8007768:	4605      	mov	r5, r0

  /* Wait till PLLSAI1 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
 800776a:	e005      	b.n	8007778 <HAL_RCCEx_DisablePLLSAI1+0x24>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800776c:	f7f9 f9cc 	bl	8000b08 <HAL_GetTick>
 8007770:	1b40      	subs	r0, r0, r5
 8007772:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8007776:	d814      	bhi.n	80077a2 <HAL_RCCEx_DisablePLLSAI1+0x4e>
 8007778:	fa96 f3a6 	rbit	r3, r6

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till PLLSAI1 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
 800777c:	6820      	ldr	r0, [r4, #0]
 800777e:	fa96 f3a6 	rbit	r3, r6
 8007782:	fab3 f383 	clz	r3, r3
 8007786:	f003 031f 	and.w	r3, r3, #31
 800778a:	40d8      	lsrs	r0, r3
 800778c:	f010 0001 	ands.w	r0, r0, #1
 8007790:	d1ec      	bne.n	800776c <HAL_RCCEx_DisablePLLSAI1+0x18>
      break;
    }
  }
  
  /* Disable the PLLSAI1 Clock outputs */    
  __HAL_RCC_PLLSAI1CLKOUT_DISABLE(RCC_PLLSAI1_SAI1CLK|RCC_PLLSAI1_48M2CLK|RCC_PLLSAI1_ADC1CLK);
 8007792:	4a05      	ldr	r2, [pc, #20]	; (80077a8 <HAL_RCCEx_DisablePLLSAI1+0x54>)
 8007794:	6913      	ldr	r3, [r2, #16]
 8007796:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 800779a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800779e:	6113      	str	r3, [r2, #16]

  return status;
}
 80077a0:	bd70      	pop	{r4, r5, r6, pc}
  /* Wait till PLLSAI1 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI1RDY) != RESET)
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
    {
      status = HAL_TIMEOUT;
 80077a2:	2003      	movs	r0, #3
 80077a4:	e7f5      	b.n	8007792 <HAL_RCCEx_DisablePLLSAI1+0x3e>
 80077a6:	bf00      	nop
 80077a8:	40021000 	.word	0x40021000

080077ac <HAL_RCCEx_EnablePLLSAI2>:
  * @param  PLLSAI2Init  pointer to an RCC_PLLSAI2InitTypeDef structure that
  *         contains the configuration information for the PLLSAI2
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI2(RCC_PLLSAI2InitTypeDef  *PLLSAI2Init)
{
 80077ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI2P_VALUE(PLLSAI2Init->PLLSAI2P));
  assert_param(IS_RCC_PLLSAI2R_VALUE(PLLSAI2Init->PLLSAI2R));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PLLSAI2Init->PLLSAI2ClockOut));

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();
 80077ae:	4c29      	ldr	r4, [pc, #164]	; (8007854 <HAL_RCCEx_EnablePLLSAI2+0xa8>)
 80077b0:	6823      	ldr	r3, [r4, #0]
 80077b2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80077b6:	6023      	str	r3, [r4, #0]
  * @param  PLLSAI2Init  pointer to an RCC_PLLSAI2InitTypeDef structure that
  *         contains the configuration information for the PLLSAI2
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI2(RCC_PLLSAI2InitTypeDef  *PLLSAI2Init)
{
 80077b8:	4606      	mov	r6, r0

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80077ba:	f7f9 f9a5 	bl	8000b08 <HAL_GetTick>
 80077be:	f04f 5700 	mov.w	r7, #536870912	; 0x20000000
 80077c2:	4605      	mov	r5, r0

  /* Wait till PLLSAI2 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
 80077c4:	e005      	b.n	80077d2 <HAL_RCCEx_EnablePLLSAI2+0x26>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 80077c6:	f7f9 f99f 	bl	8000b08 <HAL_GetTick>
 80077ca:	1b40      	subs	r0, r0, r5
 80077cc:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80077d0:	d83d      	bhi.n	800784e <HAL_RCCEx_EnablePLLSAI2+0xa2>
 80077d2:	fa97 f3a7 	rbit	r3, r7

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till PLLSAI2 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
 80077d6:	491f      	ldr	r1, [pc, #124]	; (8007854 <HAL_RCCEx_EnablePLLSAI2+0xa8>)
 80077d8:	6822      	ldr	r2, [r4, #0]
 80077da:	fa97 f3a7 	rbit	r3, r7
 80077de:	fab3 f383 	clz	r3, r3
 80077e2:	f003 031f 	and.w	r3, r3, #31
 80077e6:	fa22 f303 	lsr.w	r3, r2, r3
 80077ea:	07da      	lsls	r2, r3, #31
 80077ec:	d4eb      	bmi.n	80077c6 <HAL_RCCEx_EnablePLLSAI2+0x1a>

  if(status == HAL_OK)    
  {
    /* Configure the PLLSAI2 Multiplication factor N */
    /* Configure the PLLSAI2 Division factors P and R */
    __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2R);
 80077ee:	6870      	ldr	r0, [r6, #4]
 80077f0:	6833      	ldr	r3, [r6, #0]
 80077f2:	68b2      	ldr	r2, [r6, #8]
 80077f4:	0900      	lsrs	r0, r0, #4
 80077f6:	021b      	lsls	r3, r3, #8
 80077f8:	0852      	lsrs	r2, r2, #1
 80077fa:	ea43 4340 	orr.w	r3, r3, r0, lsl #17
 80077fe:	3a01      	subs	r2, #1
 8007800:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8007804:	614b      	str	r3, [r1, #20]
    /* Configure the PLLSAI2 Clock output(s) */    
    __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PLLSAI2Init->PLLSAI2ClockOut);
 8007806:	68f3      	ldr	r3, [r6, #12]
 8007808:	694a      	ldr	r2, [r1, #20]
 800780a:	4313      	orrs	r3, r2
 800780c:	614b      	str	r3, [r1, #20]

    /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
    __HAL_RCC_PLLSAI2_ENABLE();
 800780e:	680b      	ldr	r3, [r1, #0]
 8007810:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8007814:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
 8007816:	460c      	mov	r4, r1

    /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
    __HAL_RCC_PLLSAI2_ENABLE();

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8007818:	f7f9 f976 	bl	8000b08 <HAL_GetTick>
 800781c:	f04f 5500 	mov.w	r5, #536870912	; 0x20000000
 8007820:	4606      	mov	r6, r0

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
 8007822:	e005      	b.n	8007830 <HAL_RCCEx_EnablePLLSAI2+0x84>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8007824:	f7f9 f970 	bl	8000b08 <HAL_GetTick>
 8007828:	1b80      	subs	r0, r0, r6
 800782a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800782e:	d80e      	bhi.n	800784e <HAL_RCCEx_EnablePLLSAI2+0xa2>
 8007830:	fa95 f3a5 	rbit	r3, r5

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) == RESET)
 8007834:	6822      	ldr	r2, [r4, #0]
 8007836:	fa95 f3a5 	rbit	r3, r5
 800783a:	fab3 f383 	clz	r3, r3
 800783e:	f003 031f 	and.w	r3, r3, #31
 8007842:	fa22 f303 	lsr.w	r3, r2, r3
 8007846:	07db      	lsls	r3, r3, #31
 8007848:	d5ec      	bpl.n	8007824 <HAL_RCCEx_EnablePLLSAI2+0x78>
 800784a:	2000      	movs	r0, #0
 800784c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* Wait till PLLSAI2 is ready to be updated */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
    {
      status = HAL_TIMEOUT;
 800784e:	2003      	movs	r0, #3
 8007850:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007852:	bf00      	nop
 8007854:	40021000 	.word	0x40021000

08007858 <HAL_RCCEx_DisablePLLSAI2>:
/**
  * @brief  Disable PLLISAI2.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI2(void)
{
 8007858:	b570      	push	{r4, r5, r6, lr}
  uint32_t tickstart = 0;
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();
 800785a:	4c14      	ldr	r4, [pc, #80]	; (80078ac <HAL_RCCEx_DisablePLLSAI2+0x54>)
 800785c:	6823      	ldr	r3, [r4, #0]
 800785e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8007862:	6023      	str	r3, [r4, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8007864:	f7f9 f950 	bl	8000b08 <HAL_GetTick>
 8007868:	f04f 5600 	mov.w	r6, #536870912	; 0x20000000
 800786c:	4605      	mov	r5, r0

  /* Wait till PLLSAI2 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
 800786e:	e005      	b.n	800787c <HAL_RCCEx_DisablePLLSAI2+0x24>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8007870:	f7f9 f94a 	bl	8000b08 <HAL_GetTick>
 8007874:	1b40      	subs	r0, r0, r5
 8007876:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800787a:	d814      	bhi.n	80078a6 <HAL_RCCEx_DisablePLLSAI2+0x4e>
 800787c:	fa96 f3a6 	rbit	r3, r6

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till PLLSAI2 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
 8007880:	6820      	ldr	r0, [r4, #0]
 8007882:	fa96 f3a6 	rbit	r3, r6
 8007886:	fab3 f383 	clz	r3, r3
 800788a:	f003 031f 	and.w	r3, r3, #31
 800788e:	40d8      	lsrs	r0, r3
 8007890:	f010 0001 	ands.w	r0, r0, #1
 8007894:	d1ec      	bne.n	8007870 <HAL_RCCEx_DisablePLLSAI2+0x18>
      break;
    }
  }
  
  /* Disable the PLLSAI2 Clock outputs */    
  __HAL_RCC_PLLSAI2CLKOUT_DISABLE(RCC_PLLSAI2_SAI2CLK|RCC_PLLSAI2_ADC2CLK);
 8007896:	4a05      	ldr	r2, [pc, #20]	; (80078ac <HAL_RCCEx_DisablePLLSAI2+0x54>)
 8007898:	6953      	ldr	r3, [r2, #20]
 800789a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800789e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80078a2:	6153      	str	r3, [r2, #20]

  return status;
}
 80078a4:	bd70      	pop	{r4, r5, r6, pc}
  /* Wait till PLLSAI2 is ready */
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLSAI2RDY) != RESET)
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
    {
      status = HAL_TIMEOUT;
 80078a6:	2003      	movs	r0, #3
 80078a8:	e7f5      	b.n	8007896 <HAL_RCCEx_DisablePLLSAI2+0x3e>
 80078aa:	bf00      	nop
 80078ac:	40021000 	.word	0x40021000

080078b0 <HAL_RCCEx_WakeUpStopCLKConfig>:
  */
void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
{
  assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));
  
  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
 80078b0:	4a03      	ldr	r2, [pc, #12]	; (80078c0 <HAL_RCCEx_WakeUpStopCLKConfig+0x10>)
 80078b2:	6893      	ldr	r3, [r2, #8]
 80078b4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80078b8:	4318      	orrs	r0, r3
 80078ba:	6090      	str	r0, [r2, #8]
 80078bc:	4770      	bx	lr
 80078be:	bf00      	nop
 80078c0:	40021000 	.word	0x40021000

080078c4 <HAL_RCCEx_StandbyMSIRangeConfig>:
  */
void HAL_RCCEx_StandbyMSIRangeConfig(uint32_t MSIRange)
{
  assert_param(IS_RCC_MSI_STANDBY_CLOCK_RANGE(MSIRange));
  
  __HAL_RCC_MSI_STANDBY_RANGE_CONFIG(MSIRange);
 80078c4:	4a04      	ldr	r2, [pc, #16]	; (80078d8 <HAL_RCCEx_StandbyMSIRangeConfig+0x14>)
 80078c6:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 80078ca:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80078ce:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
 80078d2:	f8c2 0094 	str.w	r0, [r2, #148]	; 0x94
 80078d6:	4770      	bx	lr
 80078d8:	40021000 	.word	0x40021000

080078dc <HAL_RCCEx_EnableLSECSS>:
  *         clock with HAL_RCCEx_PeriphCLKConfig().
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
 80078dc:	4a03      	ldr	r2, [pc, #12]	; (80078ec <HAL_RCCEx_EnableLSECSS+0x10>)
 80078de:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80078e2:	f043 0320 	orr.w	r3, r3, #32
 80078e6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 80078ea:	4770      	bx	lr
 80078ec:	40021000 	.word	0x40021000

080078f0 <HAL_RCCEx_DisableLSECSS>:
  * @note   LSE Clock Security System can only be disabled after a LSE failure detection.
  * @retval None
  */
void HAL_RCCEx_DisableLSECSS(void)
{
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
 80078f0:	4b05      	ldr	r3, [pc, #20]	; (8007908 <HAL_RCCEx_DisableLSECSS+0x18>)
 80078f2:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80078f6:	f022 0220 	bic.w	r2, r2, #32
 80078fa:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  
  /* Disable LSE CSS IT if any */
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
 80078fe:	699a      	ldr	r2, [r3, #24]
 8007900:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8007904:	619a      	str	r2, [r3, #24]
 8007906:	4770      	bx	lr
 8007908:	40021000 	.word	0x40021000

0800790c <HAL_RCCEx_EnableLSECSS_IT>:
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS_IT(void)
{
  /* Enable LSE CSS */
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
 800790c:	4a0a      	ldr	r2, [pc, #40]	; (8007938 <HAL_RCCEx_EnableLSECSS_IT+0x2c>)

  /* Enable LSE CSS IT */
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
  
  /* Enable IT on EXTI Line 19 */
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
 800790e:	4b0b      	ldr	r3, [pc, #44]	; (800793c <HAL_RCCEx_EnableLSECSS_IT+0x30>)
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS_IT(void)
{
  /* Enable LSE CSS */
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
 8007910:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 8007914:	f041 0120 	orr.w	r1, r1, #32
 8007918:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90

  /* Enable LSE CSS IT */
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
 800791c:	6991      	ldr	r1, [r2, #24]
 800791e:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8007922:	6191      	str	r1, [r2, #24]
  
  /* Enable IT on EXTI Line 19 */
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
 8007924:	681a      	ldr	r2, [r3, #0]
 8007926:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800792a:	601a      	str	r2, [r3, #0]
  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
 800792c:	689a      	ldr	r2, [r3, #8]
 800792e:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8007932:	609a      	str	r2, [r3, #8]
 8007934:	4770      	bx	lr
 8007936:	bf00      	nop
 8007938:	40021000 	.word	0x40021000
 800793c:	40010400 	.word	0x40010400

08007940 <HAL_RCCEx_LSECSS_Callback>:
/**
  * @brief  RCCEx LSE Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_LSECSS_Callback(void)
{
 8007940:	4770      	bx	lr
 8007942:	bf00      	nop

08007944 <HAL_RCCEx_LSECSS_IRQHandler>:
/**
  * @brief Handle the RCC LSE Clock Security System interrupt request.
  * @retval None
  */
void HAL_RCCEx_LSECSS_IRQHandler(void)
{
 8007944:	b510      	push	{r4, lr}
  /* Check RCC LSE CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
 8007946:	4c05      	ldr	r4, [pc, #20]	; (800795c <HAL_RCCEx_LSECSS_IRQHandler+0x18>)
 8007948:	69e3      	ldr	r3, [r4, #28]
 800794a:	059b      	lsls	r3, r3, #22
 800794c:	d504      	bpl.n	8007958 <HAL_RCCEx_LSECSS_IRQHandler+0x14>
  {
    /* RCC LSE Clock Security System interrupt user callback */
    HAL_RCCEx_LSECSS_Callback();
 800794e:	f7ff fff7 	bl	8007940 <HAL_RCCEx_LSECSS_Callback>

    /* Clear RCC LSE CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
 8007952:	f44f 7300 	mov.w	r3, #512	; 0x200
 8007956:	6223      	str	r3, [r4, #32]
 8007958:	bd10      	pop	{r4, pc}
 800795a:	bf00      	nop
 800795c:	40021000 	.word	0x40021000

08007960 <HAL_RCCEx_EnableLSCO>:
  *            @arg @ref RCC_LSCOSOURCE_LSI  LSI clock selected as LSCO source
  *            @arg @ref RCC_LSCOSOURCE_LSE  LSE clock selected as LSCO source
  * @retval None
  */
void HAL_RCCEx_EnableLSCO(uint32_t LSCOSource)
{
 8007960:	b5f0      	push	{r4, r5, r6, r7, lr}
  
  /* Check the parameters */
  assert_param(IS_RCC_LSCOSOURCE(LSCOSource));

  /* LSCO Pin Clock Enable */
  __LSCO_CLK_ENABLE();
 8007962:	4c26      	ldr	r4, [pc, #152]	; (80079fc <HAL_RCCEx_EnableLSCO+0x9c>)
 8007964:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8007966:	f043 0301 	orr.w	r3, r3, #1
 800796a:	64e3      	str	r3, [r4, #76]	; 0x4c
 800796c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  *            @arg @ref RCC_LSCOSOURCE_LSI  LSI clock selected as LSCO source
  *            @arg @ref RCC_LSCOSOURCE_LSE  LSE clock selected as LSCO source
  * @retval None
  */
void HAL_RCCEx_EnableLSCO(uint32_t LSCOSource)
{
 800796e:	b089      	sub	sp, #36	; 0x24
  
  /* Check the parameters */
  assert_param(IS_RCC_LSCOSOURCE(LSCOSource));

  /* LSCO Pin Clock Enable */
  __LSCO_CLK_ENABLE();
 8007970:	f003 0301 	and.w	r3, r3, #1
 8007974:	9301      	str	r3, [sp, #4]

  /* Configue the LSCO pin in analog mode */
  GPIO_InitStruct.Pin = LSCO_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8007976:	2203      	movs	r2, #3
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8007978:	2302      	movs	r3, #2
  *            @arg @ref RCC_LSCOSOURCE_LSI  LSI clock selected as LSCO source
  *            @arg @ref RCC_LSCOSOURCE_LSE  LSE clock selected as LSCO source
  * @retval None
  */
void HAL_RCCEx_EnableLSCO(uint32_t LSCOSource)
{
 800797a:	4606      	mov	r6, r0

  /* LSCO Pin Clock Enable */
  __LSCO_CLK_ENABLE();

  /* Configue the LSCO pin in analog mode */
  GPIO_InitStruct.Pin = LSCO_PIN;
 800797c:	2704      	movs	r7, #4
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800797e:	2500      	movs	r5, #0
  HAL_GPIO_Init(LSCO_GPIO_PORT, &GPIO_InitStruct);
 8007980:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8007984:	a903      	add	r1, sp, #12
  /* LSCO Pin Clock Enable */
  __LSCO_CLK_ENABLE();

  /* Configue the LSCO pin in analog mode */
  GPIO_InitStruct.Pin = LSCO_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8007986:	9204      	str	r2, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8007988:	9306      	str	r3, [sp, #24]
  
  /* Check the parameters */
  assert_param(IS_RCC_LSCOSOURCE(LSCOSource));

  /* LSCO Pin Clock Enable */
  __LSCO_CLK_ENABLE();
 800798a:	f8dd e004 	ldr.w	lr, [sp, #4]

  /* Configue the LSCO pin in analog mode */
  GPIO_InitStruct.Pin = LSCO_PIN;
 800798e:	9703      	str	r7, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007990:	9505      	str	r5, [sp, #20]
  HAL_GPIO_Init(LSCO_GPIO_PORT, &GPIO_InitStruct);
 8007992:	f7fa faf5 	bl	8001f80 <HAL_GPIO_Init>

  /* Update LSCOSEL clock source in Backup Domain control register */
  if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8007996:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007998:	00da      	lsls	r2, r3, #3
 800799a:	d409      	bmi.n	80079b0 <HAL_RCCEx_EnableLSCO+0x50>
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 800799c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800799e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80079a2:	65a3      	str	r3, [r4, #88]	; 0x58
 80079a4:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80079a6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80079aa:	9302      	str	r3, [sp, #8]
 80079ac:	9b02      	ldr	r3, [sp, #8]
    pwrclkchanged = SET;
 80079ae:	2501      	movs	r5, #1
  }
  if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80079b0:	4b13      	ldr	r3, [pc, #76]	; (8007a00 <HAL_RCCEx_EnableLSCO+0xa0>)
 80079b2:	681b      	ldr	r3, [r3, #0]
 80079b4:	05db      	lsls	r3, r3, #23
 80079b6:	d511      	bpl.n	80079dc <HAL_RCCEx_EnableLSCO+0x7c>
  {
    HAL_PWR_EnableBkUpAccess();
    backupchanged = SET;
  }
  
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSCOSEL | RCC_BDCR_LSCOEN, LSCOSource | RCC_BDCR_LSCOEN);
 80079b8:	4b10      	ldr	r3, [pc, #64]	; (80079fc <HAL_RCCEx_EnableLSCO+0x9c>)
 80079ba:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
 80079be:	f020 7040 	bic.w	r0, r0, #50331648	; 0x3000000
 80079c2:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
 80079c6:	4330      	orrs	r0, r6
 80079c8:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
  
  if(backupchanged == SET)
  {
    HAL_PWR_DisableBkUpAccess();
  }
  if(pwrclkchanged == SET)
 80079cc:	b125      	cbz	r5, 80079d8 <HAL_RCCEx_EnableLSCO+0x78>
  {
    __HAL_RCC_PWR_CLK_DISABLE();
 80079ce:	4a0b      	ldr	r2, [pc, #44]	; (80079fc <HAL_RCCEx_EnableLSCO+0x9c>)
 80079d0:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80079d2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80079d6:	6593      	str	r3, [r2, #88]	; 0x58
  }
}
 80079d8:	b009      	add	sp, #36	; 0x24
 80079da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
    pwrclkchanged = SET;
  }
  if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
  {
    HAL_PWR_EnableBkUpAccess();
 80079dc:	f004 fb14 	bl	800c008 <HAL_PWR_EnableBkUpAccess>
    backupchanged = SET;
  }
  
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSCOSEL | RCC_BDCR_LSCOEN, LSCOSource | RCC_BDCR_LSCOEN);
 80079e0:	4b06      	ldr	r3, [pc, #24]	; (80079fc <HAL_RCCEx_EnableLSCO+0x9c>)
 80079e2:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
 80079e6:	f020 7040 	bic.w	r0, r0, #50331648	; 0x3000000
 80079ea:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
 80079ee:	4330      	orrs	r0, r6
 80079f0:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
  
  if(backupchanged == SET)
  {
    HAL_PWR_DisableBkUpAccess();
 80079f4:	f004 fb10 	bl	800c018 <HAL_PWR_DisableBkUpAccess>
 80079f8:	e7e8      	b.n	80079cc <HAL_RCCEx_EnableLSCO+0x6c>
 80079fa:	bf00      	nop
 80079fc:	40021000 	.word	0x40021000
 8007a00:	40007000 	.word	0x40007000

08007a04 <HAL_RCCEx_DisableLSCO>:
/**
  * @brief  Disable the Low Speed clock output.
  * @retval None
  */
void HAL_RCCEx_DisableLSCO(void)
{
 8007a04:	b510      	push	{r4, lr}
  FlagStatus       pwrclkchanged = RESET;
  FlagStatus       backupchanged = RESET;
  
  /* Update LSCOEN bit in Backup Domain control register */
  if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8007a06:	4b1a      	ldr	r3, [pc, #104]	; (8007a70 <HAL_RCCEx_DisableLSCO+0x6c>)
 8007a08:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007a0a:	00d2      	lsls	r2, r2, #3
/**
  * @brief  Disable the Low Speed clock output.
  * @retval None
  */
void HAL_RCCEx_DisableLSCO(void)
{
 8007a0c:	b082      	sub	sp, #8
  FlagStatus       pwrclkchanged = RESET;
  FlagStatus       backupchanged = RESET;
  
  /* Update LSCOEN bit in Backup Domain control register */
  if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8007a0e:	d41d      	bmi.n	8007a4c <HAL_RCCEx_DisableLSCO+0x48>
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8007a10:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007a12:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007a16:	659a      	str	r2, [r3, #88]	; 0x58
 8007a18:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007a1a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8007a1e:	9301      	str	r3, [sp, #4]
 8007a20:	9b01      	ldr	r3, [sp, #4]
    pwrclkchanged = SET;
  }
  if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8007a22:	4b14      	ldr	r3, [pc, #80]	; (8007a74 <HAL_RCCEx_DisableLSCO+0x70>)
 8007a24:	681b      	ldr	r3, [r3, #0]
 8007a26:	05db      	lsls	r3, r3, #23
  
  /* Update LSCOEN bit in Backup Domain control register */
  if(__HAL_RCC_PWR_IS_CLK_DISABLED())
  {
    __HAL_RCC_PWR_CLK_ENABLE();
    pwrclkchanged = SET;
 8007a28:	f04f 0401 	mov.w	r4, #1
  }
  if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8007a2c:	d514      	bpl.n	8007a58 <HAL_RCCEx_DisableLSCO+0x54>
    /* Enable access to the backup domain */
    HAL_PWR_EnableBkUpAccess();
    backupchanged = SET;
  }
  
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSCOEN);
 8007a2e:	4a10      	ldr	r2, [pc, #64]	; (8007a70 <HAL_RCCEx_DisableLSCO+0x6c>)
 8007a30:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8007a34:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8007a38:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  if(backupchanged == SET)
  {
    /* Disable access to the backup domain */
    HAL_PWR_DisableBkUpAccess();
  }
  if(pwrclkchanged == SET)
 8007a3c:	b124      	cbz	r4, 8007a48 <HAL_RCCEx_DisableLSCO+0x44>
  {
    __HAL_RCC_PWR_CLK_DISABLE();
 8007a3e:	4a0c      	ldr	r2, [pc, #48]	; (8007a70 <HAL_RCCEx_DisableLSCO+0x6c>)
 8007a40:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8007a42:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8007a46:	6593      	str	r3, [r2, #88]	; 0x58
  }
}
 8007a48:	b002      	add	sp, #8
 8007a4a:	bd10      	pop	{r4, pc}
  if(__HAL_RCC_PWR_IS_CLK_DISABLED())
  {
    __HAL_RCC_PWR_CLK_ENABLE();
    pwrclkchanged = SET;
  }
  if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8007a4c:	4b09      	ldr	r3, [pc, #36]	; (8007a74 <HAL_RCCEx_DisableLSCO+0x70>)
 8007a4e:	681b      	ldr	r3, [r3, #0]
 8007a50:	05db      	lsls	r3, r3, #23
  * @brief  Disable the Low Speed clock output.
  * @retval None
  */
void HAL_RCCEx_DisableLSCO(void)
{
  FlagStatus       pwrclkchanged = RESET;
 8007a52:	f04f 0400 	mov.w	r4, #0
  if(__HAL_RCC_PWR_IS_CLK_DISABLED())
  {
    __HAL_RCC_PWR_CLK_ENABLE();
    pwrclkchanged = SET;
  }
  if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8007a56:	d4ea      	bmi.n	8007a2e <HAL_RCCEx_DisableLSCO+0x2a>
  {
    /* Enable access to the backup domain */
    HAL_PWR_EnableBkUpAccess();
 8007a58:	f004 fad6 	bl	800c008 <HAL_PWR_EnableBkUpAccess>
    backupchanged = SET;
  }
  
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSCOEN);
 8007a5c:	4a04      	ldr	r2, [pc, #16]	; (8007a70 <HAL_RCCEx_DisableLSCO+0x6c>)
 8007a5e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8007a62:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8007a66:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  
  /* Restore previous configuration */
  if(backupchanged == SET)
  {
    /* Disable access to the backup domain */
    HAL_PWR_DisableBkUpAccess();
 8007a6a:	f004 fad5 	bl	800c018 <HAL_PWR_DisableBkUpAccess>
 8007a6e:	e7e5      	b.n	8007a3c <HAL_RCCEx_DisableLSCO+0x38>
 8007a70:	40021000 	.word	0x40021000
 8007a74:	40007000 	.word	0x40007000

08007a78 <HAL_RCCEx_EnableMSIPLLMode>:
  *         calibration LSE oscillator is to be enabled with HAL_RCC_OscConfig().
  * @retval None
  */
void HAL_RCCEx_EnableMSIPLLMode(void)
{
  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 8007a78:	4a02      	ldr	r2, [pc, #8]	; (8007a84 <HAL_RCCEx_EnableMSIPLLMode+0xc>)
 8007a7a:	6813      	ldr	r3, [r2, #0]
 8007a7c:	f043 0304 	orr.w	r3, r3, #4
 8007a80:	6013      	str	r3, [r2, #0]
 8007a82:	4770      	bx	lr
 8007a84:	40021000 	.word	0x40021000

08007a88 <HAL_RCCEx_DisableMSIPLLMode>:
  * @note   PLL-mode of the MSI is automatically reset when LSE oscillator is disabled.
  * @retval None
  */
void HAL_RCCEx_DisableMSIPLLMode(void)
{
  CLEAR_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 8007a88:	4a02      	ldr	r2, [pc, #8]	; (8007a94 <HAL_RCCEx_DisableMSIPLLMode+0xc>)
 8007a8a:	6813      	ldr	r3, [r2, #0]
 8007a8c:	f023 0304 	bic.w	r3, r3, #4
 8007a90:	6013      	str	r3, [r2, #0]
 8007a92:	4770      	bx	lr
 8007a94:	40021000 	.word	0x40021000
  * @brief  Initialize the RTC MSP.
  * @param  hrtc: RTC handle  
  * @retval None
  */
__weak void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 8007a98:	4770      	bx	lr
 8007a9a:	bf00      	nop
  * @brief  DeInitialize the RTC MSP.
  * @param  hrtc: RTC handle 
  * @retval None
  */
__weak void HAL_RTC_MspDeInit(RTC_HandleTypeDef* hrtc)
{
 8007a9c:	4770      	bx	lr
 8007a9e:	bf00      	nop

08007aa0 <HAL_RTC_GetTime>:
  *        Reading RTC current time locks the values in calendar shadow registers until Current date is read
  *        to ensure consistency between the time and date values.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
 8007aa0:	b4f0      	push	{r4, r5, r6, r7}

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Get subseconds structure field from the corresponding register*/
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8007aa2:	6803      	ldr	r3, [r0, #0]
 8007aa4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007aa6:	604b      	str	r3, [r1, #4]

  /* Get SecondFraction structure field from the corresponding register field*/
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8007aa8:	6803      	ldr	r3, [r0, #0]
 8007aaa:	691b      	ldr	r3, [r3, #16]
 8007aac:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8007ab0:	608b      	str	r3, [r1, #8]
  
  /* Get the TR register */
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
 8007ab2:	6803      	ldr	r3, [r0, #0]
 8007ab4:	681b      	ldr	r3, [r3, #0]

  /* Fill the structure fields with the read parameters */
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);
 8007ab6:	f403 0680 	and.w	r6, r3, #4194304	; 0x400000
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);

  /* Fill the structure fields with the read parameters */
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8007aba:	f003 057f 	and.w	r5, r3, #127	; 0x7f
  
  /* Get the TR register */
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);

  /* Fill the structure fields with the read parameters */
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8007abe:	f3c3 4005 	ubfx	r0, r3, #16, #6
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);
 8007ac2:	0c36      	lsrs	r6, r6, #16
  /* Get the TR register */
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);

  /* Fill the structure fields with the read parameters */
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8007ac4:	f3c3 2306 	ubfx	r3, r3, #8, #7
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);
 8007ac8:	70ce      	strb	r6, [r1, #3]
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);

  /* Fill the structure fields with the read parameters */
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8007aca:	708d      	strb	r5, [r1, #2]
  
  /* Get the TR register */
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);

  /* Fill the structure fields with the read parameters */
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8007acc:	7008      	strb	r0, [r1, #0]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8007ace:	704b      	strb	r3, [r1, #1]
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);

  /* Check the input parameters format */
  if(Format == RTC_FORMAT_BIN)
 8007ad0:	b9ba      	cbnz	r2, 8007b02 <HAL_RTC_GetTime+0x62>
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8007ad2:	0906      	lsrs	r6, r0, #4
 8007ad4:	091a      	lsrs	r2, r3, #4
 8007ad6:	092c      	lsrs	r4, r5, #4
 8007ad8:	eb06 0786 	add.w	r7, r6, r6, lsl #2
 8007adc:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8007ae0:	eb02 0682 	add.w	r6, r2, r2, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8007ae4:	f005 050f 	and.w	r5, r5, #15
 8007ae8:	f000 000f 	and.w	r0, r0, #15
 8007aec:	f003 020f 	and.w	r2, r3, #15
 8007af0:	eb05 0444 	add.w	r4, r5, r4, lsl #1
 8007af4:	eb00 0047 	add.w	r0, r0, r7, lsl #1
 8007af8:	eb02 0346 	add.w	r3, r2, r6, lsl #1
  if(Format == RTC_FORMAT_BIN)
  {
    /* Convert the time structure parameters to Binary format */
    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
 8007afc:	708c      	strb	r4, [r1, #2]

  /* Check the input parameters format */
  if(Format == RTC_FORMAT_BIN)
  {
    /* Convert the time structure parameters to Binary format */
    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 8007afe:	7008      	strb	r0, [r1, #0]
    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 8007b00:	704b      	strb	r3, [r1, #1]
    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
  }

  return HAL_OK;
}
 8007b02:	2000      	movs	r0, #0
 8007b04:	bcf0      	pop	{r4, r5, r6, r7}
 8007b06:	4770      	bx	lr

08007b08 <HAL_RTC_GetDate>:
  *        in the higher-order calendar shadow registers to ensure consistency between the time and date values.
  *        Reading RTC current time locks the values in calendar shadow registers until Current date is read.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
 8007b08:	b4f0      	push	{r4, r5, r6, r7}

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Get the DR register */
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
 8007b0a:	6803      	ldr	r3, [r0, #0]
 8007b0c:	685b      	ldr	r3, [r3, #4]

  /* Fill the structure fields with the read parameters */
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8007b0e:	f003 053f 	and.w	r5, r3, #63	; 0x3f
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13); 
 8007b12:	f3c3 3642 	ubfx	r6, r3, #13, #3

  /* Get the DR register */
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);

  /* Fill the structure fields with the read parameters */
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8007b16:	f3c3 4007 	ubfx	r0, r3, #16, #8
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8007b1a:	f3c3 2304 	ubfx	r3, r3, #8, #5
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13); 
 8007b1e:	700e      	strb	r6, [r1, #0]
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);

  /* Fill the structure fields with the read parameters */
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8007b20:	708d      	strb	r5, [r1, #2]

  /* Get the DR register */
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);

  /* Fill the structure fields with the read parameters */
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8007b22:	70c8      	strb	r0, [r1, #3]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8007b24:	704b      	strb	r3, [r1, #1]
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13); 

  /* Check the input parameters format */
  if(Format == RTC_FORMAT_BIN)
 8007b26:	b9ba      	cbnz	r2, 8007b58 <HAL_RTC_GetDate+0x50>
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8007b28:	091e      	lsrs	r6, r3, #4
 8007b2a:	092c      	lsrs	r4, r5, #4
 8007b2c:	0902      	lsrs	r2, r0, #4
 8007b2e:	00b7      	lsls	r7, r6, #2
 8007b30:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8007b34:	f005 050f 	and.w	r5, r5, #15
 8007b38:	f003 030f 	and.w	r3, r3, #15
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8007b3c:	443e      	add	r6, r7
 8007b3e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8007b42:	f000 000f 	and.w	r0, r0, #15
 8007b46:	eb05 0444 	add.w	r4, r5, r4, lsl #1
 8007b4a:	eb03 0346 	add.w	r3, r3, r6, lsl #1
 8007b4e:	eb00 0042 	add.w	r0, r0, r2, lsl #1
  if(Format == RTC_FORMAT_BIN)
  {
    /* Convert the date structure parameters to Binary format */
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
 8007b52:	708c      	strb	r4, [r1, #2]
  /* Check the input parameters format */
  if(Format == RTC_FORMAT_BIN)
  {
    /* Convert the date structure parameters to Binary format */
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
 8007b54:	704b      	strb	r3, [r1, #1]

  /* Check the input parameters format */
  if(Format == RTC_FORMAT_BIN)
  {
    /* Convert the date structure parameters to Binary format */
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
 8007b56:	70c8      	strb	r0, [r1, #3]
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
  }
  return HAL_OK;
}
 8007b58:	2000      	movs	r0, #0
 8007b5a:	bcf0      	pop	{r4, r5, r6, r7}
 8007b5c:	4770      	bx	lr
 8007b5e:	bf00      	nop

08007b60 <HAL_RTC_SetAlarm>:
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8007b60:	f890 3020 	ldrb.w	r3, [r0, #32]
 8007b64:	2b01      	cmp	r3, #1
 8007b66:	f000 80bd 	beq.w	8007ce4 <HAL_RTC_SetAlarm+0x184>
  *             @arg RTC_FORMAT_BIN: Binary data format 
  *             @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
{
 8007b6a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8007b6e:	2302      	movs	r3, #2
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8007b70:	2401      	movs	r4, #1
 8007b72:	f880 4020 	strb.w	r4, [r0, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8007b76:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21

  if(Format == RTC_FORMAT_BIN)
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8007b7a:	6806      	ldr	r6, [r0, #0]
  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  if(Format == RTC_FORMAT_BIN)
 8007b7c:	2a00      	cmp	r2, #0
 8007b7e:	d058      	beq.n	8007c32 <HAL_RTC_SetAlarm+0xd2>
 8007b80:	694a      	ldr	r2, [r1, #20]
 8007b82:	69cf      	ldr	r7, [r1, #28]
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
              ((uint32_t)sAlarm->AlarmMask));
  }
  else
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8007b84:	68b4      	ldr	r4, [r6, #8]
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));
    }

    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8) | \
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 8007b86:	788d      	ldrb	r5, [r1, #2]
    {
      tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));
    }

    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
 8007b88:	f891 c000 	ldrb.w	ip, [r1]
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8) | \
 8007b8c:	784b      	ldrb	r3, [r1, #1]
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24) | \
 8007b8e:	f891 e020 	ldrb.w	lr, [r1, #32]
 8007b92:	433a      	orrs	r2, r7
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
              ((uint32_t)sAlarm->AlarmMask));
  }
  else
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8007b94:	f014 0440 	ands.w	r4, r4, #64	; 0x40
 8007b98:	ea42 0205 	orr.w	r2, r2, r5
 8007b9c:	bf14      	ite	ne
 8007b9e:	78cc      	ldrbne	r4, [r1, #3]
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
    }
    else
    {
      sAlarm->AlarmTime.TimeFormat = 0x00;
 8007ba0:	70cc      	strbeq	r4, [r1, #3]
 8007ba2:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
 8007ba6:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8007baa:	bf18      	it	ne
 8007bac:	0424      	lslne	r4, r4, #16
 8007bae:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
 8007bb2:	bf08      	it	eq
 8007bb4:	6806      	ldreq	r6, [r0, #0]
    {
      tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));
    }

    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
 8007bb6:	431c      	orrs	r4, r3
 8007bb8:	4607      	mov	r7, r0

  /* Configure the Alarm A or Alarm B Sub Second registers */
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007bba:	23ca      	movs	r3, #202	; 0xca
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
              ((uint32_t)sAlarm->AlarmMask));   
  }

  /* Configure the Alarm A or Alarm B Sub Second registers */
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 8007bbc:	684a      	ldr	r2, [r1, #4]
 8007bbe:	6988      	ldr	r0, [r1, #24]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007bc0:	6273      	str	r3, [r6, #36]	; 0x24
 8007bc2:	683b      	ldr	r3, [r7, #0]
 8007bc4:	2553      	movs	r5, #83	; 0x53
 8007bc6:	625d      	str	r5, [r3, #36]	; 0x24

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
 8007bc8:	6a4b      	ldr	r3, [r1, #36]	; 0x24
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
              ((uint32_t)sAlarm->AlarmMask));   
  }

  /* Configure the Alarm A or Alarm B Sub Second registers */
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 8007bca:	ea40 0602 	orr.w	r6, r0, r2

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
  {
    /* Disable the Alarm A interrupt */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8007bce:	683a      	ldr	r2, [r7, #0]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
 8007bd0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  {
    /* Disable the Alarm A interrupt */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8007bd4:	6893      	ldr	r3, [r2, #8]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
 8007bd6:	f000 8092 	beq.w	8007cfe <HAL_RTC_SetAlarm+0x19e>
    __HAL_RTC_ALARMA_ENABLE(hrtc);
  }
  else
  {
    /* Disable the Alarm B interrupt */
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 8007bda:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007bde:	6093      	str	r3, [r2, #8]

    /* In case of interrupt mode is used, the interrupt source must disabled */
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
 8007be0:	683a      	ldr	r2, [r7, #0]
 8007be2:	6893      	ldr	r3, [r2, #8]
 8007be4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8007be8:	6093      	str	r3, [r2, #8]

    tickstart = HAL_GetTick();
 8007bea:	f7f8 ff8d 	bl	8000b08 <HAL_GetTick>
 8007bee:	4680      	mov	r8, r0
    /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 8007bf0:	e006      	b.n	8007c00 <HAL_RTC_SetAlarm+0xa0>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8007bf2:	f7f8 ff89 	bl	8000b08 <HAL_GetTick>
 8007bf6:	ebc8 0000 	rsb	r0, r8, r0
 8007bfa:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8007bfe:	d873      	bhi.n	8007ce8 <HAL_RTC_SetAlarm+0x188>
    /* In case of interrupt mode is used, the interrupt source must disabled */
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);

    tickstart = HAL_GetTick();
    /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 8007c00:	683a      	ldr	r2, [r7, #0]
 8007c02:	68d3      	ldr	r3, [r2, #12]
 8007c04:	f013 0502 	ands.w	r5, r3, #2
 8007c08:	d0f3      	beq.n	8007bf2 <HAL_RTC_SetAlarm+0x92>

        return HAL_TIMEOUT;
      }
    }

    hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
 8007c0a:	6214      	str	r4, [r2, #32]
    /* Configure the Alarm B Sub Second register */
    hrtc->Instance->ALRMBSSR = subsecondtmpreg;
 8007c0c:	683b      	ldr	r3, [r7, #0]
 8007c0e:	649e      	str	r6, [r3, #72]	; 0x48
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMB_ENABLE(hrtc);
 8007c10:	683a      	ldr	r2, [r7, #0]
 8007c12:	6893      	ldr	r3, [r2, #8]
 8007c14:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8007c18:	6093      	str	r3, [r2, #8]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007c1a:	6839      	ldr	r1, [r7, #0]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8007c1c:	2300      	movs	r3, #0
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMB_ENABLE(hrtc);
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007c1e:	20ff      	movs	r0, #255	; 0xff

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8007c20:	2201      	movs	r2, #1
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMB_ENABLE(hrtc);
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007c22:	6248      	str	r0, [r1, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8007c24:	f887 2021 	strb.w	r2, [r7, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8007c28:	f887 3020 	strb.w	r3, [r7, #32]

  return HAL_OK;
 8007c2c:	4618      	mov	r0, r3
 8007c2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  hrtc->State = HAL_RTC_STATE_BUSY;

  if(Format == RTC_FORMAT_BIN)
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8007c32:	68b7      	ldr	r7, [r6, #8]
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8007c34:	780a      	ldrb	r2, [r1, #0]

  hrtc->State = HAL_RTC_STATE_BUSY;

  if(Format == RTC_FORMAT_BIN)
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8007c36:	f017 0740 	ands.w	r7, r7, #64	; 0x40
 8007c3a:	bf15      	itete	ne
 8007c3c:	78cf      	ldrbne	r7, [r1, #3]
      assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
    }
    else
    {
      sAlarm->AlarmTime.TimeFormat = 0x00;
 8007c3e:	70cf      	strbeq	r7, [r1, #3]
 8007c40:	043f      	lslne	r7, r7, #16
 8007c42:	6806      	ldreq	r6, [r0, #0]
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c44:	2a09      	cmp	r2, #9
 8007c46:	d97e      	bls.n	8007d46 <HAL_RTC_SetAlarm+0x1e6>
 8007c48:	2300      	movs	r3, #0
  {
    bcdhigh++;
    Value -= 10;
 8007c4a:	3a0a      	subs	r2, #10
 8007c4c:	b2d2      	uxtb	r2, r2
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c4e:	2a09      	cmp	r2, #9
  {
    bcdhigh++;
 8007c50:	f103 0301 	add.w	r3, r3, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c54:	d8f9      	bhi.n	8007c4a <HAL_RTC_SetAlarm+0xea>
 8007c56:	011b      	lsls	r3, r3, #4
 8007c58:	b2dc      	uxtb	r4, r3
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
 8007c5a:	784b      	ldrb	r3, [r1, #1]
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8007c5c:	4322      	orrs	r2, r4
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c5e:	2b09      	cmp	r3, #9
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8007c60:	ea4f 4202 	mov.w	r2, r2, lsl #16
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c64:	d971      	bls.n	8007d4a <HAL_RTC_SetAlarm+0x1ea>
 8007c66:	2400      	movs	r4, #0
  {
    bcdhigh++;
    Value -= 10;
 8007c68:	3b0a      	subs	r3, #10
 8007c6a:	b2db      	uxtb	r3, r3
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c6c:	2b09      	cmp	r3, #9
  {
    bcdhigh++;
 8007c6e:	f104 0401 	add.w	r4, r4, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c72:	d8f9      	bhi.n	8007c68 <HAL_RTC_SetAlarm+0x108>
 8007c74:	0124      	lsls	r4, r4, #4
 8007c76:	b2e5      	uxtb	r5, r4
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8007c78:	788c      	ldrb	r4, [r1, #2]
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
 8007c7a:	432b      	orrs	r3, r5
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c7c:	2c09      	cmp	r4, #9
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
 8007c7e:	ea4f 2303 	mov.w	r3, r3, lsl #8
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c82:	f04f 0500 	mov.w	r5, #0
 8007c86:	d907      	bls.n	8007c98 <HAL_RTC_SetAlarm+0x138>
  {
    bcdhigh++;
    Value -= 10;
 8007c88:	3c0a      	subs	r4, #10
 8007c8a:	b2e4      	uxtb	r4, r4
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c8c:	2c09      	cmp	r4, #9
  {
    bcdhigh++;
 8007c8e:	f105 0501 	add.w	r5, r5, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c92:	d8f9      	bhi.n	8007c88 <HAL_RTC_SetAlarm+0x128>
 8007c94:	012d      	lsls	r5, r5, #4
 8007c96:	b2ed      	uxtb	r5, r5

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24) | \
 8007c98:	f891 e020 	ldrb.w	lr, [r1, #32]
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007c9c:	f1be 0f09 	cmp.w	lr, #9
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8007ca0:	ea45 0504 	orr.w	r5, r5, r4
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007ca4:	d94c      	bls.n	8007d40 <HAL_RTC_SetAlarm+0x1e0>
 8007ca6:	f04f 0c00 	mov.w	ip, #0
  {
    bcdhigh++;
    Value -= 10;
 8007caa:	f1ae 0e0a 	sub.w	lr, lr, #10
 8007cae:	fa5f fe8e 	uxtb.w	lr, lr
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007cb2:	f1be 0f09 	cmp.w	lr, #9
  {
    bcdhigh++;
 8007cb6:	f10c 0c01 	add.w	ip, ip, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007cba:	d8f6      	bhi.n	8007caa <HAL_RTC_SetAlarm+0x14a>
 8007cbc:	ea4f 140c 	mov.w	r4, ip, lsl #4
 8007cc0:	fa5f f884 	uxtb.w	r8, r4
 8007cc4:	694c      	ldr	r4, [r1, #20]
 8007cc6:	46a4      	mov	ip, r4
 8007cc8:	69cc      	ldr	r4, [r1, #28]
 8007cca:	ea4c 0c04 	orr.w	ip, ip, r4
 8007cce:	ea4c 0707 	orr.w	r7, ip, r7
 8007cd2:	433a      	orrs	r2, r7
 8007cd4:	4313      	orrs	r3, r2

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24) | \
 8007cd6:	ea48 0e0e 	orr.w	lr, r8, lr
 8007cda:	ea43 0405 	orr.w	r4, r3, r5
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8007cde:	ea44 640e 	orr.w	r4, r4, lr, lsl #24
 8007ce2:	e769      	b.n	8007bb8 <HAL_RTC_SetAlarm+0x58>
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8007ce4:	2002      	movs	r0, #2
 8007ce6:	4770      	bx	lr
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007ce8:	683a      	ldr	r2, [r7, #0]

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8007cea:	2303      	movs	r3, #3
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007cec:	21ff      	movs	r1, #255	; 0xff
 8007cee:	6251      	str	r1, [r2, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8007cf0:	f887 5020 	strb.w	r5, [r7, #32]
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8007cf4:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);

        return HAL_TIMEOUT;
 8007cf8:	4618      	mov	r0, r3
 8007cfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
  {
    /* Disable the Alarm A interrupt */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8007cfe:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007d02:	6093      	str	r3, [r2, #8]

    /* In case of interrupt mode is used, the interrupt source must disabled */
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
 8007d04:	683a      	ldr	r2, [r7, #0]
 8007d06:	6893      	ldr	r3, [r2, #8]
 8007d08:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8007d0c:	6093      	str	r3, [r2, #8]

    tickstart = HAL_GetTick();
 8007d0e:	f7f8 fefb 	bl	8000b08 <HAL_GetTick>
 8007d12:	4680      	mov	r8, r0
    /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 8007d14:	e006      	b.n	8007d24 <HAL_RTC_SetAlarm+0x1c4>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8007d16:	f7f8 fef7 	bl	8000b08 <HAL_GetTick>
 8007d1a:	ebc8 0000 	rsb	r0, r8, r0
 8007d1e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8007d22:	d8e1      	bhi.n	8007ce8 <HAL_RTC_SetAlarm+0x188>
    /* In case of interrupt mode is used, the interrupt source must disabled */
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);

    tickstart = HAL_GetTick();
    /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 8007d24:	683a      	ldr	r2, [r7, #0]
 8007d26:	68d3      	ldr	r3, [r2, #12]
 8007d28:	f013 0501 	ands.w	r5, r3, #1
 8007d2c:	d0f3      	beq.n	8007d16 <HAL_RTC_SetAlarm+0x1b6>

        return HAL_TIMEOUT;
      }
    }

    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
 8007d2e:	61d4      	str	r4, [r2, #28]
    /* Configure the Alarm A Sub Second register */
    hrtc->Instance->ALRMASSR = subsecondtmpreg;
 8007d30:	683b      	ldr	r3, [r7, #0]
 8007d32:	645e      	str	r6, [r3, #68]	; 0x44
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMA_ENABLE(hrtc);
 8007d34:	683a      	ldr	r2, [r7, #0]
 8007d36:	6893      	ldr	r3, [r2, #8]
 8007d38:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8007d3c:	6093      	str	r3, [r2, #8]
 8007d3e:	e76c      	b.n	8007c1a <HAL_RTC_SetAlarm+0xba>
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007d40:	f04f 0800 	mov.w	r8, #0
 8007d44:	e7be      	b.n	8007cc4 <HAL_RTC_SetAlarm+0x164>
 8007d46:	2400      	movs	r4, #0
 8007d48:	e787      	b.n	8007c5a <HAL_RTC_SetAlarm+0xfa>
 8007d4a:	2500      	movs	r5, #0
 8007d4c:	e794      	b.n	8007c78 <HAL_RTC_SetAlarm+0x118>
 8007d4e:	bf00      	nop

08007d50 <HAL_RTC_SetAlarm_IT>:
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8007d50:	f890 3020 	ldrb.w	r3, [r0, #32]
 8007d54:	2b01      	cmp	r3, #1
 8007d56:	f000 80ce 	beq.w	8007ef6 <HAL_RTC_SetAlarm_IT+0x1a6>
  *         is disabled (Use the HAL_RTC_DeactivateAlarm()).   
  * @note   The HAL_RTC_SetTime() must be called before enabling the Alarm feature.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
{
 8007d5a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8007d5e:	2302      	movs	r3, #2
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8007d60:	2401      	movs	r4, #1
 8007d62:	f880 4020 	strb.w	r4, [r0, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8007d66:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21

  if(Format == RTC_FORMAT_BIN)
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8007d6a:	6806      	ldr	r6, [r0, #0]
  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  if(Format == RTC_FORMAT_BIN)
 8007d6c:	2a00      	cmp	r2, #0
 8007d6e:	d068      	beq.n	8007e42 <HAL_RTC_SetAlarm_IT+0xf2>
 8007d70:	694a      	ldr	r2, [r1, #20]
 8007d72:	69cf      	ldr	r7, [r1, #28]
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
              ((uint32_t)sAlarm->AlarmMask));
  }
  else
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8007d74:	68b4      	ldr	r4, [r6, #8]
      tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));
    }
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8) | \
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 8007d76:	788d      	ldrb	r5, [r1, #2]
    else
    {
      tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));
    }
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
 8007d78:	f891 c000 	ldrb.w	ip, [r1]
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8) | \
 8007d7c:	784b      	ldrb	r3, [r1, #1]
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24) | \
 8007d7e:	f891 e020 	ldrb.w	lr, [r1, #32]
 8007d82:	433a      	orrs	r2, r7
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
              ((uint32_t)sAlarm->AlarmMask));
  }
  else
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8007d84:	f014 0440 	ands.w	r4, r4, #64	; 0x40
 8007d88:	ea42 0205 	orr.w	r2, r2, r5
 8007d8c:	bf14      	ite	ne
 8007d8e:	78cc      	ldrbne	r4, [r1, #3]
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
    } 
    else
    {
      sAlarm->AlarmTime.TimeFormat = 0x00;
 8007d90:	70cc      	strbeq	r4, [r1, #3]
 8007d92:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
 8007d96:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8007d9a:	bf18      	it	ne
 8007d9c:	0424      	lslne	r4, r4, #16
 8007d9e:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
 8007da2:	bf08      	it	eq
 8007da4:	6806      	ldreq	r6, [r0, #0]
    else
    {
      tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));
    }
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
 8007da6:	431c      	orrs	r4, r3
 8007da8:	4607      	mov	r7, r0
  }
  /* Configure the Alarm A or Alarm B Sub Second registers */
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007daa:	23ca      	movs	r3, #202	; 0xca
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24) | \
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
              ((uint32_t)sAlarm->AlarmMask));     
  }
  /* Configure the Alarm A or Alarm B Sub Second registers */
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 8007dac:	684a      	ldr	r2, [r1, #4]
 8007dae:	6988      	ldr	r0, [r1, #24]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007db0:	6273      	str	r3, [r6, #36]	; 0x24
 8007db2:	683b      	ldr	r3, [r7, #0]
 8007db4:	2553      	movs	r5, #83	; 0x53
 8007db6:	625d      	str	r5, [r3, #36]	; 0x24

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
 8007db8:	6a4b      	ldr	r3, [r1, #36]	; 0x24
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24) | \
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
              ((uint32_t)sAlarm->AlarmMask));     
  }
  /* Configure the Alarm A or Alarm B Sub Second registers */
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 8007dba:	ea40 0602 	orr.w	r6, r0, r2

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
  {
    /* Disable the Alarm A interrupt */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8007dbe:	683a      	ldr	r2, [r7, #0]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
 8007dc0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  {
    /* Disable the Alarm A interrupt */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8007dc4:	6893      	ldr	r3, [r2, #8]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
 8007dc6:	f000 80a3 	beq.w	8007f10 <HAL_RTC_SetAlarm_IT+0x1c0>
    __HAL_RTC_ALARM_ENABLE_IT(hrtc,RTC_IT_ALRA);
  }
  else
  {
    /* Disable the Alarm B interrupt */
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 8007dca:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007dce:	6093      	str	r3, [r2, #8]
    
    /* Clear flag alarm B */
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 8007dd0:	683a      	ldr	r2, [r7, #0]
 8007dd2:	68d3      	ldr	r3, [r2, #12]
 8007dd4:	b2db      	uxtb	r3, r3
 8007dd6:	f463 7320 	orn	r3, r3, #640	; 0x280
 8007dda:	60d3      	str	r3, [r2, #12]

    tickstart = HAL_GetTick();
 8007ddc:	f7f8 fe94 	bl	8000b08 <HAL_GetTick>
 8007de0:	4680      	mov	r8, r0
    /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 8007de2:	e007      	b.n	8007df4 <HAL_RTC_SetAlarm_IT+0xa4>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8007de4:	f7f8 fe90 	bl	8000b08 <HAL_GetTick>
 8007de8:	ebc8 0000 	rsb	r0, r8, r0
 8007dec:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8007df0:	f200 8083 	bhi.w	8007efa <HAL_RTC_SetAlarm_IT+0x1aa>
    /* Clear flag alarm B */
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);

    tickstart = HAL_GetTick();
    /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 8007df4:	683a      	ldr	r2, [r7, #0]
 8007df6:	68d3      	ldr	r3, [r2, #12]
 8007df8:	f013 0502 	ands.w	r5, r3, #2
 8007dfc:	d0f2      	beq.n	8007de4 <HAL_RTC_SetAlarm_IT+0x94>

        return HAL_TIMEOUT;
      }
    }

    hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
 8007dfe:	6214      	str	r4, [r2, #32]
    /* Configure the Alarm B Sub Second register */
    hrtc->Instance->ALRMBSSR = subsecondtmpreg;
 8007e00:	683b      	ldr	r3, [r7, #0]
 8007e02:	649e      	str	r6, [r3, #72]	; 0x48
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMB_ENABLE(hrtc);
 8007e04:	683a      	ldr	r2, [r7, #0]
 8007e06:	6893      	ldr	r3, [r2, #8]
 8007e08:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8007e0c:	6093      	str	r3, [r2, #8]
    /* Configure the Alarm interrupt */
    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
 8007e0e:	683a      	ldr	r2, [r7, #0]
 8007e10:	6893      	ldr	r3, [r2, #8]
 8007e12:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8007e16:	6093      	str	r3, [r2, #8]
  }

  /* RTC Alarm Interrupt Configuration: EXTI configuration */
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8007e18:	4b54      	ldr	r3, [pc, #336]	; (8007f6c <HAL_RTC_SetAlarm_IT+0x21c>)
 8007e1a:	681a      	ldr	r2, [r3, #0]
 8007e1c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8007e20:	601a      	str	r2, [r3, #0]

  __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();
 8007e22:	689a      	ldr	r2, [r3, #8]
 8007e24:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8007e28:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007e2a:	6839      	ldr	r1, [r7, #0]

  hrtc->State = HAL_RTC_STATE_READY; 

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8007e2c:	2300      	movs	r3, #0
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();

  __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007e2e:	20ff      	movs	r0, #255	; 0xff

  hrtc->State = HAL_RTC_STATE_READY; 
 8007e30:	2201      	movs	r2, #1
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();

  __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007e32:	6248      	str	r0, [r1, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY; 
 8007e34:	f887 2021 	strb.w	r2, [r7, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8007e38:	f887 3020 	strb.w	r3, [r7, #32]

  return HAL_OK;
 8007e3c:	4618      	mov	r0, r3
 8007e3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  hrtc->State = HAL_RTC_STATE_BUSY;

  if(Format == RTC_FORMAT_BIN)
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8007e42:	68b7      	ldr	r7, [r6, #8]
    }
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8007e44:	780a      	ldrb	r2, [r1, #0]

  hrtc->State = HAL_RTC_STATE_BUSY;

  if(Format == RTC_FORMAT_BIN)
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8007e46:	f017 0740 	ands.w	r7, r7, #64	; 0x40
 8007e4a:	bf15      	itete	ne
 8007e4c:	78cf      	ldrbne	r7, [r1, #3]
      assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
    }
    else
    {
      sAlarm->AlarmTime.TimeFormat = 0x00;
 8007e4e:	70cf      	strbeq	r7, [r1, #3]
 8007e50:	043f      	lslne	r7, r7, #16
 8007e52:	6806      	ldreq	r6, [r0, #0]
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007e54:	2a09      	cmp	r2, #9
 8007e56:	f240 8085 	bls.w	8007f64 <HAL_RTC_SetAlarm_IT+0x214>
 8007e5a:	2300      	movs	r3, #0
  {
    bcdhigh++;
    Value -= 10;
 8007e5c:	3a0a      	subs	r2, #10
 8007e5e:	b2d2      	uxtb	r2, r2
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007e60:	2a09      	cmp	r2, #9
  {
    bcdhigh++;
 8007e62:	f103 0301 	add.w	r3, r3, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007e66:	d8f9      	bhi.n	8007e5c <HAL_RTC_SetAlarm_IT+0x10c>
 8007e68:	011b      	lsls	r3, r3, #4
 8007e6a:	b2dc      	uxtb	r4, r3
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
 8007e6c:	784b      	ldrb	r3, [r1, #1]
    }
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8007e6e:	4322      	orrs	r2, r4
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007e70:	2b09      	cmp	r3, #9
    }
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8007e72:	ea4f 4202 	mov.w	r2, r2, lsl #16
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007e76:	d977      	bls.n	8007f68 <HAL_RTC_SetAlarm_IT+0x218>
 8007e78:	2400      	movs	r4, #0
  {
    bcdhigh++;
    Value -= 10;
 8007e7a:	3b0a      	subs	r3, #10
 8007e7c:	b2db      	uxtb	r3, r3
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007e7e:	2b09      	cmp	r3, #9
  {
    bcdhigh++;
 8007e80:	f104 0401 	add.w	r4, r4, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007e84:	d8f9      	bhi.n	8007e7a <HAL_RTC_SetAlarm_IT+0x12a>
 8007e86:	0124      	lsls	r4, r4, #4
 8007e88:	b2e5      	uxtb	r5, r4
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8007e8a:	788c      	ldrb	r4, [r1, #2]
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
 8007e8c:	432b      	orrs	r3, r5
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007e8e:	2c09      	cmp	r4, #9
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
 8007e90:	ea4f 2303 	mov.w	r3, r3, lsl #8
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007e94:	f04f 0500 	mov.w	r5, #0
 8007e98:	d907      	bls.n	8007eaa <HAL_RTC_SetAlarm_IT+0x15a>
  {
    bcdhigh++;
    Value -= 10;
 8007e9a:	3c0a      	subs	r4, #10
 8007e9c:	b2e4      	uxtb	r4, r4
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007e9e:	2c09      	cmp	r4, #9
  {
    bcdhigh++;
 8007ea0:	f105 0501 	add.w	r5, r5, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007ea4:	d8f9      	bhi.n	8007e9a <HAL_RTC_SetAlarm_IT+0x14a>
 8007ea6:	012d      	lsls	r5, r5, #4
 8007ea8:	b2ed      	uxtb	r5, r5
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24) | \
 8007eaa:	f891 e020 	ldrb.w	lr, [r1, #32]
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007eae:	f1be 0f09 	cmp.w	lr, #9
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8007eb2:	ea45 0504 	orr.w	r5, r5, r4
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007eb6:	d952      	bls.n	8007f5e <HAL_RTC_SetAlarm_IT+0x20e>
 8007eb8:	f04f 0c00 	mov.w	ip, #0
  {
    bcdhigh++;
    Value -= 10;
 8007ebc:	f1ae 0e0a 	sub.w	lr, lr, #10
 8007ec0:	fa5f fe8e 	uxtb.w	lr, lr
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007ec4:	f1be 0f09 	cmp.w	lr, #9
  {
    bcdhigh++;
 8007ec8:	f10c 0c01 	add.w	ip, ip, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007ecc:	d8f6      	bhi.n	8007ebc <HAL_RTC_SetAlarm_IT+0x16c>
 8007ece:	ea4f 140c 	mov.w	r4, ip, lsl #4
 8007ed2:	fa5f f884 	uxtb.w	r8, r4
 8007ed6:	694c      	ldr	r4, [r1, #20]
 8007ed8:	46a4      	mov	ip, r4
 8007eda:	69cc      	ldr	r4, [r1, #28]
 8007edc:	ea4c 0c04 	orr.w	ip, ip, r4
 8007ee0:	ea4c 0707 	orr.w	r7, ip, r7
 8007ee4:	433a      	orrs	r2, r7
 8007ee6:	4313      	orrs	r3, r2
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24) | \
 8007ee8:	ea48 0e0e 	orr.w	lr, r8, lr
 8007eec:	ea43 0405 	orr.w	r4, r3, r5
    }
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8007ef0:	ea44 640e 	orr.w	r4, r4, lr, lsl #24
 8007ef4:	e758      	b.n	8007da8 <HAL_RTC_SetAlarm_IT+0x58>
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8007ef6:	2002      	movs	r0, #2
 8007ef8:	4770      	bx	lr
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007efa:	683a      	ldr	r2, [r7, #0]

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8007efc:	2303      	movs	r3, #3
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007efe:	21ff      	movs	r1, #255	; 0xff
 8007f00:	6251      	str	r1, [r2, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8007f02:	f887 5020 	strb.w	r5, [r7, #32]
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8007f06:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);

        return HAL_TIMEOUT;
 8007f0a:	4618      	mov	r0, r3
 8007f0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
  {
    /* Disable the Alarm A interrupt */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8007f10:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007f14:	6093      	str	r3, [r2, #8]
    
    /* Clear flag alarm A */
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 8007f16:	683a      	ldr	r2, [r7, #0]
 8007f18:	68d3      	ldr	r3, [r2, #12]
 8007f1a:	b2db      	uxtb	r3, r3
 8007f1c:	f463 73c0 	orn	r3, r3, #384	; 0x180
 8007f20:	60d3      	str	r3, [r2, #12]

    tickstart = HAL_GetTick();
 8007f22:	f7f8 fdf1 	bl	8000b08 <HAL_GetTick>
 8007f26:	4680      	mov	r8, r0
    /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 8007f28:	e006      	b.n	8007f38 <HAL_RTC_SetAlarm_IT+0x1e8>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8007f2a:	f7f8 fded 	bl	8000b08 <HAL_GetTick>
 8007f2e:	ebc8 0000 	rsb	r0, r8, r0
 8007f32:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8007f36:	d8e0      	bhi.n	8007efa <HAL_RTC_SetAlarm_IT+0x1aa>
    /* Clear flag alarm A */
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);

    tickstart = HAL_GetTick();
    /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 8007f38:	683a      	ldr	r2, [r7, #0]
 8007f3a:	68d3      	ldr	r3, [r2, #12]
 8007f3c:	f013 0501 	ands.w	r5, r3, #1
 8007f40:	d0f3      	beq.n	8007f2a <HAL_RTC_SetAlarm_IT+0x1da>

        return HAL_TIMEOUT;
      }
    }

    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
 8007f42:	61d4      	str	r4, [r2, #28]
    /* Configure the Alarm A Sub Second register */
    hrtc->Instance->ALRMASSR = subsecondtmpreg;
 8007f44:	683b      	ldr	r3, [r7, #0]
 8007f46:	645e      	str	r6, [r3, #68]	; 0x44
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMA_ENABLE(hrtc);
 8007f48:	683a      	ldr	r2, [r7, #0]
 8007f4a:	6893      	ldr	r3, [r2, #8]
 8007f4c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8007f50:	6093      	str	r3, [r2, #8]
    /* Configure the Alarm interrupt */
    __HAL_RTC_ALARM_ENABLE_IT(hrtc,RTC_IT_ALRA);
 8007f52:	683a      	ldr	r2, [r7, #0]
 8007f54:	6893      	ldr	r3, [r2, #8]
 8007f56:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8007f5a:	6093      	str	r3, [r2, #8]
 8007f5c:	e75c      	b.n	8007e18 <HAL_RTC_SetAlarm_IT+0xc8>
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8007f5e:	f04f 0800 	mov.w	r8, #0
 8007f62:	e7b8      	b.n	8007ed6 <HAL_RTC_SetAlarm_IT+0x186>
 8007f64:	2400      	movs	r4, #0
 8007f66:	e781      	b.n	8007e6c <HAL_RTC_SetAlarm_IT+0x11c>
 8007f68:	2500      	movs	r5, #0
 8007f6a:	e78e      	b.n	8007e8a <HAL_RTC_SetAlarm_IT+0x13a>
 8007f6c:	40010400 	.word	0x40010400

08007f70 <HAL_RTC_DeactivateAlarm>:

  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8007f70:	f890 3020 	ldrb.w	r3, [r0, #32]
 8007f74:	2b01      	cmp	r3, #1
 8007f76:	d033      	beq.n	8007fe0 <HAL_RTC_DeactivateAlarm+0x70>
  *            @arg RTC_ALARM_A:  AlarmA
  *            @arg RTC_ALARM_B:  AlarmB
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
{
 8007f78:	b570      	push	{r4, r5, r6, lr}
 8007f7a:	4605      	mov	r5, r0
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007f7c:	6803      	ldr	r3, [r0, #0]
 8007f7e:	22ca      	movs	r2, #202	; 0xca

  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8007f80:	2401      	movs	r4, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 8007f82:	2002      	movs	r0, #2

  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8007f84:	f885 4020 	strb.w	r4, [r5, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8007f88:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8007f8c:	625a      	str	r2, [r3, #36]	; 0x24
 8007f8e:	682b      	ldr	r3, [r5, #0]
 8007f90:	2253      	movs	r2, #83	; 0x53
 8007f92:	625a      	str	r2, [r3, #36]	; 0x24

  if(Alarm == RTC_ALARM_A)
  {
    /* AlarmA */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8007f94:	682a      	ldr	r2, [r5, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  if(Alarm == RTC_ALARM_A)
 8007f96:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
  {
    /* AlarmA */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8007f9a:	6893      	ldr	r3, [r2, #8]
  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  if(Alarm == RTC_ALARM_A)
 8007f9c:	d02c      	beq.n	8007ff8 <HAL_RTC_DeactivateAlarm+0x88>
    }
  }
  else
  {
    /* AlarmB */
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 8007f9e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007fa2:	6093      	str	r3, [r2, #8]

    /* In case of interrupt mode is used, the interrupt source must disabled */
    __HAL_RTC_ALARM_DISABLE_IT(hrtc,RTC_IT_ALRB);
 8007fa4:	682a      	ldr	r2, [r5, #0]
 8007fa6:	6893      	ldr	r3, [r2, #8]
 8007fa8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8007fac:	6093      	str	r3, [r2, #8]

    tickstart = HAL_GetTick();
 8007fae:	f7f8 fdab 	bl	8000b08 <HAL_GetTick>
 8007fb2:	4606      	mov	r6, r0

    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 8007fb4:	e005      	b.n	8007fc2 <HAL_RTC_DeactivateAlarm+0x52>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8007fb6:	f7f8 fda7 	bl	8000b08 <HAL_GetTick>
 8007fba:	1b80      	subs	r0, r0, r6
 8007fbc:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8007fc0:	d810      	bhi.n	8007fe4 <HAL_RTC_DeactivateAlarm+0x74>
    __HAL_RTC_ALARM_DISABLE_IT(hrtc,RTC_IT_ALRB);

    tickstart = HAL_GetTick();

    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 8007fc2:	682a      	ldr	r2, [r5, #0]
 8007fc4:	68d3      	ldr	r3, [r2, #12]
 8007fc6:	f013 0402 	ands.w	r4, r3, #2
 8007fca:	d0f4      	beq.n	8007fb6 <HAL_RTC_DeactivateAlarm+0x46>
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8007fcc:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
      }
    }
  }
  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007fce:	20ff      	movs	r0, #255	; 0xff

  hrtc->State = HAL_RTC_STATE_READY;
 8007fd0:	2101      	movs	r1, #1
        return HAL_TIMEOUT;
      }
    }
  }
  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007fd2:	6250      	str	r0, [r2, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8007fd4:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8007fd8:	f885 3020 	strb.w	r3, [r5, #32]

  return HAL_OK; 
 8007fdc:	4618      	mov	r0, r3
 8007fde:	bd70      	pop	{r4, r5, r6, pc}

  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8007fe0:	2002      	movs	r0, #2
 8007fe2:	4770      	bx	lr
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007fe4:	682a      	ldr	r2, [r5, #0]

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8007fe6:	2303      	movs	r3, #3
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8007fe8:	21ff      	movs	r1, #255	; 0xff
 8007fea:	6251      	str	r1, [r2, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8007fec:	f885 4020 	strb.w	r4, [r5, #32]
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8007ff0:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);

        return HAL_TIMEOUT;
 8007ff4:	4618      	mov	r0, r3
 8007ff6:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  if(Alarm == RTC_ALARM_A)
  {
    /* AlarmA */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8007ff8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007ffc:	6093      	str	r3, [r2, #8]

    /* In case of interrupt mode is used, the interrupt source must disabled */
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
 8007ffe:	682a      	ldr	r2, [r5, #0]
 8008000:	6893      	ldr	r3, [r2, #8]
 8008002:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8008006:	6093      	str	r3, [r2, #8]

    tickstart = HAL_GetTick();
 8008008:	f7f8 fd7e 	bl	8000b08 <HAL_GetTick>
 800800c:	4606      	mov	r6, r0

    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 800800e:	e005      	b.n	800801c <HAL_RTC_DeactivateAlarm+0xac>
    {
      if( (HAL_GetTick()  - tickstart ) > RTC_TIMEOUT_VALUE)
 8008010:	f7f8 fd7a 	bl	8000b08 <HAL_GetTick>
 8008014:	1b80      	subs	r0, r0, r6
 8008016:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800801a:	d8e3      	bhi.n	8007fe4 <HAL_RTC_DeactivateAlarm+0x74>
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);

    tickstart = HAL_GetTick();

    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 800801c:	682a      	ldr	r2, [r5, #0]
 800801e:	68d3      	ldr	r3, [r2, #12]
 8008020:	f013 0401 	ands.w	r4, r3, #1
 8008024:	d0f4      	beq.n	8008010 <HAL_RTC_DeactivateAlarm+0xa0>
 8008026:	e7d1      	b.n	8007fcc <HAL_RTC_DeactivateAlarm+0x5c>

08008028 <HAL_RTC_GetAlarm>:

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));
  assert_param(IS_RTC_ALARM(Alarm));

  if(Alarm == RTC_ALARM_A)
 8008028:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
  *             @arg RTC_FORMAT_BIN: Binary data format 
  *             @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)
{
 800802c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));
  assert_param(IS_RTC_ALARM(Alarm));

  if(Alarm == RTC_ALARM_A)
 8008030:	d04a      	beq.n	80080c8 <HAL_RTC_GetAlarm+0xa0>
    tmpreg = (uint32_t)(hrtc->Instance->ALRMAR);
    subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMASSR ) & RTC_ALRMASSR_SS);
  }
  else
  {
    sAlarm->Alarm = RTC_ALARM_B;
 8008032:	f44f 7200 	mov.w	r2, #512	; 0x200
 8008036:	624a      	str	r2, [r1, #36]	; 0x24

    tmpreg = (uint32_t)(hrtc->Instance->ALRMBR);
 8008038:	6800      	ldr	r0, [r0, #0]
 800803a:	6a02      	ldr	r2, [r0, #32]
    subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMBSSR) & RTC_ALRMBSSR_SS);
 800803c:	6c80      	ldr	r0, [r0, #72]	; 0x48
 800803e:	f3c0 0c0e 	ubfx	ip, r0, #0, #15

  /* Fill the structure with the read parameters */
  /* ALRMAR/ALRMBR registers have same mapping)  */
  sAlarm->AlarmTime.Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | RTC_ALRMAR_HU)) >> 16);
  sAlarm->AlarmTime.Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> 8);
  sAlarm->AlarmTime.Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | RTC_ALRMAR_SU));
 8008042:	b2d7      	uxtb	r7, r2
  sAlarm->AlarmTime.TimeFormat = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 8008044:	f402 0e80 	and.w	lr, r2, #4194304	; 0x400000
    subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMBSSR) & RTC_ALRMBSSR_SS);
  }

  /* Fill the structure with the read parameters */
  /* ALRMAR/ALRMBR registers have same mapping)  */
  sAlarm->AlarmTime.Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | RTC_ALRMAR_HU)) >> 16);
 8008048:	f3c2 4505 	ubfx	r5, r2, #16, #6
  sAlarm->AlarmTime.Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> 8);
 800804c:	f3c2 2406 	ubfx	r4, r2, #8, #7
  sAlarm->AlarmTime.Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | RTC_ALRMAR_SU));
  sAlarm->AlarmTime.TimeFormat = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
  sAlarm->AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 8008050:	f3c2 6005 	ubfx	r0, r2, #24, #6
  sAlarm->AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 8008054:	f002 4880 	and.w	r8, r2, #1073741824	; 0x40000000

  /* Fill the structure with the read parameters */
  /* ALRMAR/ALRMBR registers have same mapping)  */
  sAlarm->AlarmTime.Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | RTC_ALRMAR_HU)) >> 16);
  sAlarm->AlarmTime.Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> 8);
  sAlarm->AlarmTime.Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | RTC_ALRMAR_SU));
 8008058:	f007 067f 	and.w	r6, r7, #127	; 0x7f
  sAlarm->AlarmTime.TimeFormat = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 800805c:	ea4f 4e1e 	mov.w	lr, lr, lsr #16
  sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
  sAlarm->AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
  sAlarm->AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
  sAlarm->AlarmMask = (uint32_t)(tmpreg & RTC_ALARMMASK_ALL);
 8008060:	f002 3280 	and.w	r2, r2, #2155905152	; 0x80808080
  /* ALRMAR/ALRMBR registers have same mapping)  */
  sAlarm->AlarmTime.Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | RTC_ALRMAR_HU)) >> 16);
  sAlarm->AlarmTime.Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> 8);
  sAlarm->AlarmTime.Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | RTC_ALRMAR_SU));
  sAlarm->AlarmTime.TimeFormat = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
 8008064:	f8c1 c004 	str.w	ip, [r1, #4]

  /* Fill the structure with the read parameters */
  /* ALRMAR/ALRMBR registers have same mapping)  */
  sAlarm->AlarmTime.Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | RTC_ALRMAR_HU)) >> 16);
  sAlarm->AlarmTime.Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> 8);
  sAlarm->AlarmTime.Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | RTC_ALRMAR_SU));
 8008068:	708e      	strb	r6, [r1, #2]
  sAlarm->AlarmTime.TimeFormat = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 800806a:	f881 e003 	strb.w	lr, [r1, #3]
    subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMBSSR) & RTC_ALRMBSSR_SS);
  }

  /* Fill the structure with the read parameters */
  /* ALRMAR/ALRMBR registers have same mapping)  */
  sAlarm->AlarmTime.Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | RTC_ALRMAR_HU)) >> 16);
 800806e:	700d      	strb	r5, [r1, #0]
  sAlarm->AlarmTime.Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> 8);
 8008070:	704c      	strb	r4, [r1, #1]
  sAlarm->AlarmTime.Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | RTC_ALRMAR_SU));
  sAlarm->AlarmTime.TimeFormat = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
  sAlarm->AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 8008072:	f881 0020 	strb.w	r0, [r1, #32]
  sAlarm->AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 8008076:	f8c1 801c 	str.w	r8, [r1, #28]
  sAlarm->AlarmMask = (uint32_t)(tmpreg & RTC_ALARMMASK_ALL);
 800807a:	614a      	str	r2, [r1, #20]

  if(Format == RTC_FORMAT_BIN)
 800807c:	bb0b      	cbnz	r3, 80080c2 <HAL_RTC_GetAlarm+0x9a>
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 800807e:	ea4f 1e15 	mov.w	lr, r5, lsr #4
 8008082:	0922      	lsrs	r2, r4, #4
 8008084:	0903      	lsrs	r3, r0, #4
 8008086:	0936      	lsrs	r6, r6, #4
 8008088:	eb06 0686 	add.w	r6, r6, r6, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 800808c:	f007 070f 	and.w	r7, r7, #15
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8008090:	eb0e 0e8e 	add.w	lr, lr, lr, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8008094:	f005 050f 	and.w	r5, r5, #15
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8008098:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 800809c:	f004 040f 	and.w	r4, r4, #15
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 80080a0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 80080a4:	f000 000f 	and.w	r0, r0, #15
 80080a8:	eb07 0646 	add.w	r6, r7, r6, lsl #1
 80080ac:	eb05 054e 	add.w	r5, r5, lr, lsl #1
 80080b0:	eb04 0442 	add.w	r4, r4, r2, lsl #1
 80080b4:	eb00 0043 	add.w	r0, r0, r3, lsl #1

  if(Format == RTC_FORMAT_BIN)
  {
    sAlarm->AlarmTime.Hours = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);
    sAlarm->AlarmTime.Minutes = RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes);
    sAlarm->AlarmTime.Seconds = RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds);
 80080b8:	708e      	strb	r6, [r1, #2]
  sAlarm->AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
  sAlarm->AlarmMask = (uint32_t)(tmpreg & RTC_ALARMMASK_ALL);

  if(Format == RTC_FORMAT_BIN)
  {
    sAlarm->AlarmTime.Hours = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);
 80080ba:	700d      	strb	r5, [r1, #0]
    sAlarm->AlarmTime.Minutes = RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes);
 80080bc:	704c      	strb	r4, [r1, #1]
    sAlarm->AlarmTime.Seconds = RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds);
    sAlarm->AlarmDateWeekDay = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
 80080be:	f881 0020 	strb.w	r0, [r1, #32]
  }

  return HAL_OK;
}
 80080c2:	2000      	movs	r0, #0
 80080c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RTC_ALARM(Alarm));

  if(Alarm == RTC_ALARM_A)
  {
    /* AlarmA */
    sAlarm->Alarm = RTC_ALARM_A;
 80080c8:	624a      	str	r2, [r1, #36]	; 0x24

    tmpreg = (uint32_t)(hrtc->Instance->ALRMAR);
 80080ca:	6800      	ldr	r0, [r0, #0]
 80080cc:	69c2      	ldr	r2, [r0, #28]
    subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMASSR ) & RTC_ALRMASSR_SS);
 80080ce:	6c40      	ldr	r0, [r0, #68]	; 0x44
 80080d0:	f3c0 0c0e 	ubfx	ip, r0, #0, #15
 80080d4:	e7b5      	b.n	8008042 <HAL_RTC_GetAlarm+0x1a>
 80080d6:	bf00      	nop

080080d8 <HAL_RTC_AlarmAEventCallback>:
  * @brief  Alarm A callback.
  * @param  hrtc: RTC handle
  * @retval None
  */
__weak void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{
 80080d8:	4770      	bx	lr
 80080da:	bf00      	nop

080080dc <HAL_RTC_AlarmIRQHandler>:
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc: RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef* hrtc)
{
 80080dc:	b510      	push	{r4, lr}
  /* Get the AlarmA interrupt source enable status */
  if(__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != RESET)
 80080de:	6803      	ldr	r3, [r0, #0]
 80080e0:	689a      	ldr	r2, [r3, #8]
 80080e2:	04d2      	lsls	r2, r2, #19
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc: RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef* hrtc)
{
 80080e4:	4604      	mov	r4, r0
  /* Get the AlarmA interrupt source enable status */
  if(__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != RESET)
 80080e6:	d502      	bpl.n	80080ee <HAL_RTC_AlarmIRQHandler+0x12>
  {
    /* Get the pending status of the AlarmA Interrupt */
    if(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != RESET)
 80080e8:	68da      	ldr	r2, [r3, #12]
 80080ea:	05d1      	lsls	r1, r2, #23
 80080ec:	d417      	bmi.n	800811e <HAL_RTC_AlarmIRQHandler+0x42>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
    }
  }

  /* Get the AlarmB interrupt source enable status */
  if(__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != RESET)
 80080ee:	689a      	ldr	r2, [r3, #8]
 80080f0:	0492      	lsls	r2, r2, #18
 80080f2:	d502      	bpl.n	80080fa <HAL_RTC_AlarmIRQHandler+0x1e>
  {
    /* Get the pending status of the AlarmB Interrupt */
    if(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != RESET)
 80080f4:	68db      	ldr	r3, [r3, #12]
 80080f6:	059b      	lsls	r3, r3, #22
 80080f8:	d407      	bmi.n	800810a <HAL_RTC_AlarmIRQHandler+0x2e>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
    }
  }

  /* Clear the EXTI's line Flag for RTC Alarm */
  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
 80080fa:	4a0e      	ldr	r2, [pc, #56]	; (8008134 <HAL_RTC_AlarmIRQHandler+0x58>)
 80080fc:	f44f 2180 	mov.w	r1, #262144	; 0x40000

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008100:	2301      	movs	r3, #1
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
    }
  }

  /* Clear the EXTI's line Flag for RTC Alarm */
  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
 8008102:	6151      	str	r1, [r2, #20]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008104:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
 8008108:	bd10      	pop	{r4, pc}
  {
    /* Get the pending status of the AlarmB Interrupt */
    if(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != RESET)
    {
      /* AlarmB callback */
      HAL_RTCEx_AlarmBEventCallback(hrtc);
 800810a:	4620      	mov	r0, r4
 800810c:	f001 f908 	bl	8009320 <HAL_RTCEx_AlarmBEventCallback>

      /* Clear the AlarmB interrupt pending bit */
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 8008110:	6822      	ldr	r2, [r4, #0]
 8008112:	68d3      	ldr	r3, [r2, #12]
 8008114:	b2db      	uxtb	r3, r3
 8008116:	f463 7320 	orn	r3, r3, #640	; 0x280
 800811a:	60d3      	str	r3, [r2, #12]
 800811c:	e7ed      	b.n	80080fa <HAL_RTC_AlarmIRQHandler+0x1e>
  {
    /* Get the pending status of the AlarmA Interrupt */
    if(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != RESET)
    {
      /* AlarmA callback */
      HAL_RTC_AlarmAEventCallback(hrtc);
 800811e:	f7ff ffdb 	bl	80080d8 <HAL_RTC_AlarmAEventCallback>

      /* Clear the AlarmA interrupt pending bit */
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 8008122:	6822      	ldr	r2, [r4, #0]
 8008124:	68d3      	ldr	r3, [r2, #12]
 8008126:	b2db      	uxtb	r3, r3
 8008128:	f463 73c0 	orn	r3, r3, #384	; 0x180
 800812c:	60d3      	str	r3, [r2, #12]
 800812e:	6823      	ldr	r3, [r4, #0]
 8008130:	e7dd      	b.n	80080ee <HAL_RTC_AlarmIRQHandler+0x12>
 8008132:	bf00      	nop
 8008134:	40010400 	.word	0x40010400

08008138 <HAL_RTC_PollForAlarmAEvent>:
  * @param  hrtc: RTC handle
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{
 8008138:	b570      	push	{r4, r5, r6, lr}
 800813a:	4605      	mov	r5, r0
 800813c:	460c      	mov	r4, r1

  uint32_t tickstart = HAL_GetTick();   
 800813e:	f7f8 fce3 	bl	8000b08 <HAL_GetTick>
 8008142:	4606      	mov	r6, r0
 8008144:	682a      	ldr	r2, [r5, #0]
 8008146:	e001      	b.n	800814c <HAL_RTC_PollForAlarmAEvent+0x14>
  
  while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
 8008148:	1c61      	adds	r1, r4, #1
 800814a:	d10c      	bne.n	8008166 <HAL_RTC_PollForAlarmAEvent+0x2e>
HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{

  uint32_t tickstart = HAL_GetTick();   
  
  while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == RESET)
 800814c:	68d3      	ldr	r3, [r2, #12]
 800814e:	05db      	lsls	r3, r3, #23
 8008150:	d5fa      	bpl.n	8008148 <HAL_RTC_PollForAlarmAEvent+0x10>
      }
    }
  }

  /* Clear the Alarm interrupt pending bit */
  __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 8008152:	68d3      	ldr	r3, [r2, #12]
 8008154:	b2db      	uxtb	r3, r3
 8008156:	f463 73c0 	orn	r3, r3, #384	; 0x180

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 800815a:	2101      	movs	r1, #1
      }
    }
  }

  /* Clear the Alarm interrupt pending bit */
  __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 800815c:	60d3      	str	r3, [r2, #12]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 800815e:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

  return HAL_OK;
 8008162:	2000      	movs	r0, #0
}
 8008164:	bd70      	pop	{r4, r5, r6, pc}
  
  while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8008166:	b124      	cbz	r4, 8008172 <HAL_RTC_PollForAlarmAEvent+0x3a>
 8008168:	f7f8 fcce 	bl	8000b08 <HAL_GetTick>
 800816c:	1b80      	subs	r0, r0, r6
 800816e:	4284      	cmp	r4, r0
 8008170:	d2e8      	bcs.n	8008144 <HAL_RTC_PollForAlarmAEvent+0xc>
      {
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008172:	2003      	movs	r0, #3
 8008174:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21
        return HAL_TIMEOUT;
 8008178:	bd70      	pop	{r4, r5, r6, pc}
 800817a:	bf00      	nop

0800817c <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
 800817c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 800817e:	6802      	ldr	r2, [r0, #0]
 8008180:	68d3      	ldr	r3, [r2, #12]
 8008182:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8008186:	60d3      	str	r3, [r2, #12]
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
 8008188:	4604      	mov	r4, r0
  uint32_t tickstart = 0;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;

  tickstart = HAL_GetTick();
 800818a:	f7f8 fcbd 	bl	8000b08 <HAL_GetTick>
 800818e:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8008190:	e005      	b.n	800819e <HAL_RTC_WaitForSynchro+0x22>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8008192:	f7f8 fcb9 	bl	8000b08 <HAL_GetTick>
 8008196:	1b40      	subs	r0, r0, r5
 8008198:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800819c:	d805      	bhi.n	80081aa <HAL_RTC_WaitForSynchro+0x2e>
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;

  tickstart = HAL_GetTick();

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 800819e:	6823      	ldr	r3, [r4, #0]
 80081a0:	68db      	ldr	r3, [r3, #12]
 80081a2:	069b      	lsls	r3, r3, #26
 80081a4:	d5f5      	bpl.n	8008192 <HAL_RTC_WaitForSynchro+0x16>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 80081a6:	2000      	movs	r0, #0
 80081a8:	bd38      	pop	{r3, r4, r5, pc}
  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
 80081aa:	2003      	movs	r0, #3
    }
  }

  return HAL_OK;
}
 80081ac:	bd38      	pop	{r3, r4, r5, pc}
 80081ae:	bf00      	nop

080081b0 <HAL_RTC_GetState>:
  * @retval HAL state
  */
HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef* hrtc)
{
  /* Return RTC handle state */
  return hrtc->State;
 80081b0:	f890 0021 	ldrb.w	r0, [r0, #33]	; 0x21
}
 80081b4:	4770      	bx	lr
 80081b6:	bf00      	nop

080081b8 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 80081b8:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0;

  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80081ba:	6803      	ldr	r3, [r0, #0]
 80081bc:	68da      	ldr	r2, [r3, #12]
 80081be:	0652      	lsls	r2, r2, #25
 80081c0:	d501      	bpl.n	80081c6 <RTC_EnterInitMode+0xe>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 80081c2:	2000      	movs	r0, #0
 80081c4:	bd38      	pop	{r3, r4, r5, pc}

  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 80081c6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80081ca:	60da      	str	r2, [r3, #12]
 80081cc:	4604      	mov	r4, r0

    tickstart = HAL_GetTick();
 80081ce:	f7f8 fc9b 	bl	8000b08 <HAL_GetTick>
 80081d2:	4605      	mov	r5, r0
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80081d4:	6823      	ldr	r3, [r4, #0]
 80081d6:	68db      	ldr	r3, [r3, #12]
 80081d8:	065b      	lsls	r3, r3, #25
 80081da:	d4f2      	bmi.n	80081c2 <RTC_EnterInitMode+0xa>
    {
      if((HAL_GetTick()  - tickstart ) > RTC_TIMEOUT_VALUE)
 80081dc:	f7f8 fc94 	bl	8000b08 <HAL_GetTick>
 80081e0:	1b40      	subs	r0, r0, r5
 80081e2:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80081e6:	d9f5      	bls.n	80081d4 <RTC_EnterInitMode+0x1c>
      {
        return HAL_TIMEOUT;
 80081e8:	2003      	movs	r0, #3
      }
    }
  }

  return HAL_OK;
}
 80081ea:	bd38      	pop	{r3, r4, r5, pc}

080081ec <HAL_RTC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
  /* Check the RTC peripheral state */
  if(hrtc == NULL)
 80081ec:	2800      	cmp	r0, #0
 80081ee:	d052      	beq.n	8008296 <HAL_RTC_Init+0xaa>
  *         in the RTC_InitTypeDef structure and initialize the associated handle.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 80081f0:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_RTC_OUTPUT(hrtc->Init.OutPut));
  assert_param(IS_RTC_OUTPUT_REMAP(hrtc->Init.OutPutRemap));
  assert_param(IS_RTC_OUTPUT_POL(hrtc->Init.OutPutPolarity));
  assert_param(IS_RTC_OUTPUT_TYPE(hrtc->Init.OutPutType));
  
  if(hrtc->State == HAL_RTC_STATE_RESET)
 80081f2:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 80081f6:	4604      	mov	r4, r0
 80081f8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80081fc:	2b00      	cmp	r3, #0
 80081fe:	d045      	beq.n	800828c <HAL_RTC_Init+0xa0>

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008200:	6823      	ldr	r3, [r4, #0]
    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
  }

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 8008202:	2102      	movs	r1, #2

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008204:	22ca      	movs	r2, #202	; 0xca
    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
  }

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 8008206:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800820a:	625a      	str	r2, [r3, #36]	; 0x24
 800820c:	6823      	ldr	r3, [r4, #0]
 800820e:	2253      	movs	r2, #83	; 0x53
 8008210:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8008212:	4620      	mov	r0, r4
 8008214:	f7ff ffd0 	bl	80081b8 <RTC_EnterInitMode>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008218:	6822      	ldr	r2, [r4, #0]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 800821a:	2800      	cmp	r0, #0
 800821c:	d12f      	bne.n	800827e <HAL_RTC_Init+0x92>
    return HAL_ERROR;
  }
  else
  {
    /* Clear RTC_CR FMT, OSEL and POL Bits */
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 800821e:	6893      	ldr	r3, [r2, #8]
 8008220:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8008224:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8008228:	6093      	str	r3, [r2, #8]
    /* Set RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 800822a:	6825      	ldr	r5, [r4, #0]
 800822c:	6861      	ldr	r1, [r4, #4]
 800822e:	68ae      	ldr	r6, [r5, #8]
 8008230:	6922      	ldr	r2, [r4, #16]
 8008232:	69a3      	ldr	r3, [r4, #24]
 8008234:	4331      	orrs	r1, r6
 8008236:	430a      	orrs	r2, r1
 8008238:	4313      	orrs	r3, r2
 800823a:	60ab      	str	r3, [r5, #8]

    /* Configure the RTC PRER */
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 800823c:	6823      	ldr	r3, [r4, #0]
 800823e:	68e2      	ldr	r2, [r4, #12]
 8008240:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16);
 8008242:	6822      	ldr	r2, [r4, #0]
 8008244:	68a1      	ldr	r1, [r4, #8]
 8008246:	6913      	ldr	r3, [r2, #16]
 8008248:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800824c:	6113      	str	r3, [r2, #16]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 800824e:	6822      	ldr	r2, [r4, #0]
 8008250:	68d3      	ldr	r3, [r2, #12]
 8008252:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008256:	60d3      	str	r3, [r2, #12]

    hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 8008258:	6822      	ldr	r2, [r4, #0]
 800825a:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 800825c:	f023 0303 	bic.w	r3, r3, #3
 8008260:	64d3      	str	r3, [r2, #76]	; 0x4c
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8008262:	6821      	ldr	r1, [r4, #0]
 8008264:	69e2      	ldr	r2, [r4, #28]
 8008266:	6ccd      	ldr	r5, [r1, #76]	; 0x4c
 8008268:	6963      	ldr	r3, [r4, #20]
 800826a:	432a      	orrs	r2, r5
 800826c:	4313      	orrs	r3, r2
 800826e:	64cb      	str	r3, [r1, #76]	; 0x4c

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008270:	6822      	ldr	r2, [r4, #0]
 8008272:	21ff      	movs	r1, #255	; 0xff

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
 8008274:	2301      	movs	r3, #1

    hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008276:	6251      	str	r1, [r2, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
 8008278:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21

    return HAL_OK;
 800827c:	bd70      	pop	{r4, r5, r6, pc}

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800827e:	21ff      	movs	r1, #255	; 0xff

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 8008280:	2304      	movs	r3, #4

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008282:	6251      	str	r1, [r2, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 8008284:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21

    return HAL_ERROR;
 8008288:	2001      	movs	r0, #1
 800828a:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_RTC_OUTPUT_TYPE(hrtc->Init.OutPutType));
  
  if(hrtc->State == HAL_RTC_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hrtc->Lock = HAL_UNLOCKED;
 800828c:	f880 2020 	strb.w	r2, [r0, #32]

    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
 8008290:	f7f8 f9e2 	bl	8000658 <HAL_RTC_MspInit>
 8008294:	e7b4      	b.n	8008200 <HAL_RTC_Init+0x14>
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
  /* Check the RTC peripheral state */
  if(hrtc == NULL)
  {
     return HAL_ERROR;
 8008296:	2001      	movs	r0, #1
 8008298:	4770      	bx	lr
 800829a:	bf00      	nop

0800829c <HAL_RTC_DeInit>:
  * @param  hrtc: RTC handle
  * @note   This function doesn't reset the RTC Backup Data registers.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
{
 800829c:	b570      	push	{r4, r5, r6, lr}

  /* Check the parameters */
  assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 800829e:	2202      	movs	r2, #2

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80082a0:	6803      	ldr	r3, [r0, #0]

  /* Check the parameters */
  assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 80082a2:	f880 2021 	strb.w	r2, [r0, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80082a6:	22ca      	movs	r2, #202	; 0xca
 80082a8:	625a      	str	r2, [r3, #36]	; 0x24
 80082aa:	6803      	ldr	r3, [r0, #0]
 80082ac:	2253      	movs	r2, #83	; 0x53
 80082ae:	625a      	str	r2, [r3, #36]	; 0x24
  * @param  hrtc: RTC handle
  * @note   This function doesn't reset the RTC Backup Data registers.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
{
 80082b0:	4604      	mov	r4, r0

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80082b2:	f7ff ff81 	bl	80081b8 <RTC_EnterInitMode>
 80082b6:	4606      	mov	r6, r0
 80082b8:	b140      	cbz	r0, 80082cc <HAL_RTC_DeInit+0x30>
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 80082ba:	6822      	ldr	r2, [r4, #0]
 80082bc:	21ff      	movs	r1, #255	; 0xff

        hrtc->State = HAL_RTC_STATE_ERROR;
 80082be:	2304      	movs	r3, #4
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 80082c0:	6251      	str	r1, [r2, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;

        return HAL_ERROR;
 80082c2:	2601      	movs	r6, #1
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  

        hrtc->State = HAL_RTC_STATE_ERROR;
 80082c4:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  
  /* Release Lock */
  __HAL_UNLOCK(hrtc);

  return HAL_OK;
}
 80082c8:	4630      	mov	r0, r6
 80082ca:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
  }
  else
  {
    /* Reset TR, DR and CR registers */
    hrtc->Instance->TR = (uint32_t)0x00000000;
 80082cc:	6823      	ldr	r3, [r4, #0]
 80082ce:	6018      	str	r0, [r3, #0]
    hrtc->Instance->DR = ((uint32_t)(RTC_DR_WDU_0 | RTC_DR_MU_0 | RTC_DR_DU_0));
 80082d0:	6823      	ldr	r3, [r4, #0]
 80082d2:	f242 1201 	movw	r2, #8449	; 0x2101
 80082d6:	605a      	str	r2, [r3, #4]
    /* Reset All CR bits except CR[2:0] */
    hrtc->Instance->CR &= RTC_CR_WUCKSEL;
 80082d8:	6822      	ldr	r2, [r4, #0]
 80082da:	6893      	ldr	r3, [r2, #8]
 80082dc:	f003 0307 	and.w	r3, r3, #7
 80082e0:	6093      	str	r3, [r2, #8]

    tickstart = HAL_GetTick();
 80082e2:	f7f8 fc11 	bl	8000b08 <HAL_GetTick>
 80082e6:	4605      	mov	r5, r0

    /* Wait till WUTWF flag is set and if Time out is reached exit */
    while(((hrtc->Instance->ISR) & RTC_ISR_WUTWF) == (uint32_t)RESET)
 80082e8:	e005      	b.n	80082f6 <HAL_RTC_DeInit+0x5a>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 80082ea:	f7f8 fc0d 	bl	8000b08 <HAL_GetTick>
 80082ee:	1b40      	subs	r0, r0, r5
 80082f0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80082f4:	d835      	bhi.n	8008362 <HAL_RTC_DeInit+0xc6>
    hrtc->Instance->CR &= RTC_CR_WUCKSEL;

    tickstart = HAL_GetTick();

    /* Wait till WUTWF flag is set and if Time out is reached exit */
    while(((hrtc->Instance->ISR) & RTC_ISR_WUTWF) == (uint32_t)RESET)
 80082f6:	6823      	ldr	r3, [r4, #0]
 80082f8:	68da      	ldr	r2, [r3, #12]
 80082fa:	0751      	lsls	r1, r2, #29
 80082fc:	d5f5      	bpl.n	80082ea <HAL_RTC_DeInit+0x4e>
        return HAL_TIMEOUT;
      }
    }

    /* Reset all RTC CR register bits */
    hrtc->Instance->CR &= (uint32_t)0x00000000;
 80082fe:	2200      	movs	r2, #0
 8008300:	6899      	ldr	r1, [r3, #8]
 8008302:	609a      	str	r2, [r3, #8]
    hrtc->Instance->WUTR = RTC_WUTR_WUT;
 8008304:	6823      	ldr	r3, [r4, #0]
    hrtc->Instance->PRER = ((uint32_t)(RTC_PRER_PREDIV_A | 0x000000FF));
 8008306:	491b      	ldr	r1, [pc, #108]	; (8008374 <HAL_RTC_DeInit+0xd8>)
      }
    }

    /* Reset all RTC CR register bits */
    hrtc->Instance->CR &= (uint32_t)0x00000000;
    hrtc->Instance->WUTR = RTC_WUTR_WUT;
 8008308:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800830c:	6158      	str	r0, [r3, #20]
    hrtc->Instance->PRER = ((uint32_t)(RTC_PRER_PREDIV_A | 0x000000FF));
 800830e:	6823      	ldr	r3, [r4, #0]
 8008310:	6119      	str	r1, [r3, #16]
    hrtc->Instance->ALRMAR = (uint32_t)0x00000000;
 8008312:	6823      	ldr	r3, [r4, #0]
 8008314:	61da      	str	r2, [r3, #28]
    hrtc->Instance->ALRMBR = (uint32_t)0x00000000;
 8008316:	6823      	ldr	r3, [r4, #0]
 8008318:	621a      	str	r2, [r3, #32]
    hrtc->Instance->SHIFTR = (uint32_t)0x00000000;
 800831a:	6823      	ldr	r3, [r4, #0]
 800831c:	62da      	str	r2, [r3, #44]	; 0x2c
    hrtc->Instance->CALR = (uint32_t)0x00000000;
 800831e:	6823      	ldr	r3, [r4, #0]
 8008320:	63da      	str	r2, [r3, #60]	; 0x3c
    hrtc->Instance->ALRMASSR = (uint32_t)0x00000000;
 8008322:	6823      	ldr	r3, [r4, #0]
 8008324:	645a      	str	r2, [r3, #68]	; 0x44
    hrtc->Instance->ALRMBSSR = (uint32_t)0x00000000;
 8008326:	6823      	ldr	r3, [r4, #0]
 8008328:	649a      	str	r2, [r3, #72]	; 0x48

    /* Reset ISR register and exit initialization mode */
    hrtc->Instance->ISR = (uint32_t)0x00000000;
 800832a:	6823      	ldr	r3, [r4, #0]
 800832c:	60da      	str	r2, [r3, #12]

    /* Reset Tamper configuration register */
    hrtc->Instance->TAMPCR = 0x00000000;
 800832e:	6823      	ldr	r3, [r4, #0]
 8008330:	641a      	str	r2, [r3, #64]	; 0x40

    /* Reset Option register */
    hrtc->Instance->OR = 0x00000000;
 8008332:	6823      	ldr	r3, [r4, #0]
 8008334:	64da      	str	r2, [r3, #76]	; 0x4c

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8008336:	6823      	ldr	r3, [r4, #0]
 8008338:	689a      	ldr	r2, [r3, #8]
 800833a:	0692      	lsls	r2, r2, #26
 800833c:	d405      	bmi.n	800834a <HAL_RTC_DeInit+0xae>
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 800833e:	4620      	mov	r0, r4
 8008340:	f7ff ff1c 	bl	800817c <HAL_RTC_WaitForSynchro>
 8008344:	2800      	cmp	r0, #0
 8008346:	d1b8      	bne.n	80082ba <HAL_RTC_DeInit+0x1e>
 8008348:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800834a:	22ff      	movs	r2, #255	; 0xff
 800834c:	625a      	str	r2, [r3, #36]	; 0x24

  /* De-Initialize RTC MSP */
  HAL_RTC_MspDeInit(hrtc);
 800834e:	4620      	mov	r0, r4
 8008350:	f7f8 f994 	bl	800067c <HAL_RTC_MspDeInit>

  hrtc->State = HAL_RTC_STATE_RESET;
 8008354:	2300      	movs	r3, #0
 8008356:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  
  /* Release Lock */
  __HAL_UNLOCK(hrtc);
 800835a:	f884 3020 	strb.w	r3, [r4, #32]

  return HAL_OK;
}
 800835e:	4630      	mov	r0, r6
 8008360:	bd70      	pop	{r4, r5, r6, pc}
    while(((hrtc->Instance->ISR) & RTC_ISR_WUTWF) == (uint32_t)RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008362:	6822      	ldr	r2, [r4, #0]

        /* Set RTC state */
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008364:	2303      	movs	r3, #3
    while(((hrtc->Instance->ISR) & RTC_ISR_WUTWF) == (uint32_t)RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008366:	21ff      	movs	r1, #255	; 0xff
 8008368:	6251      	str	r1, [r2, #36]	; 0x24

        /* Set RTC state */
        hrtc->State = HAL_RTC_STATE_TIMEOUT;

        return HAL_TIMEOUT;
 800836a:	461e      	mov	r6, r3
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

        /* Set RTC state */
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 800836c:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  
  /* Release Lock */
  __HAL_UNLOCK(hrtc);

  return HAL_OK;
}
 8008370:	4630      	mov	r0, r6
 8008372:	bd70      	pop	{r4, r5, r6, pc}
 8008374:	007f00ff 	.word	0x007f00ff

08008378 <HAL_RTC_SetTime>:
  *            @arg RTC_FORMAT_BIN: Binary data format 
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
 8008378:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RTC_FORMAT(Format));
  assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 800837a:	f890 3020 	ldrb.w	r3, [r0, #32]
 800837e:	2b01      	cmp	r3, #1
 8008380:	f000 808b 	beq.w	800849a <HAL_RTC_SetTime+0x122>
 8008384:	2401      	movs	r4, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008386:	2302      	movs	r3, #2
  assert_param(IS_RTC_FORMAT(Format));
  assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008388:	f880 4020 	strb.w	r4, [r0, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 800838c:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21

  if(Format == RTC_FORMAT_BIN)
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8008390:	6806      	ldr	r6, [r0, #0]
  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  if(Format == RTC_FORMAT_BIN)
 8008392:	2a00      	cmp	r2, #0
 8008394:	d043      	beq.n	800841e <HAL_RTC_SetTime+0xa6>
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
                        (((uint32_t)sTime->TimeFormat) << 16));
  }
  else
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8008396:	68b4      	ldr	r4, [r6, #8]
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    }
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
              ((uint32_t)(sTime->Minutes) << 8) | \
 8008398:	784f      	ldrb	r7, [r1, #1]
      sTime->TimeFormat = 0x00;
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    }
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 800839a:	780b      	ldrb	r3, [r1, #0]
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
                        (((uint32_t)sTime->TimeFormat) << 16));
  }
  else
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 800839c:	f014 0540 	ands.w	r5, r4, #64	; 0x40
 80083a0:	bf16      	itet	ne
 80083a2:	78cc      	ldrbne	r4, [r1, #3]
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    }
    else
    {
      sTime->TimeFormat = 0x00;
 80083a4:	70cd      	strbeq	r5, [r1, #3]
 80083a6:	0425      	lslne	r5, r4, #16
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    }
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
              ((uint32_t)(sTime->Minutes) << 8) | \
 80083a8:	ea4f 2707 	mov.w	r7, r7, lsl #8
              ((uint32_t)sTime->Seconds) | \
 80083ac:	788c      	ldrb	r4, [r1, #2]
 80083ae:	bf08      	it	eq
 80083b0:	6806      	ldreq	r6, [r0, #0]
      sTime->TimeFormat = 0x00;
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    }
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 80083b2:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
              ((uint32_t)(sTime->Minutes) << 8) | \
 80083b6:	4323      	orrs	r3, r4
      sTime->TimeFormat = 0x00;
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    }
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 80083b8:	ea43 0405 	orr.w	r4, r3, r5
              ((uint32_t)sTime->Seconds) | \
              ((uint32_t)(sTime->TimeFormat) << 16));
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80083bc:	23ca      	movs	r3, #202	; 0xca
 80083be:	6273      	str	r3, [r6, #36]	; 0x24
 80083c0:	6803      	ldr	r3, [r0, #0]
 80083c2:	2253      	movs	r2, #83	; 0x53
 80083c4:	625a      	str	r2, [r3, #36]	; 0x24
 80083c6:	460f      	mov	r7, r1
 80083c8:	4605      	mov	r5, r0

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80083ca:	f7ff fef5 	bl	80081b8 <RTC_EnterInitMode>
 80083ce:	4606      	mov	r6, r0
 80083d0:	2800      	cmp	r0, #0
 80083d2:	d165      	bne.n	80084a0 <HAL_RTC_SetTime+0x128>
    return HAL_ERROR;
  }
  else
  {
    /* Set the RTC_TR register */
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 80083d4:	682a      	ldr	r2, [r5, #0]
 80083d6:	f004 337f 	and.w	r3, r4, #2139062143	; 0x7f7f7f7f
 80083da:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 80083de:	6013      	str	r3, [r2, #0]

    /* Clear the bits to be configured */
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BCK);
 80083e0:	682a      	ldr	r2, [r5, #0]
 80083e2:	6893      	ldr	r3, [r2, #8]
 80083e4:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80083e8:	6093      	str	r3, [r2, #8]

    /* Configure the RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 80083ea:	6829      	ldr	r1, [r5, #0]
 80083ec:	68fb      	ldr	r3, [r7, #12]
 80083ee:	6888      	ldr	r0, [r1, #8]
 80083f0:	693a      	ldr	r2, [r7, #16]
 80083f2:	4303      	orrs	r3, r0
 80083f4:	4313      	orrs	r3, r2
 80083f6:	608b      	str	r3, [r1, #8]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 80083f8:	682a      	ldr	r2, [r5, #0]
 80083fa:	68d3      	ldr	r3, [r2, #12]
 80083fc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008400:	60d3      	str	r3, [r2, #12]

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8008402:	682b      	ldr	r3, [r5, #0]
 8008404:	689a      	ldr	r2, [r3, #8]
 8008406:	0692      	lsls	r2, r2, #26
 8008408:	d556      	bpl.n	80084b8 <HAL_RTC_SetTime+0x140>
        return HAL_ERROR;
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800840a:	20ff      	movs	r0, #255	; 0xff
    
   hrtc->State = HAL_RTC_STATE_READY;
 800840c:	2101      	movs	r1, #1

   __HAL_UNLOCK(hrtc); 
 800840e:	2200      	movs	r2, #0
        return HAL_ERROR;
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008410:	6258      	str	r0, [r3, #36]	; 0x24
    
   hrtc->State = HAL_RTC_STATE_READY;
 8008412:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

   __HAL_UNLOCK(hrtc); 
 8008416:	f885 2020 	strb.w	r2, [r5, #32]

   return HAL_OK;
  }
}
 800841a:	4630      	mov	r0, r6
 800841c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  hrtc->State = HAL_RTC_STATE_BUSY;

  if(Format == RTC_FORMAT_BIN)
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 800841e:	68b2      	ldr	r2, [r6, #8]
      assert_param(IS_RTC_HOUR24(sTime->Hours));
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8008420:	780b      	ldrb	r3, [r1, #0]

  hrtc->State = HAL_RTC_STATE_BUSY;

  if(Format == RTC_FORMAT_BIN)
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8008422:	f012 0e40 	ands.w	lr, r2, #64	; 0x40
 8008426:	bf15      	itete	ne
 8008428:	f891 e003 	ldrbne.w	lr, [r1, #3]
      assert_param(IS_RTC_HOUR12(sTime->Hours));
      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    }
    else
    {
      sTime->TimeFormat = 0x00;
 800842c:	f881 e003 	strbeq.w	lr, [r1, #3]
 8008430:	ea4f 4e0e 	movne.w	lr, lr, lsl #16
 8008434:	6806      	ldreq	r6, [r0, #0]
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008436:	2b09      	cmp	r3, #9
 8008438:	d94e      	bls.n	80084d8 <HAL_RTC_SetTime+0x160>
 800843a:	2200      	movs	r2, #0
  {
    bcdhigh++;
    Value -= 10;
 800843c:	3b0a      	subs	r3, #10
 800843e:	b2db      	uxtb	r3, r3
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008440:	2b09      	cmp	r3, #9
  {
    bcdhigh++;
 8008442:	f102 0201 	add.w	r2, r2, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008446:	d8f9      	bhi.n	800843c <HAL_RTC_SetTime+0xc4>
 8008448:	0112      	lsls	r2, r2, #4
 800844a:	b2d4      	uxtb	r4, r2
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 800844c:	784a      	ldrb	r2, [r1, #1]
      assert_param(IS_RTC_HOUR24(sTime->Hours));
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 800844e:	4323      	orrs	r3, r4
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008450:	2a09      	cmp	r2, #9
      assert_param(IS_RTC_HOUR24(sTime->Hours));
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8008452:	ea4f 4503 	mov.w	r5, r3, lsl #16
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008456:	f04f 0400 	mov.w	r4, #0
 800845a:	d907      	bls.n	800846c <HAL_RTC_SetTime+0xf4>
  {
    bcdhigh++;
    Value -= 10;
 800845c:	3a0a      	subs	r2, #10
 800845e:	b2d2      	uxtb	r2, r2
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008460:	2a09      	cmp	r2, #9
  {
    bcdhigh++;
 8008462:	f104 0401 	add.w	r4, r4, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008466:	d8f9      	bhi.n	800845c <HAL_RTC_SetTime+0xe4>
 8008468:	0124      	lsls	r4, r4, #4
 800846a:	b2e4      	uxtb	r4, r4
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 800846c:	788b      	ldrb	r3, [r1, #2]
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 800846e:	4322      	orrs	r2, r4
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008470:	2b09      	cmp	r3, #9
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 8008472:	ea4f 2402 	mov.w	r4, r2, lsl #8
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008476:	f04f 0700 	mov.w	r7, #0
 800847a:	d907      	bls.n	800848c <HAL_RTC_SetTime+0x114>
  {
    bcdhigh++;
    Value -= 10;
 800847c:	3b0a      	subs	r3, #10
 800847e:	b2db      	uxtb	r3, r3
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008480:	2b09      	cmp	r3, #9
  {
    bcdhigh++;
 8008482:	f107 0701 	add.w	r7, r7, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008486:	d8f9      	bhi.n	800847c <HAL_RTC_SetTime+0x104>
 8008488:	013f      	lsls	r7, r7, #4
 800848a:	b2ff      	uxtb	r7, r7
 800848c:	ea45 020e 	orr.w	r2, r5, lr
 8008490:	4322      	orrs	r2, r4
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8008492:	433b      	orrs	r3, r7
      assert_param(IS_RTC_HOUR24(sTime->Hours));
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8008494:	ea42 0403 	orr.w	r4, r2, r3
 8008498:	e790      	b.n	80083bc <HAL_RTC_SetTime+0x44>
  assert_param(IS_RTC_FORMAT(Format));
  assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 800849a:	2602      	movs	r6, #2

   __HAL_UNLOCK(hrtc); 

   return HAL_OK;
  }
}
 800849c:	4630      	mov	r0, r6
 800849e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80084a0:	6829      	ldr	r1, [r5, #0]
 80084a2:	20ff      	movs	r0, #255	; 0xff

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 80084a4:	2204      	movs	r2, #4

    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);
 80084a6:	2300      	movs	r3, #0

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80084a8:	6248      	str	r0, [r1, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;

    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);

    return HAL_ERROR;
 80084aa:	2601      	movs	r6, #1
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 80084ac:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21

    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);
 80084b0:	f885 3020 	strb.w	r3, [r5, #32]

   __HAL_UNLOCK(hrtc); 

   return HAL_OK;
  }
}
 80084b4:	4630      	mov	r0, r6
 80084b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 80084b8:	4628      	mov	r0, r5
 80084ba:	f7ff fe5f 	bl	800817c <HAL_RTC_WaitForSynchro>
 80084be:	b908      	cbnz	r0, 80084c4 <HAL_RTC_SetTime+0x14c>
 80084c0:	682b      	ldr	r3, [r5, #0]
 80084c2:	e7a2      	b.n	800840a <HAL_RTC_SetTime+0x92>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80084c4:	682a      	ldr	r2, [r5, #0]
 80084c6:	21ff      	movs	r1, #255	; 0xff

        hrtc->State = HAL_RTC_STATE_ERROR;
 80084c8:	2304      	movs	r3, #4
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80084ca:	6251      	str	r1, [r2, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);
 80084cc:	f885 6020 	strb.w	r6, [r5, #32]
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

        hrtc->State = HAL_RTC_STATE_ERROR;
 80084d0:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);

        return HAL_ERROR;
 80084d4:	2601      	movs	r6, #1
 80084d6:	e7a0      	b.n	800841a <HAL_RTC_SetTime+0xa2>
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 80084d8:	2400      	movs	r4, #0
 80084da:	e7b7      	b.n	800844c <HAL_RTC_SetTime+0xd4>

080084dc <HAL_RTC_SetDate>:
  *            @arg RTC_FORMAT_BIN: Binary data format 
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
 80084dc:	b570      	push	{r4, r5, r6, lr}

 /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

 /* Process Locked */
 __HAL_LOCK(hrtc);
 80084de:	f890 3020 	ldrb.w	r3, [r0, #32]
 80084e2:	2b01      	cmp	r3, #1
 80084e4:	d06e      	beq.n	80085c4 <HAL_RTC_SetDate+0xe8>
 80084e6:	2401      	movs	r4, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 80084e8:	2302      	movs	r3, #2

 /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

 /* Process Locked */
 __HAL_LOCK(hrtc);
 80084ea:	f880 4020 	strb.w	r4, [r0, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 80084ee:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21

  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10) == 0x10))
 80084f2:	2a00      	cmp	r2, #0
 80084f4:	d02f      	beq.n	8008556 <HAL_RTC_SetDate+0x7a>
    assert_param(IS_RTC_MONTH(datetmpreg));
    datetmpreg = RTC_Bcd2ToByte(sDate->Date);
    assert_param(IS_RTC_DATE(datetmpreg));

    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
                  (((uint32_t)sDate->Month) << 8) | \
 80084f6:	784d      	ldrb	r5, [r1, #1]
    datetmpreg = RTC_Bcd2ToByte(sDate->Month);
    assert_param(IS_RTC_MONTH(datetmpreg));
    datetmpreg = RTC_Bcd2ToByte(sDate->Date);
    assert_param(IS_RTC_DATE(datetmpreg));

    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 80084f8:	78cc      	ldrb	r4, [r1, #3]
                  (((uint32_t)sDate->Month) << 8) | \
                  ((uint32_t)sDate->Date) | \
 80084fa:	788a      	ldrb	r2, [r1, #2]
                  (((uint32_t)sDate->WeekDay) << 13));
 80084fc:	780e      	ldrb	r6, [r1, #0]
    assert_param(IS_RTC_MONTH(datetmpreg));
    datetmpreg = RTC_Bcd2ToByte(sDate->Date);
    assert_param(IS_RTC_DATE(datetmpreg));

    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
                  (((uint32_t)sDate->Month) << 8) | \
 80084fe:	0229      	lsls	r1, r5, #8
    datetmpreg = RTC_Bcd2ToByte(sDate->Month);
    assert_param(IS_RTC_MONTH(datetmpreg));
    datetmpreg = RTC_Bcd2ToByte(sDate->Date);
    assert_param(IS_RTC_DATE(datetmpreg));

    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 8008500:	ea41 4404 	orr.w	r4, r1, r4, lsl #16
                  (((uint32_t)sDate->Month) << 8) | \
 8008504:	ea44 0302 	orr.w	r3, r4, r2
    datetmpreg = RTC_Bcd2ToByte(sDate->Month);
    assert_param(IS_RTC_MONTH(datetmpreg));
    datetmpreg = RTC_Bcd2ToByte(sDate->Date);
    assert_param(IS_RTC_DATE(datetmpreg));

    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 8008508:	ea43 3446 	orr.w	r4, r3, r6, lsl #13
                  ((uint32_t)sDate->Date) | \
                  (((uint32_t)sDate->WeekDay) << 13));
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800850c:	6803      	ldr	r3, [r0, #0]
 800850e:	22ca      	movs	r2, #202	; 0xca
 8008510:	625a      	str	r2, [r3, #36]	; 0x24
 8008512:	6803      	ldr	r3, [r0, #0]
 8008514:	2253      	movs	r2, #83	; 0x53
 8008516:	625a      	str	r2, [r3, #36]	; 0x24
 8008518:	4605      	mov	r5, r0

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 800851a:	f7ff fe4d 	bl	80081b8 <RTC_EnterInitMode>
 800851e:	4606      	mov	r6, r0
 8008520:	2800      	cmp	r0, #0
 8008522:	d152      	bne.n	80085ca <HAL_RTC_SetDate+0xee>
    return HAL_ERROR;
  }
  else
  {
    /* Set the RTC_DR register */
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 8008524:	682a      	ldr	r2, [r5, #0]
 8008526:	f024 437f 	bic.w	r3, r4, #4278190080	; 0xff000000
 800852a:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800852e:	6053      	str	r3, [r2, #4]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8008530:	682a      	ldr	r2, [r5, #0]
 8008532:	68d3      	ldr	r3, [r2, #12]
 8008534:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008538:	60d3      	str	r3, [r2, #12]

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 800853a:	682b      	ldr	r3, [r5, #0]
 800853c:	689a      	ldr	r2, [r3, #8]
 800853e:	0692      	lsls	r2, r2, #26
 8008540:	d555      	bpl.n	80085ee <HAL_RTC_SetDate+0x112>
        return HAL_ERROR;
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008542:	20ff      	movs	r0, #255	; 0xff

    hrtc->State = HAL_RTC_STATE_READY ;
 8008544:	2101      	movs	r1, #1

    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);
 8008546:	2200      	movs	r2, #0
        return HAL_ERROR;
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008548:	6258      	str	r0, [r3, #36]	; 0x24

    hrtc->State = HAL_RTC_STATE_READY ;
 800854a:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);
 800854e:	f885 2020 	strb.w	r2, [r5, #32]

    return HAL_OK;
  }
}
 8008552:	4630      	mov	r0, r6
 8008554:	bd70      	pop	{r4, r5, r6, pc}
 /* Process Locked */
 __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10) == 0x10))
 8008556:	784a      	ldrb	r2, [r1, #1]
 8008558:	06d4      	lsls	r4, r2, #27
 800855a:	d442      	bmi.n	80085e2 <HAL_RTC_SetDate+0x106>
  {
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 800855c:	78cb      	ldrb	r3, [r1, #3]
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 800855e:	2b09      	cmp	r3, #9
 8008560:	f04f 0600 	mov.w	r6, #0
 8008564:	d907      	bls.n	8008576 <HAL_RTC_SetDate+0x9a>
  {
    bcdhigh++;
    Value -= 10;
 8008566:	3b0a      	subs	r3, #10
 8008568:	b2db      	uxtb	r3, r3
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 800856a:	2b09      	cmp	r3, #9
  {
    bcdhigh++;
 800856c:	f106 0601 	add.w	r6, r6, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008570:	d8f9      	bhi.n	8008566 <HAL_RTC_SetDate+0x8a>
 8008572:	0136      	lsls	r6, r6, #4
 8008574:	b2f6      	uxtb	r6, r6
  {
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8008576:	4333      	orrs	r3, r6
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008578:	2a09      	cmp	r2, #9
  {
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 800857a:	ea4f 4603 	mov.w	r6, r3, lsl #16
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 800857e:	f04f 0500 	mov.w	r5, #0
 8008582:	d907      	bls.n	8008594 <HAL_RTC_SetDate+0xb8>
  {
    bcdhigh++;
    Value -= 10;
 8008584:	3a0a      	subs	r2, #10
 8008586:	b2d2      	uxtb	r2, r2
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008588:	2a09      	cmp	r2, #9
  {
    bcdhigh++;
 800858a:	f105 0501 	add.w	r5, r5, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 800858e:	d8f9      	bhi.n	8008584 <HAL_RTC_SetDate+0xa8>
 8008590:	012d      	lsls	r5, r5, #4
 8008592:	b2ed      	uxtb	r5, r5
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 8008594:	788b      	ldrb	r3, [r1, #2]
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
 8008596:	432a      	orrs	r2, r5
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008598:	2b09      	cmp	r3, #9
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
 800859a:	ea4f 2502 	mov.w	r5, r2, lsl #8
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 800859e:	f04f 0400 	mov.w	r4, #0
 80085a2:	d907      	bls.n	80085b4 <HAL_RTC_SetDate+0xd8>
  {
    bcdhigh++;
    Value -= 10;
 80085a4:	3b0a      	subs	r3, #10
 80085a6:	b2db      	uxtb	r3, r3
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 80085a8:	2b09      	cmp	r3, #9
  {
    bcdhigh++;
 80085aa:	f104 0401 	add.w	r4, r4, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 80085ae:	d8f9      	bhi.n	80085a4 <HAL_RTC_SetDate+0xc8>
 80085b0:	0124      	lsls	r4, r4, #4
 80085b2:	b2e4      	uxtb	r4, r4
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
                 ((uint32_t)sDate->WeekDay << 13));
 80085b4:	780a      	ldrb	r2, [r1, #0]
 80085b6:	ea46 3242 	orr.w	r2, r6, r2, lsl #13
 80085ba:	432a      	orrs	r2, r5
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 80085bc:	4323      	orrs	r3, r4
  {
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 80085be:	ea42 0403 	orr.w	r4, r2, r3
 80085c2:	e7a3      	b.n	800850c <HAL_RTC_SetDate+0x30>

 /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

 /* Process Locked */
 __HAL_LOCK(hrtc);
 80085c4:	2602      	movs	r6, #2
    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);

    return HAL_OK;
  }
}
 80085c6:	4630      	mov	r0, r6
 80085c8:	bd70      	pop	{r4, r5, r6, pc}

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80085ca:	6829      	ldr	r1, [r5, #0]
 80085cc:	20ff      	movs	r0, #255	; 0xff

    /* Set RTC state*/
    hrtc->State = HAL_RTC_STATE_ERROR;
 80085ce:	2204      	movs	r2, #4

    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);
 80085d0:	2300      	movs	r3, #0

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80085d2:	6248      	str	r0, [r1, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;

    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);

    return HAL_ERROR;
 80085d4:	2601      	movs	r6, #1
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

    /* Set RTC state*/
    hrtc->State = HAL_RTC_STATE_ERROR;
 80085d6:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21

    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);
 80085da:	f885 3020 	strb.w	r3, [r5, #32]
    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);

    return HAL_OK;
  }
}
 80085de:	4630      	mov	r0, r6
 80085e0:	bd70      	pop	{r4, r5, r6, pc}

  hrtc->State = HAL_RTC_STATE_BUSY;

  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10) == 0x10))
  {
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10)) + (uint8_t)0x0A);
 80085e2:	f022 0210 	bic.w	r2, r2, #16
 80085e6:	320a      	adds	r2, #10
 80085e8:	b2d2      	uxtb	r2, r2
 80085ea:	704a      	strb	r2, [r1, #1]
 80085ec:	e7b6      	b.n	800855c <HAL_RTC_SetDate+0x80>
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 80085ee:	4628      	mov	r0, r5
 80085f0:	f7ff fdc4 	bl	800817c <HAL_RTC_WaitForSynchro>
 80085f4:	b908      	cbnz	r0, 80085fa <HAL_RTC_SetDate+0x11e>
 80085f6:	682b      	ldr	r3, [r5, #0]
 80085f8:	e7a3      	b.n	8008542 <HAL_RTC_SetDate+0x66>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 80085fa:	682a      	ldr	r2, [r5, #0]
 80085fc:	21ff      	movs	r1, #255	; 0xff

        hrtc->State = HAL_RTC_STATE_ERROR;
 80085fe:	2304      	movs	r3, #4
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8008600:	6251      	str	r1, [r2, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);
 8008602:	f885 6020 	strb.w	r6, [r5, #32]
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  

        hrtc->State = HAL_RTC_STATE_ERROR;
 8008606:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);

        return HAL_ERROR;
 800860a:	2601      	movs	r6, #1
 800860c:	e7a1      	b.n	8008552 <HAL_RTC_SetDate+0x76>
 800860e:	bf00      	nop

08008610 <RTC_ByteToBcd2>:
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008610:	2809      	cmp	r0, #9
 8008612:	f04f 0300 	mov.w	r3, #0
 8008616:	d907      	bls.n	8008628 <RTC_ByteToBcd2+0x18>
  {
    bcdhigh++;
    Value -= 10;
 8008618:	380a      	subs	r0, #10
 800861a:	b2c0      	uxtb	r0, r0
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 800861c:	2809      	cmp	r0, #9
  {
    bcdhigh++;
 800861e:	f103 0301 	add.w	r3, r3, #1
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;

  while(Value >= 10)
 8008622:	d8f9      	bhi.n	8008618 <RTC_ByteToBcd2+0x8>
 8008624:	011b      	lsls	r3, r3, #4
 8008626:	b2db      	uxtb	r3, r3
    bcdhigh++;
    Value -= 10;
  }

  return  ((uint8_t)(bcdhigh << 4) | Value);
}
 8008628:	4318      	orrs	r0, r3
 800862a:	4770      	bx	lr

0800862c <RTC_Bcd2ToByte>:
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 800862c:	0903      	lsrs	r3, r0, #4
 800862e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8008632:	f000 000f 	and.w	r0, r0, #15
 8008636:	eb00 0043 	add.w	r0, r0, r3, lsl #1
}
 800863a:	b2c0      	uxtb	r0, r0
 800863c:	4770      	bx	lr
 800863e:	bf00      	nop

08008640 <HAL_RTCEx_SetTimeStamp>:
  *               The RTC TimeStamp Pin is per default PC13, but for reasons of
  *               compatibility, this parameter is required.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
{
 8008640:	4603      	mov	r3, r0
  /* Check the parameters */
  assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008642:	f890 0020 	ldrb.w	r0, [r0, #32]
 8008646:	2801      	cmp	r0, #1
 8008648:	d024      	beq.n	8008694 <HAL_RTCEx_SetTimeStamp+0x54>
  *               The RTC TimeStamp Pin is per default PC13, but for reasons of
  *               compatibility, this parameter is required.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
{
 800864a:	b470      	push	{r4, r5, r6}
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 800864c:	2202      	movs	r2, #2

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 800864e:	681d      	ldr	r5, [r3, #0]
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008650:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  /* Check the parameters */
  assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008654:	2401      	movs	r4, #1
 8008656:	f883 4020 	strb.w	r4, [r3, #32]
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));

  tmpreg|= TimeStampEdge;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800865a:	22ca      	movs	r2, #202	; 0xca
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 800865c:	68a8      	ldr	r0, [r5, #8]

  tmpreg|= TimeStampEdge;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800865e:	626a      	str	r2, [r5, #36]	; 0x24
 8008660:	681d      	ldr	r5, [r3, #0]
 8008662:	2653      	movs	r6, #83	; 0x53
 8008664:	626e      	str	r6, [r5, #36]	; 0x24
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 8008666:	f420 6200 	bic.w	r2, r0, #2048	; 0x800
 800866a:	f022 0208 	bic.w	r2, r2, #8

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Configure the Time Stamp TSEDGE and Enable bits */
  hrtc->Instance->CR = (uint32_t)tmpreg;
 800866e:	6818      	ldr	r0, [r3, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));

  tmpreg|= TimeStampEdge;
 8008670:	430a      	orrs	r2, r1

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Configure the Time Stamp TSEDGE and Enable bits */
  hrtc->Instance->CR = (uint32_t)tmpreg;
 8008672:	6082      	str	r2, [r0, #8]

  __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
 8008674:	6819      	ldr	r1, [r3, #0]
 8008676:	688a      	ldr	r2, [r1, #8]
 8008678:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800867c:	608a      	str	r2, [r1, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800867e:	6819      	ldr	r1, [r3, #0]
 8008680:	20ff      	movs	r0, #255	; 0xff

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY; 

  /* Process Unlocked */ 
  __HAL_UNLOCK(hrtc);
 8008682:	2200      	movs	r2, #0
  hrtc->Instance->CR = (uint32_t)tmpreg;

  __HAL_RTC_TIMESTAMP_ENABLE(hrtc);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008684:	6248      	str	r0, [r1, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY; 
 8008686:	f883 4021 	strb.w	r4, [r3, #33]	; 0x21

  /* Process Unlocked */ 
  __HAL_UNLOCK(hrtc);
 800868a:	f883 2020 	strb.w	r2, [r3, #32]

  return HAL_OK;
 800868e:	4610      	mov	r0, r2
}
 8008690:	bc70      	pop	{r4, r5, r6}
 8008692:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008694:	2002      	movs	r0, #2
 8008696:	4770      	bx	lr

08008698 <HAL_RTCEx_SetTimeStamp_IT>:
  *               The RTC TimeStamp Pin is per default PC13, but for reasons of
  *               compatibility, this parameter is required.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
{
 8008698:	4603      	mov	r3, r0
  /* Check the parameters */
  assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 800869a:	f890 0020 	ldrb.w	r0, [r0, #32]
 800869e:	2801      	cmp	r0, #1
 80086a0:	d032      	beq.n	8008708 <HAL_RTCEx_SetTimeStamp_IT+0x70>
  *               The RTC TimeStamp Pin is per default PC13, but for reasons of
  *               compatibility, this parameter is required.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
{
 80086a2:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 80086a4:	2202      	movs	r2, #2

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 80086a6:	681c      	ldr	r4, [r3, #0]
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 80086a8:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  /* Check the parameters */
  assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 80086ac:	2501      	movs	r5, #1
 80086ae:	f883 5020 	strb.w	r5, [r3, #32]
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));

  tmpreg |= TimeStampEdge;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80086b2:	22ca      	movs	r2, #202	; 0xca
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 80086b4:	68a0      	ldr	r0, [r4, #8]

  tmpreg |= TimeStampEdge;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80086b6:	6262      	str	r2, [r4, #36]	; 0x24
 80086b8:	681e      	ldr	r6, [r3, #0]

  /* Enable IT timestamp */
  __HAL_RTC_TIMESTAMP_ENABLE_IT(hrtc,RTC_IT_TS);

  /* RTC timestamp Interrupt Configuration: EXTI configuration */
  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
 80086ba:	4c14      	ldr	r4, [pc, #80]	; (800870c <HAL_RTCEx_SetTimeStamp_IT+0x74>)
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));

  tmpreg |= TimeStampEdge;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80086bc:	2753      	movs	r7, #83	; 0x53
 80086be:	6277      	str	r7, [r6, #36]	; 0x24
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 80086c0:	f420 6200 	bic.w	r2, r0, #2048	; 0x800
 80086c4:	f022 0208 	bic.w	r2, r2, #8

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Configure the Time Stamp TSEDGE and Enable bits */
  hrtc->Instance->CR = (uint32_t)tmpreg;
 80086c8:	6818      	ldr	r0, [r3, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));

  tmpreg |= TimeStampEdge;
 80086ca:	430a      	orrs	r2, r1

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Configure the Time Stamp TSEDGE and Enable bits */
  hrtc->Instance->CR = (uint32_t)tmpreg;
 80086cc:	6082      	str	r2, [r0, #8]

  __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
 80086ce:	6819      	ldr	r1, [r3, #0]
 80086d0:	688a      	ldr	r2, [r1, #8]
 80086d2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80086d6:	608a      	str	r2, [r1, #8]

  /* Enable IT timestamp */
  __HAL_RTC_TIMESTAMP_ENABLE_IT(hrtc,RTC_IT_TS);
 80086d8:	6819      	ldr	r1, [r3, #0]
 80086da:	688a      	ldr	r2, [r1, #8]
 80086dc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80086e0:	608a      	str	r2, [r1, #8]

  /* RTC timestamp Interrupt Configuration: EXTI configuration */
  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
 80086e2:	6822      	ldr	r2, [r4, #0]
 80086e4:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 80086e8:	6022      	str	r2, [r4, #0]

  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();
 80086ea:	68a2      	ldr	r2, [r4, #8]
 80086ec:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 80086f0:	60a2      	str	r2, [r4, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80086f2:	6819      	ldr	r1, [r3, #0]
 80086f4:	20ff      	movs	r0, #255	; 0xff

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80086f6:	2200      	movs	r2, #0
  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();

  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80086f8:	6248      	str	r0, [r1, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 80086fa:	f883 5021 	strb.w	r5, [r3, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80086fe:	f883 2020 	strb.w	r2, [r3, #32]

  return HAL_OK;
 8008702:	4610      	mov	r0, r2
}
 8008704:	bcf0      	pop	{r4, r5, r6, r7}
 8008706:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008708:	2002      	movs	r0, #2
 800870a:	4770      	bx	lr
 800870c:	40010400 	.word	0x40010400

08008710 <HAL_RTCEx_DeactivateTimeStamp>:
HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
{
  uint32_t tmpreg = 0;

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008710:	f890 2020 	ldrb.w	r2, [r0, #32]
 8008714:	2a01      	cmp	r2, #1
  * @brief  Deactivate TimeStamp.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
{
 8008716:	4603      	mov	r3, r0
  uint32_t tmpreg = 0;

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008718:	d024      	beq.n	8008764 <HAL_RTCEx_DeactivateTimeStamp+0x54>
  * @brief  Deactivate TimeStamp.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
{
 800871a:	b410      	push	{r4}
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800871c:	6802      	ldr	r2, [r0, #0]
HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
{
  uint32_t tmpreg = 0;

  /* Process Locked */
  __HAL_LOCK(hrtc);
 800871e:	2101      	movs	r1, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008720:	2402      	movs	r4, #2

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008722:	20ca      	movs	r0, #202	; 0xca
  uint32_t tmpreg = 0;

  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008724:	f883 4021 	strb.w	r4, [r3, #33]	; 0x21
HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
{
  uint32_t tmpreg = 0;

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008728:	f883 1020 	strb.w	r1, [r3, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800872c:	6250      	str	r0, [r2, #36]	; 0x24
 800872e:	681a      	ldr	r2, [r3, #0]
 8008730:	2053      	movs	r0, #83	; 0x53
 8008732:	6250      	str	r0, [r2, #36]	; 0x24

  /* In case of interrupt mode is used, the interrupt source must disabled */
  __HAL_RTC_TIMESTAMP_DISABLE_IT(hrtc, RTC_IT_TS);
 8008734:	6818      	ldr	r0, [r3, #0]
 8008736:	6882      	ldr	r2, [r0, #8]
 8008738:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800873c:	6082      	str	r2, [r0, #8]

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 800873e:	6818      	ldr	r0, [r3, #0]
 8008740:	6882      	ldr	r2, [r0, #8]
 8008742:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8008746:	f022 0208 	bic.w	r2, r2, #8

  /* Configure the Time Stamp TSEDGE and Enable bits */
  hrtc->Instance->CR = (uint32_t)tmpreg;
 800874a:	6082      	str	r2, [r0, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800874c:	6818      	ldr	r0, [r3, #0]
 800874e:	24ff      	movs	r4, #255	; 0xff

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008750:	2200      	movs	r2, #0

  /* Configure the Time Stamp TSEDGE and Enable bits */
  hrtc->Instance->CR = (uint32_t)tmpreg;

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008752:	6244      	str	r4, [r0, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8008754:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008758:	f883 2020 	strb.w	r2, [r3, #32]

  return HAL_OK;
 800875c:	4610      	mov	r0, r2
}
 800875e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008762:	4770      	bx	lr
HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
{
  uint32_t tmpreg = 0;

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008764:	2002      	movs	r0, #2
 8008766:	4770      	bx	lr

08008768 <HAL_RTCEx_SetInternalTimeStamp>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008768:	f890 2020 	ldrb.w	r2, [r0, #32]
 800876c:	2a01      	cmp	r2, #1
  * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
 800876e:	4603      	mov	r3, r0
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008770:	d01d      	beq.n	80087ae <HAL_RTCEx_SetInternalTimeStamp+0x46>
  * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
 8008772:	b410      	push	{r4}
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008774:	6802      	ldr	r2, [r0, #0]
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008776:	2101      	movs	r1, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008778:	2402      	movs	r4, #2

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800877a:	20ca      	movs	r0, #202	; 0xca
HAL_StatusTypeDef HAL_RTCEx_SetInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 800877c:	f883 4021 	strb.w	r4, [r3, #33]	; 0x21
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008780:	f883 1020 	strb.w	r1, [r3, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008784:	6250      	str	r0, [r2, #36]	; 0x24
 8008786:	681a      	ldr	r2, [r3, #0]
 8008788:	2053      	movs	r0, #83	; 0x53
 800878a:	6250      	str	r0, [r2, #36]	; 0x24

  /* Configure the internal Time Stamp Enable bits */
  __HAL_RTC_INTERNAL_TIMESTAMP_ENABLE(hrtc);
 800878c:	6818      	ldr	r0, [r3, #0]
 800878e:	6882      	ldr	r2, [r0, #8]
 8008790:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8008794:	6082      	str	r2, [r0, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008796:	6818      	ldr	r0, [r3, #0]
 8008798:	24ff      	movs	r4, #255	; 0xff

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */ 
  __HAL_UNLOCK(hrtc);
 800879a:	2200      	movs	r2, #0

  /* Configure the internal Time Stamp Enable bits */
  __HAL_RTC_INTERNAL_TIMESTAMP_ENABLE(hrtc);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800879c:	6244      	str	r4, [r0, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 800879e:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21

  /* Process Unlocked */ 
  __HAL_UNLOCK(hrtc);
 80087a2:	f883 2020 	strb.w	r2, [r3, #32]

  return HAL_OK;
 80087a6:	4610      	mov	r0, r2
}
 80087a8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80087ac:	4770      	bx	lr
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80087ae:	2002      	movs	r0, #2
 80087b0:	4770      	bx	lr
 80087b2:	bf00      	nop

080087b4 <HAL_RTCEx_DeactivateInternalTimeStamp>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80087b4:	f890 2020 	ldrb.w	r2, [r0, #32]
 80087b8:	2a01      	cmp	r2, #1
  * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
 80087ba:	4603      	mov	r3, r0
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80087bc:	d01d      	beq.n	80087fa <HAL_RTCEx_DeactivateInternalTimeStamp+0x46>
  * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
 80087be:	b410      	push	{r4}
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80087c0:	6802      	ldr	r2, [r0, #0]
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80087c2:	2101      	movs	r1, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 80087c4:	2402      	movs	r4, #2

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80087c6:	20ca      	movs	r0, #202	; 0xca
HAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 80087c8:	f883 4021 	strb.w	r4, [r3, #33]	; 0x21
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80087cc:	f883 1020 	strb.w	r1, [r3, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80087d0:	6250      	str	r0, [r2, #36]	; 0x24
 80087d2:	681a      	ldr	r2, [r3, #0]
 80087d4:	2053      	movs	r0, #83	; 0x53
 80087d6:	6250      	str	r0, [r2, #36]	; 0x24

  /* Configure the internal Time Stamp Enable bits */
  __HAL_RTC_INTERNAL_TIMESTAMP_DISABLE(hrtc);
 80087d8:	6818      	ldr	r0, [r3, #0]
 80087da:	6882      	ldr	r2, [r0, #8]
 80087dc:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80087e0:	6082      	str	r2, [r0, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80087e2:	6818      	ldr	r0, [r3, #0]
 80087e4:	24ff      	movs	r4, #255	; 0xff

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80087e6:	2200      	movs	r2, #0

  /* Configure the internal Time Stamp Enable bits */
  __HAL_RTC_INTERNAL_TIMESTAMP_DISABLE(hrtc);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80087e8:	6244      	str	r4, [r0, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 80087ea:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80087ee:	f883 2020 	strb.w	r2, [r3, #32]

  return HAL_OK;
 80087f2:	4610      	mov	r0, r2
}
 80087f4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80087f8:	4770      	bx	lr
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTimeStamp(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80087fa:	2002      	movs	r0, #2
 80087fc:	4770      	bx	lr
 80087fe:	bf00      	nop

08008800 <HAL_RTCEx_GetTimeStamp>:
  *             @arg RTC_FORMAT_BIN: Binary data format 
  *             @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef* sTimeStamp, RTC_DateTypeDef* sTimeStampDate, uint32_t Format)
{
 8008800:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008802:	4606      	mov	r6, r0

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
 8008804:	6800      	ldr	r0, [r0, #0]
  *             @arg RTC_FORMAT_BIN: Binary data format 
  *             @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef* sTimeStamp, RTC_DateTypeDef* sTimeStampDate, uint32_t Format)
{
 8008806:	460c      	mov	r4, r1

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
 8008808:	6b01      	ldr	r1, [r0, #48]	; 0x30
  tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);
 800880a:	6b40      	ldr	r0, [r0, #52]	; 0x34

  /* Fill the Time structure fields with the read parameters */
  sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
  sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
  sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);
 800880c:	f401 0580 	and.w	r5, r1, #4194304	; 0x400000
  tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
  tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);

  /* Fill the Time structure fields with the read parameters */
  sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 8008810:	f3c1 2706 	ubfx	r7, r1, #8, #7
  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
  tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);

  /* Fill the Time structure fields with the read parameters */
  sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8008814:	f3c1 4e05 	ubfx	lr, r1, #16, #6
  sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
  sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
  sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);
 8008818:	0c2d      	lsrs	r5, r5, #16
  tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);

  /* Fill the Time structure fields with the read parameters */
  sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
  sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 800881a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
  tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);

  /* Fill the Time structure fields with the read parameters */
  sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 800881e:	7067      	strb	r7, [r4, #1]
  sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
  sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);
 8008820:	70e5      	strb	r5, [r4, #3]
  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
  tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);

  /* Fill the Time structure fields with the read parameters */
  sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8008822:	f884 e000 	strb.w	lr, [r4]
  sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
  sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 8008826:	70a1      	strb	r1, [r4, #2]
  sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);
  sTimeStamp->SubSeconds = (uint32_t) hrtc->Instance->TSSSR;
 8008828:	6831      	ldr	r1, [r6, #0]
  *             @arg RTC_FORMAT_BIN: Binary data format 
  *             @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef* sTimeStamp, RTC_DateTypeDef* sTimeStampDate, uint32_t Format)
{
 800882a:	4615      	mov	r5, r2
  /* Fill the Time structure fields with the read parameters */
  sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
  sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
  sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);
  sTimeStamp->SubSeconds = (uint32_t) hrtc->Instance->TSSSR;
 800882c:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 800882e:	6062      	str	r2, [r4, #4]

  /* Fill the Date structure fields with the read parameters */
  sTimeStampDate->Year = 0;
  sTimeStampDate->Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8008830:	f3c0 2104 	ubfx	r1, r0, #8, #5
  sTimeStampDate->Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 8008834:	f000 023f 	and.w	r2, r0, #63	; 0x3f
  sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
  sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);
  sTimeStamp->SubSeconds = (uint32_t) hrtc->Instance->TSSSR;

  /* Fill the Date structure fields with the read parameters */
  sTimeStampDate->Year = 0;
 8008838:	2700      	movs	r7, #0
  sTimeStampDate->Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
  sTimeStampDate->Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
  sTimeStampDate->WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 800883a:	f3c0 3042 	ubfx	r0, r0, #13, #3
  sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
  sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);
  sTimeStamp->SubSeconds = (uint32_t) hrtc->Instance->TSSSR;

  /* Fill the Date structure fields with the read parameters */
  sTimeStampDate->Year = 0;
 800883e:	70ef      	strb	r7, [r5, #3]
  sTimeStampDate->Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8008840:	7069      	strb	r1, [r5, #1]
  sTimeStampDate->Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 8008842:	70aa      	strb	r2, [r5, #2]
  sTimeStampDate->WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 8008844:	7028      	strb	r0, [r5, #0]

  /* Check the input parameters format */
  if(Format == RTC_FORMAT_BIN)
 8008846:	b9bb      	cbnz	r3, 8008878 <HAL_RTCEx_GetTimeStamp+0x78>
  {
    /* Convert the TimeStamp structure parameters to Binary format */
    sTimeStamp->Hours = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Hours);
 8008848:	7820      	ldrb	r0, [r4, #0]
 800884a:	f7ff feef 	bl	800862c <RTC_Bcd2ToByte>
 800884e:	7020      	strb	r0, [r4, #0]
    sTimeStamp->Minutes = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Minutes);
 8008850:	7860      	ldrb	r0, [r4, #1]
 8008852:	f7ff feeb 	bl	800862c <RTC_Bcd2ToByte>
 8008856:	7060      	strb	r0, [r4, #1]
    sTimeStamp->Seconds = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Seconds);
 8008858:	78a0      	ldrb	r0, [r4, #2]
 800885a:	f7ff fee7 	bl	800862c <RTC_Bcd2ToByte>
 800885e:	70a0      	strb	r0, [r4, #2]

    /* Convert the DateTimeStamp structure parameters to Binary format */
    sTimeStampDate->Month = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Month);
 8008860:	7868      	ldrb	r0, [r5, #1]
 8008862:	f7ff fee3 	bl	800862c <RTC_Bcd2ToByte>
 8008866:	7068      	strb	r0, [r5, #1]
    sTimeStampDate->Date = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Date);
 8008868:	78a8      	ldrb	r0, [r5, #2]
 800886a:	f7ff fedf 	bl	800862c <RTC_Bcd2ToByte>
 800886e:	70a8      	strb	r0, [r5, #2]
    sTimeStampDate->WeekDay = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->WeekDay);
 8008870:	7828      	ldrb	r0, [r5, #0]
 8008872:	f7ff fedb 	bl	800862c <RTC_Bcd2ToByte>
 8008876:	7028      	strb	r0, [r5, #0]
  }

  /* Clear the TIMESTAMP Flags */
  __HAL_RTC_INTERNAL_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_ITSF);
 8008878:	6831      	ldr	r1, [r6, #0]
 800887a:	4b06      	ldr	r3, [pc, #24]	; (8008894 <HAL_RTCEx_GetTimeStamp+0x94>)
 800887c:	68ca      	ldr	r2, [r1, #12]
 800887e:	b2d2      	uxtb	r2, r2
 8008880:	4313      	orrs	r3, r2
 8008882:	60cb      	str	r3, [r1, #12]
  __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
 8008884:	6832      	ldr	r2, [r6, #0]
 8008886:	68d3      	ldr	r3, [r2, #12]
 8008888:	b2db      	uxtb	r3, r3
 800888a:	f463 6308 	orn	r3, r3, #2176	; 0x880
 800888e:	60d3      	str	r3, [r2, #12]

  return HAL_OK;
}
 8008890:	2000      	movs	r0, #0
 8008892:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008894:	fffdff7f 	.word	0xfffdff7f

08008898 <HAL_RTCEx_SetTamper>:
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008898:	f890 3020 	ldrb.w	r3, [r0, #32]
 800889c:	2b01      	cmp	r3, #1
  * @param  hrtc: RTC handle
  * @param  sTamper: Pointer to Tamper Structure.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
{
 800889e:	4602      	mov	r2, r0
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 80088a0:	d064      	beq.n	800896c <HAL_RTCEx_SetTamper+0xd4>
  * @param  hrtc: RTC handle
  * @param  sTamper: Pointer to Tamper Structure.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
{
 80088a2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));

  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 80088a6:	2302      	movs	r3, #2
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 80088a8:	2001      	movs	r0, #1
 80088aa:	f882 0020 	strb.w	r0, [r2, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 80088ae:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21

  /* Configure the tamper trigger */
  if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
 80088b2:	688d      	ldr	r5, [r1, #8]
  { 
    sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1); 
 80088b4:	680b      	ldr	r3, [r1, #0]
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Configure the tamper trigger */
  if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
 80088b6:	2d00      	cmp	r5, #0
 80088b8:	d154      	bne.n	8008964 <HAL_RTCEx_SetTamper+0xcc>
 80088ba:	fa03 f900 	lsl.w	r9, r3, r0
  { 
    sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1); 
  }

  if(sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)
 80088be:	68cc      	ldr	r4, [r1, #12]
 80088c0:	b17c      	cbz	r4, 80088e2 <HAL_RTCEx_SetTamper+0x4a>
  { 
    sTamper->NoErase = 0;
    if((sTamper->Tamper & RTC_TAMPER_1) != 0)
 80088c2:	f013 0401 	ands.w	r4, r3, #1
    {
      sTamper->NoErase |= RTC_TAMPCR_TAMP1NOERASE;
 80088c6:	bf18      	it	ne
 80088c8:	f44f 3400 	movne.w	r4, #131072	; 0x20000
    }
    if((sTamper->Tamper & RTC_TAMPER_2) != 0)
 80088cc:	071e      	lsls	r6, r3, #28
  if(sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)
  { 
    sTamper->NoErase = 0;
    if((sTamper->Tamper & RTC_TAMPER_1) != 0)
    {
      sTamper->NoErase |= RTC_TAMPCR_TAMP1NOERASE;
 80088ce:	60cc      	str	r4, [r1, #12]
    }
    if((sTamper->Tamper & RTC_TAMPER_2) != 0)
    {
      sTamper->NoErase |= RTC_TAMPCR_TAMP2NOERASE;
 80088d0:	bf44      	itt	mi
 80088d2:	f444 1480 	orrmi.w	r4, r4, #1048576	; 0x100000
 80088d6:	60cc      	strmi	r4, [r1, #12]
    }
    if((sTamper->Tamper & RTC_TAMPER_3) != 0)
 80088d8:	0698      	lsls	r0, r3, #26
    {
      sTamper->NoErase |= RTC_TAMPCR_TAMP3NOERASE;
 80088da:	bf44      	itt	mi
 80088dc:	f444 0400 	orrmi.w	r4, r4, #8388608	; 0x800000
 80088e0:	60cc      	strmi	r4, [r1, #12]
    }
  }

  if(sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)
 80088e2:	6908      	ldr	r0, [r1, #16]
 80088e4:	b178      	cbz	r0, 8008906 <HAL_RTCEx_SetTamper+0x6e>
  {
    sTamper->MaskFlag = 0;
    if((sTamper->Tamper & RTC_TAMPER_1) != 0)
 80088e6:	f013 0001 	ands.w	r0, r3, #1
    {
      sTamper->MaskFlag |= RTC_TAMPCR_TAMP1MF;
 80088ea:	bf18      	it	ne
 80088ec:	f44f 2080 	movne.w	r0, #262144	; 0x40000
    }
    if((sTamper->Tamper & RTC_TAMPER_2) != 0)
 80088f0:	071f      	lsls	r7, r3, #28
  if(sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)
  {
    sTamper->MaskFlag = 0;
    if((sTamper->Tamper & RTC_TAMPER_1) != 0)
    {
      sTamper->MaskFlag |= RTC_TAMPCR_TAMP1MF;
 80088f2:	6108      	str	r0, [r1, #16]
    }
    if((sTamper->Tamper & RTC_TAMPER_2) != 0)
    {
      sTamper->MaskFlag |= RTC_TAMPCR_TAMP2MF;
 80088f4:	bf44      	itt	mi
 80088f6:	f440 1000 	orrmi.w	r0, r0, #2097152	; 0x200000
 80088fa:	6108      	strmi	r0, [r1, #16]
    }
    if((sTamper->Tamper & RTC_TAMPER_3) != 0)
 80088fc:	069e      	lsls	r6, r3, #26
    {
      sTamper->MaskFlag |= RTC_TAMPCR_TAMP3MF;
 80088fe:	bf44      	itt	mi
 8008900:	f040 7080 	orrmi.w	r0, r0, #16777216	; 0x1000000
 8008904:	6108      	strmi	r0, [r1, #16]

  tmpreg = ((uint32_t)sTamper->Tamper | (uint32_t)sTamper->Trigger  | (uint32_t)sTamper->NoErase |\
            (uint32_t)sTamper->MaskFlag | (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency |\
            (uint32_t)sTamper->PrechargeDuration | (uint32_t)sTamper->TamperPullUp | sTamper->TimeStampOnTamperDetection);

  hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1) | (uint32_t)RTC_TAMPCR_TAMPTS |\
 8008906:	f8d2 a000 	ldr.w	sl, [r2]
                                       (uint32_t)RTC_TAMPCR_TAMPFREQ | (uint32_t)RTC_TAMPCR_TAMPFLT | (uint32_t)RTC_TAMPCR_TAMPPRCH |\
                                       (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE | (uint32_t)RTC_TAMPCR_TAMP1IE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2IE | (uint32_t)RTC_TAMPCR_TAMP3IE | (uint32_t)RTC_TAMPCR_TAMP1NOERASE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP3NOERASE | (uint32_t)RTC_TAMPCR_TAMP1MF |\
                                       (uint32_t)RTC_TAMPCR_TAMP2MF | (uint32_t)RTC_TAMPCR_TAMP3MF);
 800890a:	f8df 8064 	ldr.w	r8, [pc, #100]	; 8008970 <HAL_RTCEx_SetTamper+0xd8>

  tmpreg = ((uint32_t)sTamper->Tamper | (uint32_t)sTamper->Trigger  | (uint32_t)sTamper->NoErase |\
            (uint32_t)sTamper->MaskFlag | (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency |\
            (uint32_t)sTamper->PrechargeDuration | (uint32_t)sTamper->TamperPullUp | sTamper->TimeStampOnTamperDetection);

  hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1) | (uint32_t)RTC_TAMPCR_TAMPTS |\
 800890e:	f8da c040 	ldr.w	ip, [sl, #64]	; 0x40
 8008912:	f8d1 b018 	ldr.w	fp, [r1, #24]
 8008916:	f8d1 e014 	ldr.w	lr, [r1, #20]
 800891a:	69cf      	ldr	r7, [r1, #28]
 800891c:	6a0e      	ldr	r6, [r1, #32]
 800891e:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8008920:	ea43 0909 	orr.w	r9, r3, r9
                                       (uint32_t)RTC_TAMPCR_TAMPFREQ | (uint32_t)RTC_TAMPCR_TAMPFLT | (uint32_t)RTC_TAMPCR_TAMPPRCH |\
                                       (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE | (uint32_t)RTC_TAMPCR_TAMP1IE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2IE | (uint32_t)RTC_TAMPCR_TAMP3IE | (uint32_t)RTC_TAMPCR_TAMP1NOERASE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP3NOERASE | (uint32_t)RTC_TAMPCR_TAMP1MF |\
                                       (uint32_t)RTC_TAMPCR_TAMP2MF | (uint32_t)RTC_TAMPCR_TAMP3MF);
 8008924:	ea49 0808 	orr.w	r8, r9, r8

  tmpreg = ((uint32_t)sTamper->Tamper | (uint32_t)sTamper->Trigger  | (uint32_t)sTamper->NoErase |\
            (uint32_t)sTamper->MaskFlag | (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency |\
            (uint32_t)sTamper->PrechargeDuration | (uint32_t)sTamper->TamperPullUp | sTamper->TimeStampOnTamperDetection);

  hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1) | (uint32_t)RTC_TAMPCR_TAMPTS |\
 8008928:	ea2c 0c08 	bic.w	ip, ip, r8
 800892c:	f8ca c040 	str.w	ip, [sl, #64]	; 0x40
                                       (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE | (uint32_t)RTC_TAMPCR_TAMP1IE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2IE | (uint32_t)RTC_TAMPCR_TAMP3IE | (uint32_t)RTC_TAMPCR_TAMP1NOERASE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP3NOERASE | (uint32_t)RTC_TAMPCR_TAMP1MF |\
                                       (uint32_t)RTC_TAMPCR_TAMP2MF | (uint32_t)RTC_TAMPCR_TAMP3MF);

  hrtc->Instance->TAMPCR |= tmpreg;
 8008930:	f8d2 c000 	ldr.w	ip, [r2]
 8008934:	ea4b 0e0e 	orr.w	lr, fp, lr
 8008938:	ea4e 0707 	orr.w	r7, lr, r7
 800893c:	433e      	orrs	r6, r7
 800893e:	f8dc 7040 	ldr.w	r7, [ip, #64]	; 0x40
 8008942:	4331      	orrs	r1, r6
 8008944:	4339      	orrs	r1, r7
 8008946:	430d      	orrs	r5, r1
 8008948:	432b      	orrs	r3, r5
 800894a:	4323      	orrs	r3, r4
 800894c:	4318      	orrs	r0, r3

  hrtc->State = HAL_RTC_STATE_READY;
 800894e:	2101      	movs	r1, #1

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008950:	2300      	movs	r3, #0
                                       (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE | (uint32_t)RTC_TAMPCR_TAMP1IE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2IE | (uint32_t)RTC_TAMPCR_TAMP3IE | (uint32_t)RTC_TAMPCR_TAMP1NOERASE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP3NOERASE | (uint32_t)RTC_TAMPCR_TAMP1MF |\
                                       (uint32_t)RTC_TAMPCR_TAMP2MF | (uint32_t)RTC_TAMPCR_TAMP3MF);

  hrtc->Instance->TAMPCR |= tmpreg;
 8008952:	f8cc 0040 	str.w	r0, [ip, #64]	; 0x40

  hrtc->State = HAL_RTC_STATE_READY;
 8008956:	f882 1021 	strb.w	r1, [r2, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800895a:	f882 3020 	strb.w	r3, [r2, #32]

  return HAL_OK;
 800895e:	4618      	mov	r0, r3
 8008960:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Configure the tamper trigger */
  if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
  { 
    sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1); 
 8008964:	005d      	lsls	r5, r3, #1
 8008966:	608d      	str	r5, [r1, #8]
 8008968:	46a9      	mov	r9, r5
 800896a:	e7a8      	b.n	80088be <HAL_RTCEx_SetTamper+0x26>
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 800896c:	2002      	movs	r0, #2
 800896e:	4770      	bx	lr
 8008970:	01ffff84 	.word	0x01ffff84

08008974 <HAL_RTCEx_SetTamper_IT>:
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008974:	f890 3020 	ldrb.w	r3, [r0, #32]
 8008978:	2b01      	cmp	r3, #1
  * @param  hrtc: RTC handle
  * @param  sTamper: Pointer to RTC Tamper.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
{
 800897a:	4602      	mov	r2, r0
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 800897c:	d072      	beq.n	8008a64 <HAL_RTCEx_SetTamper_IT+0xf0>
  * @param  hrtc: RTC handle
  * @param  sTamper: Pointer to RTC Tamper.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
{
 800897e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));

  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008982:	2302      	movs	r3, #2
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008984:	2001      	movs	r0, #1
 8008986:	f882 0020 	strb.w	r0, [r2, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 800898a:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21

  /* Configure the tamper trigger */
  if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
 800898e:	688d      	ldr	r5, [r1, #8]
  {
    sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1);
 8008990:	680b      	ldr	r3, [r1, #0]
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Configure the tamper trigger */
  if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
 8008992:	2d00      	cmp	r5, #0
 8008994:	d162      	bne.n	8008a5c <HAL_RTCEx_SetTamper_IT+0xe8>
 8008996:	fa03 fc00 	lsl.w	ip, r3, r0
  {
    sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1);
  }

  if(sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)
 800899a:	68cc      	ldr	r4, [r1, #12]
 800899c:	b17c      	cbz	r4, 80089be <HAL_RTCEx_SetTamper_IT+0x4a>
  { 
    sTamper->NoErase = 0;
    if((sTamper->Tamper & RTC_TAMPER_1) != 0)
 800899e:	f013 0401 	ands.w	r4, r3, #1
    {
      sTamper->NoErase |= RTC_TAMPCR_TAMP1NOERASE;
 80089a2:	bf18      	it	ne
 80089a4:	f44f 3400 	movne.w	r4, #131072	; 0x20000
    }
    if((sTamper->Tamper & RTC_TAMPER_2) != 0)
 80089a8:	071e      	lsls	r6, r3, #28
  if(sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)
  { 
    sTamper->NoErase = 0;
    if((sTamper->Tamper & RTC_TAMPER_1) != 0)
    {
      sTamper->NoErase |= RTC_TAMPCR_TAMP1NOERASE;
 80089aa:	60cc      	str	r4, [r1, #12]
    }
    if((sTamper->Tamper & RTC_TAMPER_2) != 0)
    {
      sTamper->NoErase |= RTC_TAMPCR_TAMP2NOERASE;
 80089ac:	bf44      	itt	mi
 80089ae:	f444 1480 	orrmi.w	r4, r4, #1048576	; 0x100000
 80089b2:	60cc      	strmi	r4, [r1, #12]
    }
    if((sTamper->Tamper & RTC_TAMPER_3) != 0)
 80089b4:	0698      	lsls	r0, r3, #26
    {
      sTamper->NoErase |= RTC_TAMPCR_TAMP3NOERASE;
 80089b6:	bf44      	itt	mi
 80089b8:	f444 0400 	orrmi.w	r4, r4, #8388608	; 0x800000
 80089bc:	60cc      	strmi	r4, [r1, #12]
    }
  }

  if(sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)
 80089be:	6908      	ldr	r0, [r1, #16]
 80089c0:	b178      	cbz	r0, 80089e2 <HAL_RTCEx_SetTamper_IT+0x6e>
  {
    sTamper->MaskFlag = 0;
    if((sTamper->Tamper & RTC_TAMPER_1) != 0)
 80089c2:	f013 0001 	ands.w	r0, r3, #1
    {
      sTamper->MaskFlag |= RTC_TAMPCR_TAMP1MF;
 80089c6:	bf18      	it	ne
 80089c8:	f44f 2080 	movne.w	r0, #262144	; 0x40000
    }
    if((sTamper->Tamper & RTC_TAMPER_2) != 0)
 80089cc:	071f      	lsls	r7, r3, #28
  if(sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)
  {
    sTamper->MaskFlag = 0;
    if((sTamper->Tamper & RTC_TAMPER_1) != 0)
    {
      sTamper->MaskFlag |= RTC_TAMPCR_TAMP1MF;
 80089ce:	6108      	str	r0, [r1, #16]
    }
    if((sTamper->Tamper & RTC_TAMPER_2) != 0)
    {
      sTamper->MaskFlag |= RTC_TAMPCR_TAMP2MF;
 80089d0:	bf44      	itt	mi
 80089d2:	f440 1000 	orrmi.w	r0, r0, #2097152	; 0x200000
 80089d6:	6108      	strmi	r0, [r1, #16]
    }
    if((sTamper->Tamper & RTC_TAMPER_3) != 0)
 80089d8:	069e      	lsls	r6, r3, #26
    {
      sTamper->MaskFlag |= RTC_TAMPCR_TAMP3MF;
 80089da:	bf44      	itt	mi
 80089dc:	f040 7080 	orrmi.w	r0, r0, #16777216	; 0x1000000
 80089e0:	6108      	strmi	r0, [r1, #16]

  tmpreg = ((uint32_t)sTamper->Tamper | (uint32_t)sTamper->Interrupt | (uint32_t)sTamper->Trigger  | (uint32_t)sTamper->NoErase |\
            (uint32_t)sTamper->MaskFlag | (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency |\
            (uint32_t)sTamper->PrechargeDuration | (uint32_t)sTamper->TamperPullUp | sTamper->TimeStampOnTamperDetection);
  
  hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1) | (uint32_t)RTC_TAMPCR_TAMPTS |\
 80089e2:	f8d2 b000 	ldr.w	fp, [r2]
                                       (uint32_t)RTC_TAMPCR_TAMPFREQ | (uint32_t)RTC_TAMPCR_TAMPFLT | (uint32_t)RTC_TAMPCR_TAMPPRCH |\
                                       (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE | (uint32_t)RTC_TAMPCR_TAMP1IE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2IE | (uint32_t)RTC_TAMPCR_TAMP3IE | (uint32_t)RTC_TAMPCR_TAMP1NOERASE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP3NOERASE | (uint32_t)RTC_TAMPCR_TAMP1MF |\
                                       (uint32_t)RTC_TAMPCR_TAMP2MF | (uint32_t)RTC_TAMPCR_TAMP3MF);
 80089e6:	4e20      	ldr	r6, [pc, #128]	; (8008a68 <HAL_RTCEx_SetTamper_IT+0xf4>)

  tmpreg = ((uint32_t)sTamper->Tamper | (uint32_t)sTamper->Interrupt | (uint32_t)sTamper->Trigger  | (uint32_t)sTamper->NoErase |\
            (uint32_t)sTamper->MaskFlag | (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency |\
            (uint32_t)sTamper->PrechargeDuration | (uint32_t)sTamper->TamperPullUp | sTamper->TimeStampOnTamperDetection);
  
  hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1) | (uint32_t)RTC_TAMPCR_TAMPTS |\
 80089e8:	f8db a040 	ldr.w	sl, [fp, #64]	; 0x40
 80089ec:	698f      	ldr	r7, [r1, #24]
 80089ee:	f8d1 901c 	ldr.w	r9, [r1, #28]
 80089f2:	f8d1 8020 	ldr.w	r8, [r1, #32]
 80089f6:	ea43 0c0c 	orr.w	ip, r3, ip
                                       (uint32_t)RTC_TAMPCR_TAMPFREQ | (uint32_t)RTC_TAMPCR_TAMPFLT | (uint32_t)RTC_TAMPCR_TAMPPRCH |\
                                       (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE | (uint32_t)RTC_TAMPCR_TAMP1IE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2IE | (uint32_t)RTC_TAMPCR_TAMP3IE | (uint32_t)RTC_TAMPCR_TAMP1NOERASE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP3NOERASE | (uint32_t)RTC_TAMPCR_TAMP1MF |\
                                       (uint32_t)RTC_TAMPCR_TAMP2MF | (uint32_t)RTC_TAMPCR_TAMP3MF);
 80089fa:	ea4c 0606 	orr.w	r6, ip, r6

  tmpreg = ((uint32_t)sTamper->Tamper | (uint32_t)sTamper->Interrupt | (uint32_t)sTamper->Trigger  | (uint32_t)sTamper->NoErase |\
            (uint32_t)sTamper->MaskFlag | (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency |\
            (uint32_t)sTamper->PrechargeDuration | (uint32_t)sTamper->TamperPullUp | sTamper->TimeStampOnTamperDetection);
  
  hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1) | (uint32_t)RTC_TAMPCR_TAMPTS |\
 80089fe:	ea2a 0a06 	bic.w	sl, sl, r6
 8008a02:	694e      	ldr	r6, [r1, #20]
 8008a04:	46b6      	mov	lr, r6
 8008a06:	684e      	ldr	r6, [r1, #4]
 8008a08:	ea4e 0c06 	orr.w	ip, lr, r6
 8008a0c:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 8008a0e:	f8cb a040 	str.w	sl, [fp, #64]	; 0x40
                                       (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE | (uint32_t)RTC_TAMPCR_TAMP1IE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2IE | (uint32_t)RTC_TAMPCR_TAMP3IE | (uint32_t)RTC_TAMPCR_TAMP1NOERASE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP3NOERASE | (uint32_t)RTC_TAMPCR_TAMP1MF |\
                                       (uint32_t)RTC_TAMPCR_TAMP2MF | (uint32_t)RTC_TAMPCR_TAMP3MF);

  hrtc->Instance->TAMPCR |= tmpreg;
 8008a12:	f8d2 e000 	ldr.w	lr, [r2]

  /* RTC Tamper Interrupt Configuration: EXTI configuration */
  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
 8008a16:	4915      	ldr	r1, [pc, #84]	; (8008a6c <HAL_RTCEx_SetTamper_IT+0xf8>)
 8008a18:	ea4c 0c07 	orr.w	ip, ip, r7
 8008a1c:	ea4c 0c09 	orr.w	ip, ip, r9
                                       (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE | (uint32_t)RTC_TAMPCR_TAMP1IE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2IE | (uint32_t)RTC_TAMPCR_TAMP3IE | (uint32_t)RTC_TAMPCR_TAMP1NOERASE |\
                                       (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP3NOERASE | (uint32_t)RTC_TAMPCR_TAMP1MF |\
                                       (uint32_t)RTC_TAMPCR_TAMP2MF | (uint32_t)RTC_TAMPCR_TAMP3MF);

  hrtc->Instance->TAMPCR |= tmpreg;
 8008a20:	f8de 7040 	ldr.w	r7, [lr, #64]	; 0x40
 8008a24:	ea4c 0c08 	orr.w	ip, ip, r8
 8008a28:	ea4c 0606 	orr.w	r6, ip, r6
 8008a2c:	433e      	orrs	r6, r7
 8008a2e:	4335      	orrs	r5, r6
 8008a30:	432b      	orrs	r3, r5
 8008a32:	4323      	orrs	r3, r4
 8008a34:	4318      	orrs	r0, r3
 8008a36:	f8ce 0040 	str.w	r0, [lr, #64]	; 0x40

  /* RTC Tamper Interrupt Configuration: EXTI configuration */
  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
 8008a3a:	680b      	ldr	r3, [r1, #0]
 8008a3c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8008a40:	600b      	str	r3, [r1, #0]

  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();
 8008a42:	688b      	ldr	r3, [r1, #8]

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008a44:	2400      	movs	r4, #0
  /* RTC Tamper Interrupt Configuration: EXTI configuration */
  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();

  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();

  hrtc->State = HAL_RTC_STATE_READY;
 8008a46:	2501      	movs	r5, #1
  hrtc->Instance->TAMPCR |= tmpreg;

  /* RTC Tamper Interrupt Configuration: EXTI configuration */
  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();

  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();
 8008a48:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8008a4c:	608b      	str	r3, [r1, #8]

  hrtc->State = HAL_RTC_STATE_READY;
 8008a4e:	f882 5021 	strb.w	r5, [r2, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008a52:	f882 4020 	strb.w	r4, [r2, #32]

  return HAL_OK;
 8008a56:	4620      	mov	r0, r4
 8008a58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Configure the tamper trigger */
  if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
  {
    sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1);
 8008a5c:	005d      	lsls	r5, r3, #1
 8008a5e:	608d      	str	r5, [r1, #8]
 8008a60:	46ac      	mov	ip, r5
 8008a62:	e79a      	b.n	800899a <HAL_RTCEx_SetTamper_IT+0x26>
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008a64:	2002      	movs	r0, #2
 8008a66:	4770      	bx	lr
 8008a68:	01ffff84 	.word	0x01ffff84
 8008a6c:	40010400 	.word	0x40010400

08008a70 <HAL_RTCEx_DeactivateTamper>:
HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
{
  assert_param(IS_RTC_TAMPER(Tamper));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008a70:	f890 3020 	ldrb.w	r3, [r0, #32]
 8008a74:	2b01      	cmp	r3, #1
 8008a76:	d030      	beq.n	8008ada <HAL_RTCEx_DeactivateTamper+0x6a>
  * @param  Tamper: Selected tamper pin.
  *          This parameter can be any combination of RTC_TAMPER_1, RTC_TAMPER_2 and RTC_TAMPER_3.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
{
 8008a78:	b410      	push	{r4}
  assert_param(IS_RTC_TAMPER(Tamper));

  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008a7a:	2302      	movs	r3, #2
HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
{
  assert_param(IS_RTC_TAMPER(Tamper));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008a7c:	2401      	movs	r4, #1

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the selected Tamper pin */
  hrtc->Instance->TAMPCR &= ((uint32_t)~Tamper);
 8008a7e:	6802      	ldr	r2, [r0, #0]
HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
{
  assert_param(IS_RTC_TAMPER(Tamper));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008a80:	f880 4020 	strb.w	r4, [r0, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008a84:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21

  /* Disable the selected Tamper pin */
  hrtc->Instance->TAMPCR &= ((uint32_t)~Tamper);
 8008a88:	6c13      	ldr	r3, [r2, #64]	; 0x40

  if ((Tamper & RTC_TAMPER_1) != 0)
 8008a8a:	07cc      	lsls	r4, r1, #31
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the selected Tamper pin */
  hrtc->Instance->TAMPCR &= ((uint32_t)~Tamper);
 8008a8c:	ea23 0301 	bic.w	r3, r3, r1
 8008a90:	6413      	str	r3, [r2, #64]	; 0x40

  if ((Tamper & RTC_TAMPER_1) != 0)
 8008a92:	d506      	bpl.n	8008aa2 <HAL_RTCEx_DeactivateTamper+0x32>
  {
    /* Disable the Tamper1 interrupt */
    hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP1));
 8008a94:	6802      	ldr	r2, [r0, #0]
 8008a96:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8008a98:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008a9c:	f023 0304 	bic.w	r3, r3, #4
 8008aa0:	6413      	str	r3, [r2, #64]	; 0x40
  }
  if ((Tamper & RTC_TAMPER_2) != 0)
 8008aa2:	070a      	lsls	r2, r1, #28
 8008aa4:	d506      	bpl.n	8008ab4 <HAL_RTCEx_DeactivateTamper+0x44>
  {
    /* Disable the Tamper2 interrupt */
    hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP2));
 8008aa6:	6802      	ldr	r2, [r0, #0]
 8008aa8:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8008aaa:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8008aae:	f023 0304 	bic.w	r3, r3, #4
 8008ab2:	6413      	str	r3, [r2, #64]	; 0x40
  }
  if ((Tamper & RTC_TAMPER_3) != 0)
 8008ab4:	068b      	lsls	r3, r1, #26
 8008ab6:	d506      	bpl.n	8008ac6 <HAL_RTCEx_DeactivateTamper+0x56>
  {
    /* Disable the Tamper3 interrupt */
    hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP3));
 8008ab8:	6802      	ldr	r2, [r0, #0]
 8008aba:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8008abc:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8008ac0:	f023 0304 	bic.w	r3, r3, #4
 8008ac4:	6413      	str	r3, [r2, #64]	; 0x40
  }

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008ac6:	2300      	movs	r3, #0
  {
    /* Disable the Tamper3 interrupt */
    hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP3));
  }

  hrtc->State = HAL_RTC_STATE_READY;
 8008ac8:	2201      	movs	r2, #1
 8008aca:	f880 2021 	strb.w	r2, [r0, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008ace:	f880 3020 	strb.w	r3, [r0, #32]

  return HAL_OK;
}
 8008ad2:	f85d 4b04 	ldr.w	r4, [sp], #4
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);

  return HAL_OK;
 8008ad6:	4618      	mov	r0, r3
}
 8008ad8:	4770      	bx	lr
HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
{
  assert_param(IS_RTC_TAMPER(Tamper));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8008ada:	2002      	movs	r0, #2
 8008adc:	4770      	bx	lr
 8008ade:	bf00      	nop

08008ae0 <HAL_RTCEx_TimeStampEventCallback>:
  * @brief  TimeStamp callback. 
  * @param  hrtc: RTC handle
  * @retval None
  */
__weak void HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc)
{
 8008ae0:	4770      	bx	lr
 8008ae2:	bf00      	nop

08008ae4 <HAL_RTCEx_Tamper1EventCallback>:
  * @brief  Tamper 1 callback.
  * @param  hrtc: RTC handle
  * @retval None
  */
__weak void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc)
{
 8008ae4:	4770      	bx	lr
 8008ae6:	bf00      	nop

08008ae8 <HAL_RTCEx_Tamper2EventCallback>:
  * @brief  Tamper 2 callback. 
  * @param  hrtc: RTC handle
  * @retval None
  */
__weak void HAL_RTCEx_Tamper2EventCallback(RTC_HandleTypeDef *hrtc)
{
 8008ae8:	4770      	bx	lr
 8008aea:	bf00      	nop

08008aec <HAL_RTCEx_Tamper3EventCallback>:
  * @brief  Tamper 3 callback. 
  * @param  hrtc: RTC handle
  * @retval None
  */
__weak void HAL_RTCEx_Tamper3EventCallback(RTC_HandleTypeDef *hrtc)
{
 8008aec:	4770      	bx	lr
 8008aee:	bf00      	nop

08008af0 <HAL_RTCEx_TamperTimeStampIRQHandler>:
  * @brief  Handle TimeStamp interrupt request.
  * @param  hrtc: RTC handle
  * @retval None
  */
void HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc)
{ 
 8008af0:	b510      	push	{r4, lr}
  /* Get the TimeStamp interrupt source enable status */
  if(__HAL_RTC_TIMESTAMP_GET_IT_SOURCE(hrtc, RTC_IT_TS) != RESET)
 8008af2:	6803      	ldr	r3, [r0, #0]
 8008af4:	689a      	ldr	r2, [r3, #8]
 8008af6:	0411      	lsls	r1, r2, #16
  * @brief  Handle TimeStamp interrupt request.
  * @param  hrtc: RTC handle
  * @retval None
  */
void HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc)
{ 
 8008af8:	4604      	mov	r4, r0
  /* Get the TimeStamp interrupt source enable status */
  if(__HAL_RTC_TIMESTAMP_GET_IT_SOURCE(hrtc, RTC_IT_TS) != RESET)
 8008afa:	d502      	bpl.n	8008b02 <HAL_RTCEx_TamperTimeStampIRQHandler+0x12>
  {
    /* Get the pending status of the TIMESTAMP Interrupt */
    if(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) != RESET)
 8008afc:	68da      	ldr	r2, [r3, #12]
 8008afe:	0512      	lsls	r2, r2, #20
 8008b00:	d431      	bmi.n	8008b66 <HAL_RTCEx_TamperTimeStampIRQHandler+0x76>
      __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
    }
  }

  /* Get the Tamper1 interrupts source enable status */
  if(__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP1) != RESET)
 8008b02:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8008b04:	4a22      	ldr	r2, [pc, #136]	; (8008b90 <HAL_RTCEx_TamperTimeStampIRQHandler+0xa0>)
 8008b06:	400a      	ands	r2, r1
 8008b08:	b112      	cbz	r2, 8008b10 <HAL_RTCEx_TamperTimeStampIRQHandler+0x20>
  {
    /* Get the pending status of the Tamper1 Interrupt */
    if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) != RESET)
 8008b0a:	68da      	ldr	r2, [r3, #12]
 8008b0c:	0491      	lsls	r1, r2, #18
 8008b0e:	d434      	bmi.n	8008b7a <HAL_RTCEx_TamperTimeStampIRQHandler+0x8a>
      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
    }
  }
    
  /* Get the Tamper2 interrupts source enable status */
  if(__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP2) != RESET)
 8008b10:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8008b12:	4a20      	ldr	r2, [pc, #128]	; (8008b94 <HAL_RTCEx_TamperTimeStampIRQHandler+0xa4>)
 8008b14:	400a      	ands	r2, r1
 8008b16:	b112      	cbz	r2, 8008b1e <HAL_RTCEx_TamperTimeStampIRQHandler+0x2e>
  {
    /* Get the pending status of the Tamper2 Interrupt */
    if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) != RESET)
 8008b18:	68da      	ldr	r2, [r3, #12]
 8008b1a:	0452      	lsls	r2, r2, #17
 8008b1c:	d418      	bmi.n	8008b50 <HAL_RTCEx_TamperTimeStampIRQHandler+0x60>
      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
    }
  }

  /* Get the Tamper3 interrupts source enable status */
  if(__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP3) != RESET)
 8008b1e:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8008b20:	4a1d      	ldr	r2, [pc, #116]	; (8008b98 <HAL_RTCEx_TamperTimeStampIRQHandler+0xa8>)
 8008b22:	400a      	ands	r2, r1
 8008b24:	b112      	cbz	r2, 8008b2c <HAL_RTCEx_TamperTimeStampIRQHandler+0x3c>
  {
    /* Get the pending status of the Tamper3 Interrupt */
    if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) != RESET)
 8008b26:	68db      	ldr	r3, [r3, #12]
 8008b28:	041b      	lsls	r3, r3, #16
 8008b2a:	d407      	bmi.n	8008b3c <HAL_RTCEx_TamperTimeStampIRQHandler+0x4c>
      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);
    }
  }
  
  /* Clear the EXTI's Flag for RTC TimeStamp and Tamper */
  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG();
 8008b2c:	4a1b      	ldr	r2, [pc, #108]	; (8008b9c <HAL_RTCEx_TamperTimeStampIRQHandler+0xac>)
 8008b2e:	f44f 2100 	mov.w	r1, #524288	; 0x80000

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008b32:	2301      	movs	r3, #1
      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);
    }
  }
  
  /* Clear the EXTI's Flag for RTC TimeStamp and Tamper */
  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG();
 8008b34:	6151      	str	r1, [r2, #20]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008b36:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
 8008b3a:	bd10      	pop	{r4, pc}
  {
    /* Get the pending status of the Tamper3 Interrupt */
    if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) != RESET)
    {
      /* Tamper3 callback */
      HAL_RTCEx_Tamper3EventCallback(hrtc);
 8008b3c:	4620      	mov	r0, r4
 8008b3e:	f7ff ffd5 	bl	8008aec <HAL_RTCEx_Tamper3EventCallback>

      /* Clear the Tamper3 interrupt pending bit */
      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);
 8008b42:	6821      	ldr	r1, [r4, #0]
 8008b44:	4b16      	ldr	r3, [pc, #88]	; (8008ba0 <HAL_RTCEx_TamperTimeStampIRQHandler+0xb0>)
 8008b46:	68ca      	ldr	r2, [r1, #12]
 8008b48:	b2d2      	uxtb	r2, r2
 8008b4a:	4313      	orrs	r3, r2
 8008b4c:	60cb      	str	r3, [r1, #12]
 8008b4e:	e7ed      	b.n	8008b2c <HAL_RTCEx_TamperTimeStampIRQHandler+0x3c>
  {
    /* Get the pending status of the Tamper2 Interrupt */
    if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) != RESET)
    {
      /* Tamper2 callback */
      HAL_RTCEx_Tamper2EventCallback(hrtc);
 8008b50:	4620      	mov	r0, r4
 8008b52:	f7ff ffc9 	bl	8008ae8 <HAL_RTCEx_Tamper2EventCallback>

      /* Clear the Tamper2 interrupt pending bit */
      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
 8008b56:	6822      	ldr	r2, [r4, #0]
 8008b58:	68d3      	ldr	r3, [r2, #12]
 8008b5a:	b2db      	uxtb	r3, r3
 8008b5c:	f463 4381 	orn	r3, r3, #16512	; 0x4080
 8008b60:	60d3      	str	r3, [r2, #12]
 8008b62:	6823      	ldr	r3, [r4, #0]
 8008b64:	e7db      	b.n	8008b1e <HAL_RTCEx_TamperTimeStampIRQHandler+0x2e>
  {
    /* Get the pending status of the TIMESTAMP Interrupt */
    if(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) != RESET)
    {
      /* TIMESTAMP callback */ 
      HAL_RTCEx_TimeStampEventCallback(hrtc);
 8008b66:	f7ff ffbb 	bl	8008ae0 <HAL_RTCEx_TimeStampEventCallback>
      
      /* Clear the TIMESTAMP interrupt pending bit */
      __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
 8008b6a:	6822      	ldr	r2, [r4, #0]
 8008b6c:	68d3      	ldr	r3, [r2, #12]
 8008b6e:	b2db      	uxtb	r3, r3
 8008b70:	f463 6308 	orn	r3, r3, #2176	; 0x880
 8008b74:	60d3      	str	r3, [r2, #12]
 8008b76:	6823      	ldr	r3, [r4, #0]
 8008b78:	e7c3      	b.n	8008b02 <HAL_RTCEx_TamperTimeStampIRQHandler+0x12>
  {
    /* Get the pending status of the Tamper1 Interrupt */
    if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) != RESET)
    {
      /* Tamper1 callback */
      HAL_RTCEx_Tamper1EventCallback(hrtc);
 8008b7a:	4620      	mov	r0, r4
 8008b7c:	f7ff ffb2 	bl	8008ae4 <HAL_RTCEx_Tamper1EventCallback>

      /* Clear the Tamper1 interrupt pending bit */
      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
 8008b80:	6822      	ldr	r2, [r4, #0]
 8008b82:	68d3      	ldr	r3, [r2, #12]
 8008b84:	b2db      	uxtb	r3, r3
 8008b86:	f463 5302 	orn	r3, r3, #8320	; 0x2080
 8008b8a:	60d3      	str	r3, [r2, #12]
 8008b8c:	6823      	ldr	r3, [r4, #0]
 8008b8e:	e7bf      	b.n	8008b10 <HAL_RTCEx_TamperTimeStampIRQHandler+0x20>
 8008b90:	00010004 	.word	0x00010004
 8008b94:	00080004 	.word	0x00080004
 8008b98:	00400004 	.word	0x00400004
 8008b9c:	40010400 	.word	0x40010400
 8008ba0:	ffff7f7f 	.word	0xffff7f7f

08008ba4 <HAL_RTCEx_PollForTimeStampEvent>:
  * @param  hrtc: RTC handle
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{ 
 8008ba4:	b570      	push	{r4, r5, r6, lr}
 8008ba6:	4605      	mov	r5, r0
 8008ba8:	460c      	mov	r4, r1
  uint32_t tickstart = HAL_GetTick();
 8008baa:	f7f7 ffad 	bl	8000b08 <HAL_GetTick>
 8008bae:	4606      	mov	r6, r0
 8008bb0:	682b      	ldr	r3, [r5, #0]
 8008bb2:	e004      	b.n	8008bbe <HAL_RTCEx_PollForTimeStampEvent+0x1a>

  while(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) == RESET)
  {
    if(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSOVF) != RESET)
 8008bb4:	68da      	ldr	r2, [r3, #12]
 8008bb6:	04d0      	lsls	r0, r2, #19
 8008bb8:	d409      	bmi.n	8008bce <HAL_RTCEx_PollForTimeStampEvent+0x2a>
      hrtc->State = HAL_RTC_STATE_ERROR; 

      return HAL_ERROR; 
    }

    if(Timeout != HAL_MAX_DELAY)
 8008bba:	1c61      	adds	r1, r4, #1
 8008bbc:	d111      	bne.n	8008be2 <HAL_RTCEx_PollForTimeStampEvent+0x3e>
  */
HAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{ 
  uint32_t tickstart = HAL_GetTick();

  while(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) == RESET)
 8008bbe:	68da      	ldr	r2, [r3, #12]
 8008bc0:	0512      	lsls	r2, r2, #20
 8008bc2:	d5f7      	bpl.n	8008bb4 <HAL_RTCEx_PollForTimeStampEvent+0x10>
      }
    }
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008bc4:	2301      	movs	r3, #1
 8008bc6:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
  
  return HAL_OK;
 8008bca:	2000      	movs	r0, #0
}
 8008bcc:	bd70      	pop	{r4, r5, r6, pc}
  while(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) == RESET)
  {
    if(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSOVF) != RESET)
    {
      /* Clear the TIMESTAMP OverRun Flag */
      __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);
 8008bce:	68da      	ldr	r2, [r3, #12]
 8008bd0:	b2d2      	uxtb	r2, r2
 8008bd2:	f462 5284 	orn	r2, r2, #4224	; 0x1080

      /* Change TIMESTAMP state */
      hrtc->State = HAL_RTC_STATE_ERROR; 
 8008bd6:	2104      	movs	r1, #4
  while(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) == RESET)
  {
    if(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSOVF) != RESET)
    {
      /* Clear the TIMESTAMP OverRun Flag */
      __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);
 8008bd8:	60da      	str	r2, [r3, #12]

      /* Change TIMESTAMP state */
      hrtc->State = HAL_RTC_STATE_ERROR; 
 8008bda:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

      return HAL_ERROR; 
 8008bde:	2001      	movs	r0, #1
 8008be0:	bd70      	pop	{r4, r5, r6, pc}
    }

    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8008be2:	b124      	cbz	r4, 8008bee <HAL_RTCEx_PollForTimeStampEvent+0x4a>
 8008be4:	f7f7 ff90 	bl	8000b08 <HAL_GetTick>
 8008be8:	1b80      	subs	r0, r0, r6
 8008bea:	4284      	cmp	r4, r0
 8008bec:	d2e0      	bcs.n	8008bb0 <HAL_RTCEx_PollForTimeStampEvent+0xc>
      {
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008bee:	2003      	movs	r0, #3
 8008bf0:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21
        return HAL_TIMEOUT;
 8008bf4:	bd70      	pop	{r4, r5, r6, pc}
 8008bf6:	bf00      	nop

08008bf8 <HAL_RTCEx_PollForTamper1Event>:
  * @param  hrtc: RTC handle
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{
 8008bf8:	b570      	push	{r4, r5, r6, lr}
 8008bfa:	4605      	mov	r5, r0
 8008bfc:	460c      	mov	r4, r1
  uint32_t tickstart = HAL_GetTick();
 8008bfe:	f7f7 ff83 	bl	8000b08 <HAL_GetTick>
 8008c02:	4606      	mov	r6, r0
 8008c04:	682a      	ldr	r2, [r5, #0]
 8008c06:	e001      	b.n	8008c0c <HAL_RTCEx_PollForTamper1Event+0x14>

  /* Get the status of the Interrupt */
  while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F)== RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
 8008c08:	1c61      	adds	r1, r4, #1
 8008c0a:	d10c      	bne.n	8008c26 <HAL_RTCEx_PollForTamper1Event+0x2e>
HAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{
  uint32_t tickstart = HAL_GetTick();

  /* Get the status of the Interrupt */
  while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F)== RESET)
 8008c0c:	68d3      	ldr	r3, [r2, #12]
 8008c0e:	049b      	lsls	r3, r3, #18
 8008c10:	d5fa      	bpl.n	8008c08 <HAL_RTCEx_PollForTamper1Event+0x10>
      }
    }
  }

  /* Clear the Tamper Flag */
  __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
 8008c12:	68d3      	ldr	r3, [r2, #12]
 8008c14:	b2db      	uxtb	r3, r3
 8008c16:	f463 5302 	orn	r3, r3, #8320	; 0x2080
  
  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008c1a:	2101      	movs	r1, #1
      }
    }
  }

  /* Clear the Tamper Flag */
  __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
 8008c1c:	60d3      	str	r3, [r2, #12]
  
  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008c1e:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
  
  return HAL_OK; 
 8008c22:	2000      	movs	r0, #0
}
 8008c24:	bd70      	pop	{r4, r5, r6, pc}
  /* Get the status of the Interrupt */
  while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F)== RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8008c26:	b124      	cbz	r4, 8008c32 <HAL_RTCEx_PollForTamper1Event+0x3a>
 8008c28:	f7f7 ff6e 	bl	8000b08 <HAL_GetTick>
 8008c2c:	1b80      	subs	r0, r0, r6
 8008c2e:	4284      	cmp	r4, r0
 8008c30:	d2e8      	bcs.n	8008c04 <HAL_RTCEx_PollForTamper1Event+0xc>
      {
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008c32:	2003      	movs	r0, #3
 8008c34:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21
        return HAL_TIMEOUT;
 8008c38:	bd70      	pop	{r4, r5, r6, pc}
 8008c3a:	bf00      	nop

08008c3c <HAL_RTCEx_PollForTamper2Event>:
  * @param  hrtc: RTC handle
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{
 8008c3c:	b570      	push	{r4, r5, r6, lr}
 8008c3e:	4605      	mov	r5, r0
 8008c40:	460c      	mov	r4, r1
  uint32_t tickstart = HAL_GetTick();
 8008c42:	f7f7 ff61 	bl	8000b08 <HAL_GetTick>
 8008c46:	4606      	mov	r6, r0
 8008c48:	682a      	ldr	r2, [r5, #0]
 8008c4a:	e001      	b.n	8008c50 <HAL_RTCEx_PollForTamper2Event+0x14>

  /* Get the status of the Interrupt */
  while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) == RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
 8008c4c:	1c61      	adds	r1, r4, #1
 8008c4e:	d10c      	bne.n	8008c6a <HAL_RTCEx_PollForTamper2Event+0x2e>
HAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{
  uint32_t tickstart = HAL_GetTick();

  /* Get the status of the Interrupt */
  while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) == RESET)
 8008c50:	68d3      	ldr	r3, [r2, #12]
 8008c52:	045b      	lsls	r3, r3, #17
 8008c54:	d5fa      	bpl.n	8008c4c <HAL_RTCEx_PollForTamper2Event+0x10>
      }
    }
  }

  /* Clear the Tamper Flag */
  __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
 8008c56:	68d3      	ldr	r3, [r2, #12]
 8008c58:	b2db      	uxtb	r3, r3
 8008c5a:	f463 4381 	orn	r3, r3, #16512	; 0x4080

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008c5e:	2101      	movs	r1, #1
      }
    }
  }

  /* Clear the Tamper Flag */
  __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
 8008c60:	60d3      	str	r3, [r2, #12]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008c62:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

  return HAL_OK;
 8008c66:	2000      	movs	r0, #0
}
 8008c68:	bd70      	pop	{r4, r5, r6, pc}
  /* Get the status of the Interrupt */
  while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) == RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8008c6a:	b124      	cbz	r4, 8008c76 <HAL_RTCEx_PollForTamper2Event+0x3a>
 8008c6c:	f7f7 ff4c 	bl	8000b08 <HAL_GetTick>
 8008c70:	1b80      	subs	r0, r0, r6
 8008c72:	4284      	cmp	r4, r0
 8008c74:	d2e8      	bcs.n	8008c48 <HAL_RTCEx_PollForTamper2Event+0xc>
      {
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008c76:	2003      	movs	r0, #3
 8008c78:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21
        return HAL_TIMEOUT;
 8008c7c:	bd70      	pop	{r4, r5, r6, pc}
 8008c7e:	bf00      	nop

08008c80 <HAL_RTCEx_PollForTamper3Event>:
  * @param  hrtc: RTC handle
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_PollForTamper3Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{
 8008c80:	b570      	push	{r4, r5, r6, lr}
 8008c82:	4605      	mov	r5, r0
 8008c84:	460c      	mov	r4, r1
  uint32_t tickstart = HAL_GetTick();
 8008c86:	f7f7 ff3f 	bl	8000b08 <HAL_GetTick>
 8008c8a:	4606      	mov	r6, r0
 8008c8c:	682a      	ldr	r2, [r5, #0]
 8008c8e:	e001      	b.n	8008c94 <HAL_RTCEx_PollForTamper3Event+0x14>

  /* Get the status of the Interrupt */
  while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) == RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
 8008c90:	1c61      	adds	r1, r4, #1
 8008c92:	d10c      	bne.n	8008cae <HAL_RTCEx_PollForTamper3Event+0x2e>
HAL_StatusTypeDef HAL_RTCEx_PollForTamper3Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{
  uint32_t tickstart = HAL_GetTick();

  /* Get the status of the Interrupt */
  while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) == RESET)
 8008c94:	68d3      	ldr	r3, [r2, #12]
 8008c96:	041b      	lsls	r3, r3, #16
 8008c98:	d5fa      	bpl.n	8008c90 <HAL_RTCEx_PollForTamper3Event+0x10>
      }
    }
  }

  /* Clear the Tamper Flag */
  __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);
 8008c9a:	68d1      	ldr	r1, [r2, #12]
 8008c9c:	4b09      	ldr	r3, [pc, #36]	; (8008cc4 <HAL_RTCEx_PollForTamper3Event+0x44>)
 8008c9e:	b2c9      	uxtb	r1, r1
 8008ca0:	430b      	orrs	r3, r1

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008ca2:	2101      	movs	r1, #1
      }
    }
  }

  /* Clear the Tamper Flag */
  __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);
 8008ca4:	60d3      	str	r3, [r2, #12]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008ca6:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

  return HAL_OK;
 8008caa:	2000      	movs	r0, #0
}
 8008cac:	bd70      	pop	{r4, r5, r6, pc}
  /* Get the status of the Interrupt */
  while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) == RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8008cae:	b124      	cbz	r4, 8008cba <HAL_RTCEx_PollForTamper3Event+0x3a>
 8008cb0:	f7f7 ff2a 	bl	8000b08 <HAL_GetTick>
 8008cb4:	1b80      	subs	r0, r0, r6
 8008cb6:	4284      	cmp	r4, r0
 8008cb8:	d2e8      	bcs.n	8008c8c <HAL_RTCEx_PollForTamper3Event+0xc>
      {
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008cba:	2003      	movs	r0, #3
 8008cbc:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21
        return HAL_TIMEOUT;
 8008cc0:	bd70      	pop	{r4, r5, r6, pc}
 8008cc2:	bf00      	nop
 8008cc4:	ffff7f7f 	.word	0xffff7f7f

08008cc8 <HAL_RTCEx_SetWakeUpTimer>:
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008cc8:	f890 3020 	ldrb.w	r3, [r0, #32]
 8008ccc:	2b01      	cmp	r3, #1
 8008cce:	d051      	beq.n	8008d74 <HAL_RTCEx_SetWakeUpTimer+0xac>
  * @param  WakeUpCounter: Wake up counter
  * @param  WakeUpClock: Wake up clock
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
{
 8008cd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008cd4:	4605      	mov	r5, r0
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008cd6:	6803      	ldr	r3, [r0, #0]
 8008cd8:	4617      	mov	r7, r2
 8008cda:	460e      	mov	r6, r1
 8008cdc:	22ca      	movs	r2, #202	; 0xca
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008cde:	2102      	movs	r1, #2
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008ce0:	2001      	movs	r0, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008ce2:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008ce6:	f885 0020 	strb.w	r0, [r5, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008cea:	625a      	str	r2, [r3, #36]	; 0x24
 8008cec:	682b      	ldr	r3, [r5, #0]
 8008cee:	2253      	movs	r2, #83	; 0x53
 8008cf0:	625a      	str	r2, [r3, #36]	; 0x24

  /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
  if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
 8008cf2:	682b      	ldr	r3, [r5, #0]
 8008cf4:	689a      	ldr	r2, [r3, #8]
 8008cf6:	0551      	lsls	r1, r2, #21
 8008cf8:	d50d      	bpl.n	8008d16 <HAL_RTCEx_SetWakeUpTimer+0x4e>
  {
    tickstart = HAL_GetTick();
 8008cfa:	f7f7 ff05 	bl	8000b08 <HAL_GetTick>
 8008cfe:	4604      	mov	r4, r0

    /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
 8008d00:	e005      	b.n	8008d0e <HAL_RTCEx_SetWakeUpTimer+0x46>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8008d02:	f7f7 ff01 	bl	8000b08 <HAL_GetTick>
 8008d06:	1b00      	subs	r0, r0, r4
 8008d08:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8008d0c:	d83f      	bhi.n	8008d8e <HAL_RTCEx_SetWakeUpTimer+0xc6>
  if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
  {
    tickstart = HAL_GetTick();

    /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
 8008d0e:	682b      	ldr	r3, [r5, #0]
 8008d10:	68da      	ldr	r2, [r3, #12]
 8008d12:	0752      	lsls	r2, r2, #29
 8008d14:	d4f5      	bmi.n	8008d02 <HAL_RTCEx_SetWakeUpTimer+0x3a>
        return HAL_TIMEOUT;
      }
    }
  }

  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
 8008d16:	689a      	ldr	r2, [r3, #8]
 8008d18:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8008d1c:	609a      	str	r2, [r3, #8]

  tickstart = HAL_GetTick();
 8008d1e:	f7f7 fef3 	bl	8000b08 <HAL_GetTick>
 8008d22:	4680      	mov	r8, r0

  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8008d24:	e006      	b.n	8008d34 <HAL_RTCEx_SetWakeUpTimer+0x6c>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8008d26:	f7f7 feef 	bl	8000b08 <HAL_GetTick>
 8008d2a:	ebc8 0000 	rsb	r0, r8, r0
 8008d2e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8008d32:	d821      	bhi.n	8008d78 <HAL_RTCEx_SetWakeUpTimer+0xb0>
  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);

  tickstart = HAL_GetTick();

  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8008d34:	6828      	ldr	r0, [r5, #0]
 8008d36:	68c3      	ldr	r3, [r0, #12]
 8008d38:	f013 0404 	ands.w	r4, r3, #4
 8008d3c:	d0f3      	beq.n	8008d26 <HAL_RTCEx_SetWakeUpTimer+0x5e>
      return HAL_TIMEOUT;
    }
  }

  /* Clear the Wakeup Timer clock source bits in CR register */
  hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 8008d3e:	6883      	ldr	r3, [r0, #8]
 8008d40:	f023 0307 	bic.w	r3, r3, #7
 8008d44:	6083      	str	r3, [r0, #8]

  /* Configure the clock source */
  hrtc->Instance->CR |= (uint32_t)WakeUpClock;
 8008d46:	682a      	ldr	r2, [r5, #0]
 8008d48:	6893      	ldr	r3, [r2, #8]
 8008d4a:	431f      	orrs	r7, r3
 8008d4c:	6097      	str	r7, [r2, #8]

  /* Configure the Wakeup Timer counter */
  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
 8008d4e:	682b      	ldr	r3, [r5, #0]
 8008d50:	615e      	str	r6, [r3, #20]

   /* Enable the Wakeup Timer */
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
 8008d52:	682a      	ldr	r2, [r5, #0]
 8008d54:	6893      	ldr	r3, [r2, #8]
 8008d56:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008d5a:	6093      	str	r3, [r2, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008d5c:	6829      	ldr	r1, [r5, #0]

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008d5e:	2300      	movs	r3, #0

   /* Enable the Wakeup Timer */
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008d60:	20ff      	movs	r0, #255	; 0xff

  hrtc->State = HAL_RTC_STATE_READY;
 8008d62:	2201      	movs	r2, #1

   /* Enable the Wakeup Timer */
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008d64:	6248      	str	r0, [r1, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8008d66:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008d6a:	f885 3020 	strb.w	r3, [r5, #32]

  return HAL_OK;
 8008d6e:	4618      	mov	r0, r3
 8008d70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008d74:	2002      	movs	r0, #2
 8008d76:	4770      	bx	lr
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008d78:	682a      	ldr	r2, [r5, #0]

      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008d7a:	2303      	movs	r3, #3
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008d7c:	21ff      	movs	r1, #255	; 0xff
 8008d7e:	6251      	str	r1, [r2, #36]	; 0x24

      hrtc->State = HAL_RTC_STATE_TIMEOUT;

      /* Process Unlocked */ 
      __HAL_UNLOCK(hrtc);
 8008d80:	f885 4020 	strb.w	r4, [r5, #32]
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008d84:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21

      /* Process Unlocked */ 
      __HAL_UNLOCK(hrtc);

      return HAL_TIMEOUT;
 8008d88:	4618      	mov	r0, r3
 8008d8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008d8e:	6829      	ldr	r1, [r5, #0]

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008d90:	2303      	movs	r3, #3
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008d92:	20ff      	movs	r0, #255	; 0xff

        hrtc->State = HAL_RTC_STATE_TIMEOUT;

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);
 8008d94:	2200      	movs	r2, #0
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008d96:	6248      	str	r0, [r1, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008d98:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);
 8008d9c:	f885 2020 	strb.w	r2, [r5, #32]

        return HAL_TIMEOUT;
 8008da0:	4618      	mov	r0, r3
 8008da2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008da6:	bf00      	nop

08008da8 <HAL_RTCEx_SetWakeUpTimer_IT>:
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008da8:	f890 3020 	ldrb.w	r3, [r0, #32]
 8008dac:	2b01      	cmp	r3, #1
 8008dae:	d05f      	beq.n	8008e70 <HAL_RTCEx_SetWakeUpTimer_IT+0xc8>
  * @param  WakeUpCounter: Wake up counter
  * @param  WakeUpClock: Wake up clock  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
{
 8008db0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008db4:	4605      	mov	r5, r0
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008db6:	6803      	ldr	r3, [r0, #0]
 8008db8:	4616      	mov	r6, r2
 8008dba:	460f      	mov	r7, r1
 8008dbc:	22ca      	movs	r2, #202	; 0xca
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008dbe:	2102      	movs	r1, #2
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008dc0:	2001      	movs	r0, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008dc2:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008dc6:	f885 0020 	strb.w	r0, [r5, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008dca:	625a      	str	r2, [r3, #36]	; 0x24
 8008dcc:	682b      	ldr	r3, [r5, #0]
 8008dce:	2253      	movs	r2, #83	; 0x53
 8008dd0:	625a      	str	r2, [r3, #36]	; 0x24

  /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
  if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
 8008dd2:	682b      	ldr	r3, [r5, #0]
 8008dd4:	689a      	ldr	r2, [r3, #8]
 8008dd6:	0551      	lsls	r1, r2, #21
 8008dd8:	d50d      	bpl.n	8008df6 <HAL_RTCEx_SetWakeUpTimer_IT+0x4e>
  {
    tickstart = HAL_GetTick();
 8008dda:	f7f7 fe95 	bl	8000b08 <HAL_GetTick>
 8008dde:	4604      	mov	r4, r0

    /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
 8008de0:	e005      	b.n	8008dee <HAL_RTCEx_SetWakeUpTimer_IT+0x46>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8008de2:	f7f7 fe91 	bl	8000b08 <HAL_GetTick>
 8008de6:	1b00      	subs	r0, r0, r4
 8008de8:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8008dec:	d84d      	bhi.n	8008e8a <HAL_RTCEx_SetWakeUpTimer_IT+0xe2>
  if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
  {
    tickstart = HAL_GetTick();

    /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
 8008dee:	682b      	ldr	r3, [r5, #0]
 8008df0:	68da      	ldr	r2, [r3, #12]
 8008df2:	0752      	lsls	r2, r2, #29
 8008df4:	d4f5      	bmi.n	8008de2 <HAL_RTCEx_SetWakeUpTimer_IT+0x3a>
        return HAL_TIMEOUT;
      }
    }
  }

  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
 8008df6:	689a      	ldr	r2, [r3, #8]
 8008df8:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8008dfc:	609a      	str	r2, [r3, #8]

  tickstart = HAL_GetTick();
 8008dfe:	f7f7 fe83 	bl	8000b08 <HAL_GetTick>
 8008e02:	4680      	mov	r8, r0

  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8008e04:	e006      	b.n	8008e14 <HAL_RTCEx_SetWakeUpTimer_IT+0x6c>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8008e06:	f7f7 fe7f 	bl	8000b08 <HAL_GetTick>
 8008e0a:	ebc8 0000 	rsb	r0, r8, r0
 8008e0e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8008e12:	d82f      	bhi.n	8008e74 <HAL_RTCEx_SetWakeUpTimer_IT+0xcc>
  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);

  tickstart = HAL_GetTick();

  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8008e14:	6828      	ldr	r0, [r5, #0]
 8008e16:	68c3      	ldr	r3, [r0, #12]
 8008e18:	f013 0404 	ands.w	r4, r3, #4
 8008e1c:	d0f3      	beq.n	8008e06 <HAL_RTCEx_SetWakeUpTimer_IT+0x5e>
      return HAL_TIMEOUT;
    }
  }

  /* Configure the Wakeup Timer counter */
  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
 8008e1e:	6147      	str	r7, [r0, #20]

  /* Clear the Wakeup Timer clock source bits in CR register */
  hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 8008e20:	6829      	ldr	r1, [r5, #0]

  /* Configure the clock source */
  hrtc->Instance->CR |= (uint32_t)WakeUpClock;

  /* RTC WakeUpTimer Interrupt Configuration: EXTI configuration */
  __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
 8008e22:	4b20      	ldr	r3, [pc, #128]	; (8008ea4 <HAL_RTCEx_SetWakeUpTimer_IT+0xfc>)

  /* Configure the Wakeup Timer counter */
  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;

  /* Clear the Wakeup Timer clock source bits in CR register */
  hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 8008e24:	688a      	ldr	r2, [r1, #8]
 8008e26:	f022 0207 	bic.w	r2, r2, #7
 8008e2a:	608a      	str	r2, [r1, #8]

  /* Configure the clock source */
  hrtc->Instance->CR |= (uint32_t)WakeUpClock;
 8008e2c:	6829      	ldr	r1, [r5, #0]
 8008e2e:	688a      	ldr	r2, [r1, #8]
 8008e30:	4316      	orrs	r6, r2
 8008e32:	608e      	str	r6, [r1, #8]

  /* RTC WakeUpTimer Interrupt Configuration: EXTI configuration */
  __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
 8008e34:	681a      	ldr	r2, [r3, #0]
 8008e36:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8008e3a:	601a      	str	r2, [r3, #0]

  __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();
 8008e3c:	689a      	ldr	r2, [r3, #8]
 8008e3e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8008e42:	609a      	str	r2, [r3, #8]

  /* Configure the Interrupt in the RTC_CR register */
  __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc,RTC_IT_WUT);
 8008e44:	682a      	ldr	r2, [r5, #0]
 8008e46:	6893      	ldr	r3, [r2, #8]
 8008e48:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8008e4c:	6093      	str	r3, [r2, #8]
  
  /* Enable the Wakeup Timer */
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
 8008e4e:	682a      	ldr	r2, [r5, #0]
 8008e50:	6893      	ldr	r3, [r2, #8]
 8008e52:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008e56:	6093      	str	r3, [r2, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008e58:	6829      	ldr	r1, [r5, #0]

  hrtc->State = HAL_RTC_STATE_READY; 

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008e5a:	2300      	movs	r3, #0
  
  /* Enable the Wakeup Timer */
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008e5c:	20ff      	movs	r0, #255	; 0xff

  hrtc->State = HAL_RTC_STATE_READY; 
 8008e5e:	2201      	movs	r2, #1
  
  /* Enable the Wakeup Timer */
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008e60:	6248      	str	r0, [r1, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY; 
 8008e62:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008e66:	f885 3020 	strb.w	r3, [r5, #32]

  return HAL_OK;
 8008e6a:	4618      	mov	r0, r3
 8008e6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008e70:	2002      	movs	r0, #2
 8008e72:	4770      	bx	lr
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008e74:	682a      	ldr	r2, [r5, #0]

      hrtc->State = HAL_RTC_STATE_TIMEOUT; 
 8008e76:	2303      	movs	r3, #3
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008e78:	21ff      	movs	r1, #255	; 0xff
 8008e7a:	6251      	str	r1, [r2, #36]	; 0x24

      hrtc->State = HAL_RTC_STATE_TIMEOUT; 

      /* Process Unlocked */ 
      __HAL_UNLOCK(hrtc);
 8008e7c:	f885 4020 	strb.w	r4, [r5, #32]
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

      hrtc->State = HAL_RTC_STATE_TIMEOUT; 
 8008e80:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21

      /* Process Unlocked */ 
      __HAL_UNLOCK(hrtc);

      return HAL_TIMEOUT;
 8008e84:	4618      	mov	r0, r3
 8008e86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008e8a:	6829      	ldr	r1, [r5, #0]

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008e8c:	2303      	movs	r3, #3
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008e8e:	20ff      	movs	r0, #255	; 0xff

        hrtc->State = HAL_RTC_STATE_TIMEOUT;

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);
 8008e90:	2200      	movs	r2, #0
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008e92:	6248      	str	r0, [r1, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008e94:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);
 8008e98:	f885 2020 	strb.w	r2, [r5, #32]

        return HAL_TIMEOUT;
 8008e9c:	4618      	mov	r0, r3
 8008e9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008ea2:	bf00      	nop
 8008ea4:	40010400 	.word	0x40010400

08008ea8 <HAL_RTCEx_DeactivateWakeUpTimer>:
uint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
{
  uint32_t tickstart = 0;

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008ea8:	f890 3020 	ldrb.w	r3, [r0, #32]
 8008eac:	2b01      	cmp	r3, #1
 8008eae:	d101      	bne.n	8008eb4 <HAL_RTCEx_DeactivateWakeUpTimer+0xc>
 8008eb0:	2002      	movs	r0, #2
 8008eb2:	4770      	bx	lr
  * @brief  Deactivate wake up timer counter.
  * @param  hrtc: RTC handle 
  * @retval HAL status
  */
uint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
{
 8008eb4:	b570      	push	{r4, r5, r6, lr}
 8008eb6:	4605      	mov	r5, r0
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008eb8:	6803      	ldr	r3, [r0, #0]
  uint32_t tickstart = 0;

  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008eba:	2102      	movs	r1, #2
uint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
{
  uint32_t tickstart = 0;

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008ebc:	2001      	movs	r0, #1

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008ebe:	22ca      	movs	r2, #202	; 0xca
uint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
{
  uint32_t tickstart = 0;

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008ec0:	f885 0020 	strb.w	r0, [r5, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008ec4:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008ec8:	625a      	str	r2, [r3, #36]	; 0x24
 8008eca:	682b      	ldr	r3, [r5, #0]
 8008ecc:	2253      	movs	r2, #83	; 0x53
 8008ece:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable the Wakeup Timer */
  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
 8008ed0:	682a      	ldr	r2, [r5, #0]
 8008ed2:	6893      	ldr	r3, [r2, #8]
 8008ed4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008ed8:	6093      	str	r3, [r2, #8]

  /* In case of interrupt mode is used, the interrupt source must disabled */
  __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc,RTC_IT_WUT);
 8008eda:	682a      	ldr	r2, [r5, #0]
 8008edc:	6893      	ldr	r3, [r2, #8]
 8008ede:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8008ee2:	6093      	str	r3, [r2, #8]

  tickstart = HAL_GetTick();
 8008ee4:	f7f7 fe10 	bl	8000b08 <HAL_GetTick>
 8008ee8:	4606      	mov	r6, r0
  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8008eea:	e005      	b.n	8008ef8 <HAL_RTCEx_DeactivateWakeUpTimer+0x50>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8008eec:	f7f7 fe0c 	bl	8000b08 <HAL_GetTick>
 8008ef0:	1b80      	subs	r0, r0, r6
 8008ef2:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8008ef6:	d80e      	bhi.n	8008f16 <HAL_RTCEx_DeactivateWakeUpTimer+0x6e>
  /* In case of interrupt mode is used, the interrupt source must disabled */
  __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc,RTC_IT_WUT);

  tickstart = HAL_GetTick();
  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8008ef8:	682a      	ldr	r2, [r5, #0]
 8008efa:	68d3      	ldr	r3, [r2, #12]
 8008efc:	f013 0404 	ands.w	r4, r3, #4
 8008f00:	d0f4      	beq.n	8008eec <HAL_RTCEx_DeactivateWakeUpTimer+0x44>
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008f02:	2300      	movs	r3, #0
      return HAL_TIMEOUT;
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008f04:	20ff      	movs	r0, #255	; 0xff

  hrtc->State = HAL_RTC_STATE_READY;
 8008f06:	2101      	movs	r1, #1
      return HAL_TIMEOUT;
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008f08:	6250      	str	r0, [r2, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8008f0a:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8008f0e:	f885 3020 	strb.w	r3, [r5, #32]

  return HAL_OK;
 8008f12:	4618      	mov	r0, r3
 8008f14:	bd70      	pop	{r4, r5, r6, pc}
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008f16:	682a      	ldr	r2, [r5, #0]

      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008f18:	2303      	movs	r3, #3
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008f1a:	21ff      	movs	r1, #255	; 0xff
 8008f1c:	6251      	str	r1, [r2, #36]	; 0x24

      hrtc->State = HAL_RTC_STATE_TIMEOUT;

      /* Process Unlocked */
      __HAL_UNLOCK(hrtc);
 8008f1e:	f885 4020 	strb.w	r4, [r5, #32]
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008f22:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21

      /* Process Unlocked */
      __HAL_UNLOCK(hrtc);

      return HAL_TIMEOUT;
 8008f26:	4618      	mov	r0, r3
 8008f28:	bd70      	pop	{r4, r5, r6, pc}
 8008f2a:	bf00      	nop

08008f2c <HAL_RTCEx_GetWakeUpTimer>:
  * @retval Counter value
  */
uint32_t HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc)
{
  /* Get the counter value */
  return ((uint32_t)(hrtc->Instance->WUTR & RTC_WUTR_WUT));
 8008f2c:	6803      	ldr	r3, [r0, #0]
 8008f2e:	6958      	ldr	r0, [r3, #20]
}
 8008f30:	b280      	uxth	r0, r0
 8008f32:	4770      	bx	lr

08008f34 <HAL_RTCEx_WakeUpTimerEventCallback>:
  * @brief  Wake Up Timer callback.
  * @param  hrtc: RTC handle
  * @retval None
  */
__weak void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
{
 8008f34:	4770      	bx	lr
 8008f36:	bf00      	nop

08008f38 <HAL_RTCEx_WakeUpTimerIRQHandler>:
  * @brief  Handle Wake Up Timer interrupt request.
  * @param  hrtc: RTC handle
  * @retval None
  */
void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8008f38:	b510      	push	{r4, lr}
  /* Get the pending status of the WAKEUPTIMER Interrupt */
  if(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != RESET)
 8008f3a:	6803      	ldr	r3, [r0, #0]
 8008f3c:	68db      	ldr	r3, [r3, #12]
 8008f3e:	055b      	lsls	r3, r3, #21
  * @brief  Handle Wake Up Timer interrupt request.
  * @param  hrtc: RTC handle
  * @retval None
  */
void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8008f40:	4604      	mov	r4, r0
  /* Get the pending status of the WAKEUPTIMER Interrupt */
  if(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != RESET)
 8008f42:	d507      	bpl.n	8008f54 <HAL_RTCEx_WakeUpTimerIRQHandler+0x1c>
  {
    /* WAKEUPTIMER callback */ 
    HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
 8008f44:	f7ff fff6 	bl	8008f34 <HAL_RTCEx_WakeUpTimerEventCallback>
      
    /* Clear the WAKEUPTIMER interrupt pending bit */
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
 8008f48:	6822      	ldr	r2, [r4, #0]
 8008f4a:	68d3      	ldr	r3, [r2, #12]
 8008f4c:	b2db      	uxtb	r3, r3
 8008f4e:	f463 6390 	orn	r3, r3, #1152	; 0x480
 8008f52:	60d3      	str	r3, [r2, #12]
  }


  /* Clear the EXTI's line Flag for RTC WakeUpTimer */
  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
 8008f54:	4a03      	ldr	r2, [pc, #12]	; (8008f64 <HAL_RTCEx_WakeUpTimerIRQHandler+0x2c>)
 8008f56:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
  
  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008f5a:	2301      	movs	r3, #1
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
  }


  /* Clear the EXTI's line Flag for RTC WakeUpTimer */
  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
 8008f5c:	6151      	str	r1, [r2, #20]
  
  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008f5e:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
 8008f62:	bd10      	pop	{r4, pc}
 8008f64:	40010400 	.word	0x40010400

08008f68 <HAL_RTCEx_PollForWakeUpTimerEvent>:
  * @param  hrtc: RTC handle
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{
 8008f68:	b570      	push	{r4, r5, r6, lr}
 8008f6a:	4605      	mov	r5, r0
 8008f6c:	460c      	mov	r4, r1
  uint32_t tickstart = HAL_GetTick();
 8008f6e:	f7f7 fdcb 	bl	8000b08 <HAL_GetTick>
 8008f72:	4606      	mov	r6, r0
 8008f74:	682a      	ldr	r2, [r5, #0]
 8008f76:	e001      	b.n	8008f7c <HAL_RTCEx_PollForWakeUpTimerEvent+0x14>

  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) == RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
 8008f78:	1c61      	adds	r1, r4, #1
 8008f7a:	d10c      	bne.n	8008f96 <HAL_RTCEx_PollForWakeUpTimerEvent+0x2e>
  */
HAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{
  uint32_t tickstart = HAL_GetTick();

  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) == RESET)
 8008f7c:	68d3      	ldr	r3, [r2, #12]
 8008f7e:	055b      	lsls	r3, r3, #21
 8008f80:	d5fa      	bpl.n	8008f78 <HAL_RTCEx_PollForWakeUpTimerEvent+0x10>
      }
    }
  }

  /* Clear the WAKEUPTIMER Flag */
  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
 8008f82:	68d3      	ldr	r3, [r2, #12]
 8008f84:	b2db      	uxtb	r3, r3
 8008f86:	f463 6390 	orn	r3, r3, #1152	; 0x480
  
  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008f8a:	2101      	movs	r1, #1
      }
    }
  }

  /* Clear the WAKEUPTIMER Flag */
  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
 8008f8c:	60d3      	str	r3, [r2, #12]
  
  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8008f8e:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

  return HAL_OK;
 8008f92:	2000      	movs	r0, #0
}
 8008f94:	bd70      	pop	{r4, r5, r6, pc}

  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) == RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8008f96:	b124      	cbz	r4, 8008fa2 <HAL_RTCEx_PollForWakeUpTimerEvent+0x3a>
 8008f98:	f7f7 fdb6 	bl	8000b08 <HAL_GetTick>
 8008f9c:	1b80      	subs	r0, r0, r6
 8008f9e:	4284      	cmp	r4, r0
 8008fa0:	d2e8      	bcs.n	8008f74 <HAL_RTCEx_PollForWakeUpTimerEvent+0xc>
      {
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008fa2:	2003      	movs	r0, #3
 8008fa4:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21
      
        return HAL_TIMEOUT;
 8008fa8:	bd70      	pop	{r4, r5, r6, pc}
 8008faa:	bf00      	nop

08008fac <HAL_RTCEx_BKUPWrite>:
  uint32_t tmp = 0;

  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t)&(hrtc->Instance->BKP0R);
 8008fac:	6803      	ldr	r3, [r0, #0]
 8008fae:	3350      	adds	r3, #80	; 0x50
  tmp += (BackupRegister * 4);

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 8008fb0:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
 8008fb4:	4770      	bx	lr
 8008fb6:	bf00      	nop

08008fb8 <HAL_RTCEx_BKUPRead>:
  uint32_t tmp = 0;

  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t)&(hrtc->Instance->BKP0R);
 8008fb8:	6803      	ldr	r3, [r0, #0]
 8008fba:	3350      	adds	r3, #80	; 0x50
  tmp += (BackupRegister * 4);
  
  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8008fbc:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
}
 8008fc0:	4770      	bx	lr
 8008fc2:	bf00      	nop

08008fc4 <HAL_RTCEx_SetSmoothCalib>:
  *         must be equal to SMOOTHCALIB_PLUSPULSES_RESET and the field
  *         SmoothCalibMinusPulsesValue must be equal to 0.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef* hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmoothCalibMinusPulsesValue)
{
 8008fc4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmoothCalibMinusPulsesValue));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008fc8:	f890 4020 	ldrb.w	r4, [r0, #32]
 8008fcc:	2c01      	cmp	r4, #1
 8008fce:	d023      	beq.n	8009018 <HAL_RTCEx_SetSmoothCalib+0x54>
 8008fd0:	4604      	mov	r4, r0
 8008fd2:	461f      	mov	r7, r3

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008fd4:	6803      	ldr	r3, [r0, #0]
 8008fd6:	4690      	mov	r8, r2
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmoothCalibMinusPulsesValue));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008fd8:	2001      	movs	r0, #1

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008fda:	22ca      	movs	r2, #202	; 0xca
 8008fdc:	460e      	mov	r6, r1
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmoothCalibMinusPulsesValue));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008fde:	2102      	movs	r1, #2
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmoothCalibMinusPulsesValue));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8008fe0:	f884 0020 	strb.w	r0, [r4, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8008fe4:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008fe8:	625a      	str	r2, [r3, #36]	; 0x24
 8008fea:	6823      	ldr	r3, [r4, #0]
 8008fec:	2253      	movs	r2, #83	; 0x53
 8008fee:	625a      	str	r2, [r3, #36]	; 0x24

  /* check if a calibration is pending*/
  if((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
 8008ff0:	6820      	ldr	r0, [r4, #0]
 8008ff2:	68c3      	ldr	r3, [r0, #12]
 8008ff4:	03da      	lsls	r2, r3, #15
 8008ff6:	d412      	bmi.n	800901e <HAL_RTCEx_SetSmoothCalib+0x5a>
 8008ff8:	ea48 0707 	orr.w	r7, r8, r7
      }
    }
  }

  /* Configure the Smooth calibration settings */
  hrtc->Instance->CALR = (uint32_t)((uint32_t)SmoothCalibPeriod | (uint32_t)SmoothCalibPlusPulses | (uint32_t)SmoothCalibMinusPulsesValue);
 8008ffc:	433e      	orrs	r6, r7
 8008ffe:	63c6      	str	r6, [r0, #60]	; 0x3c

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009000:	6821      	ldr	r1, [r4, #0]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY; 

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8009002:	2300      	movs	r3, #0

  /* Configure the Smooth calibration settings */
  hrtc->Instance->CALR = (uint32_t)((uint32_t)SmoothCalibPeriod | (uint32_t)SmoothCalibPlusPulses | (uint32_t)SmoothCalibMinusPulsesValue);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009004:	20ff      	movs	r0, #255	; 0xff

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY; 
 8009006:	2201      	movs	r2, #1

  /* Configure the Smooth calibration settings */
  hrtc->Instance->CALR = (uint32_t)((uint32_t)SmoothCalibPeriod | (uint32_t)SmoothCalibPlusPulses | (uint32_t)SmoothCalibMinusPulsesValue);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009008:	6248      	str	r0, [r1, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY; 
 800900a:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800900e:	f884 3020 	strb.w	r3, [r4, #32]

  return HAL_OK;
 8009012:	4618      	mov	r0, r3
 8009014:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmoothCalibMinusPulsesValue));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8009018:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);

  return HAL_OK;
}
 800901a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* check if a calibration is pending*/
  if((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
  {
    tickstart = HAL_GetTick();
 800901e:	f7f7 fd73 	bl	8000b08 <HAL_GetTick>
 8009022:	4681      	mov	r9, r0

    /* check if a calibration is pending*/
    while((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
 8009024:	e006      	b.n	8009034 <HAL_RTCEx_SetSmoothCalib+0x70>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8009026:	f7f7 fd6f 	bl	8000b08 <HAL_GetTick>
 800902a:	ebc9 0000 	rsb	r0, r9, r0
 800902e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8009032:	d804      	bhi.n	800903e <HAL_RTCEx_SetSmoothCalib+0x7a>
  if((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
  {
    tickstart = HAL_GetTick();

    /* check if a calibration is pending*/
    while((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
 8009034:	6820      	ldr	r0, [r4, #0]
 8009036:	68c5      	ldr	r5, [r0, #12]
 8009038:	03eb      	lsls	r3, r5, #15
 800903a:	d4f4      	bmi.n	8009026 <HAL_RTCEx_SetSmoothCalib+0x62>
 800903c:	e7dc      	b.n	8008ff8 <HAL_RTCEx_SetSmoothCalib+0x34>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800903e:	6821      	ldr	r1, [r4, #0]

        /* Change RTC state */
        hrtc->State = HAL_RTC_STATE_TIMEOUT; 
 8009040:	2303      	movs	r3, #3
    while((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009042:	20ff      	movs	r0, #255	; 0xff

        /* Change RTC state */
        hrtc->State = HAL_RTC_STATE_TIMEOUT; 
        
        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8009044:	2200      	movs	r2, #0
    while((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009046:	6248      	str	r0, [r1, #36]	; 0x24

        /* Change RTC state */
        hrtc->State = HAL_RTC_STATE_TIMEOUT; 
 8009048:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
        
        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 800904c:	f884 2020 	strb.w	r2, [r4, #32]

        return HAL_TIMEOUT;
 8009050:	4618      	mov	r0, r3
 8009052:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8009056:	bf00      	nop

08009058 <HAL_RTCEx_SetSynchroShift>:
  * @param  ShiftSubFS: Select the number of Second Fractions to substitute.
  *          This parameter can be one any value from 0 to 0x7FFF.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef* hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS)
{
 8009058:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 800905a:	f890 3020 	ldrb.w	r3, [r0, #32]
 800905e:	2b01      	cmp	r3, #1
 8009060:	d101      	bne.n	8009066 <HAL_RTCEx_SetSynchroShift+0xe>
 8009062:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);

  return HAL_OK;
}
 8009064:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009066:	6803      	ldr	r3, [r0, #0]
 8009068:	4604      	mov	r4, r0
 800906a:	4617      	mov	r7, r2
  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 800906c:	2001      	movs	r0, #1

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800906e:	22ca      	movs	r2, #202	; 0xca
 8009070:	460e      	mov	r6, r1
  assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8009072:	2102      	movs	r1, #2
  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8009074:	f884 0020 	strb.w	r0, [r4, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8009078:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800907c:	625a      	str	r2, [r3, #36]	; 0x24
 800907e:	6823      	ldr	r3, [r4, #0]
 8009080:	2253      	movs	r2, #83	; 0x53
 8009082:	625a      	str	r2, [r3, #36]	; 0x24

    tickstart = HAL_GetTick();
 8009084:	f7f7 fd40 	bl	8000b08 <HAL_GetTick>
 8009088:	4605      	mov	r5, r0

    /* Wait until the shift is completed*/
    while((hrtc->Instance->ISR & RTC_ISR_SHPF) != RESET)
 800908a:	e005      	b.n	8009098 <HAL_RTCEx_SetSynchroShift+0x40>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 800908c:	f7f7 fd3c 	bl	8000b08 <HAL_GetTick>
 8009090:	1b40      	subs	r0, r0, r5
 8009092:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8009096:	d818      	bhi.n	80090ca <HAL_RTCEx_SetSynchroShift+0x72>
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

    tickstart = HAL_GetTick();

    /* Wait until the shift is completed*/
    while((hrtc->Instance->ISR & RTC_ISR_SHPF) != RESET)
 8009098:	6820      	ldr	r0, [r4, #0]
 800909a:	68c3      	ldr	r3, [r0, #12]
 800909c:	f013 0308 	ands.w	r3, r3, #8
 80090a0:	d1f4      	bne.n	800908c <HAL_RTCEx_SetSynchroShift+0x34>
        return HAL_TIMEOUT;
      }
    }

    /* Check if the reference clock detection is disabled */
    if((hrtc->Instance->CR & RTC_CR_REFCKON) == RESET)
 80090a2:	6882      	ldr	r2, [r0, #8]
 80090a4:	06d2      	lsls	r2, r2, #27
 80090a6:	d41b      	bmi.n	80090e0 <HAL_RTCEx_SetSynchroShift+0x88>
    {
      /* Configure the Shift settings */
      hrtc->Instance->SHIFTR = (uint32_t)(uint32_t)(ShiftSubFS) | (uint32_t)(ShiftAdd1S);
 80090a8:	433e      	orrs	r6, r7
 80090aa:	62c6      	str	r6, [r0, #44]	; 0x2c

      /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
      if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 80090ac:	6822      	ldr	r2, [r4, #0]
 80090ae:	6893      	ldr	r3, [r2, #8]
 80090b0:	f013 0520 	ands.w	r5, r3, #32
 80090b4:	d01d      	beq.n	80090f2 <HAL_RTCEx_SetSynchroShift+0x9a>

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80090b6:	2300      	movs	r3, #0

      return HAL_ERROR;
    }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80090b8:	20ff      	movs	r0, #255	; 0xff

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 80090ba:	2101      	movs	r1, #1

      return HAL_ERROR;
    }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80090bc:	6250      	str	r0, [r2, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 80090be:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80090c2:	f884 3020 	strb.w	r3, [r4, #32]

  return HAL_OK;
 80090c6:	4618      	mov	r0, r3
 80090c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    while((hrtc->Instance->ISR & RTC_ISR_SHPF) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80090ca:	6821      	ldr	r1, [r4, #0]

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 80090cc:	2303      	movs	r3, #3
    while((hrtc->Instance->ISR & RTC_ISR_SHPF) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80090ce:	20ff      	movs	r0, #255	; 0xff

        hrtc->State = HAL_RTC_STATE_TIMEOUT;

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);
 80090d0:	2200      	movs	r2, #0
    while((hrtc->Instance->ISR & RTC_ISR_SHPF) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80090d2:	6248      	str	r0, [r1, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 80090d4:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);
 80090d8:	f884 2020 	strb.w	r2, [r4, #32]

        return HAL_TIMEOUT;
 80090dc:	4618      	mov	r0, r3
 80090de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      }
    }
    else
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80090e0:	21ff      	movs	r1, #255	; 0xff
      
      /* Change RTC state */
      hrtc->State = HAL_RTC_STATE_ERROR;
 80090e2:	2204      	movs	r2, #4
      }
    }
    else
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80090e4:	6241      	str	r1, [r0, #36]	; 0x24
      
      /* Change RTC state */
      hrtc->State = HAL_RTC_STATE_ERROR;
      
      /* Process Unlocked */ 
      __HAL_UNLOCK(hrtc);
 80090e6:	f884 3020 	strb.w	r3, [r4, #32]
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
      
      /* Change RTC state */
      hrtc->State = HAL_RTC_STATE_ERROR;
 80090ea:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21
      
      /* Process Unlocked */ 
      __HAL_UNLOCK(hrtc);

      return HAL_ERROR;
 80090ee:	2001      	movs	r0, #1
 80090f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hrtc->Instance->SHIFTR = (uint32_t)(uint32_t)(ShiftSubFS) | (uint32_t)(ShiftAdd1S);

      /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
      if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
      {
        if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 80090f2:	4620      	mov	r0, r4
 80090f4:	f7ff f842 	bl	800817c <HAL_RTC_WaitForSynchro>
        {
          /* Enable the write protection for RTC registers */
          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80090f8:	6822      	ldr	r2, [r4, #0]
      hrtc->Instance->SHIFTR = (uint32_t)(uint32_t)(ShiftSubFS) | (uint32_t)(ShiftAdd1S);

      /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
      if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
      {
        if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 80090fa:	2800      	cmp	r0, #0
 80090fc:	d0db      	beq.n	80090b6 <HAL_RTCEx_SetSynchroShift+0x5e>
        {
          /* Enable the write protection for RTC registers */
          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80090fe:	21ff      	movs	r1, #255	; 0xff

          hrtc->State = HAL_RTC_STATE_ERROR;
 8009100:	2304      	movs	r3, #4
      if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
      {
        if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
        {
          /* Enable the write protection for RTC registers */
          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009102:	6251      	str	r1, [r2, #36]	; 0x24

          hrtc->State = HAL_RTC_STATE_ERROR;

          /* Process Unlocked */ 
          __HAL_UNLOCK(hrtc);
 8009104:	f884 5020 	strb.w	r5, [r4, #32]
        if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
        {
          /* Enable the write protection for RTC registers */
          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);

          hrtc->State = HAL_RTC_STATE_ERROR;
 8009108:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21

          /* Process Unlocked */ 
          __HAL_UNLOCK(hrtc);

          return HAL_ERROR;
 800910c:	2001      	movs	r0, #1
 800910e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08009110 <HAL_RTCEx_SetCalibrationOutPut>:
{
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8009110:	f890 2020 	ldrb.w	r2, [r0, #32]
 8009114:	2a01      	cmp	r2, #1
  *             @arg RTC_CALIBOUTPUT_512HZ: A signal has a regular waveform at 512Hz.
  *             @arg RTC_CALIBOUTPUT_1HZ: A signal has a regular waveform at 1Hz.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef* hrtc, uint32_t CalibOutput)
{
 8009116:	4603      	mov	r3, r0
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8009118:	d025      	beq.n	8009166 <HAL_RTCEx_SetCalibrationOutPut+0x56>
  *             @arg RTC_CALIBOUTPUT_512HZ: A signal has a regular waveform at 512Hz.
  *             @arg RTC_CALIBOUTPUT_1HZ: A signal has a regular waveform at 1Hz.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef* hrtc, uint32_t CalibOutput)
{
 800911a:	b430      	push	{r4, r5}
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800911c:	6802      	ldr	r2, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 800911e:	2401      	movs	r4, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 8009120:	2502      	movs	r5, #2

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009122:	20ca      	movs	r0, #202	; 0xca
{
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8009124:	f883 4020 	strb.w	r4, [r3, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8009128:	f883 5021 	strb.w	r5, [r3, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800912c:	6250      	str	r0, [r2, #36]	; 0x24
 800912e:	681a      	ldr	r2, [r3, #0]
 8009130:	2053      	movs	r0, #83	; 0x53
 8009132:	6250      	str	r0, [r2, #36]	; 0x24

  /* Clear flags before config */
  hrtc->Instance->CR &= (uint32_t)~RTC_CR_COSEL;
 8009134:	6818      	ldr	r0, [r3, #0]
 8009136:	6882      	ldr	r2, [r0, #8]
 8009138:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 800913c:	6082      	str	r2, [r0, #8]

  /* Configure the RTC_CR register */
  hrtc->Instance->CR |= (uint32_t)CalibOutput;
 800913e:	6818      	ldr	r0, [r3, #0]
 8009140:	6882      	ldr	r2, [r0, #8]
 8009142:	4311      	orrs	r1, r2
 8009144:	6081      	str	r1, [r0, #8]

  __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(hrtc);
 8009146:	6819      	ldr	r1, [r3, #0]
 8009148:	688a      	ldr	r2, [r1, #8]
 800914a:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 800914e:	608a      	str	r2, [r1, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009150:	6819      	ldr	r1, [r3, #0]
 8009152:	20ff      	movs	r0, #255	; 0xff

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8009154:	2200      	movs	r2, #0
  hrtc->Instance->CR |= (uint32_t)CalibOutput;

  __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(hrtc);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009156:	6248      	str	r0, [r1, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8009158:	f883 4021 	strb.w	r4, [r3, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800915c:	f883 2020 	strb.w	r2, [r3, #32]

  return HAL_OK;
 8009160:	4610      	mov	r0, r2
}
 8009162:	bc30      	pop	{r4, r5}
 8009164:	4770      	bx	lr
{
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8009166:	2002      	movs	r0, #2
 8009168:	4770      	bx	lr
 800916a:	bf00      	nop

0800916c <HAL_RTCEx_DeactivateCalibrationOutPut>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 800916c:	f890 2020 	ldrb.w	r2, [r0, #32]
 8009170:	2a01      	cmp	r2, #1
  * @brief  Deactivate the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef* hrtc)
{
 8009172:	4603      	mov	r3, r0
  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8009174:	d01d      	beq.n	80091b2 <HAL_RTCEx_DeactivateCalibrationOutPut+0x46>
  * @brief  Deactivate the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef* hrtc)
{
 8009176:	b410      	push	{r4}
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009178:	6802      	ldr	r2, [r0, #0]
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 800917a:	2101      	movs	r1, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 800917c:	2402      	movs	r4, #2

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800917e:	20ca      	movs	r0, #202	; 0xca
HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */ 
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 8009180:	f883 4021 	strb.w	r4, [r3, #33]	; 0x21
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8009184:	f883 1020 	strb.w	r1, [r3, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009188:	6250      	str	r0, [r2, #36]	; 0x24
 800918a:	681a      	ldr	r2, [r3, #0]
 800918c:	2053      	movs	r0, #83	; 0x53
 800918e:	6250      	str	r0, [r2, #36]	; 0x24

  __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(hrtc);
 8009190:	6818      	ldr	r0, [r3, #0]
 8009192:	6882      	ldr	r2, [r0, #8]
 8009194:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8009198:	6082      	str	r2, [r0, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800919a:	6818      	ldr	r0, [r3, #0]
 800919c:	24ff      	movs	r4, #255	; 0xff

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800919e:	2200      	movs	r2, #0
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(hrtc);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80091a0:	6244      	str	r4, [r0, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 80091a2:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80091a6:	f883 2020 	strb.w	r2, [r3, #32]

  return HAL_OK;
 80091aa:	4610      	mov	r0, r2
}
 80091ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80091b0:	4770      	bx	lr
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 80091b2:	2002      	movs	r0, #2
 80091b4:	4770      	bx	lr
 80091b6:	bf00      	nop

080091b8 <HAL_RTCEx_SetRefClock>:
  * @brief  Enable the RTC reference clock detection.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef* hrtc)
{
 80091b8:	b570      	push	{r4, r5, r6, lr}
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80091ba:	f890 3020 	ldrb.w	r3, [r0, #32]
 80091be:	2b01      	cmp	r3, #1
  * @brief  Enable the RTC reference clock detection.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef* hrtc)
{
 80091c0:	4604      	mov	r4, r0
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80091c2:	d101      	bne.n	80091c8 <HAL_RTCEx_SetRefClock+0x10>
 80091c4:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);

  return HAL_OK;
}
 80091c6:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80091c8:	6803      	ldr	r3, [r0, #0]
 80091ca:	22ca      	movs	r2, #202	; 0xca
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80091cc:	2501      	movs	r5, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 80091ce:	2102      	movs	r1, #2
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80091d0:	f880 5020 	strb.w	r5, [r0, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 80091d4:	f880 1021 	strb.w	r1, [r0, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80091d8:	625a      	str	r2, [r3, #36]	; 0x24
 80091da:	6803      	ldr	r3, [r0, #0]
 80091dc:	2253      	movs	r2, #83	; 0x53
 80091de:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80091e0:	f7fe ffea 	bl	80081b8 <RTC_EnterInitMode>
 80091e4:	b988      	cbnz	r0, 800920a <HAL_RTCEx_SetRefClock+0x52>

    return HAL_ERROR;
  }
  else
  {
    __HAL_RTC_CLOCKREF_DETECTION_ENABLE(hrtc);
 80091e6:	6822      	ldr	r2, [r4, #0]
 80091e8:	6893      	ldr	r3, [r2, #8]
 80091ea:	f043 0310 	orr.w	r3, r3, #16
 80091ee:	6093      	str	r3, [r2, #8]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 80091f0:	6822      	ldr	r2, [r4, #0]
 80091f2:	68d3      	ldr	r3, [r2, #12]
 80091f4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80091f8:	60d3      	str	r3, [r2, #12]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80091fa:	6823      	ldr	r3, [r4, #0]
 80091fc:	22ff      	movs	r2, #255	; 0xff
 80091fe:	625a      	str	r2, [r3, #36]	; 0x24

   /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8009200:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8009204:	f884 0020 	strb.w	r0, [r4, #32]

  return HAL_OK;
 8009208:	bd70      	pop	{r4, r5, r6, pc}

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800920a:	6821      	ldr	r1, [r4, #0]
 800920c:	26ff      	movs	r6, #255	; 0xff

    /* Set RTC state*/
    hrtc->State = HAL_RTC_STATE_ERROR;
 800920e:	2204      	movs	r2, #4

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 8009210:	2300      	movs	r3, #0

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009212:	624e      	str	r6, [r1, #36]	; 0x24

    /* Set RTC state*/
    hrtc->State = HAL_RTC_STATE_ERROR;
 8009214:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 8009218:	f884 3020 	strb.w	r3, [r4, #32]

    return HAL_ERROR;
 800921c:	4628      	mov	r0, r5
 800921e:	bd70      	pop	{r4, r5, r6, pc}

08009220 <HAL_RTCEx_DeactivateRefClock>:
  * @brief  Disable the RTC reference clock detection.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef* hrtc)
{
 8009220:	b570      	push	{r4, r5, r6, lr}
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8009222:	f890 3020 	ldrb.w	r3, [r0, #32]
 8009226:	2b01      	cmp	r3, #1
  * @brief  Disable the RTC reference clock detection.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef* hrtc)
{
 8009228:	4604      	mov	r4, r0
  /* Process Locked */
  __HAL_LOCK(hrtc);
 800922a:	d101      	bne.n	8009230 <HAL_RTCEx_DeactivateRefClock+0x10>
 800922c:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);

  return HAL_OK;
}
 800922e:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009230:	6803      	ldr	r3, [r0, #0]
 8009232:	22ca      	movs	r2, #202	; 0xca
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8009234:	2501      	movs	r5, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 8009236:	2102      	movs	r1, #2
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8009238:	f880 5020 	strb.w	r5, [r0, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;
 800923c:	f880 1021 	strb.w	r1, [r0, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009240:	625a      	str	r2, [r3, #36]	; 0x24
 8009242:	6803      	ldr	r3, [r0, #0]
 8009244:	2253      	movs	r2, #83	; 0x53
 8009246:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8009248:	f7fe ffb6 	bl	80081b8 <RTC_EnterInitMode>
 800924c:	b988      	cbnz	r0, 8009272 <HAL_RTCEx_DeactivateRefClock+0x52>

    return HAL_ERROR;
  }
  else
  {
    __HAL_RTC_CLOCKREF_DETECTION_DISABLE(hrtc);
 800924e:	6822      	ldr	r2, [r4, #0]
 8009250:	6893      	ldr	r3, [r2, #8]
 8009252:	f023 0310 	bic.w	r3, r3, #16
 8009256:	6093      	str	r3, [r2, #8]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 8009258:	6822      	ldr	r2, [r4, #0]
 800925a:	68d3      	ldr	r3, [r2, #12]
 800925c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009260:	60d3      	str	r3, [r2, #12]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009262:	6823      	ldr	r3, [r4, #0]
 8009264:	22ff      	movs	r2, #255	; 0xff
 8009266:	625a      	str	r2, [r3, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8009268:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800926c:	f884 0020 	strb.w	r0, [r4, #32]

  return HAL_OK;
 8009270:	bd70      	pop	{r4, r5, r6, pc}
  
  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009272:	6821      	ldr	r1, [r4, #0]
 8009274:	26ff      	movs	r6, #255	; 0xff

    /* Set RTC state*/
    hrtc->State = HAL_RTC_STATE_ERROR;
 8009276:	2204      	movs	r2, #4

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 8009278:	2300      	movs	r3, #0
  
  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800927a:	624e      	str	r6, [r1, #36]	; 0x24

    /* Set RTC state*/
    hrtc->State = HAL_RTC_STATE_ERROR;
 800927c:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 8009280:	f884 3020 	strb.w	r3, [r4, #32]

    return HAL_ERROR;
 8009284:	4628      	mov	r0, r5
 8009286:	bd70      	pop	{r4, r5, r6, pc}

08009288 <HAL_RTCEx_EnableBypassShadow>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8009288:	f890 2020 	ldrb.w	r2, [r0, #32]
 800928c:	2a01      	cmp	r2, #1
  * @note   When the Bypass Shadow is enabled the calendar value are taken
  *         directly from the Calendar counter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc)
{
 800928e:	4603      	mov	r3, r0
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8009290:	d01d      	beq.n	80092ce <HAL_RTCEx_EnableBypassShadow+0x46>
  * @note   When the Bypass Shadow is enabled the calendar value are taken
  *         directly from the Calendar counter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc)
{
 8009292:	b410      	push	{r4}
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009294:	6802      	ldr	r2, [r0, #0]
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8009296:	2101      	movs	r1, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 8009298:	2402      	movs	r4, #2

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800929a:	20ca      	movs	r0, #202	; 0xca
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 800929c:	f883 4021 	strb.w	r4, [r3, #33]	; 0x21
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80092a0:	f883 1020 	strb.w	r1, [r3, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80092a4:	6250      	str	r0, [r2, #36]	; 0x24
 80092a6:	681a      	ldr	r2, [r3, #0]
 80092a8:	2053      	movs	r0, #83	; 0x53
 80092aa:	6250      	str	r0, [r2, #36]	; 0x24

  /* Set the BYPSHAD bit */
  hrtc->Instance->CR |= (uint8_t)RTC_CR_BYPSHAD;
 80092ac:	6818      	ldr	r0, [r3, #0]
 80092ae:	6882      	ldr	r2, [r0, #8]
 80092b0:	f042 0220 	orr.w	r2, r2, #32
 80092b4:	6082      	str	r2, [r0, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80092b6:	6818      	ldr	r0, [r3, #0]
 80092b8:	24ff      	movs	r4, #255	; 0xff

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80092ba:	2200      	movs	r2, #0

  /* Set the BYPSHAD bit */
  hrtc->Instance->CR |= (uint8_t)RTC_CR_BYPSHAD;

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80092bc:	6244      	str	r4, [r0, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 80092be:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80092c2:	f883 2020 	strb.w	r2, [r3, #32]

  return HAL_OK;
 80092c6:	4610      	mov	r0, r2
}
 80092c8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80092cc:	4770      	bx	lr
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80092ce:	2002      	movs	r0, #2
 80092d0:	4770      	bx	lr
 80092d2:	bf00      	nop

080092d4 <HAL_RTCEx_DisableBypassShadow>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80092d4:	f890 2020 	ldrb.w	r2, [r0, #32]
 80092d8:	2a01      	cmp	r2, #1
  * @note   When the Bypass Shadow is enabled the calendar value are taken
  *         directly from the Calendar counter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc)
{
 80092da:	4603      	mov	r3, r0
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80092dc:	d01d      	beq.n	800931a <HAL_RTCEx_DisableBypassShadow+0x46>
  * @note   When the Bypass Shadow is enabled the calendar value are taken
  *         directly from the Calendar counter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc)
{
 80092de:	b410      	push	{r4}
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80092e0:	6802      	ldr	r2, [r0, #0]
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80092e2:	2101      	movs	r1, #1

  hrtc->State = HAL_RTC_STATE_BUSY;
 80092e4:	2402      	movs	r4, #2

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80092e6:	20ca      	movs	r0, #202	; 0xca
HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);

  hrtc->State = HAL_RTC_STATE_BUSY;
 80092e8:	f883 4021 	strb.w	r4, [r3, #33]	; 0x21
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80092ec:	f883 1020 	strb.w	r1, [r3, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80092f0:	6250      	str	r0, [r2, #36]	; 0x24
 80092f2:	681a      	ldr	r2, [r3, #0]
 80092f4:	2053      	movs	r0, #83	; 0x53
 80092f6:	6250      	str	r0, [r2, #36]	; 0x24

  /* Reset the BYPSHAD bit */
  hrtc->Instance->CR &= ((uint8_t)~RTC_CR_BYPSHAD);
 80092f8:	6818      	ldr	r0, [r3, #0]
 80092fa:	6882      	ldr	r2, [r0, #8]
 80092fc:	f002 02df 	and.w	r2, r2, #223	; 0xdf
 8009300:	6082      	str	r2, [r0, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009302:	6818      	ldr	r0, [r3, #0]
 8009304:	24ff      	movs	r4, #255	; 0xff

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8009306:	2200      	movs	r2, #0

  /* Reset the BYPSHAD bit */
  hrtc->Instance->CR &= ((uint8_t)~RTC_CR_BYPSHAD);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009308:	6244      	str	r4, [r0, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 800930a:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800930e:	f883 2020 	strb.w	r2, [r3, #32]

  return HAL_OK;
 8009312:	4610      	mov	r0, r2
}
 8009314:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009318:	4770      	bx	lr
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 800931a:	2002      	movs	r0, #2
 800931c:	4770      	bx	lr
 800931e:	bf00      	nop

08009320 <HAL_RTCEx_AlarmBEventCallback>:
  * @brief  Alarm B callback.
  * @param  hrtc: RTC handle
  * @retval None
  */
__weak void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
{
 8009320:	4770      	bx	lr
 8009322:	bf00      	nop

08009324 <HAL_RTCEx_PollForAlarmBEvent>:
  * @param  hrtc: RTC handle
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_PollForAlarmBEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{ 
 8009324:	b570      	push	{r4, r5, r6, lr}
 8009326:	4605      	mov	r5, r0
 8009328:	460c      	mov	r4, r1
  uint32_t tickstart = HAL_GetTick();
 800932a:	f7f7 fbed 	bl	8000b08 <HAL_GetTick>
 800932e:	4606      	mov	r6, r0
 8009330:	682a      	ldr	r2, [r5, #0]
 8009332:	e001      	b.n	8009338 <HAL_RTCEx_PollForAlarmBEvent+0x14>
  
  while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) == RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
 8009334:	1c61      	adds	r1, r4, #1
 8009336:	d10c      	bne.n	8009352 <HAL_RTCEx_PollForAlarmBEvent+0x2e>
  */
HAL_StatusTypeDef HAL_RTCEx_PollForAlarmBEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
{ 
  uint32_t tickstart = HAL_GetTick();
  
  while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) == RESET)
 8009338:	68d3      	ldr	r3, [r2, #12]
 800933a:	059b      	lsls	r3, r3, #22
 800933c:	d5fa      	bpl.n	8009334 <HAL_RTCEx_PollForAlarmBEvent+0x10>
      }
    }
  }

  /* Clear the Alarm Flag */
  __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 800933e:	68d3      	ldr	r3, [r2, #12]
 8009340:	b2db      	uxtb	r3, r3
 8009342:	f463 7320 	orn	r3, r3, #640	; 0x280

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8009346:	2101      	movs	r1, #1
      }
    }
  }

  /* Clear the Alarm Flag */
  __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 8009348:	60d3      	str	r3, [r2, #12]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 800934a:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

  return HAL_OK;
 800934e:	2000      	movs	r0, #0
}
 8009350:	bd70      	pop	{r4, r5, r6, pc}
  
  while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) == RESET)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8009352:	b124      	cbz	r4, 800935e <HAL_RTCEx_PollForAlarmBEvent+0x3a>
 8009354:	f7f7 fbd8 	bl	8000b08 <HAL_GetTick>
 8009358:	1b80      	subs	r0, r0, r6
 800935a:	4284      	cmp	r4, r0
 800935c:	d2e8      	bcs.n	8009330 <HAL_RTCEx_PollForAlarmBEvent+0xc>
      {
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 800935e:	2003      	movs	r0, #3
 8009360:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21
        return HAL_TIMEOUT;
 8009364:	bd70      	pop	{r4, r5, r6, pc}
 8009366:	bf00      	nop

08009368 <SPI_WaitFifoStateUntilTimeout>:
  * @param State : Fifo state to check
  * @param Timeout : Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout)
{
 8009368:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800936c:	b082      	sub	sp, #8
 800936e:	4607      	mov	r7, r0
 8009370:	460c      	mov	r4, r1
 8009372:	4615      	mov	r5, r2
 8009374:	461e      	mov	r6, r3
  __IO uint8_t tmpreg;
  uint32_t tickstart = HAL_GetTick();
 8009376:	f7f7 fbc7 	bl	8000b08 <HAL_GetTick>
 800937a:	4680      	mov	r8, r0
 800937c:	683a      	ldr	r2, [r7, #0]
 800937e:	e001      	b.n	8009384 <SPI_WaitFifoStateUntilTimeout+0x1c>
    {
      tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
      UNUSED(tmpreg); /* To avoid GCC warning */
    }

    if(Timeout != HAL_MAX_DELAY)
 8009380:	1c73      	adds	r3, r6, #1
 8009382:	d110      	bne.n	80093a6 <SPI_WaitFifoStateUntilTimeout+0x3e>
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout)
{
  __IO uint8_t tmpreg;
  uint32_t tickstart = HAL_GetTick();

  while((hspi->Instance->SR & Fifo) != State)
 8009384:	6890      	ldr	r0, [r2, #8]
 8009386:	4020      	ands	r0, r4
 8009388:	42a8      	cmp	r0, r5
 800938a:	d028      	beq.n	80093de <SPI_WaitFifoStateUntilTimeout+0x76>
  {
    if((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 800938c:	f5b4 6fc0 	cmp.w	r4, #1536	; 0x600
 8009390:	d1f6      	bne.n	8009380 <SPI_WaitFifoStateUntilTimeout+0x18>
 8009392:	2d00      	cmp	r5, #0
 8009394:	d1f4      	bne.n	8009380 <SPI_WaitFifoStateUntilTimeout+0x18>
    {
      tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
 8009396:	7b13      	ldrb	r3, [r2, #12]
 8009398:	b2db      	uxtb	r3, r3
 800939a:	f88d 3007 	strb.w	r3, [sp, #7]
      UNUSED(tmpreg); /* To avoid GCC warning */
 800939e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    }

    if(Timeout != HAL_MAX_DELAY)
 80093a2:	1c73      	adds	r3, r6, #1
 80093a4:	d0ee      	beq.n	8009384 <SPI_WaitFifoStateUntilTimeout+0x1c>
    {
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
 80093a6:	b136      	cbz	r6, 80093b6 <SPI_WaitFifoStateUntilTimeout+0x4e>
 80093a8:	f7f7 fbae 	bl	8000b08 <HAL_GetTick>
 80093ac:	ebc8 0000 	rsb	r0, r8, r0
 80093b0:	4286      	cmp	r6, r0
 80093b2:	d8e3      	bhi.n	800937c <SPI_WaitFifoStateUntilTimeout+0x14>
 80093b4:	683a      	ldr	r2, [r7, #0]
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
                  on both master and slave sides in order to resynchronize the master
                 and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80093b6:	6853      	ldr	r3, [r2, #4]
 80093b8:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 80093bc:	6053      	str	r3, [r2, #4]

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80093be:	687b      	ldr	r3, [r7, #4]
 80093c0:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80093c4:	d01b      	beq.n	80093fe <SPI_WaitFifoStateUntilTimeout+0x96>
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
        }

        /* Reset CRC Calculation */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80093c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80093c8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80093cc:	d00b      	beq.n	80093e6 <SPI_WaitFifoStateUntilTimeout+0x7e>
        {
          SPI_RESET_CRC(hspi);
        }

        hspi->State = HAL_SPI_STATE_READY;
 80093ce:	2201      	movs	r2, #1

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 80093d0:	2300      	movs	r3, #0
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
        {
          SPI_RESET_CRC(hspi);
        }

        hspi->State = HAL_SPI_STATE_READY;
 80093d2:	f887 205d 	strb.w	r2, [r7, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 80093d6:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
 80093da:	2003      	movs	r0, #3
 80093dc:	e000      	b.n	80093e0 <SPI_WaitFifoStateUntilTimeout+0x78>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 80093de:	2000      	movs	r0, #0
}
 80093e0:	b002      	add	sp, #8
 80093e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }

        /* Reset CRC Calculation */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
        {
          SPI_RESET_CRC(hspi);
 80093e6:	683a      	ldr	r2, [r7, #0]
 80093e8:	6811      	ldr	r1, [r2, #0]
 80093ea:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 80093ee:	400b      	ands	r3, r1
 80093f0:	6013      	str	r3, [r2, #0]
 80093f2:	683a      	ldr	r2, [r7, #0]
 80093f4:	6813      	ldr	r3, [r2, #0]
 80093f6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80093fa:	6013      	str	r3, [r2, #0]
 80093fc:	e7e7      	b.n	80093ce <SPI_WaitFifoStateUntilTimeout+0x66>
                 and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80093fe:	68bb      	ldr	r3, [r7, #8]
 8009400:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009404:	d002      	beq.n	800940c <SPI_WaitFifoStateUntilTimeout+0xa4>
 8009406:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800940a:	d1dc      	bne.n	80093c6 <SPI_WaitFifoStateUntilTimeout+0x5e>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800940c:	683a      	ldr	r2, [r7, #0]
 800940e:	6813      	ldr	r3, [r2, #0]
 8009410:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8009414:	6013      	str	r3, [r2, #0]
 8009416:	e7d6      	b.n	80093c6 <SPI_WaitFifoStateUntilTimeout+0x5e>

08009418 <SPI_WaitFlagStateUntilTimeout>:
  * @param State : flag state to check
  * @param Timeout : Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout)
{
 8009418:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800941c:	4680      	mov	r8, r0
 800941e:	460f      	mov	r7, r1
 8009420:	4616      	mov	r6, r2
 8009422:	461d      	mov	r5, r3
  uint32_t tickstart = HAL_GetTick();
 8009424:	f7f7 fb70 	bl	8000b08 <HAL_GetTick>
 8009428:	4681      	mov	r9, r0
 800942a:	f8d8 4000 	ldr.w	r4, [r8]
 800942e:	e001      	b.n	8009434 <SPI_WaitFlagStateUntilTimeout+0x1c>

  while((hspi->Instance->SR & Flag) != State)
  {
    if(Timeout != HAL_MAX_DELAY)
 8009430:	1c6b      	adds	r3, r5, #1
 8009432:	d106      	bne.n	8009442 <SPI_WaitFlagStateUntilTimeout+0x2a>
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout)
{
  uint32_t tickstart = HAL_GetTick();

  while((hspi->Instance->SR & Flag) != State)
 8009434:	68a0      	ldr	r0, [r4, #8]
 8009436:	4038      	ands	r0, r7
 8009438:	42b0      	cmp	r0, r6
 800943a:	d1f9      	bne.n	8009430 <SPI_WaitFlagStateUntilTimeout+0x18>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 800943c:	2000      	movs	r0, #0
}
 800943e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

  while((hspi->Instance->SR & Flag) != State)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
 8009442:	b13d      	cbz	r5, 8009454 <SPI_WaitFlagStateUntilTimeout+0x3c>
 8009444:	f7f7 fb60 	bl	8000b08 <HAL_GetTick>
 8009448:	ebc9 0000 	rsb	r0, r9, r0
 800944c:	4285      	cmp	r5, r0
 800944e:	d8ec      	bhi.n	800942a <SPI_WaitFlagStateUntilTimeout+0x12>
 8009450:	f8d8 4000 	ldr.w	r4, [r8]
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8009454:	6863      	ldr	r3, [r4, #4]
 8009456:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 800945a:	6063      	str	r3, [r4, #4]

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800945c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8009460:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8009464:	d01b      	beq.n	800949e <SPI_WaitFlagStateUntilTimeout+0x86>
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
        }

        /* Reset CRC Calculation */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009466:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
 800946a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800946e:	d008      	beq.n	8009482 <SPI_WaitFlagStateUntilTimeout+0x6a>
        {
          SPI_RESET_CRC(hspi);
        }

        hspi->State= HAL_SPI_STATE_READY;
 8009470:	2201      	movs	r2, #1

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8009472:	2300      	movs	r3, #0
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
        {
          SPI_RESET_CRC(hspi);
        }

        hspi->State= HAL_SPI_STATE_READY;
 8009474:	f888 205d 	strb.w	r2, [r8, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8009478:	f888 305c 	strb.w	r3, [r8, #92]	; 0x5c
 800947c:	2003      	movs	r0, #3
 800947e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        }

        /* Reset CRC Calculation */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
        {
          SPI_RESET_CRC(hspi);
 8009482:	f8d8 2000 	ldr.w	r2, [r8]
 8009486:	6811      	ldr	r1, [r2, #0]
 8009488:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 800948c:	400b      	ands	r3, r1
 800948e:	6013      	str	r3, [r2, #0]
 8009490:	f8d8 2000 	ldr.w	r2, [r8]
 8009494:	6813      	ldr	r3, [r2, #0]
 8009496:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800949a:	6013      	str	r3, [r2, #0]
 800949c:	e7e8      	b.n	8009470 <SPI_WaitFlagStateUntilTimeout+0x58>
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800949e:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80094a2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80094a6:	d002      	beq.n	80094ae <SPI_WaitFlagStateUntilTimeout+0x96>
 80094a8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80094ac:	d1db      	bne.n	8009466 <SPI_WaitFlagStateUntilTimeout+0x4e>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 80094ae:	f8d8 2000 	ldr.w	r2, [r8]
 80094b2:	6813      	ldr	r3, [r2, #0]
 80094b4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80094b8:	6013      	str	r3, [r2, #0]
 80094ba:	e7d4      	b.n	8009466 <SPI_WaitFlagStateUntilTimeout+0x4e>

080094bc <SPI_EndRxTxTransaction>:
  * @brief Handle the check of the RXTX or TX transaction complete.
  * @param hspi: SPI handle
  * @param Timeout : Timeout duration
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout)
{
 80094bc:	b538      	push	{r3, r4, r5, lr}
  /* Control if the TX fifo is empty */
  if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
 80094be:	2200      	movs	r2, #0
  * @brief Handle the check of the RXTX or TX transaction complete.
  * @param hspi: SPI handle
  * @param Timeout : Timeout duration
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout)
{
 80094c0:	460d      	mov	r5, r1
  /* Control if the TX fifo is empty */
  if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
 80094c2:	460b      	mov	r3, r1
 80094c4:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
  * @brief Handle the check of the RXTX or TX transaction complete.
  * @param hspi: SPI handle
  * @param Timeout : Timeout duration
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout)
{
 80094c8:	4604      	mov	r4, r0
  /* Control if the TX fifo is empty */
  if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
 80094ca:	f7ff ff4d 	bl	8009368 <SPI_WaitFifoStateUntilTimeout>
 80094ce:	b128      	cbz	r0, 80094dc <SPI_EndRxTxTransaction+0x20>
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
  {
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 80094d0:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80094d2:	f043 0320 	orr.w	r3, r3, #32
 80094d6:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 80094d8:	2003      	movs	r0, #3
  }
  return HAL_OK;
}
 80094da:	bd38      	pop	{r3, r4, r5, pc}
  {
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
 80094dc:	4602      	mov	r2, r0
 80094de:	462b      	mov	r3, r5
 80094e0:	4620      	mov	r0, r4
 80094e2:	2180      	movs	r1, #128	; 0x80
 80094e4:	f7ff ff98 	bl	8009418 <SPI_WaitFlagStateUntilTimeout>
 80094e8:	2800      	cmp	r0, #0
 80094ea:	d1f1      	bne.n	80094d0 <SPI_EndRxTxTransaction+0x14>
 80094ec:	e7f5      	b.n	80094da <SPI_EndRxTxTransaction+0x1e>
 80094ee:	bf00      	nop

080094f0 <SPI_EndRxTransaction>:
  *               the configuration information for SPI module.
  * @param Timeout : Timeout duration
  * @retval None
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout)
{
 80094f0:	b570      	push	{r4, r5, r6, lr}
  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80094f2:	6843      	ldr	r3, [r0, #4]
 80094f4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
  *               the configuration information for SPI module.
  * @param Timeout : Timeout duration
  * @retval None
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout)
{
 80094f8:	4604      	mov	r4, r0
 80094fa:	460e      	mov	r6, r1
  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80094fc:	d023      	beq.n	8009546 <SPI_EndRxTransaction+0x56>
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
  }
  
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
 80094fe:	4620      	mov	r0, r4
 8009500:	2180      	movs	r1, #128	; 0x80
 8009502:	2200      	movs	r2, #0
 8009504:	4633      	mov	r3, r6
 8009506:	f7ff ff87 	bl	8009418 <SPI_WaitFlagStateUntilTimeout>
 800950a:	4605      	mov	r5, r0
 800950c:	b130      	cbz	r0, 800951c <SPI_EndRxTransaction+0x2c>
  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
  {
    /* Empty the FRLVL fifo */
    if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK)
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 800950e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8009510:	f043 0320 	orr.w	r3, r3, #32
 8009514:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_TIMEOUT;
 8009516:	2503      	movs	r5, #3
    }
  }
  return HAL_OK;
}
 8009518:	4628      	mov	r0, r5
 800951a:	bd70      	pop	{r4, r5, r6, pc}
  {
    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
    return HAL_TIMEOUT;
  }

  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800951c:	6863      	ldr	r3, [r4, #4]
 800951e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8009522:	d1f9      	bne.n	8009518 <SPI_EndRxTransaction+0x28>
 8009524:	68a3      	ldr	r3, [r4, #8]
 8009526:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800952a:	d002      	beq.n	8009532 <SPI_EndRxTransaction+0x42>
 800952c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8009530:	d1f2      	bne.n	8009518 <SPI_EndRxTransaction+0x28>
  {
    /* Empty the FRLVL fifo */
    if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK)
 8009532:	4633      	mov	r3, r6
 8009534:	4620      	mov	r0, r4
 8009536:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 800953a:	2200      	movs	r2, #0
 800953c:	f7ff ff14 	bl	8009368 <SPI_WaitFifoStateUntilTimeout>
 8009540:	2800      	cmp	r0, #0
 8009542:	d1e4      	bne.n	800950e <SPI_EndRxTransaction+0x1e>
 8009544:	e7e8      	b.n	8009518 <SPI_EndRxTransaction+0x28>
  * @param Timeout : Timeout duration
  * @retval None
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout)
{
  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8009546:	6883      	ldr	r3, [r0, #8]
 8009548:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800954c:	d002      	beq.n	8009554 <SPI_EndRxTransaction+0x64>
 800954e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8009552:	d1d4      	bne.n	80094fe <SPI_EndRxTransaction+0xe>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 8009554:	6822      	ldr	r2, [r4, #0]
 8009556:	6813      	ldr	r3, [r2, #0]
 8009558:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800955c:	6013      	str	r3, [r2, #0]
 800955e:	e7ce      	b.n	80094fe <SPI_EndRxTransaction+0xe>

08009560 <HAL_SPI_TransmitReceive_IT.part.4>:
  * @param  pTxData: pointer to transmission data buffer
  * @param  pRxData: pointer to reception data buffer
  * @param  Size: amount of data to be sent and received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
 8009560:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009562:	4604      	mov	r4, r0
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);

  if(!((hspi->State == HAL_SPI_STATE_READY) || \
 8009564:	f890 005d 	ldrb.w	r0, [r0, #93]	; 0x5d
{
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);
 8009568:	2501      	movs	r5, #1

  if(!((hspi->State == HAL_SPI_STATE_READY) || \
 800956a:	42a8      	cmp	r0, r5
{
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);
 800956c:	f884 505c 	strb.w	r5, [r4, #92]	; 0x5c

  if(!((hspi->State == HAL_SPI_STATE_READY) || \
 8009570:	d00d      	beq.n	800958e <HAL_SPI_TransmitReceive_IT.part.4+0x2e>
 8009572:	6865      	ldr	r5, [r4, #4]
 8009574:	f5b5 7f82 	cmp.w	r5, #260	; 0x104
 8009578:	d004      	beq.n	8009584 <HAL_SPI_TransmitReceive_IT.part.4+0x24>
    ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX))))
  {
    errorcode = HAL_BUSY;
 800957a:	2002      	movs	r0, #2
    __HAL_SPI_ENABLE(hspi);
  }

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800957c:	2300      	movs	r3, #0
 800957e:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
}
 8009582:	bdf0      	pop	{r4, r5, r6, r7, pc}

  /* Process locked */
  __HAL_LOCK(hspi);

  if(!((hspi->State == HAL_SPI_STATE_READY) || \
    ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX))))
 8009584:	68a5      	ldr	r5, [r4, #8]
 8009586:	2d00      	cmp	r5, #0
 8009588:	d1f7      	bne.n	800957a <HAL_SPI_TransmitReceive_IT.part.4+0x1a>
 800958a:	2804      	cmp	r0, #4
 800958c:	d1f5      	bne.n	800957a <HAL_SPI_TransmitReceive_IT.part.4+0x1a>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
 800958e:	2900      	cmp	r1, #0
 8009590:	d03e      	beq.n	8009610 <HAL_SPI_TransmitReceive_IT.part.4+0xb0>
 8009592:	2a00      	cmp	r2, #0
 8009594:	d03c      	beq.n	8009610 <HAL_SPI_TransmitReceive_IT.part.4+0xb0>
 8009596:	2b00      	cmp	r3, #0
 8009598:	d03a      	beq.n	8009610 <HAL_SPI_TransmitReceive_IT.part.4+0xb0>
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->CRCSize = 0;
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800959a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  {
    hspi->CRCSize = 1;
    if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 800959c:	68e5      	ldr	r5, [r4, #12]
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->CRCSize = 0;
 800959e:	2700      	movs	r7, #0
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80095a0:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->CRCSize = 0;
 80095a4:	64a7      	str	r7, [r4, #72]	; 0x48
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80095a6:	d038      	beq.n	800961a <HAL_SPI_TransmitReceive_IT.part.4+0xba>
    {
      hspi->CRCSize = 2;
    }
  }

  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
 80095a8:	2804      	cmp	r0, #4
 80095aa:	d002      	beq.n	80095b2 <HAL_SPI_TransmitReceive_IT.part.4+0x52>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 80095ac:	2005      	movs	r0, #5
 80095ae:	f884 005d 	strb.w	r0, [r4, #93]	; 0x5d
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80095b2:	2000      	movs	r0, #0
  hspi->pRxBuffPtr  = pRxData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;

  /* Set the function for IT treatment */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
 80095b4:	f5b5 6fe0 	cmp.w	r5, #1792	; 0x700
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = pTxData;
 80095b8:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 80095ba:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 80095bc:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->pRxBuffPtr  = pRxData;
 80095be:	6422      	str	r2, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 80095c0:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxXferCount = Size;
 80095c4:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80095c8:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->pRxBuffPtr  = pRxData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;

  /* Set the function for IT treatment */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
 80095ca:	d93c      	bls.n	8009646 <HAL_SPI_TransmitReceive_IT.part.4+0xe6>
  {
    hspi->RxISR = SPI_2linesRxISR_16BIT;
 80095cc:	4a32      	ldr	r2, [pc, #200]	; (8009698 <HAL_SPI_TransmitReceive_IT.part.4+0x138>)
    hspi->TxISR = SPI_2linesTxISR_16BIT;
 80095ce:	4b33      	ldr	r3, [pc, #204]	; (800969c <HAL_SPI_TransmitReceive_IT.part.4+0x13c>)
  hspi->RxXferCount = Size;

  /* Set the function for IT treatment */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
  {
    hspi->RxISR = SPI_2linesRxISR_16BIT;
 80095d0:	64e2      	str	r2, [r4, #76]	; 0x4c
    hspi->TxISR = SPI_2linesTxISR_16BIT;
 80095d2:	6523      	str	r3, [r4, #80]	; 0x50
    hspi->RxISR = SPI_2linesRxISR_8BIT;
    hspi->TxISR = SPI_2linesTxISR_8BIT;
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80095d4:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
 80095d8:	d042      	beq.n	8009660 <HAL_SPI_TransmitReceive_IT.part.4+0x100>
  {
    SPI_RESET_CRC(hspi);
  }

  /* check if packing mode is enabled and if there is more than 2 data to receive */
  if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount >= 2))
 80095da:	f5b5 6fe0 	cmp.w	r5, #1792	; 0x700
 80095de:	d803      	bhi.n	80095e8 <HAL_SPI_TransmitReceive_IT.part.4+0x88>
 80095e0:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80095e4:	2b01      	cmp	r3, #1
 80095e6:	d935      	bls.n	8009654 <HAL_SPI_TransmitReceive_IT.part.4+0xf4>
  {
    /* set fiforxthresold according the reception data length: 16 bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80095e8:	6822      	ldr	r2, [r4, #0]
 80095ea:	6853      	ldr	r3, [r2, #4]
 80095ec:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80095f0:	6053      	str	r3, [r2, #4]
    /* set fiforxthresold according the reception data length: 8 bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
  }

  /* Enable TXE, RXNE and ERR interrupt */
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80095f2:	6822      	ldr	r2, [r4, #0]
 80095f4:	6853      	ldr	r3, [r2, #4]
 80095f6:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 80095fa:	6053      	str	r3, [r2, #4]

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80095fc:	6823      	ldr	r3, [r4, #0]
 80095fe:	6818      	ldr	r0, [r3, #0]
 8009600:	f010 0040 	ands.w	r0, r0, #64	; 0x40
 8009604:	d124      	bne.n	8009650 <HAL_SPI_TransmitReceive_IT.part.4+0xf0>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8009606:	681a      	ldr	r2, [r3, #0]
 8009608:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800960c:	601a      	str	r2, [r3, #0]
 800960e:	e7b5      	b.n	800957c <HAL_SPI_TransmitReceive_IT.part.4+0x1c>
  }

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 8009610:	2300      	movs	r3, #0
 8009612:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
    goto error;
  }

  if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
  {
    errorcode = HAL_ERROR;
 8009616:	2001      	movs	r0, #1

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8009618:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }

  hspi->CRCSize = 0;
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    hspi->CRCSize = 1;
 800961a:	f04f 0e01 	mov.w	lr, #1
    if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 800961e:	f5b5 6fe0 	cmp.w	r5, #1792	; 0x700
  }

  hspi->CRCSize = 0;
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    hspi->CRCSize = 1;
 8009622:	f8c4 e048 	str.w	lr, [r4, #72]	; 0x48
    if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 8009626:	d828      	bhi.n	800967a <HAL_SPI_TransmitReceive_IT.part.4+0x11a>
 8009628:	6b27      	ldr	r7, [r4, #48]	; 0x30
 800962a:	2f02      	cmp	r7, #2
 800962c:	d031      	beq.n	8009692 <HAL_SPI_TransmitReceive_IT.part.4+0x132>
    {
      hspi->CRCSize = 2;
    }
  }

  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
 800962e:	2804      	cmp	r0, #4
 8009630:	d1bc      	bne.n	80095ac <HAL_SPI_TransmitReceive_IT.part.4+0x4c>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009632:	2000      	movs	r0, #0
  hspi->pTxBuffPtr  = pTxData;
 8009634:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8009636:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 8009638:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->pRxBuffPtr  = pRxData;
 800963a:	6422      	str	r2, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 800963c:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxXferCount = Size;
 8009640:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009644:	6620      	str	r0, [r4, #96]	; 0x60
    hspi->RxISR = SPI_2linesRxISR_16BIT;
    hspi->TxISR = SPI_2linesTxISR_16BIT;
  }
  else
  {
    hspi->RxISR = SPI_2linesRxISR_8BIT;
 8009646:	4a16      	ldr	r2, [pc, #88]	; (80096a0 <HAL_SPI_TransmitReceive_IT.part.4+0x140>)
    hspi->TxISR = SPI_2linesTxISR_8BIT;
 8009648:	4b16      	ldr	r3, [pc, #88]	; (80096a4 <HAL_SPI_TransmitReceive_IT.part.4+0x144>)
    hspi->RxISR = SPI_2linesRxISR_16BIT;
    hspi->TxISR = SPI_2linesTxISR_16BIT;
  }
  else
  {
    hspi->RxISR = SPI_2linesRxISR_8BIT;
 800964a:	64e2      	str	r2, [r4, #76]	; 0x4c
    hspi->TxISR = SPI_2linesTxISR_8BIT;
 800964c:	6523      	str	r3, [r4, #80]	; 0x50
 800964e:	e7c1      	b.n	80095d4 <HAL_SPI_TransmitReceive_IT.part.4+0x74>
  * @param  Size: amount of data to be sent and received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;
 8009650:	2000      	movs	r0, #0
 8009652:	e793      	b.n	800957c <HAL_SPI_TransmitReceive_IT.part.4+0x1c>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
  }
  else
  {
    /* set fiforxthresold according the reception data length: 8 bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009654:	6822      	ldr	r2, [r4, #0]
 8009656:	6853      	ldr	r3, [r2, #4]
 8009658:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800965c:	6053      	str	r3, [r2, #4]
 800965e:	e7c8      	b.n	80095f2 <HAL_SPI_TransmitReceive_IT.part.4+0x92>
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
 8009660:	6822      	ldr	r2, [r4, #0]
 8009662:	6811      	ldr	r1, [r2, #0]
 8009664:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 8009668:	400b      	ands	r3, r1
 800966a:	6013      	str	r3, [r2, #0]
 800966c:	6822      	ldr	r2, [r4, #0]
 800966e:	6813      	ldr	r3, [r2, #0]
 8009670:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009674:	6013      	str	r3, [r2, #0]
 8009676:	68e5      	ldr	r5, [r4, #12]
 8009678:	e7af      	b.n	80095da <HAL_SPI_TransmitReceive_IT.part.4+0x7a>
    {
      hspi->CRCSize = 2;
    }
  }

  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
 800967a:	2804      	cmp	r0, #4
 800967c:	d196      	bne.n	80095ac <HAL_SPI_TransmitReceive_IT.part.4+0x4c>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800967e:	6627      	str	r7, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = pTxData;
 8009680:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8009682:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 8009684:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->pRxBuffPtr  = pRxData;
 8009686:	6422      	str	r2, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 8009688:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxXferCount = Size;
 800968c:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 8009690:	e79c      	b.n	80095cc <HAL_SPI_TransmitReceive_IT.part.4+0x6c>
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    hspi->CRCSize = 1;
    if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
    {
      hspi->CRCSize = 2;
 8009692:	64a7      	str	r7, [r4, #72]	; 0x48
 8009694:	e7cb      	b.n	800962e <HAL_SPI_TransmitReceive_IT.part.4+0xce>
 8009696:	bf00      	nop
 8009698:	0800a929 	.word	0x0800a929
 800969c:	0800a8e9 	.word	0x0800a8e9
 80096a0:	0800a835 	.word	0x0800a835
 80096a4:	0800a7d9 	.word	0x0800a7d9

080096a8 <HAL_SPI_TransmitReceive_DMA.part.5>:
  * @param  pRxData: pointer to reception data buffer
  * @note  When the CRC feature is enabled the pRxData Length must be Size + 1
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
 80096a8:	b538      	push	{r3, r4, r5, lr}
 80096aa:	4604      	mov	r4, r0
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);

  if(!((hspi->State == HAL_SPI_STATE_READY) ||
 80096ac:	f890 005d 	ldrb.w	r0, [r0, #93]	; 0x5d
{
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);
 80096b0:	2501      	movs	r5, #1

  if(!((hspi->State == HAL_SPI_STATE_READY) ||
 80096b2:	42a8      	cmp	r0, r5
{
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);
 80096b4:	f884 505c 	strb.w	r5, [r4, #92]	; 0x5c

  if(!((hspi->State == HAL_SPI_STATE_READY) ||
 80096b8:	d00d      	beq.n	80096d6 <HAL_SPI_TransmitReceive_DMA.part.5+0x2e>
 80096ba:	6865      	ldr	r5, [r4, #4]
 80096bc:	f5b5 7f82 	cmp.w	r5, #260	; 0x104
 80096c0:	d004      	beq.n	80096cc <HAL_SPI_TransmitReceive_DMA.part.5+0x24>
  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 80096c2:	2300      	movs	r3, #0
 80096c4:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  __HAL_LOCK(hspi);

  if(!((hspi->State == HAL_SPI_STATE_READY) ||
      ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX))))
  {
    errorcode = HAL_BUSY;
 80096c8:	2002      	movs	r0, #2

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 80096ca:	bd38      	pop	{r3, r4, r5, pc}

  /* Process locked */
  __HAL_LOCK(hspi);

  if(!((hspi->State == HAL_SPI_STATE_READY) ||
      ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX))))
 80096cc:	68a5      	ldr	r5, [r4, #8]
 80096ce:	2d00      	cmp	r5, #0
 80096d0:	d1f7      	bne.n	80096c2 <HAL_SPI_TransmitReceive_DMA.part.5+0x1a>
 80096d2:	2804      	cmp	r0, #4
 80096d4:	d1f5      	bne.n	80096c2 <HAL_SPI_TransmitReceive_DMA.part.5+0x1a>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
 80096d6:	2900      	cmp	r1, #0
 80096d8:	d060      	beq.n	800979c <HAL_SPI_TransmitReceive_DMA.part.5+0xf4>
 80096da:	2a00      	cmp	r2, #0
 80096dc:	d05e      	beq.n	800979c <HAL_SPI_TransmitReceive_DMA.part.5+0xf4>
 80096de:	2b00      	cmp	r3, #0
 80096e0:	d05c      	beq.n	800979c <HAL_SPI_TransmitReceive_DMA.part.5+0xf4>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* check if the transmit Receive function is not called by a receive master */
  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
 80096e2:	2804      	cmp	r0, #4
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 80096e4:	bf1c      	itt	ne
 80096e6:	2005      	movne	r0, #5
 80096e8:	f884 005d 	strbne.w	r0, [r4, #93]	; 0x5d
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;

  /* Reset CRC Calculation + increase the rxsize */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80096ec:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 80096ee:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;

  /* Reset CRC Calculation + increase the rxsize */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80096f0:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80096f4:	f04f 0100 	mov.w	r1, #0
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferSize  = Size;
 80096f8:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 80096fa:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 80096fc:	6422      	str	r2, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 80096fe:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxXferCount = Size;
 8009702:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  if(hspi->State != HAL_SPI_STATE_BUSY_RX)
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009706:	6621      	str	r1, [r4, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;

  /* Reset CRC Calculation + increase the rxsize */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009708:	f000 8083 	beq.w	8009812 <HAL_SPI_TransmitReceive_DMA.part.5+0x16a>
  {
    SPI_RESET_CRC(hspi);
  }

  /* Reset the threshold bit */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 800970c:	6822      	ldr	r2, [r4, #0]
 800970e:	6853      	ldr	r3, [r2, #4]
 8009710:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 8009714:	6053      	str	r3, [r2, #4]

  /* the packing mode management is enabled by the DMA settings according the spi data size */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009716:	68e3      	ldr	r3, [r4, #12]
  {
    /* set fiforxthreshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009718:	6822      	ldr	r2, [r4, #0]

  /* Reset the threshold bit */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);

  /* the packing mode management is enabled by the DMA settings according the spi data size */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800971a:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
  {
    /* set fiforxthreshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800971e:	6853      	ldr	r3, [r2, #4]

  /* Reset the threshold bit */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);

  /* the packing mode management is enabled by the DMA settings according the spi data size */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009720:	d941      	bls.n	80097a6 <HAL_SPI_TransmitReceive_DMA.part.5+0xfe>
  {
    /* set fiforxthreshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009722:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8009726:	6053      	str	r3, [r2, #4]
 8009728:	6da3      	ldr	r3, [r4, #88]	; 0x58
    }
  }

  /* Set the SPI Rx DMA transfer complete callback if the transfer request is a
     reception request (RXNE) */
  if(hspi->State == HAL_SPI_STATE_BUSY_RX)
 800972a:	f894 205d 	ldrb.w	r2, [r4, #93]	; 0x5d
 800972e:	2a04      	cmp	r2, #4
 8009730:	d069      	beq.n	8009806 <HAL_SPI_TransmitReceive_DMA.part.5+0x15e>
    hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
  }
  else
  {
    /* Set the SPI Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
 8009732:	4a47      	ldr	r2, [pc, #284]	; (8009850 <HAL_SPI_TransmitReceive_DMA.part.5+0x1a8>)
 8009734:	631a      	str	r2, [r3, #48]	; 0x30
    hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
 8009736:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8009738:	4a46      	ldr	r2, [pc, #280]	; (8009854 <HAL_SPI_TransmitReceive_DMA.part.5+0x1ac>)
 800973a:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  /* Set the DMA error callback */
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 800973c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800973e:	4d46      	ldr	r5, [pc, #280]	; (8009858 <HAL_SPI_TransmitReceive_DMA.part.5+0x1b0>)
 8009740:	635d      	str	r5, [r3, #52]	; 0x34

  /* Enable Rx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8009742:	6822      	ldr	r2, [r4, #0]
 8009744:	6853      	ldr	r3, [r2, #4]
 8009746:	f043 0301 	orr.w	r3, r3, #1
 800974a:	6053      	str	r3, [r2, #4]

  /* Enable the Rx DMA channel */
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t) hspi->pRxBuffPtr, hspi->RxXferCount);
 800974c:	6821      	ldr	r1, [r4, #0]
 800974e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8009750:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009754:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8009756:	310c      	adds	r1, #12
 8009758:	f7f7 fee6 	bl	8001528 <HAL_DMA_Start_IT>

  /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
  is performed in DMA reception complete callback  */
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 800975c:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800975e:	2300      	movs	r3, #0
 8009760:	6313      	str	r3, [r2, #48]	; 0x30
  hspi->hdmatx->XferCpltCallback = NULL;
 8009762:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8009764:	62d3      	str	r3, [r2, #44]	; 0x2c

  /* Set the DMA error callback */
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 8009766:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8009768:	635d      	str	r5, [r3, #52]	; 0x34

  /* Enable the Tx DMA channel */
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 800976a:	6822      	ldr	r2, [r4, #0]
 800976c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800976e:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8009770:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8009772:	320c      	adds	r2, #12
 8009774:	f7f7 fed8 	bl	8001528 <HAL_DMA_Start_IT>

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 8009778:	6823      	ldr	r3, [r4, #0]
 800977a:	681a      	ldr	r2, [r3, #0]
 800977c:	0652      	lsls	r2, r2, #25
 800977e:	d404      	bmi.n	800978a <HAL_SPI_TransmitReceive_DMA.part.5+0xe2>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8009780:	681a      	ldr	r2, [r3, #0]
 8009782:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009786:	601a      	str	r2, [r3, #0]
 8009788:	6823      	ldr	r3, [r4, #0]
  }

  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 800978a:	685a      	ldr	r2, [r3, #4]
 800978c:	f042 0202 	orr.w	r2, r2, #2
 8009790:	605a      	str	r2, [r3, #4]

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 8009792:	2300      	movs	r3, #0
 8009794:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;
 8009798:	2000      	movs	r0, #0

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 800979a:	bd38      	pop	{r3, r4, r5, pc}
  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800979c:	2300      	movs	r3, #0
 800979e:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
    goto error;
  }

  if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
  {
    errorcode = HAL_ERROR;
 80097a2:	2001      	movs	r0, #1

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 80097a4:	bd38      	pop	{r3, r4, r5, pc}
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
  }
  else
  {
    /* set fiforxthresold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80097a6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80097aa:	6053      	str	r3, [r2, #4]

    if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80097ac:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80097ae:	699b      	ldr	r3, [r3, #24]
 80097b0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80097b4:	d01a      	beq.n	80097ec <HAL_SPI_TransmitReceive_DMA.part.5+0x144>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
        hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
      }
    }

    if(hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80097b6:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80097b8:	699a      	ldr	r2, [r3, #24]
 80097ba:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 80097be:	d1b4      	bne.n	800972a <HAL_SPI_TransmitReceive_DMA.part.5+0x82>
    {
      /* set fiforxthresold according the reception data length: 16bit */
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80097c0:	6822      	ldr	r2, [r4, #0]
 80097c2:	6853      	ldr	r3, [r2, #4]
 80097c4:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80097c8:	6053      	str	r3, [r2, #4]

      if((hspi->RxXferCount & 0x1) == 0x0 )
 80097ca:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80097ce:	6822      	ldr	r2, [r4, #0]
    if(hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    {
      /* set fiforxthresold according the reception data length: 16bit */
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);

      if((hspi->RxXferCount & 0x1) == 0x0 )
 80097d0:	f013 0f01 	tst.w	r3, #1
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80097d4:	6853      	ldr	r3, [r2, #4]
    if(hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    {
      /* set fiforxthresold according the reception data length: 16bit */
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);

      if((hspi->RxXferCount & 0x1) == 0x0 )
 80097d6:	d128      	bne.n	800982a <HAL_SPI_TransmitReceive_DMA.part.5+0x182>
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80097d8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80097dc:	6053      	str	r3, [r2, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1;
 80097de:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 80097e2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80097e4:	0852      	lsrs	r2, r2, #1
 80097e6:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
 80097ea:	e79e      	b.n	800972a <HAL_SPI_TransmitReceive_DMA.part.5+0x82>
    /* set fiforxthresold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);

    if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    {
      if((hspi->TxXferSize & 0x1) == 0x0)
 80097ec:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80097ee:	6822      	ldr	r2, [r4, #0]
    /* set fiforxthresold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);

    if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    {
      if((hspi->TxXferSize & 0x1) == 0x0)
 80097f0:	f013 0f01 	tst.w	r3, #1
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80097f4:	6853      	ldr	r3, [r2, #4]
    /* set fiforxthresold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);

    if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    {
      if((hspi->TxXferSize & 0x1) == 0x0)
 80097f6:	d123      	bne.n	8009840 <HAL_SPI_TransmitReceive_DMA.part.5+0x198>
      {
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80097f8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80097fc:	6053      	str	r3, [r2, #4]
        hspi->TxXferCount = hspi->TxXferCount >> 1;
 80097fe:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009800:	085b      	lsrs	r3, r3, #1
 8009802:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8009804:	e7d7      	b.n	80097b6 <HAL_SPI_TransmitReceive_DMA.part.5+0x10e>
  /* Set the SPI Rx DMA transfer complete callback if the transfer request is a
     reception request (RXNE) */
  if(hspi->State == HAL_SPI_STATE_BUSY_RX)
  {
    /* Set the SPI Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 8009806:	4a15      	ldr	r2, [pc, #84]	; (800985c <HAL_SPI_TransmitReceive_DMA.part.5+0x1b4>)
 8009808:	631a      	str	r2, [r3, #48]	; 0x30
    hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 800980a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800980c:	4a14      	ldr	r2, [pc, #80]	; (8009860 <HAL_SPI_TransmitReceive_DMA.part.5+0x1b8>)
 800980e:	62da      	str	r2, [r3, #44]	; 0x2c
 8009810:	e794      	b.n	800973c <HAL_SPI_TransmitReceive_DMA.part.5+0x94>
  hspi->RxXferCount = Size;

  /* Reset CRC Calculation + increase the rxsize */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
 8009812:	6822      	ldr	r2, [r4, #0]
 8009814:	6811      	ldr	r1, [r2, #0]
 8009816:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 800981a:	400b      	ands	r3, r1
 800981c:	6013      	str	r3, [r2, #0]
 800981e:	6822      	ldr	r2, [r4, #0]
 8009820:	6813      	ldr	r3, [r2, #0]
 8009822:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009826:	6013      	str	r3, [r2, #0]
 8009828:	e770      	b.n	800970c <HAL_SPI_TransmitReceive_DMA.part.5+0x64>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
        hspi->RxXferCount = hspi->RxXferCount >> 1;
      }
      else
      {
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 800982a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800982e:	6053      	str	r3, [r2, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1) + 1;
 8009830:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 8009834:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8009836:	0852      	lsrs	r2, r2, #1
 8009838:	3201      	adds	r2, #1
 800983a:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
 800983e:	e774      	b.n	800972a <HAL_SPI_TransmitReceive_DMA.part.5+0x82>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
        hspi->TxXferCount = hspi->TxXferCount >> 1;
      }
      else
      {
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8009840:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8009844:	6053      	str	r3, [r2, #4]
        hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
 8009846:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009848:	085b      	lsrs	r3, r3, #1
 800984a:	3301      	adds	r3, #1
 800984c:	87e3      	strh	r3, [r4, #62]	; 0x3e
 800984e:	e7b2      	b.n	80097b6 <HAL_SPI_TransmitReceive_DMA.part.5+0x10e>
 8009850:	0800a545 	.word	0x0800a545
 8009854:	0800aafd 	.word	0x0800aafd
 8009858:	0800a98d 	.word	0x0800a98d
 800985c:	0800a535 	.word	0x0800a535
 8009860:	0800aa19 	.word	0x0800aa19
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
 __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
 {
 8009864:	4770      	bx	lr
 8009866:	bf00      	nop

08009868 <HAL_SPI_Init>:
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if(hspi == NULL)
 8009868:	2800      	cmp	r0, #0
 800986a:	f000 8093 	beq.w	8009994 <HAL_SPI_Init+0x12c>
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 800986e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
  assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));

  if(hspi->State == HAL_SPI_STATE_RESET)
 8009872:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8009876:	b082      	sub	sp, #8
 8009878:	4680      	mov	r8, r0
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
  assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));

  if(hspi->State == HAL_SPI_STATE_RESET)
 800987a:	2b00      	cmp	r3, #0
 800987c:	d067      	beq.n	800994e <HAL_SPI_Init+0xe6>

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 800987e:	2302      	movs	r3, #2

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8009880:	f8d8 2000 	ldr.w	r2, [r8]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8009884:	f888 305d 	strb.w	r3, [r8, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8009888:	6813      	ldr	r3, [r2, #0]
 800988a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800988e:	6013      	str	r3, [r2, #0]

  /* Align by default the rs fifo threshold on the data size */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009890:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8009894:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8009898:	d90d      	bls.n	80098b6 <HAL_SPI_Init+0x4e>
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
 800989a:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800989e:	d168      	bne.n	8009972 <HAL_SPI_Init+0x10a>
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  }

  /* Align the CRC Length on the data size */
  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80098a0:	f8d8 3030 	ldr.w	r3, [r8, #48]	; 0x30
 80098a4:	f8d8 7028 	ldr.w	r7, [r8, #40]	; 0x28
 80098a8:	2b00      	cmp	r3, #0
 80098aa:	d160      	bne.n	800996e <HAL_SPI_Init+0x106>
  {
    /* CRC Length aligned on the data size : value set by default */
    if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 80098ac:	2302      	movs	r3, #2
 80098ae:	f8c8 3030 	str.w	r3, [r8, #48]	; 0x30
 80098b2:	2000      	movs	r0, #0
 80098b4:	e00c      	b.n	80098d0 <HAL_SPI_Init+0x68>
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
 80098b6:	d066      	beq.n	8009986 <HAL_SPI_Init+0x11e>
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  }

  /* Align the CRC Length on the data size */
  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80098b8:	f8d8 7030 	ldr.w	r7, [r8, #48]	; 0x30

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80098bc:	2300      	movs	r3, #0
 80098be:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
  }

  /* Align the CRC Length on the data size */
  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80098c2:	2f00      	cmp	r7, #0
 80098c4:	d14f      	bne.n	8009966 <HAL_SPI_Init+0xfe>
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
    }
    else
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 80098c6:	2301      	movs	r3, #1
 80098c8:	f8c8 3030 	str.w	r3, [r8, #48]	; 0x30
 80098cc:	f44f 5080 	mov.w	r0, #4096	; 0x1000

  /*---------------------------- SPIx CR1 & CR2 Configuration ------------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit, CRC calculation state, CRC Length */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 80098d0:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80098d4:	f8d8 6004 	ldr.w	r6, [r8, #4]
 80098d8:	9301      	str	r3, [sp, #4]
 80098da:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80098de:	f8d8 5010 	ldr.w	r5, [r8, #16]
 80098e2:	f8d8 4014 	ldr.w	r4, [r8, #20]
 80098e6:	f8d8 101c 	ldr.w	r1, [r8, #28]
 80098ea:	f8d8 2020 	ldr.w	r2, [r8, #32]
 80098ee:	431e      	orrs	r6, r3
 80098f0:	4335      	orrs	r5, r6
 80098f2:	432c      	orrs	r4, r5
 80098f4:	9b01      	ldr	r3, [sp, #4]
 80098f6:	4321      	orrs	r1, r4
 80098f8:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80098fc:	430a      	orrs	r2, r1
 80098fe:	431a      	orrs	r2, r3
  }

  /*---------------------------- SPIx CR1 & CR2 Configuration ------------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit, CRC calculation state, CRC Length */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
 8009900:	f8d8 3000 	ldr.w	r3, [r8]
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 8009904:	433a      	orrs	r2, r7
  }

  /*---------------------------- SPIx CR1 & CR2 Configuration ------------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit, CRC calculation state, CRC Length */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
 8009906:	601a      	str	r2, [r3, #0]
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);

  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8009908:	f8d8 3030 	ldr.w	r3, [r8, #48]	; 0x30
 800990c:	2b02      	cmp	r3, #2
 800990e:	d023      	beq.n	8009958 <HAL_SPI_Init+0xf0>
 8009910:	f8d8 5034 	ldr.w	r5, [r8, #52]	; 0x34
 8009914:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8009918:	f8d8 100c 	ldr.w	r1, [r8, #12]
    hspi->Instance->CR1|= SPI_CR1_CRCL;
  }

  /* Configure : NSS management */
  /* Configure : Rx Fifo Threshold */
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode | hspi->Init.NSSPMode |
 800991c:	f8b8 201a 	ldrh.w	r2, [r8, #26]
 8009920:	f8d8 4000 	ldr.w	r4, [r8]
 8009924:	432b      	orrs	r3, r5
 8009926:	430b      	orrs	r3, r1
 8009928:	f002 0204 	and.w	r2, r2, #4
 800992c:	4313      	orrs	r3, r2
                         hspi->Init.DataSize ) | frxth;
 800992e:	4303      	orrs	r3, r0
    hspi->Instance->CR1|= SPI_CR1_CRCL;
  }

  /* Configure : NSS management */
  /* Configure : Rx Fifo Threshold */
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode | hspi->Init.NSSPMode |
 8009930:	6063      	str	r3, [r4, #4]
                         hspi->Init.DataSize ) | frxth;

  /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Configure : CRC Polynomial */
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
 8009932:	f8d8 3000 	ldr.w	r3, [r8]
 8009936:	f8d8 202c 	ldr.w	r2, [r8, #44]	; 0x2c
 800993a:	611a      	str	r2, [r3, #16]

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800993c:	2000      	movs	r0, #0
  hspi->State= HAL_SPI_STATE_READY;
 800993e:	2301      	movs	r3, #1

  /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Configure : CRC Polynomial */
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8009940:	f8c8 0060 	str.w	r0, [r8, #96]	; 0x60
  hspi->State= HAL_SPI_STATE_READY;
 8009944:	f888 305d 	strb.w	r3, [r8, #93]	; 0x5d

  return HAL_OK;
}
 8009948:	b002      	add	sp, #8
 800994a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));

  if(hspi->State == HAL_SPI_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800994e:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8009952:	f7f6 fef9 	bl	8000748 <HAL_SPI_MspInit>
 8009956:	e792      	b.n	800987e <HAL_SPI_Init+0x16>
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);

  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
  {
    hspi->Instance->CR1|= SPI_CR1_CRCL;
 8009958:	f8d8 2000 	ldr.w	r2, [r8]
 800995c:	6813      	ldr	r3, [r2, #0]
 800995e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009962:	6013      	str	r3, [r2, #0]
 8009964:	e7d4      	b.n	8009910 <HAL_SPI_Init+0xa8>
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  }

  /* Align the CRC Length on the data size */
  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8009966:	461f      	mov	r7, r3
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8009968:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800996c:	e7b0      	b.n	80098d0 <HAL_SPI_Init+0x68>
  __HAL_SPI_DISABLE(hspi);

  /* Align by default the rs fifo threshold on the data size */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800996e:	2000      	movs	r0, #0
 8009970:	e7ae      	b.n	80098d0 <HAL_SPI_Init+0x68>
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  }

  /* Align the CRC Length on the data size */
  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8009972:	f8d8 7030 	ldr.w	r7, [r8, #48]	; 0x30

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8009976:	2300      	movs	r3, #0
 8009978:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
  }

  /* Align the CRC Length on the data size */
  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 800997c:	2f00      	cmp	r7, #0
 800997e:	d095      	beq.n	80098ac <HAL_SPI_Init+0x44>
 8009980:	461f      	mov	r7, r3
  __HAL_SPI_DISABLE(hspi);

  /* Align by default the rs fifo threshold on the data size */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8009982:	4618      	mov	r0, r3
 8009984:	e7a4      	b.n	80098d0 <HAL_SPI_Init+0x68>
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  }

  /* Align the CRC Length on the data size */
  if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8009986:	f8d8 3030 	ldr.w	r3, [r8, #48]	; 0x30
 800998a:	f8d8 7028 	ldr.w	r7, [r8, #40]	; 0x28
 800998e:	2b00      	cmp	r3, #0
 8009990:	d099      	beq.n	80098c6 <HAL_SPI_Init+0x5e>
 8009992:	e79b      	b.n	80098cc <HAL_SPI_Init+0x64>
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
 8009994:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State= HAL_SPI_STATE_READY;

  return HAL_OK;
}
 8009996:	4770      	bx	lr
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
 __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
{
 8009998:	4770      	bx	lr
 800999a:	bf00      	nop

0800999c <HAL_SPI_DeInit>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 800999c:	b190      	cbz	r0, 80099c4 <HAL_SPI_DeInit+0x28>
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
{
 800999e:	b510      	push	{r4, lr}
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
  hspi->State = HAL_SPI_STATE_BUSY;
 80099a0:	2302      	movs	r3, #2

  /* Disable the SPI Peripheral Clock */
  __HAL_SPI_DISABLE(hspi);
 80099a2:	6802      	ldr	r2, [r0, #0]
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
  hspi->State = HAL_SPI_STATE_BUSY;
 80099a4:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d

  /* Disable the SPI Peripheral Clock */
  __HAL_SPI_DISABLE(hspi);
 80099a8:	6813      	ldr	r3, [r2, #0]
 80099aa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80099ae:	4604      	mov	r4, r0
 80099b0:	6013      	str	r3, [r2, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_SPI_MspDeInit(hspi);
 80099b2:	f7f6 ff7b 	bl	80008ac <HAL_SPI_MspDeInit>

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80099b6:	2000      	movs	r0, #0
 80099b8:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_RESET;
 80099ba:	f884 005d 	strb.w	r0, [r4, #93]	; 0x5d

  __HAL_UNLOCK(hspi);
 80099be:	f884 005c 	strb.w	r0, [r4, #92]	; 0x5c

  return HAL_OK;
 80099c2:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
 80099c4:	2001      	movs	r0, #1
 80099c6:	4770      	bx	lr

080099c8 <HAL_SPI_Transmit>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80099c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80099cc:	4604      	mov	r4, r0
 80099ce:	b082      	sub	sp, #8
 80099d0:	461d      	mov	r5, r3
 80099d2:	4688      	mov	r8, r1
 80099d4:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 80099d6:	f7f7 f897 	bl	8000b08 <HAL_GetTick>
  HAL_StatusTypeDef errorcode = HAL_OK;

  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 80099da:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 80099de:	2b01      	cmp	r3, #1
 80099e0:	d011      	beq.n	8009a06 <HAL_SPI_Transmit+0x3e>
 80099e2:	4606      	mov	r6, r0

  if(hspi->State != HAL_SPI_STATE_READY)
 80099e4:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  HAL_StatusTypeDef errorcode = HAL_OK;

  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 80099e8:	2301      	movs	r3, #1

  if(hspi->State != HAL_SPI_STATE_READY)
 80099ea:	4298      	cmp	r0, r3
  HAL_StatusTypeDef errorcode = HAL_OK;

  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 80099ec:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c

  if(hspi->State != HAL_SPI_STATE_READY)
 80099f0:	d00d      	beq.n	8009a0e <HAL_SPI_Transmit+0x46>
  {
    errorcode = HAL_BUSY;
 80099f2:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error:
  hspi->State = HAL_SPI_STATE_READY;
 80099f4:	2201      	movs	r2, #1
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 80099f6:	2300      	movs	r3, #0
  {
    errorcode = HAL_ERROR;
  }

error:
  hspi->State = HAL_SPI_STATE_READY;
 80099f8:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 80099fc:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
}
 8009a00:	b002      	add	sp, #8
 8009a02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  HAL_StatusTypeDef errorcode = HAL_OK;

  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8009a06:	2002      	movs	r0, #2
error:
  hspi->State = HAL_SPI_STATE_READY;
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8009a08:	b002      	add	sp, #8
 8009a0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pData == NULL ) || (Size == 0))
 8009a0e:	f1b8 0f00 	cmp.w	r8, #0
 8009a12:	d0ef      	beq.n	80099f4 <HAL_SPI_Transmit+0x2c>
 8009a14:	2f00      	cmp	r7, #0
 8009a16:	d0ed      	beq.n	80099f4 <HAL_SPI_Transmit+0x2c>
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0;
  hspi->RxXferCount = 0;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009a18:	68a2      	ldr	r2, [r4, #8]
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = pData;
 8009a1a:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009a1e:	2300      	movs	r3, #0
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8009a20:	2103      	movs	r1, #3
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0;
  hspi->RxXferCount = 0;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009a22:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = pData;
  hspi->TxXferSize  = Size;
 8009a26:	87a7      	strh	r7, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 8009a28:	87e7      	strh	r7, [r4, #62]	; 0x3e
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8009a2a:	f884 105d 	strb.w	r1, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009a2e:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8009a30:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->RxXferSize  = 0;
 8009a32:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxXferCount = 0;
 8009a36:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009a3a:	d05e      	beq.n	8009afa <HAL_SPI_Transmit+0x132>
  {
    SPI_1LINE_TX(hspi);
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009a3c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009a3e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009a42:	d04e      	beq.n	8009ae2 <HAL_SPI_Transmit+0x11a>
  {
    SPI_RESET_CRC(hspi);
  }

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8009a44:	6823      	ldr	r3, [r4, #0]
 8009a46:	681a      	ldr	r2, [r3, #0]
 8009a48:	0652      	lsls	r2, r2, #25
 8009a4a:	d403      	bmi.n	8009a54 <HAL_SPI_Transmit+0x8c>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8009a4c:	681a      	ldr	r2, [r3, #0]
 8009a4e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009a52:	601a      	str	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009a54:	68e3      	ldr	r3, [r4, #12]
 8009a56:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8009a58:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8009a5c:	d81c      	bhi.n	8009a98 <HAL_SPI_Transmit+0xd0>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    while (hspi->TxXferCount > 0)
 8009a5e:	2a00      	cmp	r2, #0
 8009a60:	d051      	beq.n	8009b06 <HAL_SPI_Transmit+0x13e>
    {
      /* Wait until TXE flag is set to send data */
      if((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE)
 8009a62:	6823      	ldr	r3, [r4, #0]
 8009a64:	6899      	ldr	r1, [r3, #8]
 8009a66:	0789      	lsls	r1, r1, #30
 8009a68:	d527      	bpl.n	8009aba <HAL_SPI_Transmit+0xf2>
      {
        if(hspi->TxXferCount > 1)
 8009a6a:	2a01      	cmp	r2, #1
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 8009a6c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    while (hspi->TxXferCount > 0)
    {
      /* Wait until TXE flag is set to send data */
      if((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE)
      {
        if(hspi->TxXferCount > 1)
 8009a6e:	d92f      	bls.n	8009ad0 <HAL_SPI_Transmit+0x108>
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 8009a70:	8812      	ldrh	r2, [r2, #0]
 8009a72:	60da      	str	r2, [r3, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
          hspi->TxXferCount -= 2;
 8009a74:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
      {
        if(hspi->TxXferCount > 1)
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8009a76:	6ba3      	ldr	r3, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2;
 8009a78:	3a02      	subs	r2, #2
 8009a7a:	b292      	uxth	r2, r2
      {
        if(hspi->TxXferCount > 1)
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8009a7c:	3302      	adds	r3, #2
          hspi->TxXferCount -= 2;
 8009a7e:	87e2      	strh	r2, [r4, #62]	; 0x3e
      {
        if(hspi->TxXferCount > 1)
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8009a80:	63a3      	str	r3, [r4, #56]	; 0x38
 8009a82:	e7ec      	b.n	8009a5e <HAL_SPI_Transmit+0x96>
          hspi->TxXferCount--;
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 8009a84:	2d00      	cmp	r5, #0
 8009a86:	d056      	beq.n	8009b36 <HAL_SPI_Transmit+0x16e>
 8009a88:	1c68      	adds	r0, r5, #1
 8009a8a:	d005      	beq.n	8009a98 <HAL_SPI_Transmit+0xd0>
 8009a8c:	f7f7 f83c 	bl	8000b08 <HAL_GetTick>
 8009a90:	1b80      	subs	r0, r0, r6
 8009a92:	4285      	cmp	r5, r0
 8009a94:	d94f      	bls.n	8009b36 <HAL_SPI_Transmit+0x16e>
 8009a96:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e

  /* Transmit data in 16 Bit mode */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
  {
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0)
 8009a98:	2a00      	cmp	r2, #0
 8009a9a:	d034      	beq.n	8009b06 <HAL_SPI_Transmit+0x13e>
    {
      /* Wait until TXE flag is set to send data */
      if((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE)
 8009a9c:	6823      	ldr	r3, [r4, #0]
 8009a9e:	6899      	ldr	r1, [r3, #8]
 8009aa0:	078f      	lsls	r7, r1, #30
 8009aa2:	d5ef      	bpl.n	8009a84 <HAL_SPI_Transmit+0xbc>
      {
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8009aa4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009aa6:	8812      	ldrh	r2, [r2, #0]
 8009aa8:	60da      	str	r2, [r3, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
          hspi->TxXferCount--;
 8009aaa:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    {
      /* Wait until TXE flag is set to send data */
      if((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE)
      {
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8009aac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 8009aae:	3a01      	subs	r2, #1
 8009ab0:	b292      	uxth	r2, r2
    {
      /* Wait until TXE flag is set to send data */
      if((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE)
      {
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8009ab2:	3302      	adds	r3, #2
          hspi->TxXferCount--;
 8009ab4:	87e2      	strh	r2, [r4, #62]	; 0x3e
    {
      /* Wait until TXE flag is set to send data */
      if((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE)
      {
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8009ab6:	63a3      	str	r3, [r4, #56]	; 0x38
 8009ab8:	e7ee      	b.n	8009a98 <HAL_SPI_Transmit+0xd0>
        }
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 8009aba:	2d00      	cmp	r5, #0
 8009abc:	d03b      	beq.n	8009b36 <HAL_SPI_Transmit+0x16e>
 8009abe:	1c6b      	adds	r3, r5, #1
 8009ac0:	d0cd      	beq.n	8009a5e <HAL_SPI_Transmit+0x96>
 8009ac2:	f7f7 f821 	bl	8000b08 <HAL_GetTick>
 8009ac6:	1b80      	subs	r0, r0, r6
 8009ac8:	4285      	cmp	r5, r0
 8009aca:	d934      	bls.n	8009b36 <HAL_SPI_Transmit+0x16e>
 8009acc:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8009ace:	e7c6      	b.n	8009a5e <HAL_SPI_Transmit+0x96>
          hspi->pTxBuffPtr += sizeof(uint16_t);
          hspi->TxXferCount -= 2;
        }
        else
        {
          *((__IO uint8_t*)&hspi->Instance->DR) = (*hspi->pTxBuffPtr++);
 8009ad0:	1c51      	adds	r1, r2, #1
 8009ad2:	63a1      	str	r1, [r4, #56]	; 0x38
 8009ad4:	7812      	ldrb	r2, [r2, #0]
 8009ad6:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 8009ad8:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8009ada:	3a01      	subs	r2, #1
 8009adc:	b292      	uxth	r2, r2
 8009ade:	87e2      	strh	r2, [r4, #62]	; 0x3e
 8009ae0:	e7bd      	b.n	8009a5e <HAL_SPI_Transmit+0x96>
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
 8009ae2:	6822      	ldr	r2, [r4, #0]
 8009ae4:	6811      	ldr	r1, [r2, #0]
 8009ae6:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 8009aea:	400b      	ands	r3, r1
 8009aec:	6013      	str	r3, [r2, #0]
 8009aee:	6822      	ldr	r2, [r4, #0]
 8009af0:	6813      	ldr	r3, [r2, #0]
 8009af2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009af6:	6013      	str	r3, [r2, #0]
 8009af8:	e7a4      	b.n	8009a44 <HAL_SPI_Transmit+0x7c>
  hspi->RxXferCount = 0;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 8009afa:	6822      	ldr	r2, [r4, #0]
 8009afc:	6813      	ldr	r3, [r2, #0]
 8009afe:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8009b02:	6013      	str	r3, [r2, #0]
 8009b04:	e79a      	b.n	8009a3c <HAL_SPI_Transmit+0x74>
      }
    }
  }

  /* Enable CRC Transmission */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009b06:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009b08:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009b0c:	d019      	beq.n	8009b42 <HAL_SPI_Transmit+0x17a>
  {
     hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
  }

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
 8009b0e:	4629      	mov	r1, r5
 8009b10:	4620      	mov	r0, r4
 8009b12:	f7ff fcd3 	bl	80094bc <SPI_EndRxTxTransaction>
 8009b16:	b980      	cbnz	r0, 8009b3a <HAL_SPI_Transmit+0x172>
 8009b18:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8009b1a:	3000      	adds	r0, #0
 8009b1c:	bf18      	it	ne
 8009b1e:	2001      	movne	r0, #1
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
  }
  
  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8009b20:	68a3      	ldr	r3, [r4, #8]
 8009b22:	2b00      	cmp	r3, #0
 8009b24:	f47f af66 	bne.w	80099f4 <HAL_SPI_Transmit+0x2c>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8009b28:	6823      	ldr	r3, [r4, #0]
 8009b2a:	68da      	ldr	r2, [r3, #12]
 8009b2c:	9201      	str	r2, [sp, #4]
 8009b2e:	689b      	ldr	r3, [r3, #8]
 8009b30:	9301      	str	r3, [sp, #4]
 8009b32:	9b01      	ldr	r3, [sp, #4]
 8009b34:	e75e      	b.n	80099f4 <HAL_SPI_Transmit+0x2c>
      else
      {
        /* Timeout management */
        if((Timeout == 0) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
        {
          errorcode = HAL_TIMEOUT;
 8009b36:	2003      	movs	r0, #3
 8009b38:	e75c      	b.n	80099f4 <HAL_SPI_Transmit+0x2c>
  }

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8009b3a:	2320      	movs	r3, #32
 8009b3c:	6623      	str	r3, [r4, #96]	; 0x60
 8009b3e:	2001      	movs	r0, #1
 8009b40:	e7ee      	b.n	8009b20 <HAL_SPI_Transmit+0x158>
  }

  /* Enable CRC Transmission */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
     hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
 8009b42:	6822      	ldr	r2, [r4, #0]
 8009b44:	6813      	ldr	r3, [r2, #0]
 8009b46:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8009b4a:	6013      	str	r3, [r2, #0]
 8009b4c:	e7df      	b.n	8009b0e <HAL_SPI_Transmit+0x146>
 8009b4e:	bf00      	nop

08009b50 <HAL_SPI_TransmitReceive>:
  * @param  Size: amount of data to be sent and received
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 8009b50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009b54:	4604      	mov	r4, r0
 8009b56:	b083      	sub	sp, #12
 8009b58:	461f      	mov	r7, r3
 8009b5a:	4688      	mov	r8, r1
 8009b5c:	4691      	mov	r9, r2
 8009b5e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
__IO uint16_t tmpreg;
  uint32_t tickstart = HAL_GetTick();
 8009b60:	f7f6 ffd2 	bl	8000b08 <HAL_GetTick>
  HAL_StatusTypeDef errorcode = HAL_OK;

  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8009b64:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 8009b68:	2b01      	cmp	r3, #1
 8009b6a:	d012      	beq.n	8009b92 <HAL_SPI_TransmitReceive+0x42>
 8009b6c:	4605      	mov	r5, r0

  if(hspi->State != HAL_SPI_STATE_READY)
 8009b6e:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  HAL_StatusTypeDef errorcode = HAL_OK;

  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8009b72:	2301      	movs	r3, #1

  if(hspi->State != HAL_SPI_STATE_READY)
 8009b74:	4298      	cmp	r0, r3
  HAL_StatusTypeDef errorcode = HAL_OK;

  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8009b76:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c

  if(hspi->State != HAL_SPI_STATE_READY)
 8009b7a:	d00e      	beq.n	8009b9a <HAL_SPI_TransmitReceive+0x4a>
  {
    errorcode = HAL_BUSY;
 8009b7c:	2502      	movs	r5, #2
  {
    errorcode = HAL_ERROR;
  }

error :
  hspi->State = HAL_SPI_STATE_READY;
 8009b7e:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8009b80:	2300      	movs	r3, #0
  return errorcode;
 8009b82:	4628      	mov	r0, r5
  {
    errorcode = HAL_ERROR;
  }

error :
  hspi->State = HAL_SPI_STATE_READY;
 8009b84:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8009b88:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
}
 8009b8c:	b003      	add	sp, #12
 8009b8e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  HAL_StatusTypeDef errorcode = HAL_OK;

  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8009b92:	2002      	movs	r0, #2

error :
  hspi->State = HAL_SPI_STATE_READY;
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8009b94:	b003      	add	sp, #12
 8009b96:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
 8009b9a:	f1b8 0f00 	cmp.w	r8, #0
 8009b9e:	f000 80e3 	beq.w	8009d68 <HAL_SPI_TransmitReceive+0x218>
 8009ba2:	f1b9 0f00 	cmp.w	r9, #0
 8009ba6:	d05e      	beq.n	8009c66 <HAL_SPI_TransmitReceive+0x116>
 8009ba8:	2f00      	cmp	r7, #0
 8009baa:	d05c      	beq.n	8009c66 <HAL_SPI_TransmitReceive+0x116>
  hspi->pTxBuffPtr  = pTxData;
  hspi->TxXferCount = Size;
  hspi->TxXferSize  = Size;

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009bac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = pRxData;
 8009bae:	f8c4 9040 	str.w	r9, [r4, #64]	; 0x40
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
 8009bb2:	2105      	movs	r1, #5
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009bb4:	2200      	movs	r2, #0
  hspi->pTxBuffPtr  = pTxData;
  hspi->TxXferCount = Size;
  hspi->TxXferSize  = Size;

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009bb6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  }

  hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = pRxData;
  hspi->RxXferCount = Size;
 8009bba:	f8a4 7046 	strh.w	r7, [r4, #70]	; 0x46
  hspi->RxXferSize  = Size;
 8009bbe:	f8a4 7044 	strh.w	r7, [r4, #68]	; 0x44
  hspi->pTxBuffPtr  = pTxData;
 8009bc2:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
  hspi->TxXferCount = Size;
 8009bc6:	87e7      	strh	r7, [r4, #62]	; 0x3e
  hspi->TxXferSize  = Size;
 8009bc8:	87a7      	strh	r7, [r4, #60]	; 0x3c
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
 8009bca:	f884 105d 	strb.w	r1, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009bce:	6622      	str	r2, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = pTxData;
  hspi->TxXferCount = Size;
  hspi->TxXferSize  = Size;

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009bd0:	f000 808d 	beq.w	8009cee <HAL_SPI_TransmitReceive+0x19e>
  {
    SPI_RESET_CRC(hspi);
  }

  /* Set the Rx Fido threshold */
  if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1))
 8009bd4:	68e3      	ldr	r3, [r4, #12]
 8009bd6:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8009bda:	d97d      	bls.n	8009cd8 <HAL_SPI_TransmitReceive+0x188>
  {
    /* set fiforxthreshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009bdc:	6822      	ldr	r2, [r4, #0]
 8009bde:	6853      	ldr	r3, [r2, #4]
 8009be0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8009be4:	6053      	str	r3, [r2, #4]
    /* set fiforxthreshold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
  }

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 8009be6:	6823      	ldr	r3, [r4, #0]
 8009be8:	681a      	ldr	r2, [r3, #0]
 8009bea:	0650      	lsls	r0, r2, #25
 8009bec:	d403      	bmi.n	8009bf6 <HAL_SPI_TransmitReceive+0xa6>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8009bee:	681a      	ldr	r2, [r3, #0]
 8009bf0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009bf4:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009bf6:	68e3      	ldr	r3, [r4, #12]
 8009bf8:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8009bfc:	d817      	bhi.n	8009c2e <HAL_SPI_TransmitReceive+0xde>
 8009bfe:	e04e      	b.n	8009c9e <HAL_SPI_TransmitReceive+0x14e>
  {
    while ((hspi->TxXferCount > 0 ) || (hspi->RxXferCount > 0))
 8009c00:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009c04:	2b00      	cmp	r3, #0
 8009c06:	f000 8097 	beq.w	8009d38 <HAL_SPI_TransmitReceive+0x1e8>
          hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
        }
      }

      /* Check RXNE flag */
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
 8009c0a:	6823      	ldr	r3, [r4, #0]
 8009c0c:	689a      	ldr	r2, [r3, #8]
 8009c0e:	07d2      	lsls	r2, r2, #31
 8009c10:	d50a      	bpl.n	8009c28 <HAL_SPI_TransmitReceive+0xd8>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8009c12:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8009c14:	68db      	ldr	r3, [r3, #12]
 8009c16:	8013      	strh	r3, [r2, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8009c18:	6c22      	ldr	r2, [r4, #64]	; 0x40
        hspi->RxXferCount--;
 8009c1a:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46

      /* Check RXNE flag */
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
      {
        *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8009c1e:	3202      	adds	r2, #2
        hspi->RxXferCount--;
 8009c20:	3b01      	subs	r3, #1

      /* Check RXNE flag */
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
      {
        *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8009c22:	6422      	str	r2, [r4, #64]	; 0x40
        hspi->RxXferCount--;
 8009c24:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
      }
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
 8009c28:	1c77      	adds	r7, r6, #1
 8009c2a:	f040 80a6 	bne.w	8009d7a <HAL_SPI_TransmitReceive+0x22a>
  }

  /* Transmit and Receive data in 16 Bit mode */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
  {
    while ((hspi->TxXferCount > 0 ) || (hspi->RxXferCount > 0))
 8009c2e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009c30:	2b00      	cmp	r3, #0
 8009c32:	d0e5      	beq.n	8009c00 <HAL_SPI_TransmitReceive+0xb0>
    {
      /* Check TXE flag */
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
 8009c34:	6823      	ldr	r3, [r4, #0]
 8009c36:	689a      	ldr	r2, [r3, #8]
 8009c38:	0791      	lsls	r1, r2, #30
 8009c3a:	d50f      	bpl.n	8009c5c <HAL_SPI_TransmitReceive+0x10c>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8009c3c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009c3e:	8812      	ldrh	r2, [r2, #0]
 8009c40:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
        hspi->TxXferCount--;
 8009c42:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
    {
      /* Check TXE flag */
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8009c44:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8009c46:	3b01      	subs	r3, #1
 8009c48:	b29b      	uxth	r3, r3
    {
      /* Check TXE flag */
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8009c4a:	3202      	adds	r2, #2
        hspi->TxXferCount--;
 8009c4c:	87e3      	strh	r3, [r4, #62]	; 0x3e
    {
      /* Check TXE flag */
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8009c4e:	63a2      	str	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;

        /* Enable CRC Transmission */
        if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 8009c50:	b923      	cbnz	r3, 8009c5c <HAL_SPI_TransmitReceive+0x10c>
 8009c52:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009c54:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009c58:	f000 80a1 	beq.w	8009d9e <HAL_SPI_TransmitReceive+0x24e>
          hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
        }
      }

      /* Check RXNE flag */
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
 8009c5c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009c60:	2b00      	cmp	r3, #0
 8009c62:	d0e1      	beq.n	8009c28 <HAL_SPI_TransmitReceive+0xd8>
 8009c64:	e7d1      	b.n	8009c0a <HAL_SPI_TransmitReceive+0xba>
    goto error;
  }

  if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
  {
    errorcode = HAL_ERROR;
 8009c66:	4605      	mov	r5, r0
 8009c68:	e789      	b.n	8009b7e <HAL_SPI_TransmitReceive+0x2e>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    while((hspi->TxXferCount > 0) || (hspi->RxXferCount > 0))
 8009c6a:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009c6e:	2b00      	cmp	r3, #0
 8009c70:	d062      	beq.n	8009d38 <HAL_SPI_TransmitReceive+0x1e8>
          hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
        }
      }

      /* Wait until RXNE flag is reset */
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
 8009c72:	6822      	ldr	r2, [r4, #0]
 8009c74:	6891      	ldr	r1, [r2, #8]
 8009c76:	07c9      	lsls	r1, r1, #31
 8009c78:	d50f      	bpl.n	8009c9a <HAL_SPI_TransmitReceive+0x14a>
      {
        if(hspi->RxXferCount > 1)
 8009c7a:	2b01      	cmp	r3, #1
        {
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8009c7c:	6c23      	ldr	r3, [r4, #64]	; 0x40
      }

      /* Wait until RXNE flag is reset */
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
      {
        if(hspi->RxXferCount > 1)
 8009c7e:	d94b      	bls.n	8009d18 <HAL_SPI_TransmitReceive+0x1c8>
        {
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8009c80:	68d2      	ldr	r2, [r2, #12]
 8009c82:	801a      	strh	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint16_t);
          hspi->RxXferCount -= 2;
 8009c84:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
      {
        if(hspi->RxXferCount > 1)
        {
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
          hspi->pRxBuffPtr += sizeof(uint16_t);
 8009c88:	6c22      	ldr	r2, [r4, #64]	; 0x40
          hspi->RxXferCount -= 2;
 8009c8a:	3b02      	subs	r3, #2
 8009c8c:	b29b      	uxth	r3, r3
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
      {
        if(hspi->RxXferCount > 1)
        {
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
          hspi->pRxBuffPtr += sizeof(uint16_t);
 8009c8e:	3202      	adds	r2, #2
          hspi->RxXferCount -= 2;
          if(hspi->RxXferCount <= 1)
 8009c90:	2b01      	cmp	r3, #1
      {
        if(hspi->RxXferCount > 1)
        {
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
          hspi->pRxBuffPtr += sizeof(uint16_t);
          hspi->RxXferCount -= 2;
 8009c92:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
      {
        if(hspi->RxXferCount > 1)
        {
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
          hspi->pRxBuffPtr += sizeof(uint16_t);
 8009c96:	6422      	str	r2, [r4, #64]	; 0x40
          hspi->RxXferCount -= 2;
          if(hspi->RxXferCount <= 1)
 8009c98:	d948      	bls.n	8009d2c <HAL_SPI_TransmitReceive+0x1dc>
        {
          (*hspi->pRxBuffPtr++) =  *(__IO uint8_t *)&hspi->Instance->DR;
          hspi->RxXferCount--;
        }
      }
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
 8009c9a:	1c73      	adds	r3, r6, #1
 8009c9c:	d166      	bne.n	8009d6c <HAL_SPI_TransmitReceive+0x21c>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    while((hspi->TxXferCount > 0) || (hspi->RxXferCount > 0))
 8009c9e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009ca0:	2b00      	cmp	r3, #0
 8009ca2:	d0e2      	beq.n	8009c6a <HAL_SPI_TransmitReceive+0x11a>
    {
      /* check TXE flag */
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
 8009ca4:	6822      	ldr	r2, [r4, #0]
 8009ca6:	6891      	ldr	r1, [r2, #8]
 8009ca8:	0788      	lsls	r0, r1, #30
 8009caa:	d510      	bpl.n	8009cce <HAL_SPI_TransmitReceive+0x17e>
      {
        if(hspi->TxXferCount > 1)
 8009cac:	2b01      	cmp	r3, #1
        {
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 8009cae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    while((hspi->TxXferCount > 0) || (hspi->RxXferCount > 0))
    {
      /* check TXE flag */
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
      {
        if(hspi->TxXferCount > 1)
 8009cb0:	d929      	bls.n	8009d06 <HAL_SPI_TransmitReceive+0x1b6>
        {
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 8009cb2:	881b      	ldrh	r3, [r3, #0]
 8009cb4:	60d3      	str	r3, [r2, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
          hspi->TxXferCount -= 2;
 8009cb6:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
      {
        if(hspi->TxXferCount > 1)
        {
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8009cb8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2;
 8009cba:	3b02      	subs	r3, #2
 8009cbc:	b29b      	uxth	r3, r3
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
      {
        if(hspi->TxXferCount > 1)
        {
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8009cbe:	3202      	adds	r2, #2
          hspi->TxXferCount -= 2;
 8009cc0:	87e3      	strh	r3, [r4, #62]	; 0x3e
      if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
      {
        if(hspi->TxXferCount > 1)
        {
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8009cc2:	63a2      	str	r2, [r4, #56]	; 0x38
          *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
          hspi->TxXferCount--;
        }

        /* Enable CRC Transmission */
        if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 8009cc4:	b91b      	cbnz	r3, 8009cce <HAL_SPI_TransmitReceive+0x17e>
 8009cc6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009cc8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009ccc:	d061      	beq.n	8009d92 <HAL_SPI_TransmitReceive+0x242>
          hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
        }
      }

      /* Wait until RXNE flag is reset */
      if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
 8009cce:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009cd2:	2b00      	cmp	r3, #0
 8009cd4:	d0e1      	beq.n	8009c9a <HAL_SPI_TransmitReceive+0x14a>
 8009cd6:	e7cc      	b.n	8009c72 <HAL_SPI_TransmitReceive+0x122>
  {
    SPI_RESET_CRC(hspi);
  }

  /* Set the Rx Fido threshold */
  if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1))
 8009cd8:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009cdc:	2b01      	cmp	r3, #1
 8009cde:	f63f af7d 	bhi.w	8009bdc <HAL_SPI_TransmitReceive+0x8c>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
  }
  else
  {
    /* set fiforxthreshold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009ce2:	6822      	ldr	r2, [r4, #0]
 8009ce4:	6853      	ldr	r3, [r2, #4]
 8009ce6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8009cea:	6053      	str	r3, [r2, #4]
 8009cec:	e77b      	b.n	8009be6 <HAL_SPI_TransmitReceive+0x96>
  hspi->TxXferSize  = Size;

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
 8009cee:	6822      	ldr	r2, [r4, #0]
 8009cf0:	6811      	ldr	r1, [r2, #0]
 8009cf2:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 8009cf6:	400b      	ands	r3, r1
 8009cf8:	6013      	str	r3, [r2, #0]
 8009cfa:	6822      	ldr	r2, [r4, #0]
 8009cfc:	6813      	ldr	r3, [r2, #0]
 8009cfe:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009d02:	6013      	str	r3, [r2, #0]
 8009d04:	e766      	b.n	8009bd4 <HAL_SPI_TransmitReceive+0x84>
          hspi->pTxBuffPtr += sizeof(uint16_t);
          hspi->TxXferCount -= 2;
        }
        else
        {
          *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 8009d06:	1c59      	adds	r1, r3, #1
 8009d08:	63a1      	str	r1, [r4, #56]	; 0x38
 8009d0a:	781b      	ldrb	r3, [r3, #0]
 8009d0c:	7313      	strb	r3, [r2, #12]
          hspi->TxXferCount--;
 8009d0e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009d10:	3b01      	subs	r3, #1
 8009d12:	b29b      	uxth	r3, r3
 8009d14:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8009d16:	e7d5      	b.n	8009cc4 <HAL_SPI_TransmitReceive+0x174>
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
          }
        }
        else
        {
          (*hspi->pRxBuffPtr++) =  *(__IO uint8_t *)&hspi->Instance->DR;
 8009d18:	1c59      	adds	r1, r3, #1
 8009d1a:	6421      	str	r1, [r4, #64]	; 0x40
 8009d1c:	7b12      	ldrb	r2, [r2, #12]
 8009d1e:	701a      	strb	r2, [r3, #0]
          hspi->RxXferCount--;
 8009d20:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009d24:	3b01      	subs	r3, #1
 8009d26:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 8009d2a:	e7b6      	b.n	8009c9a <HAL_SPI_TransmitReceive+0x14a>
          hspi->pRxBuffPtr += sizeof(uint16_t);
          hspi->RxXferCount -= 2;
          if(hspi->RxXferCount <= 1)
          {
            /* set fiforxthresold before to switch on 8 bit data size */
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009d2c:	6822      	ldr	r2, [r4, #0]
 8009d2e:	6853      	ldr	r3, [r2, #4]
 8009d30:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8009d34:	6053      	str	r3, [r2, #4]
 8009d36:	e7b0      	b.n	8009c9a <HAL_SPI_TransmitReceive+0x14a>
      }
    }
  }

  /* Read CRC from DR to close CRC calculation process */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009d38:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009d3a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009d3e:	d036      	beq.n	8009dae <HAL_SPI_TransmitReceive+0x25e>
 8009d40:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 8009d42:	6898      	ldr	r0, [r3, #8]
 8009d44:	f010 0010 	ands.w	r0, r0, #16
 8009d48:	d02f      	beq.n	8009daa <HAL_SPI_TransmitReceive+0x25a>
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 8009d4a:	6e22      	ldr	r2, [r4, #96]	; 0x60
    /* Clear CRC Flag */
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8009d4c:	f64f 71ef 	movw	r1, #65519	; 0xffef
  }

  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 8009d50:	f042 0202 	orr.w	r2, r2, #2
 8009d54:	6622      	str	r2, [r4, #96]	; 0x60
    /* Clear CRC Flag */
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);

    errorcode = HAL_ERROR;
 8009d56:	2501      	movs	r5, #1
  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    /* Clear CRC Flag */
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8009d58:	6099      	str	r1, [r3, #8]

    errorcode = HAL_ERROR;
  }

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
 8009d5a:	4631      	mov	r1, r6
 8009d5c:	4620      	mov	r0, r4
 8009d5e:	f7ff fbad 	bl	80094bc <SPI_EndRxTxTransaction>
 8009d62:	b188      	cbz	r0, 8009d88 <HAL_SPI_TransmitReceive+0x238>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8009d64:	2320      	movs	r3, #32
 8009d66:	6623      	str	r3, [r4, #96]	; 0x60
  }

  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
  {
    errorcode = HAL_ERROR;
 8009d68:	2501      	movs	r5, #1
 8009d6a:	e708      	b.n	8009b7e <HAL_SPI_TransmitReceive+0x2e>
        {
          (*hspi->pRxBuffPtr++) =  *(__IO uint8_t *)&hspi->Instance->DR;
          hspi->RxXferCount--;
        }
      }
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
 8009d6c:	f7f6 fecc 	bl	8000b08 <HAL_GetTick>
 8009d70:	1b40      	subs	r0, r0, r5
 8009d72:	4286      	cmp	r6, r0
 8009d74:	d893      	bhi.n	8009c9e <HAL_SPI_TransmitReceive+0x14e>
      {
        if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
        {
          /* Error on the CRC reception */
          hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
          errorcode = HAL_TIMEOUT;
 8009d76:	2503      	movs	r5, #3
          goto error;
 8009d78:	e701      	b.n	8009b7e <HAL_SPI_TransmitReceive+0x2e>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
        hspi->pRxBuffPtr += sizeof(uint16_t);
        hspi->RxXferCount--;
      }
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
 8009d7a:	f7f6 fec5 	bl	8000b08 <HAL_GetTick>
 8009d7e:	1b40      	subs	r0, r0, r5
 8009d80:	4286      	cmp	r6, r0
 8009d82:	f63f af54 	bhi.w	8009c2e <HAL_SPI_TransmitReceive+0xde>
 8009d86:	e7f6      	b.n	8009d76 <HAL_SPI_TransmitReceive+0x226>
  if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
  }

  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8009d88:	6e23      	ldr	r3, [r4, #96]	; 0x60
  {
    errorcode = HAL_ERROR;
 8009d8a:	2b00      	cmp	r3, #0
 8009d8c:	bf18      	it	ne
 8009d8e:	2501      	movne	r5, #1
 8009d90:	e6f5      	b.n	8009b7e <HAL_SPI_TransmitReceive+0x2e>
        }

        /* Enable CRC Transmission */
        if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
        {
          hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8009d92:	6822      	ldr	r2, [r4, #0]
 8009d94:	6813      	ldr	r3, [r2, #0]
 8009d96:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8009d9a:	6013      	str	r3, [r2, #0]
 8009d9c:	e797      	b.n	8009cce <HAL_SPI_TransmitReceive+0x17e>
        hspi->TxXferCount--;

        /* Enable CRC Transmission */
        if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
        {
          hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
 8009d9e:	6822      	ldr	r2, [r4, #0]
 8009da0:	6813      	ldr	r3, [r2, #0]
 8009da2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8009da6:	6013      	str	r3, [r2, #0]
 8009da8:	e758      	b.n	8009c5c <HAL_SPI_TransmitReceive+0x10c>
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
__IO uint16_t tmpreg;
  uint32_t tickstart = HAL_GetTick();
  HAL_StatusTypeDef errorcode = HAL_OK;
 8009daa:	4605      	mov	r5, r0
 8009dac:	e7d5      	b.n	8009d5a <HAL_SPI_TransmitReceive+0x20a>

  /* Read CRC from DR to close CRC calculation process */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    /* Wait until TXE flag */
    if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
 8009dae:	2101      	movs	r1, #1
 8009db0:	460a      	mov	r2, r1
 8009db2:	4620      	mov	r0, r4
 8009db4:	4633      	mov	r3, r6
 8009db6:	f7ff fb2f 	bl	8009418 <SPI_WaitFlagStateUntilTimeout>
 8009dba:	b9d0      	cbnz	r0, 8009df2 <HAL_SPI_TransmitReceive+0x2a2>
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
      errorcode = HAL_TIMEOUT;
      goto error;
    }

    if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8009dbc:	68e3      	ldr	r3, [r4, #12]
 8009dbe:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
    {
      tmpreg = hspi->Instance->DR;
 8009dc2:	6823      	ldr	r3, [r4, #0]
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
      errorcode = HAL_TIMEOUT;
      goto error;
    }

    if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8009dc4:	d01a      	beq.n	8009dfc <HAL_SPI_TransmitReceive+0x2ac>
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
      UNUSED(tmpreg); /* To avoid GCC warning */

      if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8009dc6:	6b21      	ldr	r1, [r4, #48]	; 0x30
      tmpreg = hspi->Instance->DR;
      UNUSED(tmpreg); /* To avoid GCC warning */
    }
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8009dc8:	7b1a      	ldrb	r2, [r3, #12]
 8009dca:	f8ad 2006 	strh.w	r2, [sp, #6]
      UNUSED(tmpreg); /* To avoid GCC warning */

      if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8009dce:	2902      	cmp	r1, #2
      UNUSED(tmpreg); /* To avoid GCC warning */
    }
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
      UNUSED(tmpreg); /* To avoid GCC warning */
 8009dd0:	f8bd 2006 	ldrh.w	r2, [sp, #6]

      if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8009dd4:	d1b5      	bne.n	8009d42 <HAL_SPI_TransmitReceive+0x1f2>
      {
        if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
 8009dd6:	2101      	movs	r1, #1
 8009dd8:	460a      	mov	r2, r1
 8009dda:	4620      	mov	r0, r4
 8009ddc:	4633      	mov	r3, r6
 8009dde:	f7ff fb1b 	bl	8009418 <SPI_WaitFlagStateUntilTimeout>
 8009de2:	b930      	cbnz	r0, 8009df2 <HAL_SPI_TransmitReceive+0x2a2>
          /* Error on the CRC reception */
          hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
          errorcode = HAL_TIMEOUT;
          goto error;
        }
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8009de4:	6823      	ldr	r3, [r4, #0]
 8009de6:	7b1a      	ldrb	r2, [r3, #12]
 8009de8:	f8ad 2006 	strh.w	r2, [sp, #6]
        UNUSED(tmpreg); /* To avoid GCC warning */
 8009dec:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8009df0:	e7a7      	b.n	8009d42 <HAL_SPI_TransmitReceive+0x1f2>
      if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
      {
        if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
        {
          /* Error on the CRC reception */
          hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 8009df2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8009df4:	f043 0302 	orr.w	r3, r3, #2
 8009df8:	6623      	str	r3, [r4, #96]	; 0x60
 8009dfa:	e7bc      	b.n	8009d76 <HAL_SPI_TransmitReceive+0x226>
      goto error;
    }

    if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
    {
      tmpreg = hspi->Instance->DR;
 8009dfc:	68da      	ldr	r2, [r3, #12]
 8009dfe:	b292      	uxth	r2, r2
 8009e00:	f8ad 2006 	strh.w	r2, [sp, #6]
      UNUSED(tmpreg); /* To avoid GCC warning */
 8009e04:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8009e08:	e79b      	b.n	8009d42 <HAL_SPI_TransmitReceive+0x1f2>
 8009e0a:	bf00      	nop

08009e0c <HAL_SPI_Receive>:
  * @param  Size: amount of data to be received
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8009e0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009e10:	4604      	mov	r4, r0
 8009e12:	b084      	sub	sp, #16
 8009e14:	461d      	mov	r5, r3
 8009e16:	4688      	mov	r8, r1
 8009e18:	4617      	mov	r7, r2
  __IO uint16_t tmpreg;
  uint32_t tickstart = HAL_GetTick();
 8009e1a:	f7f6 fe75 	bl	8000b08 <HAL_GetTick>
  HAL_StatusTypeDef errorcode = HAL_OK;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8009e1e:	6863      	ldr	r3, [r4, #4]
 8009e20:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
  __IO uint16_t tmpreg;
  uint32_t tickstart = HAL_GetTick();
 8009e24:	4606      	mov	r6, r0
  HAL_StatusTypeDef errorcode = HAL_OK;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8009e26:	d018      	beq.n	8009e5a <HAL_SPI_Receive+0x4e>
    /* Process Locked */
    return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 8009e28:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 8009e2c:	2b01      	cmp	r3, #1
 8009e2e:	d010      	beq.n	8009e52 <HAL_SPI_Receive+0x46>

  if(hspi->State != HAL_SPI_STATE_READY)
 8009e30:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
    /* Process Locked */
    return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 8009e34:	2301      	movs	r3, #1

  if(hspi->State != HAL_SPI_STATE_READY)
 8009e36:	4298      	cmp	r0, r3
    /* Process Locked */
    return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 8009e38:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c

  if(hspi->State != HAL_SPI_STATE_READY)
 8009e3c:	d018      	beq.n	8009e70 <HAL_SPI_Receive+0x64>
  {
    errorcode = HAL_BUSY;
 8009e3e:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error :
  hspi->State = HAL_SPI_STATE_READY;
 8009e40:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8009e42:	2300      	movs	r3, #0
  {
    errorcode = HAL_ERROR;
  }

error :
  hspi->State = HAL_SPI_STATE_READY;
 8009e44:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8009e48:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
}
 8009e4c:	b004      	add	sp, #16
 8009e4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    /* Process Locked */
    return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 8009e52:	2002      	movs	r0, #2

error :
  hspi->State = HAL_SPI_STATE_READY;
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8009e54:	b004      	add	sp, #16
 8009e56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
  __IO uint16_t tmpreg;
  uint32_t tickstart = HAL_GetTick();
  HAL_StatusTypeDef errorcode = HAL_OK;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8009e5a:	68a3      	ldr	r3, [r4, #8]
 8009e5c:	2b00      	cmp	r3, #0
 8009e5e:	d1e3      	bne.n	8009e28 <HAL_SPI_Receive+0x1c>
  {
    /* the receive process is not supported in 2Lines direction master mode */
    /* in this case we call the TransmitReceive process                     */
    /* Process Locked */
    return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
 8009e60:	9500      	str	r5, [sp, #0]
 8009e62:	4620      	mov	r0, r4
 8009e64:	463b      	mov	r3, r7
 8009e66:	4641      	mov	r1, r8
 8009e68:	4642      	mov	r2, r8
 8009e6a:	f7ff fe71 	bl	8009b50 <HAL_SPI_TransmitReceive>
 8009e6e:	e7ed      	b.n	8009e4c <HAL_SPI_Receive+0x40>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pData == NULL ) || (Size == 0))
 8009e70:	f1b8 0f00 	cmp.w	r8, #0
 8009e74:	d0e4      	beq.n	8009e40 <HAL_SPI_Receive+0x34>
 8009e76:	2f00      	cmp	r7, #0
 8009e78:	d0e2      	beq.n	8009e40 <HAL_SPI_Receive+0x34>
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
  hspi->TxXferSize  = 0;
  hspi->TxXferCount = 0;

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009e7a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = pData;
 8009e7c:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009e80:	2300      	movs	r3, #0
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8009e82:	2104      	movs	r1, #4
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
  hspi->TxXferSize  = 0;
  hspi->TxXferCount = 0;

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009e84:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = pData;
  hspi->RxXferSize  = Size;
 8009e88:	f8a4 7044 	strh.w	r7, [r4, #68]	; 0x44
  hspi->RxXferCount = Size;
 8009e8c:	f8a4 7046 	strh.w	r7, [r4, #70]	; 0x46
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8009e90:	f884 105d 	strb.w	r1, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009e94:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pRxBuffPtr  = pData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 8009e96:	63a3      	str	r3, [r4, #56]	; 0x38
  hspi->TxXferSize  = 0;
 8009e98:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxXferCount = 0;
 8009e9a:	87e3      	strh	r3, [r4, #62]	; 0x3e

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009e9c:	d05e      	beq.n	8009f5c <HAL_SPI_Receive+0x150>
    /* this is done to handle the CRCNEXT before the latest data */
    hspi->RxXferCount--;
  }

  /* Set the Rx Fido threshold */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009e9e:	68e3      	ldr	r3, [r4, #12]
  {
    /* set fiforxthresold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009ea0:	6822      	ldr	r2, [r4, #0]
    /* this is done to handle the CRCNEXT before the latest data */
    hspi->RxXferCount--;
  }

  /* Set the Rx Fido threshold */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009ea2:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
  {
    /* set fiforxthresold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009ea6:	6853      	ldr	r3, [r2, #4]
 8009ea8:	bf8c      	ite	hi
 8009eaa:	f423 5380 	bichi.w	r3, r3, #4096	; 0x1000
  }
  else
  {
    /* set fiforxthresold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009eae:	f443 5380 	orrls.w	r3, r3, #4096	; 0x1000
 8009eb2:	6053      	str	r3, [r2, #4]
  }

  /* Configure communication direction 1Line and enabled SPI if needed */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009eb4:	68a3      	ldr	r3, [r4, #8]
 8009eb6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009eba:	d049      	beq.n	8009f50 <HAL_SPI_Receive+0x144>
  {
    SPI_1LINE_RX(hspi);
  }

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8009ebc:	6823      	ldr	r3, [r4, #0]
 8009ebe:	681a      	ldr	r2, [r3, #0]
 8009ec0:	0650      	lsls	r0, r2, #25
 8009ec2:	d403      	bmi.n	8009ecc <HAL_SPI_Receive+0xc0>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8009ec4:	681a      	ldr	r2, [r3, #0]
 8009ec6:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009eca:	601a      	str	r2, [r3, #0]
  }

  if(hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
 8009ecc:	68e3      	ldr	r3, [r4, #12]
 8009ece:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8009ed2:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009ed6:	d81c      	bhi.n	8009f12 <HAL_SPI_Receive+0x106>
  {
    /* Transfer loop */
    while(hspi->RxXferCount > 0)
 8009ed8:	2b00      	cmp	r3, #0
 8009eda:	d050      	beq.n	8009f7e <HAL_SPI_Receive+0x172>
    {
      /* Check the RXNE flag */
      if((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE)
 8009edc:	6822      	ldr	r2, [r4, #0]
 8009ede:	6891      	ldr	r1, [r2, #8]
 8009ee0:	07c9      	lsls	r1, r1, #31
 8009ee2:	d529      	bpl.n	8009f38 <HAL_SPI_Receive+0x12c>
      {
        /* read the received data */
        (*hspi->pRxBuffPtr++)= *(__IO uint8_t *)&hspi->Instance->DR;
 8009ee4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8009ee6:	1c59      	adds	r1, r3, #1
 8009ee8:	6421      	str	r1, [r4, #64]	; 0x40
 8009eea:	7b12      	ldrb	r2, [r2, #12]
 8009eec:	701a      	strb	r2, [r3, #0]
        hspi->RxXferCount--;
 8009eee:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009ef2:	3b01      	subs	r3, #1
 8009ef4:	b29b      	uxth	r3, r3
 8009ef6:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 8009efa:	e7ed      	b.n	8009ed8 <HAL_SPI_Receive+0xcc>
        hspi->RxXferCount--;
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 8009efc:	2d00      	cmp	r5, #0
 8009efe:	d079      	beq.n	8009ff4 <HAL_SPI_Receive+0x1e8>
 8009f00:	1c69      	adds	r1, r5, #1
 8009f02:	d006      	beq.n	8009f12 <HAL_SPI_Receive+0x106>
 8009f04:	f7f6 fe00 	bl	8000b08 <HAL_GetTick>
 8009f08:	1b80      	subs	r0, r0, r6
 8009f0a:	4285      	cmp	r5, r0
 8009f0c:	d972      	bls.n	8009ff4 <HAL_SPI_Receive+0x1e8>
 8009f0e:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
    }
  }
  else
  {
    /* Transfer loop */
    while(hspi->RxXferCount > 0)
 8009f12:	2b00      	cmp	r3, #0
 8009f14:	d033      	beq.n	8009f7e <HAL_SPI_Receive+0x172>
    {
      /* Check the RXNE flag */
      if((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE)
 8009f16:	6822      	ldr	r2, [r4, #0]
 8009f18:	6891      	ldr	r1, [r2, #8]
 8009f1a:	07c8      	lsls	r0, r1, #31
 8009f1c:	d5ee      	bpl.n	8009efc <HAL_SPI_Receive+0xf0>
      {
        *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8009f1e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8009f20:	68d2      	ldr	r2, [r2, #12]
 8009f22:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
        hspi->RxXferCount--;
 8009f24:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
    {
      /* Check the RXNE flag */
      if((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE)
      {
        *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8009f28:	6c22      	ldr	r2, [r4, #64]	; 0x40
        hspi->RxXferCount--;
 8009f2a:	3b01      	subs	r3, #1
 8009f2c:	b29b      	uxth	r3, r3
    {
      /* Check the RXNE flag */
      if((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE)
      {
        *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8009f2e:	3202      	adds	r2, #2
        hspi->RxXferCount--;
 8009f30:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    {
      /* Check the RXNE flag */
      if((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE)
      {
        *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8009f34:	6422      	str	r2, [r4, #64]	; 0x40
 8009f36:	e7ec      	b.n	8009f12 <HAL_SPI_Receive+0x106>
        hspi->RxXferCount--;
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 8009f38:	2d00      	cmp	r5, #0
 8009f3a:	d05b      	beq.n	8009ff4 <HAL_SPI_Receive+0x1e8>
 8009f3c:	1c6f      	adds	r7, r5, #1
 8009f3e:	d0cb      	beq.n	8009ed8 <HAL_SPI_Receive+0xcc>
 8009f40:	f7f6 fde2 	bl	8000b08 <HAL_GetTick>
 8009f44:	1b80      	subs	r0, r0, r6
 8009f46:	4285      	cmp	r5, r0
 8009f48:	d954      	bls.n	8009ff4 <HAL_SPI_Receive+0x1e8>
 8009f4a:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009f4e:	e7c3      	b.n	8009ed8 <HAL_SPI_Receive+0xcc>
  }

  /* Configure communication direction 1Line and enabled SPI if needed */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_RX(hspi);
 8009f50:	6822      	ldr	r2, [r4, #0]
 8009f52:	6813      	ldr	r3, [r2, #0]
 8009f54:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8009f58:	6013      	str	r3, [r2, #0]
 8009f5a:	e7af      	b.n	8009ebc <HAL_SPI_Receive+0xb0>
  hspi->TxXferCount = 0;

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
 8009f5c:	6822      	ldr	r2, [r4, #0]
 8009f5e:	6811      	ldr	r1, [r2, #0]
 8009f60:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 8009f64:	400b      	ands	r3, r1
 8009f66:	6013      	str	r3, [r2, #0]
 8009f68:	6822      	ldr	r2, [r4, #0]
 8009f6a:	6813      	ldr	r3, [r2, #0]
 8009f6c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009f70:	6013      	str	r3, [r2, #0]
    /* this is done to handle the CRCNEXT before the latest data */
    hspi->RxXferCount--;
 8009f72:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009f76:	3b01      	subs	r3, #1
 8009f78:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 8009f7c:	e78f      	b.n	8009e9e <HAL_SPI_Receive+0x92>
      }
    }
  }

  /* Handle the CRC Transmission */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009f7e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009f80:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009f84:	d015      	beq.n	8009fb2 <HAL_SPI_Receive+0x1a6>
      }
    }
  }
  
  /* Check the end of the transaction */
  if(SPI_EndRxTransaction(hspi,Timeout) != HAL_OK)
 8009f86:	4629      	mov	r1, r5
 8009f88:	4620      	mov	r0, r4
 8009f8a:	f7ff fab1 	bl	80094f0 <SPI_EndRxTransaction>
 8009f8e:	2800      	cmp	r0, #0
 8009f90:	d132      	bne.n	8009ff8 <HAL_SPI_Receive+0x1ec>
 8009f92:	6e20      	ldr	r0, [r4, #96]	; 0x60
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
  }

  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 8009f94:	6823      	ldr	r3, [r4, #0]
 8009f96:	689a      	ldr	r2, [r3, #8]
 8009f98:	06d2      	lsls	r2, r2, #27
 8009f9a:	d506      	bpl.n	8009faa <HAL_SPI_Receive+0x19e>
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 8009f9c:	f040 0002 	orr.w	r0, r0, #2
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8009fa0:	f64f 72ef 	movw	r2, #65519	; 0xffef
  }

  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 8009fa4:	6620      	str	r0, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8009fa6:	609a      	str	r2, [r3, #8]
 8009fa8:	6e20      	ldr	r0, [r4, #96]	; 0x60
  /* Process Locked */
  __HAL_LOCK(hspi);

  if(hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 8009faa:	3000      	adds	r0, #0
 8009fac:	bf18      	it	ne
 8009fae:	2001      	movne	r0, #1
 8009fb0:	e746      	b.n	8009e40 <HAL_SPI_Receive+0x34>

  /* Handle the CRC Transmission */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    /* freeze the CRC before the latest data */
    hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
 8009fb2:	6822      	ldr	r2, [r4, #0]
 8009fb4:	6813      	ldr	r3, [r2, #0]

    /* Read the latest data */
    if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
 8009fb6:	2101      	movs	r1, #1

  /* Handle the CRC Transmission */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    /* freeze the CRC before the latest data */
    hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
 8009fb8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8009fbc:	6013      	str	r3, [r2, #0]

    /* Read the latest data */
    if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
 8009fbe:	4620      	mov	r0, r4
 8009fc0:	460a      	mov	r2, r1
 8009fc2:	462b      	mov	r3, r5
 8009fc4:	f7ff fa28 	bl	8009418 <SPI_WaitFlagStateUntilTimeout>
 8009fc8:	b9a0      	cbnz	r0, 8009ff4 <HAL_SPI_Receive+0x1e8>
      errorcode = HAL_TIMEOUT;
      goto error;
    }

    /* Receive last data in 16 Bit mode */
    if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009fca:	68e3      	ldr	r3, [r4, #12]
    {
      *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8009fcc:	6822      	ldr	r2, [r4, #0]
      errorcode = HAL_TIMEOUT;
      goto error;
    }

    /* Receive last data in 16 Bit mode */
    if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009fce:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
    {
      *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8009fd2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8009fd4:	bf8a      	itet	hi
 8009fd6:	68d2      	ldrhi	r2, [r2, #12]
    }
    /* Receive last data in 8 Bit mode */
    else
    {
      *hspi->pRxBuffPtr = *(__IO uint8_t *)&hspi->Instance->DR;
 8009fd8:	7b12      	ldrbls	r2, [r2, #12]
    }

    /* Receive last data in 16 Bit mode */
    if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    {
      *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8009fda:	801a      	strhhi	r2, [r3, #0]
    {
      *hspi->pRxBuffPtr = *(__IO uint8_t *)&hspi->Instance->DR;
    }

    /* Wait until TXE flag */
    if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
 8009fdc:	f04f 0101 	mov.w	r1, #1
      *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    }
    /* Receive last data in 8 Bit mode */
    else
    {
      *hspi->pRxBuffPtr = *(__IO uint8_t *)&hspi->Instance->DR;
 8009fe0:	bf98      	it	ls
 8009fe2:	701a      	strbls	r2, [r3, #0]
    }

    /* Wait until TXE flag */
    if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
 8009fe4:	4620      	mov	r0, r4
 8009fe6:	460a      	mov	r2, r1
 8009fe8:	462b      	mov	r3, r5
 8009fea:	f7ff fa15 	bl	8009418 <SPI_WaitFlagStateUntilTimeout>
 8009fee:	b130      	cbz	r0, 8009ffe <HAL_SPI_Receive+0x1f2>
    {
      /* Flag Error*/
      hspi->ErrorCode = HAL_SPI_ERROR_CRC;
 8009ff0:	2302      	movs	r3, #2
 8009ff2:	6623      	str	r3, [r4, #96]	; 0x60
      errorcode = HAL_TIMEOUT;
 8009ff4:	2003      	movs	r0, #3
      goto error;
 8009ff6:	e723      	b.n	8009e40 <HAL_SPI_Receive+0x34>
  }
  
  /* Check the end of the transaction */
  if(SPI_EndRxTransaction(hspi,Timeout) != HAL_OK)
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8009ff8:	2020      	movs	r0, #32
 8009ffa:	6620      	str	r0, [r4, #96]	; 0x60
 8009ffc:	e7ca      	b.n	8009f94 <HAL_SPI_Receive+0x188>
      hspi->ErrorCode = HAL_SPI_ERROR_CRC;
      errorcode = HAL_TIMEOUT;
      goto error;
    }

    if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8009ffe:	68e3      	ldr	r3, [r4, #12]
 800a000:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800a004:	d01a      	beq.n	800a03c <HAL_SPI_Receive+0x230>
      tmpreg = hspi->Instance->DR;
      UNUSED(tmpreg); /* To avoid GCC warning */
    }
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 800a006:	6822      	ldr	r2, [r4, #0]
 800a008:	7b12      	ldrb	r2, [r2, #12]
 800a00a:	f8ad 200e 	strh.w	r2, [sp, #14]
      UNUSED(tmpreg); /* To avoid GCC warning */

      if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 800a00e:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
      UNUSED(tmpreg); /* To avoid GCC warning */
    }
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
      UNUSED(tmpreg); /* To avoid GCC warning */
 800a012:	f8bd 200e 	ldrh.w	r2, [sp, #14]

      if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 800a016:	d1b6      	bne.n	8009f86 <HAL_SPI_Receive+0x17a>
 800a018:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800a01a:	2b02      	cmp	r3, #2
 800a01c:	d1b3      	bne.n	8009f86 <HAL_SPI_Receive+0x17a>
      {
        if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
 800a01e:	2101      	movs	r1, #1
 800a020:	460a      	mov	r2, r1
 800a022:	4620      	mov	r0, r4
 800a024:	462b      	mov	r3, r5
 800a026:	f7ff f9f7 	bl	8009418 <SPI_WaitFlagStateUntilTimeout>
 800a02a:	2800      	cmp	r0, #0
 800a02c:	d1e0      	bne.n	8009ff0 <HAL_SPI_Receive+0x1e4>
          /* Error on the CRC reception */
          hspi->ErrorCode = HAL_SPI_ERROR_CRC;
          errorcode = HAL_TIMEOUT;
          goto error;
        }
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 800a02e:	6823      	ldr	r3, [r4, #0]
 800a030:	7b1b      	ldrb	r3, [r3, #12]
 800a032:	f8ad 300e 	strh.w	r3, [sp, #14]
        UNUSED(tmpreg); /* To avoid GCC warning */
 800a036:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800a03a:	e7a4      	b.n	8009f86 <HAL_SPI_Receive+0x17a>
      goto error;
    }

    if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
    {
      tmpreg = hspi->Instance->DR;
 800a03c:	6823      	ldr	r3, [r4, #0]
 800a03e:	68db      	ldr	r3, [r3, #12]
 800a040:	b29b      	uxth	r3, r3
 800a042:	f8ad 300e 	strh.w	r3, [sp, #14]
      UNUSED(tmpreg); /* To avoid GCC warning */
 800a046:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800a04a:	e79c      	b.n	8009f86 <HAL_SPI_Receive+0x17a>

0800a04c <HAL_SPI_Transmit_IT>:
  * @param  pData: pointer to data buffer
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 800a04c:	b410      	push	{r4}
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a04e:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 800a052:	2b01      	cmp	r3, #1
  * @param  pData: pointer to data buffer
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 800a054:	4604      	mov	r4, r0
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a056:	d010      	beq.n	800a07a <HAL_SPI_Transmit_IT+0x2e>
 800a058:	2301      	movs	r3, #1
 800a05a:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c

  if((pData == NULL) || (Size == 0))
 800a05e:	b129      	cbz	r1, 800a06c <HAL_SPI_Transmit_IT+0x20>
 800a060:	b122      	cbz	r2, 800a06c <HAL_SPI_Transmit_IT+0x20>
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  if(hspi->State != HAL_SPI_STATE_READY)
 800a062:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 800a066:	2b01      	cmp	r3, #1
 800a068:	d00b      	beq.n	800a082 <HAL_SPI_Transmit_IT+0x36>
  {
    errorcode = HAL_BUSY;
 800a06a:	2302      	movs	r3, #2
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
  }

error :
  __HAL_UNLOCK(hspi);
 800a06c:	2200      	movs	r2, #0
 800a06e:	f884 205c 	strb.w	r2, [r4, #92]	; 0x5c
  return errorcode;
 800a072:	4618      	mov	r0, r3
}
 800a074:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a078:	4770      	bx	lr
{
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a07a:	2002      	movs	r0, #2
  }

error :
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 800a07c:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a080:	4770      	bx	lr
  hspi->RxXferSize  = 0;
  hspi->RxXferCount = 0;
  hspi->RxISR = NULL;

  /* Set the function for IT treatment */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
 800a082:	68c0      	ldr	r0, [r0, #12]
  }

  /* prepare the transfer */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = pData;
 800a084:	63a1      	str	r1, [r4, #56]	; 0x38
    goto error;
  }

  /* prepare the transfer */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a086:	2300      	movs	r3, #0
  hspi->RxXferSize  = 0;
  hspi->RxXferCount = 0;
  hspi->RxISR = NULL;

  /* Set the function for IT treatment */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
 800a088:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    goto error;
  }

  /* prepare the transfer */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a08c:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 800a08e:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->RxXferSize  = 0;
 800a090:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxXferCount = 0;
 800a094:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  hspi->RxISR = NULL;
 800a098:	64e3      	str	r3, [r4, #76]	; 0x4c

  /* Set the function for IT treatment */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
  {
    hspi->TxISR = SPI_TxISR_16BIT;
 800a09a:	bf8c      	ite	hi
 800a09c:	4b19      	ldrhi	r3, [pc, #100]	; (800a104 <HAL_SPI_Transmit_IT+0xb8>)
  }
  else
  {
    hspi->TxISR = SPI_TxISR_8BIT;
 800a09e:	4b1a      	ldrls	r3, [pc, #104]	; (800a108 <HAL_SPI_Transmit_IT+0xbc>)
 800a0a0:	6523      	str	r3, [r4, #80]	; 0x50
  }

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800a0a2:	68a3      	ldr	r3, [r4, #8]

  /* prepare the transfer */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = pData;
  hspi->TxXferSize  = Size;
 800a0a4:	87a2      	strh	r2, [r4, #60]	; 0x3c
    errorcode = HAL_BUSY;
    goto error;
  }

  /* prepare the transfer */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 800a0a6:	2103      	movs	r1, #3
  {
    hspi->TxISR = SPI_TxISR_8BIT;
  }

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800a0a8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  /* prepare the transfer */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
 800a0ac:	87e2      	strh	r2, [r4, #62]	; 0x3e
    errorcode = HAL_BUSY;
    goto error;
  }

  /* prepare the transfer */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 800a0ae:	f884 105d 	strb.w	r1, [r4, #93]	; 0x5d
  {
    hspi->TxISR = SPI_TxISR_8BIT;
  }

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800a0b2:	d020      	beq.n	800a0f6 <HAL_SPI_Transmit_IT+0xaa>
  {
    SPI_1LINE_TX(hspi);
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a0b4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a0b6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a0ba:	d010      	beq.n	800a0de <HAL_SPI_Transmit_IT+0x92>
  {
    SPI_RESET_CRC(hspi);
  }

  /* Enable TXE and ERR interrupt */
  __HAL_SPI_ENABLE_IT(hspi,(SPI_IT_TXE));
 800a0bc:	6822      	ldr	r2, [r4, #0]
 800a0be:	6853      	ldr	r3, [r2, #4]
 800a0c0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a0c4:	6053      	str	r3, [r2, #4]


  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 800a0c6:	6822      	ldr	r2, [r4, #0]
 800a0c8:	6813      	ldr	r3, [r2, #0]
 800a0ca:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 800a0ce:	d104      	bne.n	800a0da <HAL_SPI_Transmit_IT+0x8e>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 800a0d0:	6811      	ldr	r1, [r2, #0]
 800a0d2:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 800a0d6:	6011      	str	r1, [r2, #0]
 800a0d8:	e7c8      	b.n	800a06c <HAL_SPI_Transmit_IT+0x20>
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;
 800a0da:	2300      	movs	r3, #0
 800a0dc:	e7c6      	b.n	800a06c <HAL_SPI_Transmit_IT+0x20>
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
 800a0de:	6822      	ldr	r2, [r4, #0]
 800a0e0:	6811      	ldr	r1, [r2, #0]
 800a0e2:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 800a0e6:	400b      	ands	r3, r1
 800a0e8:	6013      	str	r3, [r2, #0]
 800a0ea:	6822      	ldr	r2, [r4, #0]
 800a0ec:	6813      	ldr	r3, [r2, #0]
 800a0ee:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800a0f2:	6013      	str	r3, [r2, #0]
 800a0f4:	e7e2      	b.n	800a0bc <HAL_SPI_Transmit_IT+0x70>
  }

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 800a0f6:	6822      	ldr	r2, [r4, #0]
 800a0f8:	6813      	ldr	r3, [r2, #0]
 800a0fa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800a0fe:	6013      	str	r3, [r2, #0]
 800a100:	e7d8      	b.n	800a0b4 <HAL_SPI_Transmit_IT+0x68>
 800a102:	bf00      	nop
 800a104:	0800a5e9 	.word	0x0800a5e9
 800a108:	0800a5b9 	.word	0x0800a5b9

0800a10c <HAL_SPI_Receive_IT>:
  * @param  pData: pointer to data buffer
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 800a10c:	b4f0      	push	{r4, r5, r6, r7}
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a10e:	f890 505c 	ldrb.w	r5, [r0, #92]	; 0x5c
 800a112:	2d01      	cmp	r5, #1
  * @param  pData: pointer to data buffer
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 800a114:	4604      	mov	r4, r0
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a116:	d00c      	beq.n	800a132 <HAL_SPI_Receive_IT+0x26>

  if(hspi->State != HAL_SPI_STATE_READY)
 800a118:	f890 505d 	ldrb.w	r5, [r0, #93]	; 0x5d
HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a11c:	2601      	movs	r6, #1

  if(hspi->State != HAL_SPI_STATE_READY)
 800a11e:	42b5      	cmp	r5, r6
HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a120:	f880 605c 	strb.w	r6, [r0, #92]	; 0x5c

  if(hspi->State != HAL_SPI_STATE_READY)
 800a124:	d008      	beq.n	800a138 <HAL_SPI_Receive_IT+0x2c>
  {
    errorcode = HAL_BUSY;
 800a126:	2002      	movs	r0, #2
    __HAL_SPI_ENABLE(hspi);
  }

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800a128:	2300      	movs	r3, #0
 800a12a:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
}
 800a12e:	bcf0      	pop	{r4, r5, r6, r7}
 800a130:	4770      	bx	lr
HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a132:	2002      	movs	r0, #2

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 800a134:	bcf0      	pop	{r4, r5, r6, r7}
 800a136:	4770      	bx	lr
 800a138:	4613      	mov	r3, r2
 800a13a:	460a      	mov	r2, r1
  if(hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
    goto error;
  }
  if((pData == NULL) || (Size == 0))
 800a13c:	2900      	cmp	r1, #0
 800a13e:	d03b      	beq.n	800a1b8 <HAL_SPI_Receive_IT+0xac>
 800a140:	2b00      	cmp	r3, #0
 800a142:	d039      	beq.n	800a1b8 <HAL_SPI_Receive_IT+0xac>
  hspi->RxXferCount = Size;
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
  hspi->TxXferSize  = 0;
  hspi->TxXferCount = 0;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 800a144:	6846      	ldr	r6, [r0, #4]
  }

  /* Configure communication */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = pData;
 800a146:	6421      	str	r1, [r4, #64]	; 0x40
    goto error;
  }

  /* Configure communication */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a148:	2500      	movs	r5, #0
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Configure communication */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 800a14a:	2704      	movs	r7, #4
  hspi->RxXferCount = Size;
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
  hspi->TxXferSize  = 0;
  hspi->TxXferCount = 0;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 800a14c:	f5b6 7f82 	cmp.w	r6, #260	; 0x104

  /* Configure communication */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = pData;
  hspi->RxXferSize  = Size;
 800a150:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
  hspi->RxXferCount = Size;
 800a154:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Configure communication */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 800a158:	f880 705d 	strb.w	r7, [r0, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a15c:	6605      	str	r5, [r0, #96]	; 0x60
  hspi->pRxBuffPtr  = pData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 800a15e:	6385      	str	r5, [r0, #56]	; 0x38
  hspi->TxXferSize  = 0;
 800a160:	8785      	strh	r5, [r0, #60]	; 0x3c
  hspi->TxXferCount = 0;
 800a162:	87c5      	strh	r5, [r0, #62]	; 0x3e

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 800a164:	d02a      	beq.n	800a1bc <HAL_SPI_Receive_IT+0xb0>
    /* the receive process is not supported in 2Lines direction master mode */
    /* in this we call the TransmitReceive process          */
    return HAL_SPI_TransmitReceive_IT(hspi,pData,pData,Size);
  }

  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a166:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a168:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a16c:	d02e      	beq.n	800a1cc <HAL_SPI_Receive_IT+0xc0>
 800a16e:	68e2      	ldr	r2, [r4, #12]
      hspi->CRCSize = 2;
    }
  }
  else
  {
    hspi->CRCSize = 0;
 800a170:	2300      	movs	r3, #0
  }

  hspi->TxISR = NULL;
  /* check the data size to adapt Rx threshold and the set the function for IT treatment */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
 800a172:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
      hspi->CRCSize = 2;
    }
  }
  else
  {
    hspi->CRCSize = 0;
 800a176:	64a3      	str	r3, [r4, #72]	; 0x48
  }

  hspi->TxISR = NULL;
 800a178:	6523      	str	r3, [r4, #80]	; 0x50
  /* check the data size to adapt Rx threshold and the set the function for IT treatment */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
 800a17a:	d932      	bls.n	800a1e2 <HAL_SPI_Receive_IT+0xd6>
  {
    /* set fiforxthresold according the reception data length: 16 bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a17c:	6822      	ldr	r2, [r4, #0]
    hspi->RxISR = SPI_RxISR_16BIT;
 800a17e:	4929      	ldr	r1, [pc, #164]	; (800a224 <HAL_SPI_Receive_IT+0x118>)
  hspi->TxISR = NULL;
  /* check the data size to adapt Rx threshold and the set the function for IT treatment */
  if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
  {
    /* set fiforxthresold according the reception data length: 16 bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a180:	6853      	ldr	r3, [r2, #4]
 800a182:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800a186:	6053      	str	r3, [r2, #4]
    hspi->RxISR = SPI_RxISR_16BIT;
 800a188:	64e1      	str	r1, [r4, #76]	; 0x4c
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    hspi->RxISR = SPI_RxISR_8BIT;
  }

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800a18a:	68a3      	ldr	r3, [r4, #8]
 800a18c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800a190:	d03d      	beq.n	800a20e <HAL_SPI_Receive_IT+0x102>
  {
    SPI_1LINE_RX(hspi);
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a192:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a194:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a198:	d02d      	beq.n	800a1f6 <HAL_SPI_Receive_IT+0xea>
  {
    SPI_RESET_CRC(hspi);
  }

  /* Enable TXE and ERR interrupt */
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
 800a19a:	6822      	ldr	r2, [r4, #0]
 800a19c:	6853      	ldr	r3, [r2, #4]
 800a19e:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 800a1a2:	6053      	str	r3, [r2, #4]

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800a1a4:	6823      	ldr	r3, [r4, #0]
 800a1a6:	6818      	ldr	r0, [r3, #0]
 800a1a8:	f010 0040 	ands.w	r0, r0, #64	; 0x40
 800a1ac:	d121      	bne.n	800a1f2 <HAL_SPI_Receive_IT+0xe6>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 800a1ae:	681a      	ldr	r2, [r3, #0]
 800a1b0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a1b4:	601a      	str	r2, [r3, #0]
 800a1b6:	e7b7      	b.n	800a128 <HAL_SPI_Receive_IT+0x1c>
    errorcode = HAL_BUSY;
    goto error;
  }
  if((pData == NULL) || (Size == 0))
  {
    errorcode = HAL_ERROR;
 800a1b8:	4628      	mov	r0, r5
 800a1ba:	e7b5      	b.n	800a128 <HAL_SPI_Receive_IT+0x1c>
  hspi->RxXferCount = Size;
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
  hspi->TxXferSize  = 0;
  hspi->TxXferCount = 0;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 800a1bc:	6885      	ldr	r5, [r0, #8]
 800a1be:	2d00      	cmp	r5, #0
 800a1c0:	d1d1      	bne.n	800a166 <HAL_SPI_Receive_IT+0x5a>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 800a1c2:	f880 505c 	strb.w	r5, [r0, #92]	; 0x5c

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 800a1c6:	bcf0      	pop	{r4, r5, r6, r7}
 800a1c8:	f7ff b9ca 	b.w	8009560 <HAL_SPI_TransmitReceive_IT.part.4>
  }

  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    hspi->CRCSize = 1;
    if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 800a1cc:	68e3      	ldr	r3, [r4, #12]
    return HAL_SPI_TransmitReceive_IT(hspi,pData,pData,Size);
  }

  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    hspi->CRCSize = 1;
 800a1ce:	2201      	movs	r2, #1
    if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 800a1d0:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
    return HAL_SPI_TransmitReceive_IT(hspi,pData,pData,Size);
  }

  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    hspi->CRCSize = 1;
 800a1d4:	64a2      	str	r2, [r4, #72]	; 0x48
    if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 800a1d6:	d820      	bhi.n	800a21a <HAL_SPI_Receive_IT+0x10e>
 800a1d8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800a1da:	2b02      	cmp	r3, #2
 800a1dc:	d020      	beq.n	800a220 <HAL_SPI_Receive_IT+0x114>
  else
  {
    hspi->CRCSize = 0;
  }

  hspi->TxISR = NULL;
 800a1de:	2300      	movs	r3, #0
 800a1e0:	6523      	str	r3, [r4, #80]	; 0x50
    hspi->RxISR = SPI_RxISR_16BIT;
  }
  else
  {
    /* set fiforxthresold according the reception data length: 8 bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a1e2:	6822      	ldr	r2, [r4, #0]
    hspi->RxISR = SPI_RxISR_8BIT;
 800a1e4:	4910      	ldr	r1, [pc, #64]	; (800a228 <HAL_SPI_Receive_IT+0x11c>)
    hspi->RxISR = SPI_RxISR_16BIT;
  }
  else
  {
    /* set fiforxthresold according the reception data length: 8 bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a1e6:	6853      	ldr	r3, [r2, #4]
 800a1e8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800a1ec:	6053      	str	r3, [r2, #4]
    hspi->RxISR = SPI_RxISR_8BIT;
 800a1ee:	64e1      	str	r1, [r4, #76]	; 0x4c
 800a1f0:	e7cb      	b.n	800a18a <HAL_SPI_Receive_IT+0x7e>
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;
 800a1f2:	2000      	movs	r0, #0
 800a1f4:	e798      	b.n	800a128 <HAL_SPI_Receive_IT+0x1c>
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
 800a1f6:	6822      	ldr	r2, [r4, #0]
 800a1f8:	6811      	ldr	r1, [r2, #0]
 800a1fa:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 800a1fe:	400b      	ands	r3, r1
 800a200:	6013      	str	r3, [r2, #0]
 800a202:	6822      	ldr	r2, [r4, #0]
 800a204:	6813      	ldr	r3, [r2, #0]
 800a206:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800a20a:	6013      	str	r3, [r2, #0]
 800a20c:	e7c5      	b.n	800a19a <HAL_SPI_Receive_IT+0x8e>
  }

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_RX(hspi);
 800a20e:	6822      	ldr	r2, [r4, #0]
 800a210:	6813      	ldr	r3, [r2, #0]
 800a212:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800a216:	6013      	str	r3, [r2, #0]
 800a218:	e7bb      	b.n	800a192 <HAL_SPI_Receive_IT+0x86>
  else
  {
    hspi->CRCSize = 0;
  }

  hspi->TxISR = NULL;
 800a21a:	2300      	movs	r3, #0
 800a21c:	6523      	str	r3, [r4, #80]	; 0x50
 800a21e:	e7ad      	b.n	800a17c <HAL_SPI_Receive_IT+0x70>
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    hspi->CRCSize = 1;
    if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
    {
      hspi->CRCSize = 2;
 800a220:	64a3      	str	r3, [r4, #72]	; 0x48
 800a222:	e7dc      	b.n	800a1de <HAL_SPI_Receive_IT+0xd2>
 800a224:	0800a6ed 	.word	0x0800a6ed
 800a228:	0800a67d 	.word	0x0800a67d

0800a22c <HAL_SPI_TransmitReceive_IT>:
  * @param  pRxData: pointer to reception data buffer
  * @param  Size: amount of data to be sent and received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
{
 800a22c:	b410      	push	{r4}
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);
 800a22e:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
 800a232:	2c01      	cmp	r4, #1
 800a234:	d003      	beq.n	800a23e <HAL_SPI_TransmitReceive_IT+0x12>

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 800a236:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a23a:	f7ff b991 	b.w	8009560 <HAL_SPI_TransmitReceive_IT.part.4>
 800a23e:	2002      	movs	r0, #2
 800a240:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a244:	4770      	bx	lr
 800a246:	bf00      	nop

0800a248 <HAL_SPI_Transmit_DMA>:
  * @param  pData: pointer to data buffer
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 800a248:	b510      	push	{r4, lr}
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a24a:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 800a24e:	2b01      	cmp	r3, #1
  * @param  pData: pointer to data buffer
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 800a250:	4604      	mov	r4, r0
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a252:	d00b      	beq.n	800a26c <HAL_SPI_Transmit_DMA+0x24>

  if(hspi->State != HAL_SPI_STATE_READY)
 800a254:	f890 005d 	ldrb.w	r0, [r0, #93]	; 0x5d
{
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a258:	2301      	movs	r3, #1

  if(hspi->State != HAL_SPI_STATE_READY)
 800a25a:	4298      	cmp	r0, r3
{
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a25c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c

  if(hspi->State != HAL_SPI_STATE_READY)
 800a260:	d006      	beq.n	800a270 <HAL_SPI_Transmit_DMA+0x28>
  {
    errorcode = HAL_BUSY;
 800a262:	2002      	movs	r0, #2
  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800a264:	2300      	movs	r3, #0
 800a266:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 800a26a:	bd10      	pop	{r4, pc}
{
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a26c:	2002      	movs	r0, #2

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 800a26e:	bd10      	pop	{r4, pc}
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pData == NULL) || (Size == 0))
 800a270:	2900      	cmp	r1, #0
 800a272:	d0f7      	beq.n	800a264 <HAL_SPI_Transmit_DMA+0x1c>
 800a274:	2a00      	cmp	r2, #0
 800a276:	d0f5      	beq.n	800a264 <HAL_SPI_Transmit_DMA+0x1c>
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0;
  hspi->RxXferCount = 0;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800a278:	68a0      	ldr	r0, [r4, #8]
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = pData;
 800a27a:	63a1      	str	r1, [r4, #56]	; 0x38
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a27c:	2300      	movs	r3, #0
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 800a27e:	2103      	movs	r1, #3
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0;
  hspi->RxXferCount = 0;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800a280:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
  }

  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = pData;
  hspi->TxXferSize  = Size;
 800a284:	87a2      	strh	r2, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 800a286:	87e2      	strh	r2, [r4, #62]	; 0x3e
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 800a288:	f884 105d 	strb.w	r1, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a28c:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 800a28e:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->RxXferSize  = 0;
 800a290:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxXferCount = 0;
 800a294:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800a298:	d049      	beq.n	800a32e <HAL_SPI_Transmit_DMA+0xe6>
  {
    SPI_1LINE_TX(hspi);
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a29a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a29c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a2a0:	d039      	beq.n	800a316 <HAL_SPI_Transmit_DMA+0xce>
  {
    SPI_RESET_CRC(hspi);
  }

  /* Set the SPI TxDMA Half transfer complete callback */
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 800a2a2:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800a2a4:	4a29      	ldr	r2, [pc, #164]	; (800a34c <HAL_SPI_Transmit_DMA+0x104>)
 800a2a6:	631a      	str	r2, [r3, #48]	; 0x30

  /* Set the SPI TxDMA transfer complete callback */
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 800a2a8:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800a2aa:	4a29      	ldr	r2, [pc, #164]	; (800a350 <HAL_SPI_Transmit_DMA+0x108>)
 800a2ac:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the DMA error callback */
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 800a2ae:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800a2b0:	4a28      	ldr	r2, [pc, #160]	; (800a354 <HAL_SPI_Transmit_DMA+0x10c>)
 800a2b2:	635a      	str	r2, [r3, #52]	; 0x34

  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800a2b4:	6822      	ldr	r2, [r4, #0]
 800a2b6:	6853      	ldr	r3, [r2, #4]
 800a2b8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800a2bc:	6053      	str	r3, [r2, #4]
  /* packing mode is enabled only if the DMA setting is HALWORD */
  if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 800a2be:	68e3      	ldr	r3, [r4, #12]
 800a2c0:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800a2c2:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800a2c6:	d914      	bls.n	800a2f2 <HAL_SPI_Transmit_DMA+0xaa>
 800a2c8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
      hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
    }
  }

  /* Enable the Tx DMA channel */
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 800a2ca:	6822      	ldr	r2, [r4, #0]
 800a2cc:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800a2ce:	320c      	adds	r2, #12
 800a2d0:	f7f7 f92a 	bl	8001528 <HAL_DMA_Start_IT>

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 800a2d4:	6823      	ldr	r3, [r4, #0]
 800a2d6:	681a      	ldr	r2, [r3, #0]
 800a2d8:	0652      	lsls	r2, r2, #25
 800a2da:	d404      	bmi.n	800a2e6 <HAL_SPI_Transmit_DMA+0x9e>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 800a2dc:	681a      	ldr	r2, [r3, #0]
 800a2de:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a2e2:	601a      	str	r2, [r3, #0]
 800a2e4:	6823      	ldr	r3, [r4, #0]
  }

  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 800a2e6:	685a      	ldr	r2, [r3, #4]
 800a2e8:	f042 0202 	orr.w	r2, r2, #2
 800a2ec:	605a      	str	r2, [r3, #4]
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;
 800a2ee:	2000      	movs	r0, #0
 800a2f0:	e7b8      	b.n	800a264 <HAL_SPI_Transmit_DMA+0x1c>
  /* Set the DMA error callback */
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;

  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
  /* packing mode is enabled only if the DMA setting is HALWORD */
  if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 800a2f2:	6983      	ldr	r3, [r0, #24]
 800a2f4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  {
    /* Check the even/odd of the data size + crc if enabled */
    if((hspi->TxXferCount & 0x1) == 0)
 800a2f8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
  /* Set the DMA error callback */
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;

  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
  /* packing mode is enabled only if the DMA setting is HALWORD */
  if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 800a2fa:	d1e6      	bne.n	800a2ca <HAL_SPI_Transmit_DMA+0x82>
  {
    /* Check the even/odd of the data size + crc if enabled */
    if((hspi->TxXferCount & 0x1) == 0)
    {
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800a2fc:	6822      	ldr	r2, [r4, #0]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
  /* packing mode is enabled only if the DMA setting is HALWORD */
  if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
  {
    /* Check the even/odd of the data size + crc if enabled */
    if((hspi->TxXferCount & 0x1) == 0)
 800a2fe:	f013 0f01 	tst.w	r3, #1
    {
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800a302:	6853      	ldr	r3, [r2, #4]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
  /* packing mode is enabled only if the DMA setting is HALWORD */
  if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
  {
    /* Check the even/odd of the data size + crc if enabled */
    if((hspi->TxXferCount & 0x1) == 0)
 800a304:	d119      	bne.n	800a33a <HAL_SPI_Transmit_DMA+0xf2>
    {
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800a306:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800a30a:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1);
 800a30c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800a30e:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800a310:	085b      	lsrs	r3, r3, #1
 800a312:	87e3      	strh	r3, [r4, #62]	; 0x3e
 800a314:	e7d9      	b.n	800a2ca <HAL_SPI_Transmit_DMA+0x82>
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
 800a316:	6822      	ldr	r2, [r4, #0]
 800a318:	6811      	ldr	r1, [r2, #0]
 800a31a:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 800a31e:	400b      	ands	r3, r1
 800a320:	6013      	str	r3, [r2, #0]
 800a322:	6822      	ldr	r2, [r4, #0]
 800a324:	6813      	ldr	r3, [r2, #0]
 800a326:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800a32a:	6013      	str	r3, [r2, #0]
 800a32c:	e7b9      	b.n	800a2a2 <HAL_SPI_Transmit_DMA+0x5a>
  hspi->RxXferCount = 0;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 800a32e:	6822      	ldr	r2, [r4, #0]
 800a330:	6813      	ldr	r3, [r2, #0]
 800a332:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800a336:	6013      	str	r3, [r2, #0]
 800a338:	e7af      	b.n	800a29a <HAL_SPI_Transmit_DMA+0x52>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
      hspi->TxXferCount = (hspi->TxXferCount >> 1);
    }
    else
    {
      SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800a33a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800a33e:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
 800a340:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800a342:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800a344:	085b      	lsrs	r3, r3, #1
 800a346:	3301      	adds	r3, #1
 800a348:	87e3      	strh	r3, [r4, #62]	; 0x3e
 800a34a:	e7be      	b.n	800a2ca <HAL_SPI_Transmit_DMA+0x82>
 800a34c:	0800a525 	.word	0x0800a525
 800a350:	0800a9b1 	.word	0x0800a9b1
 800a354:	0800a98d 	.word	0x0800a98d

0800a358 <HAL_SPI_Receive_DMA>:
  * @note  When the CRC feature is enabled the pData Length must be Size + 1.
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 800a358:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a35c:	f890 505c 	ldrb.w	r5, [r0, #92]	; 0x5c
 800a360:	2d01      	cmp	r5, #1
  * @note  When the CRC feature is enabled the pData Length must be Size + 1.
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
 800a362:	4604      	mov	r4, r0
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a364:	d00c      	beq.n	800a380 <HAL_SPI_Receive_DMA+0x28>

  if(hspi->State != HAL_SPI_STATE_READY)
 800a366:	f890 505d 	ldrb.w	r5, [r0, #93]	; 0x5d
HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a36a:	2601      	movs	r6, #1

  if(hspi->State != HAL_SPI_STATE_READY)
 800a36c:	42b5      	cmp	r5, r6
HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a36e:	f880 605c 	strb.w	r6, [r0, #92]	; 0x5c

  if(hspi->State != HAL_SPI_STATE_READY)
 800a372:	d008      	beq.n	800a386 <HAL_SPI_Receive_DMA+0x2e>
  {
    errorcode = HAL_BUSY;
 800a374:	2002      	movs	r0, #2
    __HAL_SPI_ENABLE(hspi);
  }

error:
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800a376:	2300      	movs	r3, #0
 800a378:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 800a37c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hspi);
 800a380:	2002      	movs	r0, #2

error:
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 800a382:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a386:	4613      	mov	r3, r2
 800a388:	460a      	mov	r2, r1
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pData == NULL) || (Size == 0))
 800a38a:	2900      	cmp	r1, #0
 800a38c:	d053      	beq.n	800a436 <HAL_SPI_Receive_DMA+0xde>
 800a38e:	2b00      	cmp	r3, #0
 800a390:	d051      	beq.n	800a436 <HAL_SPI_Receive_DMA+0xde>
  hspi->RxXferCount = Size;
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
  hspi->TxXferSize  = 0;
  hspi->TxXferCount = 0;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 800a392:	6846      	ldr	r6, [r0, #4]
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = pData;
 800a394:	6421      	str	r1, [r4, #64]	; 0x40
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a396:	2500      	movs	r5, #0
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 800a398:	2704      	movs	r7, #4
  hspi->RxXferCount = Size;
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
  hspi->TxXferSize  = 0;
  hspi->TxXferCount = 0;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 800a39a:	f5b6 7f82 	cmp.w	r6, #260	; 0x104
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800a39e:	6605      	str	r5, [r0, #96]	; 0x60
  hspi->pRxBuffPtr  = pData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 800a3a0:	6385      	str	r5, [r0, #56]	; 0x38
  hspi->TxXferSize  = 0;
 800a3a2:	8785      	strh	r5, [r0, #60]	; 0x3c
  hspi->TxXferCount = 0;
 800a3a4:	87c5      	strh	r5, [r0, #62]	; 0x3e
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = pData;
  hspi->RxXferSize  = Size;
 800a3a6:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
  hspi->RxXferCount = Size;
 800a3aa:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  {
    errorcode = HAL_ERROR;
    goto error;
  }

  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 800a3ae:	f880 705d 	strb.w	r7, [r0, #93]	; 0x5d
  hspi->RxXferCount = Size;
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
  hspi->TxXferSize  = 0;
  hspi->TxXferCount = 0;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 800a3b2:	6885      	ldr	r5, [r0, #8]
 800a3b4:	d043      	beq.n	800a43e <HAL_SPI_Receive_DMA+0xe6>
    /* in this case we call the TransmitReceive process                     */
    return HAL_SPI_TransmitReceive_DMA(hspi,pData,pData,Size);
  }

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800a3b6:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 800a3ba:	d054      	beq.n	800a466 <HAL_SPI_Receive_DMA+0x10e>
  {
    SPI_1LINE_RX(hspi);
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a3bc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a3be:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a3c2:	d044      	beq.n	800a44e <HAL_SPI_Receive_DMA+0xf6>
  {
    SPI_RESET_CRC(hspi);
  }

  /* packing mode management is enabled by the DMA settings */
  if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 800a3c4:	68e3      	ldr	r3, [r4, #12]
 800a3c6:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800a3ca:	d804      	bhi.n	800a3d6 <HAL_SPI_Receive_DMA+0x7e>
 800a3cc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800a3ce:	699b      	ldr	r3, [r3, #24]
 800a3d0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800a3d4:	d02f      	beq.n	800a436 <HAL_SPI_Receive_DMA+0xde>
    /* Restriction the DMA data received is not allowed in this mode */
    errorcode = HAL_ERROR;
    goto error;
  }

  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 800a3d6:	6822      	ldr	r2, [r4, #0]
 800a3d8:	6853      	ldr	r3, [r2, #4]
 800a3da:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800a3de:	6053      	str	r3, [r2, #4]
  if( hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800a3e0:	68e3      	ldr	r3, [r4, #12]
  {
    /* set fiforxthresold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a3e2:	6822      	ldr	r2, [r4, #0]
    errorcode = HAL_ERROR;
    goto error;
  }

  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
  if( hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800a3e4:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
  {
    /* set fiforxthresold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a3e8:	6853      	ldr	r3, [r2, #4]
 800a3ea:	bf8c      	ite	hi
 800a3ec:	f423 5380 	bichi.w	r3, r3, #4096	; 0x1000
  }
  else
  {
    /* set fiforxthresold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a3f0:	f443 5380 	orrls.w	r3, r3, #4096	; 0x1000
 800a3f4:	6053      	str	r3, [r2, #4]
  }

  /* Set the SPI RxDMA Half transfer complete callback */
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 800a3f6:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800a3f8:	4a1e      	ldr	r2, [pc, #120]	; (800a474 <HAL_SPI_Receive_DMA+0x11c>)
 800a3fa:	631a      	str	r2, [r3, #48]	; 0x30

  /* Set the SPI Rx DMA transfer complete callback */
  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 800a3fc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800a3fe:	4a1e      	ldr	r2, [pc, #120]	; (800a478 <HAL_SPI_Receive_DMA+0x120>)
 800a400:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the DMA error callback */
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 800a402:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800a404:	4a1d      	ldr	r2, [pc, #116]	; (800a47c <HAL_SPI_Receive_DMA+0x124>)
 800a406:	635a      	str	r2, [r3, #52]	; 0x34

  /* Enable Rx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 800a408:	6822      	ldr	r2, [r4, #0]
 800a40a:	6853      	ldr	r3, [r2, #4]
 800a40c:	f043 0301 	orr.w	r3, r3, #1
 800a410:	6053      	str	r3, [r2, #4]

  /* Enable the Rx DMA channel */
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 800a412:	6821      	ldr	r1, [r4, #0]
 800a414:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 800a418:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800a41a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800a41c:	310c      	adds	r1, #12
 800a41e:	f7f7 f883 	bl	8001528 <HAL_DMA_Start_IT>

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800a422:	6823      	ldr	r3, [r4, #0]
 800a424:	6818      	ldr	r0, [r3, #0]
 800a426:	f010 0040 	ands.w	r0, r0, #64	; 0x40
 800a42a:	d106      	bne.n	800a43a <HAL_SPI_Receive_DMA+0xe2>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 800a42c:	681a      	ldr	r2, [r3, #0]
 800a42e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a432:	601a      	str	r2, [r3, #0]
 800a434:	e79f      	b.n	800a376 <HAL_SPI_Receive_DMA+0x1e>
    goto error;
  }

  if((pData == NULL) || (Size == 0))
  {
    errorcode = HAL_ERROR;
 800a436:	2001      	movs	r0, #1
 800a438:	e79d      	b.n	800a376 <HAL_SPI_Receive_DMA+0x1e>
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
{
  HAL_StatusTypeDef errorcode = HAL_OK;
 800a43a:	2000      	movs	r0, #0
 800a43c:	e79b      	b.n	800a376 <HAL_SPI_Receive_DMA+0x1e>
  hspi->RxXferCount = Size;
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
  hspi->TxXferSize  = 0;
  hspi->TxXferCount = 0;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 800a43e:	2d00      	cmp	r5, #0
 800a440:	d1b9      	bne.n	800a3b6 <HAL_SPI_Receive_DMA+0x5e>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 800a442:	f880 505c 	strb.w	r5, [r0, #92]	; 0x5c

error:
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 800a446:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800a44a:	f7ff b92d 	b.w	80096a8 <HAL_SPI_TransmitReceive_DMA.part.5>
  }

  /* Reset CRC Calculation */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
 800a44e:	6822      	ldr	r2, [r4, #0]
 800a450:	6811      	ldr	r1, [r2, #0]
 800a452:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 800a456:	400b      	ands	r3, r1
 800a458:	6013      	str	r3, [r2, #0]
 800a45a:	6822      	ldr	r2, [r4, #0]
 800a45c:	6813      	ldr	r3, [r2, #0]
 800a45e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800a462:	6013      	str	r3, [r2, #0]
 800a464:	e7ae      	b.n	800a3c4 <HAL_SPI_Receive_DMA+0x6c>
  }

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_RX(hspi);
 800a466:	6822      	ldr	r2, [r4, #0]
 800a468:	6813      	ldr	r3, [r2, #0]
 800a46a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800a46e:	6013      	str	r3, [r2, #0]
 800a470:	e7a4      	b.n	800a3bc <HAL_SPI_Receive_DMA+0x64>
 800a472:	bf00      	nop
 800a474:	0800a535 	.word	0x0800a535
 800a478:	0800aa19 	.word	0x0800aa19
 800a47c:	0800a98d 	.word	0x0800a98d

0800a480 <HAL_SPI_TransmitReceive_DMA>:
  * @note  When the CRC feature is enabled the pRxData Length must be Size + 1
  * @param  Size: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
{
 800a480:	b410      	push	{r4}
  HAL_StatusTypeDef errorcode = HAL_OK;
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);
 800a482:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
 800a486:	2c01      	cmp	r4, #1
 800a488:	d003      	beq.n	800a492 <HAL_SPI_TransmitReceive_DMA+0x12>

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 800a48a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a48e:	f7ff b90b 	b.w	80096a8 <HAL_SPI_TransmitReceive_DMA.part.5>
 800a492:	2002      	movs	r0, #2
 800a494:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a498:	4770      	bx	lr
 800a49a:	bf00      	nop

0800a49c <HAL_SPI_DMAPause>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
{
  /* Process Locked */
  __HAL_LOCK(hspi);
 800a49c:	f890 205c 	ldrb.w	r2, [r0, #92]	; 0x5c
 800a4a0:	2a01      	cmp	r2, #1
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
{
 800a4a2:	4603      	mov	r3, r0
  /* Process Locked */
  __HAL_LOCK(hspi);
 800a4a4:	d00c      	beq.n	800a4c0 <HAL_SPI_DMAPause+0x24>

  /* Disable the SPI DMA Tx & Rx requests */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800a4a6:	6800      	ldr	r0, [r0, #0]
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
{
  /* Process Locked */
  __HAL_LOCK(hspi);
 800a4a8:	2201      	movs	r2, #1
 800a4aa:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

  /* Disable the SPI DMA Tx & Rx requests */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800a4ae:	6842      	ldr	r2, [r0, #4]

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800a4b0:	2100      	movs	r1, #0
{
  /* Process Locked */
  __HAL_LOCK(hspi);

  /* Disable the SPI DMA Tx & Rx requests */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800a4b2:	f022 0203 	bic.w	r2, r2, #3
 800a4b6:	6042      	str	r2, [r0, #4]

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);

  return HAL_OK;
 800a4b8:	4608      	mov	r0, r1

  /* Disable the SPI DMA Tx & Rx requests */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800a4ba:	f883 105c 	strb.w	r1, [r3, #92]	; 0x5c

  return HAL_OK;
 800a4be:	4770      	bx	lr
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
{
  /* Process Locked */
  __HAL_LOCK(hspi);
 800a4c0:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);

  return HAL_OK;
}
 800a4c2:	4770      	bx	lr

0800a4c4 <HAL_SPI_DMAResume>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
{
  /* Process Locked */
  __HAL_LOCK(hspi);
 800a4c4:	f890 205c 	ldrb.w	r2, [r0, #92]	; 0x5c
 800a4c8:	2a01      	cmp	r2, #1
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
{
 800a4ca:	4603      	mov	r3, r0
  /* Process Locked */
  __HAL_LOCK(hspi);
 800a4cc:	d00c      	beq.n	800a4e8 <HAL_SPI_DMAResume+0x24>

  /* Enable the SPI DMA Tx & Rx requests */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800a4ce:	6800      	ldr	r0, [r0, #0]
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
{
  /* Process Locked */
  __HAL_LOCK(hspi);
 800a4d0:	2201      	movs	r2, #1
 800a4d2:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

  /* Enable the SPI DMA Tx & Rx requests */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800a4d6:	6842      	ldr	r2, [r0, #4]

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800a4d8:	2100      	movs	r1, #0
{
  /* Process Locked */
  __HAL_LOCK(hspi);

  /* Enable the SPI DMA Tx & Rx requests */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800a4da:	f042 0203 	orr.w	r2, r2, #3
 800a4de:	6042      	str	r2, [r0, #4]

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);

  return HAL_OK;
 800a4e0:	4608      	mov	r0, r1

  /* Enable the SPI DMA Tx & Rx requests */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800a4e2:	f883 105c 	strb.w	r1, [r3, #92]	; 0x5c

  return HAL_OK;
 800a4e6:	4770      	bx	lr
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
{
  /* Process Locked */
  __HAL_LOCK(hspi);
 800a4e8:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);

  return HAL_OK;
}
 800a4ea:	4770      	bx	lr

0800a4ec <HAL_SPI_DMAStop>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
{
 800a4ec:	b510      	push	{r4, lr}
 800a4ee:	4604      	mov	r4, r0
     when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
     and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
     */

  /* Abort the SPI DMA tx channel */
  if(hspi->hdmatx != NULL)
 800a4f0:	6d40      	ldr	r0, [r0, #84]	; 0x54
 800a4f2:	b108      	cbz	r0, 800a4f8 <HAL_SPI_DMAStop+0xc>
  {
    HAL_DMA_Abort(hspi->hdmatx);
 800a4f4:	f7f7 f846 	bl	8001584 <HAL_DMA_Abort>
  }
  /* Abort the SPI DMA rx channel */
  if(hspi->hdmarx != NULL)
 800a4f8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800a4fa:	b108      	cbz	r0, 800a500 <HAL_SPI_DMAStop+0x14>
  {
    HAL_DMA_Abort(hspi->hdmarx);
 800a4fc:	f7f7 f842 	bl	8001584 <HAL_DMA_Abort>
  }

  /* Disable the SPI DMA Tx & Rx requests */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800a500:	6822      	ldr	r2, [r4, #0]
 800a502:	6853      	ldr	r3, [r2, #4]
  hspi->State = HAL_SPI_STATE_READY;
 800a504:	2101      	movs	r1, #1
  {
    HAL_DMA_Abort(hspi->hdmarx);
  }

  /* Disable the SPI DMA Tx & Rx requests */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800a506:	f023 0303 	bic.w	r3, r3, #3
 800a50a:	6053      	str	r3, [r2, #4]
  hspi->State = HAL_SPI_STATE_READY;
 800a50c:	f884 105d 	strb.w	r1, [r4, #93]	; 0x5d
  return HAL_OK;
}
 800a510:	2000      	movs	r0, #0
 800a512:	bd10      	pop	{r4, pc}

0800a514 <HAL_SPI_TxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a514:	4770      	bx	lr
 800a516:	bf00      	nop

0800a518 <HAL_SPI_RxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a518:	4770      	bx	lr
 800a51a:	bf00      	nop

0800a51c <HAL_SPI_TxRxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a51c:	4770      	bx	lr
 800a51e:	bf00      	nop

0800a520 <HAL_SPI_TxHalfCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a520:	4770      	bx	lr
 800a522:	bf00      	nop

0800a524 <SPI_DMAHalfTransmitCplt>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
{
 800a524:	b508      	push	{r3, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  HAL_SPI_TxHalfCpltCallback(hspi);
 800a526:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800a528:	f7ff fffa 	bl	800a520 <HAL_SPI_TxHalfCpltCallback>
 800a52c:	bd08      	pop	{r3, pc}
 800a52e:	bf00      	nop

0800a530 <HAL_SPI_RxHalfCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a530:	4770      	bx	lr
 800a532:	bf00      	nop

0800a534 <SPI_DMAHalfReceiveCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
{
 800a534:	b508      	push	{r3, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  HAL_SPI_RxHalfCpltCallback(hspi);
 800a536:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800a538:	f7ff fffa 	bl	800a530 <HAL_SPI_RxHalfCpltCallback>
 800a53c:	bd08      	pop	{r3, pc}
 800a53e:	bf00      	nop

0800a540 <HAL_SPI_TxRxHalfCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
 800a540:	4770      	bx	lr
 800a542:	bf00      	nop

0800a544 <SPI_DMAHalfTransmitReceiveCplt>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
 800a544:	b508      	push	{r3, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  HAL_SPI_TxRxHalfCpltCallback(hspi);
 800a546:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800a548:	f7ff fffa 	bl	800a540 <HAL_SPI_TxRxHalfCpltCallback>
 800a54c:	bd08      	pop	{r3, pc}
 800a54e:	bf00      	nop

0800a550 <HAL_SPI_ErrorCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
 __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
 800a550:	4770      	bx	lr
 800a552:	bf00      	nop

0800a554 <SPI_CloseTx_ISR>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
{
 800a554:	b510      	push	{r4, lr}
  /* Disable TXE and ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
 800a556:	6802      	ldr	r2, [r0, #0]
 800a558:	6853      	ldr	r3, [r2, #4]
 800a55a:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
{
 800a55e:	b082      	sub	sp, #8
  /* Disable TXE and ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
 800a560:	2132      	movs	r1, #50	; 0x32
  * @retval None
  */
static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
{
  /* Disable TXE and ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
 800a562:	6053      	str	r3, [r2, #4]
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
{
 800a564:	4604      	mov	r4, r0
  /* Disable TXE and ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
 800a566:	f7fe ffa9 	bl	80094bc <SPI_EndRxTxTransaction>
 800a56a:	b958      	cbnz	r0, 800a584 <SPI_CloseTx_ISR+0x30>
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800a56c:	68a2      	ldr	r2, [r4, #8]
 800a56e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800a570:	b172      	cbz	r2, 800a590 <SPI_CloseTx_ISR+0x3c>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
  }

  hspi->State = HAL_SPI_STATE_READY;
 800a572:	2201      	movs	r2, #1
 800a574:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800a578:	b9ab      	cbnz	r3, 800a5a6 <SPI_CloseTx_ISR+0x52>
  {
    HAL_SPI_ErrorCallback(hspi);
  }
  else
  {
    HAL_SPI_TxCpltCallback(hspi);
 800a57a:	4620      	mov	r0, r4
 800a57c:	f7ff ffca 	bl	800a514 <HAL_SPI_TxCpltCallback>
  }
}
 800a580:	b002      	add	sp, #8
 800a582:	bd10      	pop	{r4, pc}
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
 800a584:	6e23      	ldr	r3, [r4, #96]	; 0x60
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800a586:	68a2      	ldr	r2, [r4, #8]
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
 800a588:	f043 0320 	orr.w	r3, r3, #32
 800a58c:	6623      	str	r3, [r4, #96]	; 0x60
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800a58e:	b97a      	cbnz	r2, 800a5b0 <SPI_CloseTx_ISR+0x5c>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800a590:	6822      	ldr	r2, [r4, #0]
 800a592:	68d1      	ldr	r1, [r2, #12]
 800a594:	9101      	str	r1, [sp, #4]
 800a596:	6892      	ldr	r2, [r2, #8]
 800a598:	9201      	str	r2, [sp, #4]
 800a59a:	9a01      	ldr	r2, [sp, #4]
  }

  hspi->State = HAL_SPI_STATE_READY;
 800a59c:	2201      	movs	r2, #1
 800a59e:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800a5a2:	2b00      	cmp	r3, #0
 800a5a4:	d0e9      	beq.n	800a57a <SPI_CloseTx_ISR+0x26>
  {
    HAL_SPI_ErrorCallback(hspi);
 800a5a6:	4620      	mov	r0, r4
 800a5a8:	f7ff ffd2 	bl	800a550 <HAL_SPI_ErrorCallback>
  }
  else
  {
    HAL_SPI_TxCpltCallback(hspi);
  }
}
 800a5ac:	b002      	add	sp, #8
 800a5ae:	bd10      	pop	{r4, pc}
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
  }

  hspi->State = HAL_SPI_STATE_READY;
 800a5b0:	2301      	movs	r3, #1
 800a5b2:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
 800a5b6:	e7f6      	b.n	800a5a6 <SPI_CloseTx_ISR+0x52>

0800a5b8 <SPI_TxISR_8BIT>:
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
{
  *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 800a5b8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800a5ba:	6802      	ldr	r2, [r0, #0]
 800a5bc:	1c59      	adds	r1, r3, #1
 800a5be:	6381      	str	r1, [r0, #56]	; 0x38
 800a5c0:	781b      	ldrb	r3, [r3, #0]
 800a5c2:	7313      	strb	r3, [r2, #12]
  hspi->TxXferCount--;
 800a5c4:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 800a5c6:	3b01      	subs	r3, #1
 800a5c8:	b29b      	uxth	r3, r3
 800a5ca:	87c3      	strh	r3, [r0, #62]	; 0x3e

  if(hspi->TxXferCount == 0)
 800a5cc:	b923      	cbnz	r3, 800a5d8 <SPI_TxISR_8BIT+0x20>
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a5ce:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a5d0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a5d4:	d001      	beq.n	800a5da <SPI_TxISR_8BIT+0x22>
    {
      /* Enable CRC Transmission */
      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    }

    SPI_CloseTx_ISR(hspi);
 800a5d6:	e7bd      	b.n	800a554 <SPI_CloseTx_ISR>
 800a5d8:	4770      	bx	lr
  if(hspi->TxXferCount == 0)
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      /* Enable CRC Transmission */
      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 800a5da:	6802      	ldr	r2, [r0, #0]
 800a5dc:	6813      	ldr	r3, [r2, #0]
 800a5de:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800a5e2:	6013      	str	r3, [r2, #0]
    }

    SPI_CloseTx_ISR(hspi);
 800a5e4:	e7b6      	b.n	800a554 <SPI_CloseTx_ISR>
 800a5e6:	bf00      	nop

0800a5e8 <SPI_TxISR_16BIT>:
  * @retval None
  */
static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Transmit data in 16 Bit mode */
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800a5e8:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800a5ea:	6803      	ldr	r3, [r0, #0]
 800a5ec:	8812      	ldrh	r2, [r2, #0]
 800a5ee:	60da      	str	r2, [r3, #12]
  hspi->pTxBuffPtr += sizeof(uint16_t);
  hspi->TxXferCount--;
 800a5f0:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
  */
static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Transmit data in 16 Bit mode */
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
  hspi->pTxBuffPtr += sizeof(uint16_t);
 800a5f2:	6b82      	ldr	r2, [r0, #56]	; 0x38
  hspi->TxXferCount--;
 800a5f4:	3b01      	subs	r3, #1
  */
static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Transmit data in 16 Bit mode */
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
  hspi->pTxBuffPtr += sizeof(uint16_t);
 800a5f6:	3202      	adds	r2, #2
  hspi->TxXferCount--;
 800a5f8:	b29b      	uxth	r3, r3
  */
static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Transmit data in 16 Bit mode */
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
  hspi->pTxBuffPtr += sizeof(uint16_t);
 800a5fa:	6382      	str	r2, [r0, #56]	; 0x38
  hspi->TxXferCount--;
 800a5fc:	87c3      	strh	r3, [r0, #62]	; 0x3e

  if(hspi->TxXferCount == 0)
 800a5fe:	b923      	cbnz	r3, 800a60a <SPI_TxISR_16BIT+0x22>
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a600:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a602:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a606:	d001      	beq.n	800a60c <SPI_TxISR_16BIT+0x24>
    {
      /* Enable CRC Transmission */
      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    }
    SPI_CloseTx_ISR(hspi);
 800a608:	e7a4      	b.n	800a554 <SPI_CloseTx_ISR>
 800a60a:	4770      	bx	lr
  if(hspi->TxXferCount == 0)
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      /* Enable CRC Transmission */
      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 800a60c:	6802      	ldr	r2, [r0, #0]
 800a60e:	6813      	ldr	r3, [r2, #0]
 800a610:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800a614:	6013      	str	r3, [r2, #0]
    }
    SPI_CloseTx_ISR(hspi);
 800a616:	e79d      	b.n	800a554 <SPI_CloseTx_ISR>

0800a618 <SPI_CloseRx_ISR>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
{
 800a618:	b510      	push	{r4, lr}
    /* Disable RXNE and ERR interrupt */
    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
 800a61a:	6802      	ldr	r2, [r0, #0]
 800a61c:	6853      	ldr	r3, [r2, #4]
 800a61e:	f023 0360 	bic.w	r3, r3, #96	; 0x60

    /* Check the end of the transaction */
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
 800a622:	2132      	movs	r1, #50	; 0x32
  * @retval None
  */
static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
{
    /* Disable RXNE and ERR interrupt */
    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
 800a624:	6053      	str	r3, [r2, #4]
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
{
 800a626:	4604      	mov	r4, r0
    /* Disable RXNE and ERR interrupt */
    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));

    /* Check the end of the transaction */
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
 800a628:	f7fe ff62 	bl	80094f0 <SPI_EndRxTransaction>
 800a62c:	b960      	cbnz	r0, 800a648 <SPI_CloseRx_ISR+0x30>
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
    }
    hspi->State = HAL_SPI_STATE_READY;
 800a62e:	2301      	movs	r3, #1

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800a630:	6822      	ldr	r2, [r4, #0]
    /* Check the end of the transaction */
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
    }
    hspi->State = HAL_SPI_STATE_READY;
 800a632:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800a636:	6891      	ldr	r1, [r2, #8]
 800a638:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800a63a:	06c8      	lsls	r0, r1, #27
 800a63c:	d40f      	bmi.n	800a65e <SPI_CloseRx_ISR+0x46>
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
      HAL_SPI_ErrorCallback(hspi);
    }
    else
    {
      if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
 800a63e:	b1c3      	cbz	r3, 800a672 <SPI_CloseRx_ISR+0x5a>
      {
        HAL_SPI_RxCpltCallback(hspi);
      }
      else
      {
        HAL_SPI_ErrorCallback(hspi);
 800a640:	4620      	mov	r0, r4
 800a642:	f7ff ff85 	bl	800a550 <HAL_SPI_ErrorCallback>
 800a646:	bd10      	pop	{r4, pc}
    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));

    /* Check the end of the transaction */
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
 800a648:	6e23      	ldr	r3, [r4, #96]	; 0x60
    }
    hspi->State = HAL_SPI_STATE_READY;

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800a64a:	6822      	ldr	r2, [r4, #0]
    /* Check the end of the transaction */
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
    }
    hspi->State = HAL_SPI_STATE_READY;
 800a64c:	2101      	movs	r1, #1
    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));

    /* Check the end of the transaction */
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
 800a64e:	f043 0320 	orr.w	r3, r3, #32
 800a652:	6623      	str	r3, [r4, #96]	; 0x60
    }
    hspi->State = HAL_SPI_STATE_READY;
 800a654:	f884 105d 	strb.w	r1, [r4, #93]	; 0x5d

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800a658:	6891      	ldr	r1, [r2, #8]
 800a65a:	06c9      	lsls	r1, r1, #27
 800a65c:	d5f0      	bpl.n	800a640 <SPI_CloseRx_ISR+0x28>
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800a65e:	f043 0302 	orr.w	r3, r3, #2
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800a662:	f64f 71ef 	movw	r1, #65519	; 0xffef
    hspi->State = HAL_SPI_STATE_READY;

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800a666:	6623      	str	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
      HAL_SPI_ErrorCallback(hspi);
 800a668:	4620      	mov	r0, r4

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800a66a:	6091      	str	r1, [r2, #8]
      HAL_SPI_ErrorCallback(hspi);
 800a66c:	f7ff ff70 	bl	800a550 <HAL_SPI_ErrorCallback>
 800a670:	bd10      	pop	{r4, pc}
    }
    else
    {
      if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
      {
        HAL_SPI_RxCpltCallback(hspi);
 800a672:	4620      	mov	r0, r4
 800a674:	f7ff ff50 	bl	800a518 <HAL_SPI_RxCpltCallback>
 800a678:	bd10      	pop	{r4, pc}
 800a67a:	bf00      	nop

0800a67c <SPI_RxISR_8BIT>:
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
{
  *hspi->pRxBuffPtr++ = (*(__IO uint8_t *)&hspi->Instance->DR);
 800a67c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a67e:	6802      	ldr	r2, [r0, #0]
 800a680:	1c59      	adds	r1, r3, #1
 800a682:	6401      	str	r1, [r0, #64]	; 0x40
 800a684:	7b12      	ldrb	r2, [r2, #12]
 800a686:	701a      	strb	r2, [r3, #0]
  hspi->RxXferCount--;
 800a688:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 800a68c:	3b01      	subs	r3, #1
 800a68e:	b29b      	uxth	r3, r3

  /* Enable CRC Transmission */
  if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 800a690:	2b01      	cmp	r3, #1
  * @retval None
  */
static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
{
  *hspi->pRxBuffPtr++ = (*(__IO uint8_t *)&hspi->Instance->DR);
  hspi->RxXferCount--;
 800a692:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46

  /* Enable CRC Transmission */
  if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 800a696:	d005      	beq.n	800a6a4 <SPI_RxISR_8BIT+0x28>
  {
    hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
  }

  if(hspi->RxXferCount == 0)
 800a698:	b943      	cbnz	r3, 800a6ac <SPI_RxISR_8BIT+0x30>
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a69a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a69c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a6a0:	d005      	beq.n	800a6ae <SPI_RxISR_8BIT+0x32>
    {
      hspi->RxISR =  SPI_RxISR_8BITCRC;
      return;
    }
    SPI_CloseRx_ISR(hspi);
 800a6a2:	e7b9      	b.n	800a618 <SPI_CloseRx_ISR>
{
  *hspi->pRxBuffPtr++ = (*(__IO uint8_t *)&hspi->Instance->DR);
  hspi->RxXferCount--;

  /* Enable CRC Transmission */
  if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 800a6a4:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a6a6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a6aa:	d003      	beq.n	800a6b4 <SPI_RxISR_8BIT+0x38>
 800a6ac:	4770      	bx	lr

  if(hspi->RxXferCount == 0)
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      hspi->RxISR =  SPI_RxISR_8BITCRC;
 800a6ae:	4b05      	ldr	r3, [pc, #20]	; (800a6c4 <SPI_RxISR_8BIT+0x48>)
 800a6b0:	64c3      	str	r3, [r0, #76]	; 0x4c
 800a6b2:	4770      	bx	lr
  hspi->RxXferCount--;

  /* Enable CRC Transmission */
  if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
  {
    hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 800a6b4:	6802      	ldr	r2, [r0, #0]
 800a6b6:	6813      	ldr	r3, [r2, #0]
 800a6b8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800a6bc:	6013      	str	r3, [r2, #0]
 800a6be:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 800a6c2:	e7e9      	b.n	800a698 <SPI_RxISR_8BIT+0x1c>
 800a6c4:	0800a6c9 	.word	0x0800a6c9

0800a6c8 <SPI_RxISR_8BITCRC>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
{
 800a6c8:	b500      	push	{lr}
  __IO uint8_t tmpreg = *((uint8_t*)&hspi->Instance->DR);
 800a6ca:	6801      	ldr	r1, [r0, #0]
  UNUSED(tmpreg); /* To avoid GCC warning */

  hspi->CRCSize--;
 800a6cc:	6c83      	ldr	r3, [r0, #72]	; 0x48
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
{
  __IO uint8_t tmpreg = *((uint8_t*)&hspi->Instance->DR);
 800a6ce:	7b09      	ldrb	r1, [r1, #12]
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
{
 800a6d0:	b083      	sub	sp, #12
  __IO uint8_t tmpreg = *((uint8_t*)&hspi->Instance->DR);
  UNUSED(tmpreg); /* To avoid GCC warning */

  hspi->CRCSize--;
 800a6d2:	3b01      	subs	r3, #1
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
{
  __IO uint8_t tmpreg = *((uint8_t*)&hspi->Instance->DR);
 800a6d4:	f88d 1007 	strb.w	r1, [sp, #7]
  UNUSED(tmpreg); /* To avoid GCC warning */
 800a6d8:	f89d 1007 	ldrb.w	r1, [sp, #7]

  hspi->CRCSize--;
 800a6dc:	6483      	str	r3, [r0, #72]	; 0x48

  if(hspi->CRCSize == 0)
 800a6de:	b90b      	cbnz	r3, 800a6e4 <SPI_RxISR_8BITCRC+0x1c>
  {
    SPI_CloseRx_ISR(hspi);
 800a6e0:	f7ff ff9a 	bl	800a618 <SPI_CloseRx_ISR>
  }
}
 800a6e4:	b003      	add	sp, #12
 800a6e6:	f85d fb04 	ldr.w	pc, [sp], #4
 800a6ea:	bf00      	nop

0800a6ec <SPI_RxISR_16BIT>:
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 800a6ec:	6802      	ldr	r2, [r0, #0]
 800a6ee:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a6f0:	68d2      	ldr	r2, [r2, #12]
 800a6f2:	801a      	strh	r2, [r3, #0]
  hspi->pRxBuffPtr += sizeof(uint16_t);
  hspi->RxXferCount--;
 800a6f4:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
  * @retval None
  */
static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
  hspi->pRxBuffPtr += sizeof(uint16_t);
 800a6f8:	6c02      	ldr	r2, [r0, #64]	; 0x40
  hspi->RxXferCount--;
 800a6fa:	3b01      	subs	r3, #1
 800a6fc:	b29b      	uxth	r3, r3
  * @retval None
  */
static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
  hspi->pRxBuffPtr += sizeof(uint16_t);
 800a6fe:	3202      	adds	r2, #2
  hspi->RxXferCount--;

  /* Enable CRC Transmission */
  if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 800a700:	2b01      	cmp	r3, #1
  * @retval None
  */
static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
  hspi->pRxBuffPtr += sizeof(uint16_t);
 800a702:	6402      	str	r2, [r0, #64]	; 0x40
  hspi->RxXferCount--;
 800a704:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46

  /* Enable CRC Transmission */
  if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 800a708:	d005      	beq.n	800a716 <SPI_RxISR_16BIT+0x2a>
  {
    hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
  }

  if(hspi->RxXferCount == 0)
 800a70a:	b943      	cbnz	r3, 800a71e <SPI_RxISR_16BIT+0x32>
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a70c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a70e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a712:	d005      	beq.n	800a720 <SPI_RxISR_16BIT+0x34>
    {
      hspi->RxISR = SPI_RxISR_16BITCRC;
      return;
    }
    SPI_CloseRx_ISR(hspi);
 800a714:	e780      	b.n	800a618 <SPI_CloseRx_ISR>
  *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
  hspi->pRxBuffPtr += sizeof(uint16_t);
  hspi->RxXferCount--;

  /* Enable CRC Transmission */
  if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 800a716:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a718:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a71c:	d003      	beq.n	800a726 <SPI_RxISR_16BIT+0x3a>
 800a71e:	4770      	bx	lr

  if(hspi->RxXferCount == 0)
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      hspi->RxISR = SPI_RxISR_16BITCRC;
 800a720:	4b05      	ldr	r3, [pc, #20]	; (800a738 <SPI_RxISR_16BIT+0x4c>)
 800a722:	64c3      	str	r3, [r0, #76]	; 0x4c
 800a724:	4770      	bx	lr
  hspi->RxXferCount--;

  /* Enable CRC Transmission */
  if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
  {
    hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 800a726:	6802      	ldr	r2, [r0, #0]
 800a728:	6813      	ldr	r3, [r2, #0]
 800a72a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800a72e:	6013      	str	r3, [r2, #0]
 800a730:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 800a734:	e7e9      	b.n	800a70a <SPI_RxISR_16BIT+0x1e>
 800a736:	bf00      	nop
 800a738:	0800a73d 	.word	0x0800a73d

0800a73c <SPI_RxISR_16BITCRC>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
{
 800a73c:	b500      	push	{lr}
  __IO uint16_t tmpreg;

  tmpreg = hspi->Instance->DR;
 800a73e:	6803      	ldr	r3, [r0, #0]
 800a740:	68da      	ldr	r2, [r3, #12]
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
{
 800a742:	b083      	sub	sp, #12
  __IO uint16_t tmpreg;

  tmpreg = hspi->Instance->DR;
 800a744:	b292      	uxth	r2, r2
 800a746:	f8ad 2006 	strh.w	r2, [sp, #6]
  UNUSED(tmpreg); /* To avoid GCC warning */
 800a74a:	f8bd 2006 	ldrh.w	r2, [sp, #6]

  /* Disable RXNE and ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
 800a74e:	685a      	ldr	r2, [r3, #4]
 800a750:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800a754:	605a      	str	r2, [r3, #4]

  SPI_CloseRx_ISR(hspi);
 800a756:	f7ff ff5f 	bl	800a618 <SPI_CloseRx_ISR>
}
 800a75a:	b003      	add	sp, #12
 800a75c:	f85d fb04 	ldr.w	pc, [sp], #4

0800a760 <SPI_CloseRxTx_ISR>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
{
 800a760:	b510      	push	{r4, lr}
  /* Disable ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 800a762:	6802      	ldr	r2, [r0, #0]
 800a764:	6853      	ldr	r3, [r2, #4]
 800a766:	f023 0320 	bic.w	r3, r3, #32

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
 800a76a:	2132      	movs	r1, #50	; 0x32
  * @retval None
  */
static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
{
  /* Disable ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 800a76c:	6053      	str	r3, [r2, #4]
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
{
 800a76e:	4604      	mov	r4, r0
  /* Disable ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
 800a770:	f7fe fea4 	bl	80094bc <SPI_EndRxTxTransaction>
 800a774:	b988      	cbnz	r0, 800a79a <SPI_CloseRxTx_ISR+0x3a>
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
  }

  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800a776:	6822      	ldr	r2, [r4, #0]
 800a778:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800a77a:	6891      	ldr	r1, [r2, #8]
 800a77c:	06c8      	lsls	r0, r1, #27
 800a77e:	d41b      	bmi.n	800a7b8 <SPI_CloseRxTx_ISR+0x58>
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    HAL_SPI_ErrorCallback(hspi);
  }
  else
  {
    if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
 800a780:	b99b      	cbnz	r3, 800a7aa <SPI_CloseRxTx_ISR+0x4a>
    {
      if(hspi->State == HAL_SPI_STATE_BUSY_RX)
 800a782:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
 800a786:	2b04      	cmp	r3, #4
      {
      	hspi->State = HAL_SPI_STATE_READY;
 800a788:	f04f 0301 	mov.w	r3, #1
 800a78c:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
        HAL_SPI_RxCpltCallback(hspi);
 800a790:	4620      	mov	r0, r4
  }
  else
  {
    if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
    {
      if(hspi->State == HAL_SPI_STATE_BUSY_RX)
 800a792:	d01e      	beq.n	800a7d2 <SPI_CloseRxTx_ISR+0x72>
        HAL_SPI_RxCpltCallback(hspi);
      }
      else
      {
      	hspi->State = HAL_SPI_STATE_READY;
        HAL_SPI_TxRxCpltCallback(hspi);
 800a794:	f7ff fec2 	bl	800a51c <HAL_SPI_TxRxCpltCallback>
 800a798:	bd10      	pop	{r4, pc}
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
 800a79a:	6e23      	ldr	r3, [r4, #96]	; 0x60
  }

  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800a79c:	6822      	ldr	r2, [r4, #0]
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);

  /* Check the end of the transaction */
  if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
  {
    hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
 800a79e:	f043 0320 	orr.w	r3, r3, #32
 800a7a2:	6623      	str	r3, [r4, #96]	; 0x60
  }

  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800a7a4:	6891      	ldr	r1, [r2, #8]
 800a7a6:	06c9      	lsls	r1, r1, #27
 800a7a8:	d406      	bmi.n	800a7b8 <SPI_CloseRxTx_ISR+0x58>
        HAL_SPI_TxRxCpltCallback(hspi);
      }
    }
    else
    {
      hspi->State = HAL_SPI_STATE_READY;
 800a7aa:	2301      	movs	r3, #1
 800a7ac:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      HAL_SPI_ErrorCallback(hspi);
 800a7b0:	4620      	mov	r0, r4
 800a7b2:	f7ff fecd 	bl	800a550 <HAL_SPI_ErrorCallback>
 800a7b6:	bd10      	pop	{r4, pc}

  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
  {
    hspi->State = HAL_SPI_STATE_READY;
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800a7b8:	f043 0302 	orr.w	r3, r3, #2
  }

  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
  {
    hspi->State = HAL_SPI_STATE_READY;
 800a7bc:	2001      	movs	r0, #1
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800a7be:	f64f 71ef 	movw	r1, #65519	; 0xffef
  }

  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
  {
    hspi->State = HAL_SPI_STATE_READY;
 800a7c2:	f884 005d 	strb.w	r0, [r4, #93]	; 0x5d
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800a7c6:	6623      	str	r3, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    HAL_SPI_ErrorCallback(hspi);
 800a7c8:	4620      	mov	r0, r4
  /* Check if CRC error occurred */
  if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
  {
    hspi->State = HAL_SPI_STATE_READY;
    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800a7ca:	6091      	str	r1, [r2, #8]
    HAL_SPI_ErrorCallback(hspi);
 800a7cc:	f7ff fec0 	bl	800a550 <HAL_SPI_ErrorCallback>
 800a7d0:	bd10      	pop	{r4, pc}
    if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
    {
      if(hspi->State == HAL_SPI_STATE_BUSY_RX)
      {
      	hspi->State = HAL_SPI_STATE_READY;
        HAL_SPI_RxCpltCallback(hspi);
 800a7d2:	f7ff fea1 	bl	800a518 <HAL_SPI_RxCpltCallback>
 800a7d6:	bd10      	pop	{r4, pc}

0800a7d8 <SPI_2linesTxISR_8BIT>:
  * @retval None
  */
static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Transmit data in packing Bit mode */
  if(hspi->TxXferCount >= 2)
 800a7d8:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 800a7da:	2b01      	cmp	r3, #1
 800a7dc:	d919      	bls.n	800a812 <SPI_2linesTxISR_8BIT+0x3a>
  {
    hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800a7de:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800a7e0:	6803      	ldr	r3, [r0, #0]
 800a7e2:	8812      	ldrh	r2, [r2, #0]
 800a7e4:	60da      	str	r2, [r3, #12]
    hspi->pTxBuffPtr += sizeof(uint16_t);
    hspi->TxXferCount -= 2;
 800a7e6:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
{
  /* Transmit data in packing Bit mode */
  if(hspi->TxXferCount >= 2)
  {
    hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
    hspi->pTxBuffPtr += sizeof(uint16_t);
 800a7e8:	6b82      	ldr	r2, [r0, #56]	; 0x38
    hspi->TxXferCount -= 2;
 800a7ea:	3b02      	subs	r3, #2
 800a7ec:	b29b      	uxth	r3, r3
{
  /* Transmit data in packing Bit mode */
  if(hspi->TxXferCount >= 2)
  {
    hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
    hspi->pTxBuffPtr += sizeof(uint16_t);
 800a7ee:	3202      	adds	r2, #2
    hspi->TxXferCount -= 2;
 800a7f0:	87c3      	strh	r3, [r0, #62]	; 0x3e
{
  /* Transmit data in packing Bit mode */
  if(hspi->TxXferCount >= 2)
  {
    hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
    hspi->pTxBuffPtr += sizeof(uint16_t);
 800a7f2:	6382      	str	r2, [r0, #56]	; 0x38
    *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
    hspi->TxXferCount--;
  }

  /* check the end of the transmission */
  if(hspi->TxXferCount == 0)
 800a7f4:	b95b      	cbnz	r3, 800a80e <SPI_2linesTxISR_8BIT+0x36>
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a7f6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a7f8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a7fc:	d014      	beq.n	800a828 <SPI_2linesTxISR_8BIT+0x50>
    {
      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    }
    /* Disable TXE interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
 800a7fe:	6802      	ldr	r2, [r0, #0]
 800a800:	6853      	ldr	r3, [r2, #4]
 800a802:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800a806:	6053      	str	r3, [r2, #4]

    if(hspi->RxXferCount == 0)
 800a808:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 800a80c:	b103      	cbz	r3, 800a810 <SPI_2linesTxISR_8BIT+0x38>
 800a80e:	4770      	bx	lr
    {
      SPI_CloseRxTx_ISR(hspi);
 800a810:	e7a6      	b.n	800a760 <SPI_CloseRxTx_ISR>
    hspi->TxXferCount -= 2;
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 800a812:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800a814:	6802      	ldr	r2, [r0, #0]
 800a816:	1c59      	adds	r1, r3, #1
 800a818:	6381      	str	r1, [r0, #56]	; 0x38
 800a81a:	781b      	ldrb	r3, [r3, #0]
 800a81c:	7313      	strb	r3, [r2, #12]
    hspi->TxXferCount--;
 800a81e:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 800a820:	3b01      	subs	r3, #1
 800a822:	b29b      	uxth	r3, r3
 800a824:	87c3      	strh	r3, [r0, #62]	; 0x3e
 800a826:	e7e5      	b.n	800a7f4 <SPI_2linesTxISR_8BIT+0x1c>
  /* check the end of the transmission */
  if(hspi->TxXferCount == 0)
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 800a828:	6802      	ldr	r2, [r0, #0]
 800a82a:	6813      	ldr	r3, [r2, #0]
 800a82c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800a830:	6013      	str	r3, [r2, #0]
 800a832:	e7e4      	b.n	800a7fe <SPI_2linesTxISR_8BIT+0x26>

0800a834 <SPI_2linesRxISR_8BIT>:
  * @retval None
  */
static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Receive data in packing mode */
  if(hspi->RxXferCount > 1)
 800a834:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 800a838:	2b01      	cmp	r3, #1
 800a83a:	d923      	bls.n	800a884 <SPI_2linesRxISR_8BIT+0x50>
  {
    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 800a83c:	6802      	ldr	r2, [r0, #0]
 800a83e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a840:	68d2      	ldr	r2, [r2, #12]
 800a842:	801a      	strh	r2, [r3, #0]
    hspi->pRxBuffPtr += sizeof(uint16_t);
    hspi->RxXferCount -= 2;
 800a844:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
{
  /* Receive data in packing mode */
  if(hspi->RxXferCount > 1)
  {
    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    hspi->pRxBuffPtr += sizeof(uint16_t);
 800a848:	6c02      	ldr	r2, [r0, #64]	; 0x40
    hspi->RxXferCount -= 2;
 800a84a:	3b02      	subs	r3, #2
 800a84c:	b29b      	uxth	r3, r3
{
  /* Receive data in packing mode */
  if(hspi->RxXferCount > 1)
  {
    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    hspi->pRxBuffPtr += sizeof(uint16_t);
 800a84e:	3202      	adds	r2, #2
    hspi->RxXferCount -= 2;
    if(hspi->RxXferCount == 1) 
 800a850:	2b01      	cmp	r3, #1
  /* Receive data in packing mode */
  if(hspi->RxXferCount > 1)
  {
    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    hspi->pRxBuffPtr += sizeof(uint16_t);
    hspi->RxXferCount -= 2;
 800a852:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
{
  /* Receive data in packing mode */
  if(hspi->RxXferCount > 1)
  {
    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    hspi->pRxBuffPtr += sizeof(uint16_t);
 800a856:	6402      	str	r2, [r0, #64]	; 0x40
    hspi->RxXferCount -= 2;
    if(hspi->RxXferCount == 1) 
 800a858:	d00c      	beq.n	800a874 <SPI_2linesRxISR_8BIT+0x40>
    *hspi->pRxBuffPtr++ = *((__IO uint8_t *)&hspi->Instance->DR);
    hspi->RxXferCount--;
  }

  /* check end of the reception */
  if(hspi->RxXferCount == 0)
 800a85a:	b953      	cbnz	r3, 800a872 <SPI_2linesRxISR_8BIT+0x3e>
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a85c:	6a83      	ldr	r3, [r0, #40]	; 0x28
    {
      SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a85e:	6802      	ldr	r2, [r0, #0]
  }

  /* check end of the reception */
  if(hspi->RxXferCount == 0)
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a860:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a864:	d01c      	beq.n	800a8a0 <SPI_2linesRxISR_8BIT+0x6c>
      hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
      return;
    }

    /* Disable RXNE interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
 800a866:	6853      	ldr	r3, [r2, #4]
 800a868:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a86c:	6053      	str	r3, [r2, #4]

    if(hspi->TxXferCount == 0)
 800a86e:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 800a870:	b1ab      	cbz	r3, 800a89e <SPI_2linesRxISR_8BIT+0x6a>
 800a872:	4770      	bx	lr
    hspi->pRxBuffPtr += sizeof(uint16_t);
    hspi->RxXferCount -= 2;
    if(hspi->RxXferCount == 1) 
    {
      /* set fiforxthresold according the reception data length: 8bit */
      SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a874:	6802      	ldr	r2, [r0, #0]
 800a876:	6853      	ldr	r3, [r2, #4]
 800a878:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800a87c:	6053      	str	r3, [r2, #4]
 800a87e:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 800a882:	e7ea      	b.n	800a85a <SPI_2linesRxISR_8BIT+0x26>
    }
  }
  /* Receive data in 8 Bit mode */
  else
  {
    *hspi->pRxBuffPtr++ = *((__IO uint8_t *)&hspi->Instance->DR);
 800a884:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a886:	6802      	ldr	r2, [r0, #0]
 800a888:	1c59      	adds	r1, r3, #1
 800a88a:	6401      	str	r1, [r0, #64]	; 0x40
 800a88c:	7b12      	ldrb	r2, [r2, #12]
 800a88e:	701a      	strb	r2, [r3, #0]
    hspi->RxXferCount--;
 800a890:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 800a894:	3b01      	subs	r3, #1
 800a896:	b29b      	uxth	r3, r3
 800a898:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
 800a89c:	e7dd      	b.n	800a85a <SPI_2linesRxISR_8BIT+0x26>
    /* Disable RXNE interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);

    if(hspi->TxXferCount == 0)
    {
      SPI_CloseRxTx_ISR(hspi);
 800a89e:	e75f      	b.n	800a760 <SPI_CloseRxTx_ISR>
  /* check end of the reception */
  if(hspi->RxXferCount == 0)
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a8a0:	6853      	ldr	r3, [r2, #4]
      hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
 800a8a2:	4903      	ldr	r1, [pc, #12]	; (800a8b0 <SPI_2linesRxISR_8BIT+0x7c>)
  /* check end of the reception */
  if(hspi->RxXferCount == 0)
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800a8a4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800a8a8:	6053      	str	r3, [r2, #4]
      hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
 800a8aa:	64c1      	str	r1, [r0, #76]	; 0x4c
 800a8ac:	4770      	bx	lr
 800a8ae:	bf00      	nop
 800a8b0:	0800a8b5 	.word	0x0800a8b5

0800a8b4 <SPI_2linesRxISR_8BITCRC>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
{
 800a8b4:	b510      	push	{r4, lr}
  __IO uint8_t tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 800a8b6:	6804      	ldr	r4, [r0, #0]
  UNUSED(tmpreg); /* To avoid GCC warning */

  hspi->CRCSize--;
 800a8b8:	6c83      	ldr	r3, [r0, #72]	; 0x48
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
{
  __IO uint8_t tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 800a8ba:	7b21      	ldrb	r1, [r4, #12]
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
{
 800a8bc:	b082      	sub	sp, #8
  __IO uint8_t tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 800a8be:	b2c9      	uxtb	r1, r1
 800a8c0:	f88d 1007 	strb.w	r1, [sp, #7]
  UNUSED(tmpreg); /* To avoid GCC warning */

  hspi->CRCSize--;
 800a8c4:	3b01      	subs	r3, #1
  * @retval None
  */
static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
{
  __IO uint8_t tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
  UNUSED(tmpreg); /* To avoid GCC warning */
 800a8c6:	f89d 1007 	ldrb.w	r1, [sp, #7]

  hspi->CRCSize--;
 800a8ca:	6483      	str	r3, [r0, #72]	; 0x48

  /* check end of the reception */
  if(hspi->CRCSize == 0)
 800a8cc:	b92b      	cbnz	r3, 800a8da <SPI_2linesRxISR_8BITCRC+0x26>
  {
    /* Disable RXNE interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
 800a8ce:	6863      	ldr	r3, [r4, #4]
 800a8d0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a8d4:	6063      	str	r3, [r4, #4]

    if(hspi->TxXferCount == 0)
 800a8d6:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 800a8d8:	b10b      	cbz	r3, 800a8de <SPI_2linesRxISR_8BITCRC+0x2a>
    {
      SPI_CloseRxTx_ISR(hspi);
    }
  }
}
 800a8da:	b002      	add	sp, #8
 800a8dc:	bd10      	pop	{r4, pc}
    /* Disable RXNE interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);

    if(hspi->TxXferCount == 0)
    {
      SPI_CloseRxTx_ISR(hspi);
 800a8de:	f7ff ff3f 	bl	800a760 <SPI_CloseRxTx_ISR>
    }
  }
}
 800a8e2:	b002      	add	sp, #8
 800a8e4:	bd10      	pop	{r4, pc}
 800a8e6:	bf00      	nop

0800a8e8 <SPI_2linesTxISR_16BIT>:
  * @retval None
  */
static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Transmit data in 16 Bit mode */
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800a8e8:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800a8ea:	6803      	ldr	r3, [r0, #0]
 800a8ec:	8812      	ldrh	r2, [r2, #0]
 800a8ee:	60da      	str	r2, [r3, #12]
  hspi->pTxBuffPtr += sizeof(uint16_t);
  hspi->TxXferCount--;
 800a8f0:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
  */
static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Transmit data in 16 Bit mode */
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
  hspi->pTxBuffPtr += sizeof(uint16_t);
 800a8f2:	6b82      	ldr	r2, [r0, #56]	; 0x38
  hspi->TxXferCount--;
 800a8f4:	3b01      	subs	r3, #1
  */
static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Transmit data in 16 Bit mode */
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
  hspi->pTxBuffPtr += sizeof(uint16_t);
 800a8f6:	3202      	adds	r2, #2
  hspi->TxXferCount--;
 800a8f8:	b29b      	uxth	r3, r3
  */
static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Transmit data in 16 Bit mode */
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
  hspi->pTxBuffPtr += sizeof(uint16_t);
 800a8fa:	6382      	str	r2, [r0, #56]	; 0x38
  hspi->TxXferCount--;
 800a8fc:	87c3      	strh	r3, [r0, #62]	; 0x3e

  /* Enable CRC Transmission */
  if(hspi->TxXferCount == 0)
 800a8fe:	b95b      	cbnz	r3, 800a918 <SPI_2linesTxISR_16BIT+0x30>
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a900:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a902:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a906:	d009      	beq.n	800a91c <SPI_2linesTxISR_16BIT+0x34>
    {
      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    }
    /* Disable TXE interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
 800a908:	6802      	ldr	r2, [r0, #0]
 800a90a:	6853      	ldr	r3, [r2, #4]
 800a90c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800a910:	6053      	str	r3, [r2, #4]

    if(hspi->RxXferCount == 0)
 800a912:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 800a916:	b103      	cbz	r3, 800a91a <SPI_2linesTxISR_16BIT+0x32>
 800a918:	4770      	bx	lr
    {
      SPI_CloseRxTx_ISR(hspi);
 800a91a:	e721      	b.n	800a760 <SPI_CloseRxTx_ISR>
  /* Enable CRC Transmission */
  if(hspi->TxXferCount == 0)
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 800a91c:	6802      	ldr	r2, [r0, #0]
 800a91e:	6813      	ldr	r3, [r2, #0]
 800a920:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800a924:	6013      	str	r3, [r2, #0]
 800a926:	e7ef      	b.n	800a908 <SPI_2linesTxISR_16BIT+0x20>

0800a928 <SPI_2linesRxISR_16BIT>:
  * @retval None
  */
static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Receive data in 16 Bit mode */
  *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 800a928:	6801      	ldr	r1, [r0, #0]
 800a92a:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800a92c:	68c9      	ldr	r1, [r1, #12]
 800a92e:	8011      	strh	r1, [r2, #0]
  hspi->pRxBuffPtr += sizeof(uint16_t);
  hspi->RxXferCount--;
 800a930:	f8b0 2046 	ldrh.w	r2, [r0, #70]	; 0x46
  */
static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Receive data in 16 Bit mode */
  *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
  hspi->pRxBuffPtr += sizeof(uint16_t);
 800a934:	6c01      	ldr	r1, [r0, #64]	; 0x40
  hspi->RxXferCount--;
 800a936:	3a01      	subs	r2, #1
  */
static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Receive data in 16 Bit mode */
  *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
  hspi->pRxBuffPtr += sizeof(uint16_t);
 800a938:	3102      	adds	r1, #2
  hspi->RxXferCount--;
 800a93a:	b292      	uxth	r2, r2
  */
static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
{
  /* Receive data in 16 Bit mode */
  *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
  hspi->pRxBuffPtr += sizeof(uint16_t);
 800a93c:	6401      	str	r1, [r0, #64]	; 0x40
  hspi->RxXferCount--;
 800a93e:	f8a0 2046 	strh.w	r2, [r0, #70]	; 0x46

  if(hspi->RxXferCount == 0)
 800a942:	b952      	cbnz	r2, 800a95a <SPI_2linesRxISR_16BIT+0x32>
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800a944:	6a82      	ldr	r2, [r0, #40]	; 0x28
 800a946:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 800a94a:	d008      	beq.n	800a95e <SPI_2linesRxISR_16BIT+0x36>
      hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
      return;
    }

    /* Disable RXNE interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
 800a94c:	6801      	ldr	r1, [r0, #0]
 800a94e:	684a      	ldr	r2, [r1, #4]
 800a950:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a954:	604a      	str	r2, [r1, #4]

    if(hspi->TxXferCount == 0)
 800a956:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 800a958:	b103      	cbz	r3, 800a95c <SPI_2linesRxISR_16BIT+0x34>
 800a95a:	4770      	bx	lr
    {
      SPI_CloseRxTx_ISR(hspi);
 800a95c:	e700      	b.n	800a760 <SPI_CloseRxTx_ISR>

  if(hspi->RxXferCount == 0)
  {
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
 800a95e:	4a01      	ldr	r2, [pc, #4]	; (800a964 <SPI_2linesRxISR_16BIT+0x3c>)
 800a960:	64c2      	str	r2, [r0, #76]	; 0x4c
      return;
 800a962:	4770      	bx	lr
 800a964:	0800a969 	.word	0x0800a969

0800a968 <SPI_2linesRxISR_16BITCRC>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
{
 800a968:	b500      	push	{lr}
  /* Receive data in 16 Bit mode */
  __IO uint16_t tmpreg = hspi->Instance->DR;
 800a96a:	6803      	ldr	r3, [r0, #0]
 800a96c:	68da      	ldr	r2, [r3, #12]
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
{
 800a96e:	b083      	sub	sp, #12
  /* Receive data in 16 Bit mode */
  __IO uint16_t tmpreg = hspi->Instance->DR;
 800a970:	b292      	uxth	r2, r2
 800a972:	f8ad 2006 	strh.w	r2, [sp, #6]
  UNUSED(tmpreg); /* To avoid GCC warning */
 800a976:	f8bd 2006 	ldrh.w	r2, [sp, #6]

  /* Disable RXNE interrupt */
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
 800a97a:	685a      	ldr	r2, [r3, #4]
 800a97c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a980:	605a      	str	r2, [r3, #4]

  SPI_CloseRxTx_ISR(hspi);
 800a982:	f7ff feed 	bl	800a760 <SPI_CloseRxTx_ISR>
}
 800a986:	b003      	add	sp, #12
 800a988:	f85d fb04 	ldr.w	pc, [sp], #4

0800a98c <SPI_DMAError>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAError(DMA_HandleTypeDef *hdma)
{
 800a98c:	b508      	push	{r3, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800a98e:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* Stop the disable DMA transfer on SPI side */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800a990:	6802      	ldr	r2, [r0, #0]
 800a992:	6853      	ldr	r3, [r2, #4]
 800a994:	f023 0303 	bic.w	r3, r3, #3
 800a998:	6053      	str	r3, [r2, #4]

  hspi->ErrorCode|= HAL_SPI_ERROR_DMA;
 800a99a:	6e03      	ldr	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 800a99c:	2201      	movs	r2, #1
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  /* Stop the disable DMA transfer on SPI side */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);

  hspi->ErrorCode|= HAL_SPI_ERROR_DMA;
 800a99e:	f043 0310 	orr.w	r3, r3, #16
 800a9a2:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 800a9a4:	f880 205d 	strb.w	r2, [r0, #93]	; 0x5d
  HAL_SPI_ErrorCallback(hspi);
 800a9a8:	f7ff fdd2 	bl	800a550 <HAL_SPI_ErrorCallback>
 800a9ac:	bd08      	pop	{r3, pc}
 800a9ae:	bf00      	nop

0800a9b0 <SPI_DMATransmitCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 800a9b0:	b530      	push	{r4, r5, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800a9b2:	6803      	ldr	r3, [r0, #0]
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800a9b4:	6a84      	ldr	r4, [r0, #40]	; 0x28

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800a9b6:	681b      	ldr	r3, [r3, #0]
 800a9b8:	f013 0520 	ands.w	r5, r3, #32
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 800a9bc:	b083      	sub	sp, #12
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800a9be:	d119      	bne.n	800a9f4 <SPI_DMATransmitCplt+0x44>
  {
    /* Disable Tx DMA Request */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 800a9c0:	6822      	ldr	r2, [r4, #0]
 800a9c2:	6853      	ldr	r3, [r2, #4]
 800a9c4:	f023 0302 	bic.w	r3, r3, #2
 800a9c8:	6053      	str	r3, [r2, #4]

    /* Check the end of the transaction */
    if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT) != HAL_OK)
 800a9ca:	4620      	mov	r0, r4
 800a9cc:	2132      	movs	r1, #50	; 0x32
 800a9ce:	f7fe fd75 	bl	80094bc <SPI_EndRxTxTransaction>
    {
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
    }

    /* Clear overrun flag in 2 Lines communication mode because received data is not read */
    if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800a9d2:	68a2      	ldr	r2, [r4, #8]
  {
    /* Disable Tx DMA Request */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);

    /* Check the end of the transaction */
    if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT) != HAL_OK)
 800a9d4:	b198      	cbz	r0, 800a9fe <SPI_DMATransmitCplt+0x4e>
    {
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 800a9d6:	2320      	movs	r3, #32
 800a9d8:	6623      	str	r3, [r4, #96]	; 0x60
    }

    /* Clear overrun flag in 2 Lines communication mode because received data is not read */
    if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800a9da:	b9a2      	cbnz	r2, 800aa06 <SPI_DMATransmitCplt+0x56>
    {
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800a9dc:	6822      	ldr	r2, [r4, #0]
 800a9de:	68d1      	ldr	r1, [r2, #12]
 800a9e0:	9101      	str	r1, [sp, #4]
 800a9e2:	6892      	ldr	r2, [r2, #8]
 800a9e4:	9201      	str	r2, [sp, #4]
 800a9e6:	9a01      	ldr	r2, [sp, #4]
    }

    hspi->TxXferCount = 0;
 800a9e8:	2100      	movs	r1, #0
    hspi->State = HAL_SPI_STATE_READY;
 800a9ea:	2201      	movs	r2, #1
    if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
    {
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
    }

    hspi->TxXferCount = 0;
 800a9ec:	87e1      	strh	r1, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 800a9ee:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d

    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800a9f2:	b963      	cbnz	r3, 800aa0e <SPI_DMATransmitCplt+0x5e>
    {
      HAL_SPI_ErrorCallback(hspi);
      return;
    }
  }
  HAL_SPI_TxCpltCallback(hspi);
 800a9f4:	4620      	mov	r0, r4
 800a9f6:	f7ff fd8d 	bl	800a514 <HAL_SPI_TxCpltCallback>
}
 800a9fa:	b003      	add	sp, #12
 800a9fc:	bd30      	pop	{r4, r5, pc}
 800a9fe:	6e23      	ldr	r3, [r4, #96]	; 0x60
    {
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
    }

    /* Clear overrun flag in 2 Lines communication mode because received data is not read */
    if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800aa00:	2a00      	cmp	r2, #0
 800aa02:	d0eb      	beq.n	800a9dc <SPI_DMATransmitCplt+0x2c>
 800aa04:	e7f0      	b.n	800a9e8 <SPI_DMATransmitCplt+0x38>
    {
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
    }

    hspi->TxXferCount = 0;
    hspi->State = HAL_SPI_STATE_READY;
 800aa06:	2301      	movs	r3, #1
    if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
    {
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
    }

    hspi->TxXferCount = 0;
 800aa08:	87e5      	strh	r5, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 800aa0a:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
    {
      HAL_SPI_ErrorCallback(hspi);
 800aa0e:	4620      	mov	r0, r4
 800aa10:	f7ff fd9e 	bl	800a550 <HAL_SPI_ErrorCallback>
      return;
    }
  }
  HAL_SPI_TxCpltCallback(hspi);
}
 800aa14:	b003      	add	sp, #12
 800aa16:	bd30      	pop	{r4, r5, pc}

0800aa18 <SPI_DMAReceiveCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 800aa18:	b510      	push	{r4, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800aa1a:	6803      	ldr	r3, [r0, #0]
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800aa1c:	6a84      	ldr	r4, [r0, #40]	; 0x28

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800aa1e:	681b      	ldr	r3, [r3, #0]
 800aa20:	069b      	lsls	r3, r3, #26
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 800aa22:	b082      	sub	sp, #8
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800aa24:	d423      	bmi.n	800aa6e <SPI_DMAReceiveCplt+0x56>
  {
    __IO uint16_t tmpreg;

    /* CRC handling */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800aa26:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800aa28:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800aa2c:	d034      	beq.n	800aa98 <SPI_DMAReceiveCplt+0x80>
 800aa2e:	6822      	ldr	r2, [r4, #0]
        }
      }
    }

    /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800aa30:	6853      	ldr	r3, [r2, #4]
 800aa32:	f023 0303 	bic.w	r3, r3, #3
 800aa36:	6053      	str	r3, [r2, #4]

    /* Check the end of the transaction */
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
 800aa38:	4620      	mov	r0, r4
 800aa3a:	2132      	movs	r1, #50	; 0x32
 800aa3c:	f7fe fd58 	bl	80094f0 <SPI_EndRxTransaction>
 800aa40:	b1d0      	cbz	r0, 800aa78 <SPI_DMAReceiveCplt+0x60>
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
 800aa42:	6e23      	ldr	r3, [r4, #96]	; 0x60

    hspi->RxXferCount = 0;
    hspi->State = HAL_SPI_STATE_READY;

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800aa44:	6822      	ldr	r2, [r4, #0]
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
    }

    hspi->RxXferCount = 0;
    hspi->State = HAL_SPI_STATE_READY;
 800aa46:	2101      	movs	r1, #1
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);

    /* Check the end of the transaction */
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
 800aa48:	f043 0320 	orr.w	r3, r3, #32
    }

    hspi->RxXferCount = 0;
 800aa4c:	2000      	movs	r0, #0
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);

    /* Check the end of the transaction */
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
 800aa4e:	6623      	str	r3, [r4, #96]	; 0x60
    }

    hspi->RxXferCount = 0;
 800aa50:	f8a4 0046 	strh.w	r0, [r4, #70]	; 0x46
    hspi->State = HAL_SPI_STATE_READY;
 800aa54:	f884 105d 	strb.w	r1, [r4, #93]	; 0x5d

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800aa58:	6891      	ldr	r1, [r2, #8]
 800aa5a:	06c9      	lsls	r1, r1, #27
 800aa5c:	d517      	bpl.n	800aa8e <SPI_DMAReceiveCplt+0x76>
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800aa5e:	f043 0302 	orr.w	r3, r3, #2
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800aa62:	f64f 71ef 	movw	r1, #65519	; 0xffef
    hspi->State = HAL_SPI_STATE_READY;

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800aa66:	6623      	str	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800aa68:	6091      	str	r1, [r2, #8]
 800aa6a:	6e23      	ldr	r3, [r4, #96]	; 0x60
    }

    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800aa6c:	b97b      	cbnz	r3, 800aa8e <SPI_DMAReceiveCplt+0x76>
    {
      HAL_SPI_ErrorCallback(hspi);
      return;
    }
  }
  HAL_SPI_RxCpltCallback(hspi);
 800aa6e:	4620      	mov	r0, r4
 800aa70:	f7ff fd52 	bl	800a518 <HAL_SPI_RxCpltCallback>
}
 800aa74:	b002      	add	sp, #8
 800aa76:	bd10      	pop	{r4, pc}
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
    }

    hspi->RxXferCount = 0;
    hspi->State = HAL_SPI_STATE_READY;
 800aa78:	2301      	movs	r3, #1

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800aa7a:	6822      	ldr	r2, [r4, #0]
    if(SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT)!=HAL_OK)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
    }

    hspi->RxXferCount = 0;
 800aa7c:	f8a4 0046 	strh.w	r0, [r4, #70]	; 0x46
    hspi->State = HAL_SPI_STATE_READY;
 800aa80:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800aa84:	6891      	ldr	r1, [r2, #8]
 800aa86:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800aa88:	06c8      	lsls	r0, r1, #27
 800aa8a:	d4e8      	bmi.n	800aa5e <SPI_DMAReceiveCplt+0x46>
 800aa8c:	e7ee      	b.n	800aa6c <SPI_DMAReceiveCplt+0x54>
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    }

    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
    {
      HAL_SPI_ErrorCallback(hspi);
 800aa8e:	4620      	mov	r0, r4
 800aa90:	f7ff fd5e 	bl	800a550 <HAL_SPI_ErrorCallback>
      return;
    }
  }
  HAL_SPI_RxCpltCallback(hspi);
}
 800aa94:	b002      	add	sp, #8
 800aa96:	bd10      	pop	{r4, pc}

    /* CRC handling */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      /* Wait until TXE flag */
      if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
 800aa98:	2101      	movs	r1, #1
 800aa9a:	460a      	mov	r2, r1
 800aa9c:	4620      	mov	r0, r4
 800aa9e:	2332      	movs	r3, #50	; 0x32
 800aaa0:	f7fe fcba 	bl	8009418 <SPI_WaitFlagStateUntilTimeout>
 800aaa4:	b118      	cbz	r0, 800aaae <SPI_DMAReceiveCplt+0x96>
      {
        /* Error on the CRC reception */
        hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800aaa6:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800aaa8:	f043 0302 	orr.w	r3, r3, #2
 800aaac:	6623      	str	r3, [r4, #96]	; 0x60
      }
      if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800aaae:	68e3      	ldr	r3, [r4, #12]
      {
        tmpreg = hspi->Instance->DR;
 800aab0:	6822      	ldr	r2, [r4, #0]
      if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
      {
        /* Error on the CRC reception */
        hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
      }
      if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800aab2:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800aab6:	d819      	bhi.n	800aaec <SPI_DMAReceiveCplt+0xd4>
      else
      {
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
        UNUSED(tmpreg); /* To avoid GCC warning */

        if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 800aab8:	6b21      	ldr	r1, [r4, #48]	; 0x30
        tmpreg = hspi->Instance->DR;
        UNUSED(tmpreg); /* To avoid GCC warning */
      }
      else
      {
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 800aaba:	7b13      	ldrb	r3, [r2, #12]
 800aabc:	f8ad 3006 	strh.w	r3, [sp, #6]
        UNUSED(tmpreg); /* To avoid GCC warning */

        if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 800aac0:	2902      	cmp	r1, #2
        UNUSED(tmpreg); /* To avoid GCC warning */
      }
      else
      {
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
        UNUSED(tmpreg); /* To avoid GCC warning */
 800aac2:	f8bd 3006 	ldrh.w	r3, [sp, #6]

        if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 800aac6:	d1b3      	bne.n	800aa30 <SPI_DMAReceiveCplt+0x18>
        {
          if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
 800aac8:	2101      	movs	r1, #1
 800aaca:	460a      	mov	r2, r1
 800aacc:	4620      	mov	r0, r4
 800aace:	2332      	movs	r3, #50	; 0x32
 800aad0:	f7fe fca2 	bl	8009418 <SPI_WaitFlagStateUntilTimeout>
 800aad4:	b118      	cbz	r0, 800aade <SPI_DMAReceiveCplt+0xc6>
          {
            /* Error on the CRC reception */
            hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800aad6:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800aad8:	f043 0302 	orr.w	r3, r3, #2
 800aadc:	6623      	str	r3, [r4, #96]	; 0x60
          }
          tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 800aade:	6822      	ldr	r2, [r4, #0]
 800aae0:	7b13      	ldrb	r3, [r2, #12]
 800aae2:	f8ad 3006 	strh.w	r3, [sp, #6]
          UNUSED(tmpreg); /* To avoid GCC warning */
 800aae6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800aaea:	e7a1      	b.n	800aa30 <SPI_DMAReceiveCplt+0x18>
        /* Error on the CRC reception */
        hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
      }
      if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
      {
        tmpreg = hspi->Instance->DR;
 800aaec:	68d3      	ldr	r3, [r2, #12]
 800aaee:	b29b      	uxth	r3, r3
 800aaf0:	f8ad 3006 	strh.w	r3, [sp, #6]
        UNUSED(tmpreg); /* To avoid GCC warning */
 800aaf4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800aaf8:	e79a      	b.n	800aa30 <SPI_DMAReceiveCplt+0x18>
 800aafa:	bf00      	nop

0800aafc <SPI_DMATransmitReceiveCplt>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
 800aafc:	b510      	push	{r4, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800aafe:	6803      	ldr	r3, [r0, #0]
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800ab00:	6a84      	ldr	r4, [r0, #40]	; 0x28

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800ab02:	681b      	ldr	r3, [r3, #0]
 800ab04:	069a      	lsls	r2, r3, #26
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
 800ab06:	b082      	sub	sp, #8
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800ab08:	d41c      	bmi.n	800ab44 <SPI_DMATransmitReceiveCplt+0x48>
  {
    __IO int16_t tmpreg;
    /* CRC handling */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800ab0a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800ab0c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800ab10:	d02c      	beq.n	800ab6c <SPI_DMATransmitReceiveCplt+0x70>
        UNUSED(tmpreg); /* To avoid GCC warning */  
      }
    }

    /* Check the end of the transaction */
    if(SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT) != HAL_OK)
 800ab12:	4620      	mov	r0, r4
 800ab14:	2132      	movs	r1, #50	; 0x32
 800ab16:	f7fe fcd1 	bl	80094bc <SPI_EndRxTxTransaction>
 800ab1a:	b108      	cbz	r0, 800ab20 <SPI_DMATransmitReceiveCplt+0x24>
    {
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 800ab1c:	2320      	movs	r3, #32
 800ab1e:	6623      	str	r3, [r4, #96]	; 0x60
    }
  
    /* Disable Rx/Tx DMA Request */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800ab20:	6822      	ldr	r2, [r4, #0]
 800ab22:	6853      	ldr	r3, [r2, #4]
 800ab24:	f023 0303 	bic.w	r3, r3, #3
 800ab28:	6053      	str	r3, [r2, #4]
    hspi->TxXferCount = 0;
    hspi->RxXferCount = 0;
    hspi->State = HAL_SPI_STATE_READY;

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800ab2a:	6822      	ldr	r2, [r4, #0]
    }
  
    /* Disable Rx/Tx DMA Request */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);

    hspi->TxXferCount = 0;
 800ab2c:	2300      	movs	r3, #0
    hspi->RxXferCount = 0;
    hspi->State = HAL_SPI_STATE_READY;
 800ab2e:	2101      	movs	r1, #1
    }
  
    /* Disable Rx/Tx DMA Request */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);

    hspi->TxXferCount = 0;
 800ab30:	87e3      	strh	r3, [r4, #62]	; 0x3e
    hspi->RxXferCount = 0;
 800ab32:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    hspi->State = HAL_SPI_STATE_READY;
 800ab36:	f884 105d 	strb.w	r1, [r4, #93]	; 0x5d

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
 800ab3a:	6893      	ldr	r3, [r2, #8]
 800ab3c:	06db      	lsls	r3, r3, #27
 800ab3e:	d406      	bmi.n	800ab4e <SPI_DMATransmitReceiveCplt+0x52>
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    }

    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800ab40:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800ab42:	b973      	cbnz	r3, 800ab62 <SPI_DMATransmitReceiveCplt+0x66>
    {
      HAL_SPI_ErrorCallback(hspi);
      return;
    }
  }
  HAL_SPI_TxRxCpltCallback(hspi);
 800ab44:	4620      	mov	r0, r4
 800ab46:	f7ff fce9 	bl	800a51c <HAL_SPI_TxRxCpltCallback>
}
 800ab4a:	b002      	add	sp, #8
 800ab4c:	bd10      	pop	{r4, pc}
    hspi->State = HAL_SPI_STATE_READY;

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800ab4e:	6e23      	ldr	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800ab50:	f64f 71ef 	movw	r1, #65519	; 0xffef
    hspi->State = HAL_SPI_STATE_READY;

    /* Check if CRC error occurred */
    if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
    {
      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800ab54:	f043 0302 	orr.w	r3, r3, #2
 800ab58:	6623      	str	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800ab5a:	6091      	str	r1, [r2, #8]
    }

    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800ab5c:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800ab5e:	2b00      	cmp	r3, #0
 800ab60:	d0f0      	beq.n	800ab44 <SPI_DMATransmitReceiveCplt+0x48>
    {
      HAL_SPI_ErrorCallback(hspi);
 800ab62:	4620      	mov	r0, r4
 800ab64:	f7ff fcf4 	bl	800a550 <HAL_SPI_ErrorCallback>
      return;
    }
  }
  HAL_SPI_TxRxCpltCallback(hspi);
}
 800ab68:	b002      	add	sp, #8
 800ab6a:	bd10      	pop	{r4, pc}
  {
    __IO int16_t tmpreg;
    /* CRC handling */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
 800ab6c:	68e3      	ldr	r3, [r4, #12]
 800ab6e:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
      {
        if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
 800ab72:	4620      	mov	r0, r4
 800ab74:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  {
    __IO int16_t tmpreg;
    /* CRC handling */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
 800ab78:	d102      	bne.n	800ab80 <SPI_DMATransmitReceiveCplt+0x84>
 800ab7a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800ab7c:	2b01      	cmp	r3, #1
 800ab7e:	d011      	beq.n	800aba4 <SPI_DMATransmitReceiveCplt+0xa8>
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
        UNUSED(tmpreg); /* To avoid GCC warning */  
      }
      else
      {
        if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
 800ab80:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800ab84:	2332      	movs	r3, #50	; 0x32
 800ab86:	f7fe fbef 	bl	8009368 <SPI_WaitFifoStateUntilTimeout>
 800ab8a:	b118      	cbz	r0, 800ab94 <SPI_DMATransmitReceiveCplt+0x98>
        {
          /* Error on the CRC reception */
          hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800ab8c:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800ab8e:	f043 0302 	orr.w	r3, r3, #2
 800ab92:	6623      	str	r3, [r4, #96]	; 0x60
        }
        tmpreg = hspi->Instance->DR;
 800ab94:	6823      	ldr	r3, [r4, #0]
 800ab96:	68db      	ldr	r3, [r3, #12]
 800ab98:	b29b      	uxth	r3, r3
 800ab9a:	f8ad 3006 	strh.w	r3, [sp, #6]
        UNUSED(tmpreg); /* To avoid GCC warning */  
 800ab9e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800aba2:	e7b6      	b.n	800ab12 <SPI_DMATransmitReceiveCplt+0x16>
    /* CRC handling */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    {
      if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
      {
        if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
 800aba4:	f44f 7200 	mov.w	r2, #512	; 0x200
 800aba8:	2332      	movs	r3, #50	; 0x32
 800abaa:	f7fe fbdd 	bl	8009368 <SPI_WaitFifoStateUntilTimeout>
 800abae:	b118      	cbz	r0, 800abb8 <SPI_DMATransmitReceiveCplt+0xbc>
        {
          /* Error on the CRC reception */
          hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
 800abb0:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800abb2:	f043 0302 	orr.w	r3, r3, #2
 800abb6:	6623      	str	r3, [r4, #96]	; 0x60
        }
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 800abb8:	6823      	ldr	r3, [r4, #0]
 800abba:	7b1b      	ldrb	r3, [r3, #12]
 800abbc:	f8ad 3006 	strh.w	r3, [sp, #6]
        UNUSED(tmpreg); /* To avoid GCC warning */  
 800abc0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800abc4:	e7a5      	b.n	800ab12 <SPI_DMATransmitReceiveCplt+0x16>
 800abc6:	bf00      	nop

0800abc8 <HAL_SPI_IRQHandler>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
 800abc8:	b530      	push	{r4, r5, lr}
  uint32_t itsource = hspi->Instance->CR2;
 800abca:	6803      	ldr	r3, [r0, #0]
 800abcc:	685d      	ldr	r5, [r3, #4]
  uint32_t itflag   = hspi->Instance->SR;
 800abce:	689a      	ldr	r2, [r3, #8]

  /* SPI in mode Receiver ----------------------------------------------------*/
  if(((itflag & SPI_FLAG_OVR) == RESET) &&
 800abd0:	f002 0441 	and.w	r4, r2, #65	; 0x41
 800abd4:	2c01      	cmp	r4, #1
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
 800abd6:	b085      	sub	sp, #20
 800abd8:	4601      	mov	r1, r0
  uint32_t itsource = hspi->Instance->CR2;
  uint32_t itflag   = hspi->Instance->SR;

  /* SPI in mode Receiver ----------------------------------------------------*/
  if(((itflag & SPI_FLAG_OVR) == RESET) &&
 800abda:	d03d      	beq.n	800ac58 <HAL_SPI_IRQHandler+0x90>
    hspi->RxISR(hspi);
    return;
  }

  /* SPI in mode Transmitter ---------------------------------------------------*/
  if(((itflag & SPI_FLAG_TXE) != RESET) && ((itsource & SPI_IT_TXE) != RESET))
 800abdc:	0790      	lsls	r0, r2, #30
 800abde:	d427      	bmi.n	800ac30 <HAL_SPI_IRQHandler+0x68>
    hspi->TxISR(hspi);
    return;
  }

  /* SPI in Error Treatment ---------------------------------------------------*/
  if((itflag & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE)) != RESET)
 800abe0:	f412 7fb0 	tst.w	r2, #352	; 0x160
 800abe4:	d022      	beq.n	800ac2c <HAL_SPI_IRQHandler+0x64>
  {
    /* SPI Overrun error interrupt occurred -------------------------------------*/
    if((itflag & SPI_FLAG_OVR) != RESET)
 800abe6:	0654      	lsls	r4, r2, #25
 800abe8:	d428      	bmi.n	800ac3c <HAL_SPI_IRQHandler+0x74>
        return;
      }
    }

    /* SPI Mode Fault error interrupt occurred -------------------------------------*/
    if((itflag & SPI_FLAG_MODF) != RESET)
 800abea:	0690      	lsls	r0, r2, #26
 800abec:	d50b      	bpl.n	800ac06 <HAL_SPI_IRQHandler+0x3e>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_MODF;
 800abee:	6e08      	ldr	r0, [r1, #96]	; 0x60
 800abf0:	f040 0001 	orr.w	r0, r0, #1
 800abf4:	6608      	str	r0, [r1, #96]	; 0x60
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 800abf6:	6898      	ldr	r0, [r3, #8]
 800abf8:	9002      	str	r0, [sp, #8]
 800abfa:	6818      	ldr	r0, [r3, #0]
 800abfc:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 800ac00:	6018      	str	r0, [r3, #0]
 800ac02:	9b02      	ldr	r3, [sp, #8]
 800ac04:	680b      	ldr	r3, [r1, #0]
    }

    /* SPI Frame error interrupt occurred ----------------------------------------*/
    if((itflag & SPI_FLAG_FRE) != RESET)
 800ac06:	05d2      	lsls	r2, r2, #23
 800ac08:	d506      	bpl.n	800ac18 <HAL_SPI_IRQHandler+0x50>
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FRE;
 800ac0a:	6e0a      	ldr	r2, [r1, #96]	; 0x60
 800ac0c:	f042 0208 	orr.w	r2, r2, #8
 800ac10:	660a      	str	r2, [r1, #96]	; 0x60
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 800ac12:	689a      	ldr	r2, [r3, #8]
 800ac14:	9203      	str	r2, [sp, #12]
 800ac16:	9a03      	ldr	r2, [sp, #12]
    }

    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 800ac18:	685a      	ldr	r2, [r3, #4]
    hspi->State = HAL_SPI_STATE_READY;
 800ac1a:	2401      	movs	r4, #1
    {
      hspi->ErrorCode |= HAL_SPI_ERROR_FRE;
      __HAL_SPI_CLEAR_FREFLAG(hspi);
    }

    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 800ac1c:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 800ac20:	605a      	str	r2, [r3, #4]
    hspi->State = HAL_SPI_STATE_READY;
    HAL_SPI_ErrorCallback(hspi);
 800ac22:	4608      	mov	r0, r1
      hspi->ErrorCode |= HAL_SPI_ERROR_FRE;
      __HAL_SPI_CLEAR_FREFLAG(hspi);
    }

    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
    hspi->State = HAL_SPI_STATE_READY;
 800ac24:	f881 405d 	strb.w	r4, [r1, #93]	; 0x5d
    HAL_SPI_ErrorCallback(hspi);
 800ac28:	f7ff fc92 	bl	800a550 <HAL_SPI_ErrorCallback>
    return;
  }
}
 800ac2c:	b005      	add	sp, #20
 800ac2e:	bd30      	pop	{r4, r5, pc}
    hspi->RxISR(hspi);
    return;
  }

  /* SPI in mode Transmitter ---------------------------------------------------*/
  if(((itflag & SPI_FLAG_TXE) != RESET) && ((itsource & SPI_IT_TXE) != RESET))
 800ac30:	062d      	lsls	r5, r5, #24
 800ac32:	d5d5      	bpl.n	800abe0 <HAL_SPI_IRQHandler+0x18>
  {
    hspi->TxISR(hspi);
 800ac34:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 800ac36:	4608      	mov	r0, r1
 800ac38:	4798      	blx	r3
    return;
 800ac3a:	e7f7      	b.n	800ac2c <HAL_SPI_IRQHandler+0x64>
  if((itflag & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE)) != RESET)
  {
    /* SPI Overrun error interrupt occurred -------------------------------------*/
    if((itflag & SPI_FLAG_OVR) != RESET)
    {
      if(hspi->State != HAL_SPI_STATE_BUSY_TX)
 800ac3c:	f891 005d 	ldrb.w	r0, [r1, #93]	; 0x5d
 800ac40:	2803      	cmp	r0, #3
 800ac42:	d0f3      	beq.n	800ac2c <HAL_SPI_IRQHandler+0x64>
      {
        hspi->ErrorCode |= HAL_SPI_ERROR_OVR;
 800ac44:	6e08      	ldr	r0, [r1, #96]	; 0x60
 800ac46:	f040 0004 	orr.w	r0, r0, #4
 800ac4a:	6608      	str	r0, [r1, #96]	; 0x60
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800ac4c:	68d8      	ldr	r0, [r3, #12]
 800ac4e:	9001      	str	r0, [sp, #4]
 800ac50:	6898      	ldr	r0, [r3, #8]
 800ac52:	9001      	str	r0, [sp, #4]
 800ac54:	9801      	ldr	r0, [sp, #4]
 800ac56:	e7c8      	b.n	800abea <HAL_SPI_IRQHandler+0x22>
  uint32_t itsource = hspi->Instance->CR2;
  uint32_t itflag   = hspi->Instance->SR;

  /* SPI in mode Receiver ----------------------------------------------------*/
  if(((itflag & SPI_FLAG_OVR) == RESET) &&
     ((itflag & SPI_FLAG_RXNE) != RESET) && ((itsource & SPI_IT_RXNE) != RESET))
 800ac58:	066c      	lsls	r4, r5, #25
 800ac5a:	d5bf      	bpl.n	800abdc <HAL_SPI_IRQHandler+0x14>
  {
    hspi->RxISR(hspi);
 800ac5c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800ac5e:	4798      	blx	r3
    return;
 800ac60:	e7e4      	b.n	800ac2c <HAL_SPI_IRQHandler+0x64>
 800ac62:	bf00      	nop

0800ac64 <HAL_SPI_GetState>:
  */
HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
{
  /* Return SPI handle state */
  return hspi->State;
}
 800ac64:	f890 005d 	ldrb.w	r0, [r0, #93]	; 0x5d
 800ac68:	4770      	bx	lr
 800ac6a:	bf00      	nop

0800ac6c <HAL_SPI_GetError>:
  * @retval SPI error code in bitmap format
  */
uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
{
  return hspi->ErrorCode;
}
 800ac6c:	6e00      	ldr	r0, [r0, #96]	; 0x60
 800ac6e:	4770      	bx	lr

0800ac70 <USB_CoreInit>:
  * @param  cfg: pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800ac70:	b084      	sub	sp, #16
 800ac72:	b470      	push	{r4, r5, r6}
  /* Select FS Embedded PHY */
  USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 800ac74:	68c6      	ldr	r6, [r0, #12]
 800ac76:	4c11      	ldr	r4, [pc, #68]	; (800acbc <USB_CoreInit+0x4c>)
  * @param  cfg: pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800ac78:	ad04      	add	r5, sp, #16
  /* Select FS Embedded PHY */
  USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 800ac7a:	f046 0640 	orr.w	r6, r6, #64	; 0x40
 800ac7e:	60c6      	str	r6, [r0, #12]
  * @param  cfg: pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800ac80:	e885 000e 	stmia.w	r5, {r1, r2, r3}
 800ac84:	e001      	b.n	800ac8a <USB_CoreInit+0x1a>
  uint32_t count = 0;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000)
 800ac86:	3c01      	subs	r4, #1
 800ac88:	d00d      	beq.n	800aca6 <USB_CoreInit+0x36>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0);
 800ac8a:	6903      	ldr	r3, [r0, #16]
 800ac8c:	2b00      	cmp	r3, #0
 800ac8e:	dafa      	bge.n	800ac86 <USB_CoreInit+0x16>
  
  /* Core Soft Reset */
  count = 0;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 800ac90:	6902      	ldr	r2, [r0, #16]
 800ac92:	4b0a      	ldr	r3, [pc, #40]	; (800acbc <USB_CoreInit+0x4c>)
 800ac94:	f042 0201 	orr.w	r2, r2, #1
 800ac98:	6102      	str	r2, [r0, #16]
 800ac9a:	e001      	b.n	800aca0 <USB_CoreInit+0x30>

  do
  {
    if (++count > 200000)
 800ac9c:	3b01      	subs	r3, #1
 800ac9e:	d002      	beq.n	800aca6 <USB_CoreInit+0x36>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800aca0:	6902      	ldr	r2, [r0, #16]
 800aca2:	07d2      	lsls	r2, r2, #31
 800aca4:	d4fa      	bmi.n	800ac9c <USB_CoreInit+0x2c>
  
  /* Reset after a PHY select and set Host mode */
  USB_CoreReset(USBx);
  
  /* Deactivate the power down*/
  USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 800aca6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800acaa:	6383      	str	r3, [r0, #56]	; 0x38
  
  /* Enable srpcap*/
  USBx->GUSBCFG |= USB_OTG_GUSBCFG_SRPCAP;
 800acac:	68c3      	ldr	r3, [r0, #12]
 800acae:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800acb2:	60c3      	str	r3, [r0, #12]
  
  return HAL_OK;
}
 800acb4:	bc70      	pop	{r4, r5, r6}
 800acb6:	2000      	movs	r0, #0
 800acb8:	b004      	add	sp, #16
 800acba:	4770      	bx	lr
 800acbc:	00030d40 	.word	0x00030d40

0800acc0 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx: Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 800acc0:	4602      	mov	r2, r0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  return HAL_OK;
}
 800acc2:	2000      	movs	r0, #0
  * @param  USBx: Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 800acc4:	6893      	ldr	r3, [r2, #8]
 800acc6:	f043 0301 	orr.w	r3, r3, #1
 800acca:	6093      	str	r3, [r2, #8]
  return HAL_OK;
}
 800accc:	4770      	bx	lr
 800acce:	bf00      	nop

0800acd0 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx: Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 800acd0:	4602      	mov	r2, r0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  return HAL_OK;
}
 800acd2:	2000      	movs	r0, #0
  * @param  USBx: Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800acd4:	6893      	ldr	r3, [r2, #8]
 800acd6:	f023 0301 	bic.w	r3, r3, #1
 800acda:	6093      	str	r3, [r2, #8]
  return HAL_OK;
}
 800acdc:	4770      	bx	lr
 800acde:	bf00      	nop

0800ace0 <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 800ace0:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 800ace2:	68c3      	ldr	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 800ace4:	2901      	cmp	r1, #1
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 800ace6:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 800acea:	60c3      	str	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 800acec:	d009      	beq.n	800ad02 <USB_SetCurrentMode+0x22>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
 800acee:	b919      	cbnz	r1, 800acf8 <USB_SetCurrentMode+0x18>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 800acf0:	68c3      	ldr	r3, [r0, #12]
 800acf2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800acf6:	60c3      	str	r3, [r0, #12]
  }
  HAL_Delay(50);
 800acf8:	2032      	movs	r0, #50	; 0x32
 800acfa:	f7f5 ff0b 	bl	8000b14 <HAL_Delay>
  
  return HAL_OK;
}
 800acfe:	2000      	movs	r0, #0
 800ad00:	bd08      	pop	{r3, pc}
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  
  if ( mode == USB_OTG_HOST_MODE)
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 800ad02:	68c3      	ldr	r3, [r0, #12]
 800ad04:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800ad08:	60c3      	str	r3, [r0, #12]
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  }
  HAL_Delay(50);
 800ad0a:	2032      	movs	r0, #50	; 0x32
 800ad0c:	f7f5 ff02 	bl	8000b14 <HAL_Delay>
  
  return HAL_OK;
}
 800ad10:	2000      	movs	r0, #0
 800ad12:	bd08      	pop	{r3, pc}

0800ad14 <USB_DevInit>:
  * @param  cfg: pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800ad14:	b084      	sub	sp, #16
 800ad16:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ad1a:	ac08      	add	r4, sp, #32
 800ad1c:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  uint32_t i = 0;

  /*Activate VBUS Sensing B */
  USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 800ad20:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800ad22:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
 800ad26:	f8dd e02c 	ldr.w	lr, [sp, #44]	; 0x2c
 800ad2a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800ad2e:	6383      	str	r3, [r0, #56]	; 0x38
  
  if (cfg.vbus_sensing_enable == 0)
 800ad30:	f1b9 0f00 	cmp.w	r9, #0
 800ad34:	d10b      	bne.n	800ad4e <USB_DevInit+0x3a>
  {
    /* Deactivate VBUS Sensing B */
    USBx->GCCFG &= ~ USB_OTG_GCCFG_VBDEN;
 800ad36:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800ad38:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800ad3c:	6383      	str	r3, [r0, #56]	; 0x38
    
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 800ad3e:	6803      	ldr	r3, [r0, #0]
 800ad40:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ad44:	6003      	str	r3, [r0, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 800ad46:	6803      	ldr	r3, [r0, #0]
 800ad48:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ad4c:	6003      	str	r3, [r0, #0]
  }
   
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0;
 800ad4e:	2300      	movs	r3, #0
 800ad50:	f8c0 3e00 	str.w	r3, [r0, #3584]	; 0xe00

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 800ad54:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800ad58:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 800ad5c:	f8d0 2800 	ldr.w	r2, [r0, #2048]	; 0x800
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 800ad60:	4b41      	ldr	r3, [pc, #260]	; (800ae68 <USB_DevInit+0x154>)
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 800ad62:	f042 0203 	orr.w	r2, r2, #3
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 800ad66:	f44f 6784 	mov.w	r7, #1056	; 0x420
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 800ad6a:	f8c0 2800 	str.w	r2, [r0, #2048]	; 0x800
   
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0;

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 800ad6e:	f500 6400 	add.w	r4, r0, #2048	; 0x800
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 800ad72:	6107      	str	r7, [r0, #16]
 800ad74:	e001      	b.n	800ad7a <USB_DevInit+0x66>
 
  do
  {
    if (++count > 200000)
 800ad76:	3b01      	subs	r3, #1
 800ad78:	d002      	beq.n	800ad80 <USB_DevInit+0x6c>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800ad7a:	6902      	ldr	r2, [r0, #16]
 800ad7c:	0695      	lsls	r5, r2, #26
 800ad7e:	d4fa      	bmi.n	800ad76 <USB_DevInit+0x62>
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800ad80:	2310      	movs	r3, #16
 800ad82:	6103      	str	r3, [r0, #16]
 800ad84:	4b38      	ldr	r3, [pc, #224]	; (800ae68 <USB_DevInit+0x154>)
 800ad86:	e001      	b.n	800ad8c <USB_DevInit+0x78>
  
  do
  {
    if (++count > 200000)
 800ad88:	3b01      	subs	r3, #1
 800ad8a:	d002      	beq.n	800ad92 <USB_DevInit+0x7e>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 800ad8c:	6902      	ldr	r2, [r0, #16]
 800ad8e:	06d2      	lsls	r2, r2, #27
 800ad90:	d4fa      	bmi.n	800ad88 <USB_DevInit+0x74>
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0;
 800ad92:	2200      	movs	r2, #0
  USBx_DEVICE->DOEPMSK = 0;
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
 800ad94:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0;
 800ad98:	6122      	str	r2, [r4, #16]
  USBx_DEVICE->DOEPMSK = 0;
 800ad9a:	6162      	str	r2, [r4, #20]
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
 800ad9c:	61a3      	str	r3, [r4, #24]
  USBx_DEVICE->DAINTMSK = 0;
 800ad9e:	61e2      	str	r2, [r4, #28]
  
  for (i = 0; i < cfg.dev_endpoints; i++)
 800ada0:	b341      	cbz	r1, 800adf4 <USB_DevInit+0xe0>
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0;
 800ada2:	4615      	mov	r5, r2
 800ada4:	f500 6310 	add.w	r3, r0, #2304	; 0x900
  
  for (i = 0; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 800ada8:	f04f 4890 	mov.w	r8, #1207959552	; 0x48000000
    {
      USBx_INEP(i)->DIEPCTL = 0;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0;
    USBx_INEP(i)->DIEPINT  = 0xFF;
 800adac:	26ff      	movs	r6, #255	; 0xff
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
  USBx_DEVICE->DAINTMSK = 0;
  
  for (i = 0; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800adae:	681f      	ldr	r7, [r3, #0]
  USBx_DEVICE->DIEPMSK = 0;
  USBx_DEVICE->DOEPMSK = 0;
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
  USBx_DEVICE->DAINTMSK = 0;
  
  for (i = 0; i < cfg.dev_endpoints; i++)
 800adb0:	3201      	adds	r2, #1
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800adb2:	2f00      	cmp	r7, #0
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 800adb4:	bfb4      	ite	lt
 800adb6:	f8c3 8000 	strlt.w	r8, [r3]
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0;
 800adba:	601d      	strge	r5, [r3, #0]
  USBx_DEVICE->DIEPMSK = 0;
  USBx_DEVICE->DOEPMSK = 0;
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
  USBx_DEVICE->DAINTMSK = 0;
  
  for (i = 0; i < cfg.dev_endpoints; i++)
 800adbc:	428a      	cmp	r2, r1
    else
    {
      USBx_INEP(i)->DIEPCTL = 0;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0;
 800adbe:	611d      	str	r5, [r3, #16]
    USBx_INEP(i)->DIEPINT  = 0xFF;
 800adc0:	609e      	str	r6, [r3, #8]
 800adc2:	f103 0320 	add.w	r3, r3, #32
  USBx_DEVICE->DIEPMSK = 0;
  USBx_DEVICE->DOEPMSK = 0;
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
  USBx_DEVICE->DAINTMSK = 0;
  
  for (i = 0; i < cfg.dev_endpoints; i++)
 800adc6:	d1f2      	bne.n	800adae <USB_DevInit+0x9a>
 800adc8:	2200      	movs	r2, #0
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0;
 800adca:	4616      	mov	r6, r2
 800adcc:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  
  for (i = 0; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 800add0:	f04f 4890 	mov.w	r8, #1207959552	; 0x48000000
    {
      USBx_OUTEP(i)->DOEPCTL = 0;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0;
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
 800add4:	f04f 0cff 	mov.w	ip, #255	; 0xff
    USBx_INEP(i)->DIEPINT  = 0xFF;
  }
  
  for (i = 0; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800add8:	681f      	ldr	r7, [r3, #0]
    
    USBx_INEP(i)->DIEPTSIZ = 0;
    USBx_INEP(i)->DIEPINT  = 0xFF;
  }
  
  for (i = 0; i < cfg.dev_endpoints; i++)
 800adda:	3201      	adds	r2, #1
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800addc:	2f00      	cmp	r7, #0
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 800adde:	bfb4      	ite	lt
 800ade0:	f8c3 8000 	strlt.w	r8, [r3]
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0;
 800ade4:	601e      	strge	r6, [r3, #0]
    
    USBx_INEP(i)->DIEPTSIZ = 0;
    USBx_INEP(i)->DIEPINT  = 0xFF;
  }
  
  for (i = 0; i < cfg.dev_endpoints; i++)
 800ade6:	428a      	cmp	r2, r1
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0;
 800ade8:	611e      	str	r6, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
 800adea:	f8c3 c008 	str.w	ip, [r3, #8]
 800adee:	f103 0320 	add.w	r3, r3, #32
    
    USBx_INEP(i)->DIEPTSIZ = 0;
    USBx_INEP(i)->DIEPINT  = 0xFF;
  }
  
  for (i = 0; i < cfg.dev_endpoints; i++)
 800adf2:	d1f1      	bne.n	800add8 <USB_DevInit+0xc4>
    
    USBx_OUTEP(i)->DOEPTSIZ = 0;
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 800adf4:	6923      	ldr	r3, [r4, #16]
  
  if (cfg.dma_enable == 1)
 800adf6:	f1be 0f01 	cmp.w	lr, #1
    
    USBx_OUTEP(i)->DOEPTSIZ = 0;
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 800adfa:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800adfe:	6123      	str	r3, [r4, #16]
  
  if (cfg.dma_enable == 1)
 800ae00:	d023      	beq.n	800ae4a <USB_DevInit+0x136>
    
    i= USBx_DEVICE->DTHRCTL;
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0;
 800ae02:	2200      	movs	r2, #0
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFF;
 800ae04:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
    
    i= USBx_DEVICE->DTHRCTL;
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0;
 800ae08:	6182      	str	r2, [r0, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFF;
 800ae0a:	6143      	str	r3, [r0, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 800ae0c:	f1be 0f00 	cmp.w	lr, #0
 800ae10:	d103      	bne.n	800ae1a <USB_DevInit+0x106>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 800ae12:	6983      	ldr	r3, [r0, #24]
 800ae14:	f043 0310 	orr.w	r3, r3, #16
 800ae18:	6183      	str	r3, [r0, #24]
  }

    /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 800ae1a:	6981      	ldr	r1, [r0, #24]
 800ae1c:	4b13      	ldr	r3, [pc, #76]	; (800ae6c <USB_DevInit+0x158>)
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);

  if(cfg.Sof_enable)
 800ae1e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
  }

    /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 800ae20:	430b      	orrs	r3, r1
 800ae22:	6183      	str	r3, [r0, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);

  if(cfg.Sof_enable)
 800ae24:	b11a      	cbz	r2, 800ae2e <USB_DevInit+0x11a>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 800ae26:	6983      	ldr	r3, [r0, #24]
 800ae28:	f043 0308 	orr.w	r3, r3, #8
 800ae2c:	6183      	str	r3, [r0, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 800ae2e:	f1b9 0f01 	cmp.w	r9, #1
 800ae32:	d105      	bne.n	800ae40 <USB_DevInit+0x12c>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 800ae34:	6983      	ldr	r3, [r0, #24]
 800ae36:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800ae3a:	f043 0304 	orr.w	r3, r3, #4
 800ae3e:	6183      	str	r3, [r0, #24]
  }
  
  return HAL_OK;
}
 800ae40:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ae44:	2000      	movs	r0, #0
 800ae46:	b004      	add	sp, #16
 800ae48:	4770      	bx	lr
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
  
  if (cfg.dma_enable == 1)
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 800ae4a:	4b09      	ldr	r3, [pc, #36]	; (800ae70 <USB_DevInit+0x15c>)
 800ae4c:	6323      	str	r3, [r4, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 800ae4e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800ae50:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800ae54:	f043 0303 	orr.w	r3, r3, #3
 800ae58:	6323      	str	r3, [r4, #48]	; 0x30
    
    i= USBx_DEVICE->DTHRCTL;
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0;
 800ae5a:	2200      	movs	r2, #0
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFF;
 800ae5c:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
    
    i= USBx_DEVICE->DTHRCTL;
 800ae60:	6b21      	ldr	r1, [r4, #48]	; 0x30
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0;
 800ae62:	6182      	str	r2, [r0, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFF;
 800ae64:	6143      	str	r3, [r0, #20]
 800ae66:	e7d8      	b.n	800ae1a <USB_DevInit+0x106>
 800ae68:	00030d40 	.word	0x00030d40
 800ae6c:	803c3800 	.word	0x803c3800
 800ae70:	00800100 	.word	0x00800100

0800ae74 <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 800ae74:	0189      	lsls	r1, r1, #6
 800ae76:	f041 0120 	orr.w	r1, r1, #32
 800ae7a:	6101      	str	r1, [r0, #16]
 800ae7c:	4a05      	ldr	r2, [pc, #20]	; (800ae94 <USB_FlushTxFifo+0x20>)
 800ae7e:	e001      	b.n	800ae84 <USB_FlushTxFifo+0x10>
 
  do
  {
    if (++count > 200000)
 800ae80:	3a01      	subs	r2, #1
 800ae82:	d005      	beq.n	800ae90 <USB_FlushTxFifo+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800ae84:	6903      	ldr	r3, [r0, #16]
 800ae86:	f013 0320 	ands.w	r3, r3, #32
 800ae8a:	d1f9      	bne.n	800ae80 <USB_FlushTxFifo+0xc>
  
  return HAL_OK;
 800ae8c:	4618      	mov	r0, r3
 800ae8e:	4770      	bx	lr
 
  do
  {
    if (++count > 200000)
    {
      return HAL_TIMEOUT;
 800ae90:	2003      	movs	r0, #3
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
  
  return HAL_OK;
}
 800ae92:	4770      	bx	lr
 800ae94:	00030d40 	.word	0x00030d40

0800ae98 <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800ae98:	2310      	movs	r3, #16
 800ae9a:	6103      	str	r3, [r0, #16]
 800ae9c:	4a05      	ldr	r2, [pc, #20]	; (800aeb4 <USB_FlushRxFifo+0x1c>)
 800ae9e:	e001      	b.n	800aea4 <USB_FlushRxFifo+0xc>
  
  do
  {
    if (++count > 200000)
 800aea0:	3a01      	subs	r2, #1
 800aea2:	d005      	beq.n	800aeb0 <USB_FlushRxFifo+0x18>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 800aea4:	6903      	ldr	r3, [r0, #16]
 800aea6:	f013 0310 	ands.w	r3, r3, #16
 800aeaa:	d1f9      	bne.n	800aea0 <USB_FlushRxFifo+0x8>
  
  return HAL_OK;
 800aeac:	4618      	mov	r0, r3
 800aeae:	4770      	bx	lr
  
  do
  {
    if (++count > 200000)
    {
      return HAL_TIMEOUT;
 800aeb0:	2003      	movs	r0, #3
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
  
  return HAL_OK;
}
 800aeb2:	4770      	bx	lr
 800aeb4:	00030d40 	.word	0x00030d40

0800aeb8 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
 800aeb8:	4602      	mov	r2, r0
  USBx_DEVICE->DCFG |= speed;
  return HAL_OK;
}
 800aeba:	2000      	movs	r0, #0
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 800aebc:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 800aec0:	4319      	orrs	r1, r3
 800aec2:	f8c2 1800 	str.w	r1, [r2, #2048]	; 0x800
  return HAL_OK;
}
 800aec6:	4770      	bx	lr

0800aec8 <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint8_t speed = 0;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 800aec8:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 800aecc:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 800aed0:	f013 0006 	ands.w	r0, r3, #6
 800aed4:	d012      	beq.n	800aefc <USB_GetDevSpeed+0x34>
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 800aed6:	6893      	ldr	r3, [r2, #8]
 800aed8:	f003 0306 	and.w	r3, r3, #6
 800aedc:	2b02      	cmp	r3, #2
 800aede:	d00c      	beq.n	800aefa <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 800aee0:	6893      	ldr	r3, [r2, #8]
 800aee2:	f003 0306 	and.w	r3, r3, #6
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 800aee6:	2b06      	cmp	r3, #6
 800aee8:	d007      	beq.n	800aefa <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 800aeea:	6893      	ldr	r3, [r2, #8]
 800aeec:	f003 0306 	and.w	r3, r3, #6
 800aef0:	2b04      	cmp	r3, #4
  {
    speed = USB_OTG_SPEED_LOW;
 800aef2:	bf14      	ite	ne
 800aef4:	2000      	movne	r0, #0
 800aef6:	2002      	moveq	r0, #2
 800aef8:	4770      	bx	lr
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
 800aefa:	2003      	movs	r0, #3
  {
    speed = USB_OTG_SPEED_LOW;
  }
  
  return speed;
}
 800aefc:	4770      	bx	lr
 800aefe:	bf00      	nop

0800af00 <USB_ActivateEndpoint>:
  * @param  USBx: Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800af00:	b470      	push	{r4, r5, r6}
  if (ep->is_in == 1)
 800af02:	784b      	ldrb	r3, [r1, #1]
 800af04:	2b01      	cmp	r3, #1
 800af06:	d020      	beq.n	800af4a <USB_ActivateEndpoint+0x4a>
    } 

  }
  else
  {
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
 800af08:	780d      	ldrb	r5, [r1, #0]
 800af0a:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 800af0e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800af12:	40aa      	lsls	r2, r5
 800af14:	4322      	orrs	r2, r4
 800af16:	f8c0 281c 	str.w	r2, [r0, #2076]	; 0x81c
     
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
 800af1a:	780a      	ldrb	r2, [r1, #0]
 800af1c:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 800af20:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800af24:	581a      	ldr	r2, [r3, r0]
 800af26:	0412      	lsls	r2, r2, #16
 800af28:	d40c      	bmi.n	800af44 <USB_ActivateEndpoint+0x44>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
 800af2a:	581a      	ldr	r2, [r3, r0]
 800af2c:	688c      	ldr	r4, [r1, #8]
 800af2e:	78cd      	ldrb	r5, [r1, #3]
 800af30:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800af34:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800af38:	f3c4 010a 	ubfx	r1, r4, #0, #11
 800af3c:	430a      	orrs	r2, r1
 800af3e:	ea42 4285 	orr.w	r2, r2, r5, lsl #18
 800af42:	501a      	str	r2, [r3, r0]
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
}
 800af44:	2000      	movs	r0, #0
 800af46:	bc70      	pop	{r4, r5, r6}
 800af48:	4770      	bx	lr
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1)
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
 800af4a:	780c      	ldrb	r4, [r1, #0]
 800af4c:	40a3      	lsls	r3, r4
 800af4e:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 800af52:	b29b      	uxth	r3, r3
 800af54:	4323      	orrs	r3, r4
 800af56:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
   
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)
 800af5a:	780e      	ldrb	r6, [r1, #0]
 800af5c:	f44f 6310 	mov.w	r3, #2304	; 0x900
 800af60:	eb03 1346 	add.w	r3, r3, r6, lsl #5
 800af64:	581a      	ldr	r2, [r3, r0]
 800af66:	0414      	lsls	r4, r2, #16
 800af68:	d4ec      	bmi.n	800af44 <USB_ActivateEndpoint+0x44>
    {
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
 800af6a:	581d      	ldr	r5, [r3, r0]
 800af6c:	688c      	ldr	r4, [r1, #8]
 800af6e:	78ca      	ldrb	r2, [r1, #3]
 800af70:	f045 5580 	orr.w	r5, r5, #268435456	; 0x10000000
 800af74:	f445 4500 	orr.w	r5, r5, #32768	; 0x8000
 800af78:	f3c4 010a 	ubfx	r1, r4, #0, #11
 800af7c:	4329      	orrs	r1, r5
 800af7e:	ea41 4282 	orr.w	r2, r1, r2, lsl #18
 800af82:	ea42 5286 	orr.w	r2, r2, r6, lsl #22
 800af86:	501a      	str	r2, [r3, r0]
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
}
 800af88:	2000      	movs	r0, #0
 800af8a:	bc70      	pop	{r4, r5, r6}
 800af8c:	4770      	bx	lr
 800af8e:	bf00      	nop

0800af90 <USB_ActivateDedicatedEndpoint>:
  * @param  USBx: Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800af90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  static __IO uint32_t debug = 0;
  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800af94:	784b      	ldrb	r3, [r1, #1]
 800af96:	2b01      	cmp	r3, #1
 800af98:	d03a      	beq.n	800b010 <USB_ActivateDedicatedEndpoint+0x80>
    
   USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
 800af9a:	780b      	ldrb	r3, [r1, #0]
 800af9c:	2620      	movs	r6, #32
 800af9e:	f44f 6e30 	mov.w	lr, #2816	; 0xb00
 800afa2:	fb16 e703 	smlabb	r7, r6, r3, lr
 800afa6:	59c2      	ldr	r2, [r0, r7]
 800afa8:	0412      	lsls	r2, r2, #16
 800afaa:	d50b      	bpl.n	800afc4 <USB_ActivateDedicatedEndpoint+0x34>
      debug = (uint32_t )&USBx_OUTEP(ep->num)->DOEPCTL;
      debug |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
        ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP)); 
    } 
    
     USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
 800afac:	f8d0 283c 	ldr.w	r2, [r0, #2108]	; 0x83c
 800afb0:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800afb4:	fa01 f303 	lsl.w	r3, r1, r3
 800afb8:	4313      	orrs	r3, r2
 800afba:	f8c0 383c 	str.w	r3, [r0, #2108]	; 0x83c
  }

  return HAL_OK;
}
 800afbe:	2000      	movs	r0, #0
 800afc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
 800afc4:	59c4      	ldr	r4, [r0, r7]
 800afc6:	688a      	ldr	r2, [r1, #8]
 800afc8:	f891 8003 	ldrb.w	r8, [r1, #3]
        ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP));
      
      debug = (uint32_t)(((uint32_t )USBx) + USB_OTG_OUT_ENDPOINT_BASE + (0)*USB_OTG_EP_REG_SIZE);
 800afcc:	4d2a      	ldr	r5, [pc, #168]	; (800b078 <USB_ActivateDedicatedEndpoint+0xe8>)
 800afce:	f444 4c00 	orr.w	ip, r4, #32768	; 0x8000
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
 800afd2:	f3c2 040a 	ubfx	r4, r2, #0, #11
 800afd6:	ea4c 0204 	orr.w	r2, ip, r4
 800afda:	ea42 4288 	orr.w	r2, r2, r8, lsl #18
 800afde:	ea42 5383 	orr.w	r3, r2, r3, lsl #22
 800afe2:	51c3      	str	r3, [r0, r7]
        ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP));
      
      debug = (uint32_t)(((uint32_t )USBx) + USB_OTG_OUT_ENDPOINT_BASE + (0)*USB_OTG_EP_REG_SIZE);
      debug = (uint32_t )&USBx_OUTEP(ep->num)->DOEPCTL;
 800afe4:	780b      	ldrb	r3, [r1, #0]
      debug |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
 800afe6:	688c      	ldr	r4, [r1, #8]
 800afe8:	78cf      	ldrb	r7, [r1, #3]
 800afea:	fb16 e603 	smlabb	r6, r6, r3, lr
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
        ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP));
      
      debug = (uint32_t)(((uint32_t )USBx) + USB_OTG_OUT_ENDPOINT_BASE + (0)*USB_OTG_EP_REG_SIZE);
 800afee:	eb00 020e 	add.w	r2, r0, lr
      debug = (uint32_t )&USBx_OUTEP(ep->num)->DOEPCTL;
 800aff2:	4406      	add	r6, r0
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
        ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP));
      
      debug = (uint32_t)(((uint32_t )USBx) + USB_OTG_OUT_ENDPOINT_BASE + (0)*USB_OTG_EP_REG_SIZE);
 800aff4:	602a      	str	r2, [r5, #0]
      debug = (uint32_t )&USBx_OUTEP(ep->num)->DOEPCTL;
 800aff6:	602e      	str	r6, [r5, #0]
      debug |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
 800aff8:	682a      	ldr	r2, [r5, #0]
 800affa:	f3c4 010a 	ubfx	r1, r4, #0, #11
 800affe:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800b002:	430a      	orrs	r2, r1
 800b004:	ea42 4287 	orr.w	r2, r2, r7, lsl #18
 800b008:	ea42 5283 	orr.w	r2, r2, r3, lsl #22
 800b00c:	602a      	str	r2, [r5, #0]
 800b00e:	e7cd      	b.n	800afac <USB_ActivateDedicatedEndpoint+0x1c>
  static __IO uint32_t debug = 0;
  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)
 800b010:	780c      	ldrb	r4, [r1, #0]
 800b012:	f44f 6510 	mov.w	r5, #2304	; 0x900
 800b016:	eb05 1544 	add.w	r5, r5, r4, lsl #5
 800b01a:	5943      	ldr	r3, [r0, r5]
 800b01c:	041e      	lsls	r6, r3, #16
 800b01e:	d40f      	bmi.n	800b040 <USB_ActivateDedicatedEndpoint+0xb0>
    {
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
 800b020:	5942      	ldr	r2, [r0, r5]
 800b022:	688b      	ldr	r3, [r1, #8]
 800b024:	78cf      	ldrb	r7, [r1, #3]
 800b026:	f042 5680 	orr.w	r6, r2, #268435456	; 0x10000000
 800b02a:	f446 4600 	orr.w	r6, r6, #32768	; 0x8000
 800b02e:	f3c3 020a 	ubfx	r2, r3, #0, #11
 800b032:	4332      	orrs	r2, r6
 800b034:	ea42 4387 	orr.w	r3, r2, r7, lsl #18
 800b038:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
 800b03c:	5143      	str	r3, [r0, r5]
 800b03e:	780c      	ldrb	r4, [r1, #0]
        ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
    } 
    
    
    debug  |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
 800b040:	4e0d      	ldr	r6, [pc, #52]	; (800b078 <USB_ActivateDedicatedEndpoint+0xe8>)
 800b042:	688a      	ldr	r2, [r1, #8]
 800b044:	6835      	ldr	r5, [r6, #0]
 800b046:	78cf      	ldrb	r7, [r1, #3]
 800b048:	f045 5180 	orr.w	r1, r5, #268435456	; 0x10000000
 800b04c:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 800b050:	f3c2 020a 	ubfx	r2, r2, #0, #11
 800b054:	ea41 0302 	orr.w	r3, r1, r2
 800b058:	ea43 4387 	orr.w	r3, r3, r7, lsl #18
 800b05c:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
 800b060:	6033      	str	r3, [r6, #0]
        ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
    
   USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
 800b062:	2301      	movs	r3, #1
 800b064:	f8d0 283c 	ldr.w	r2, [r0, #2108]	; 0x83c
 800b068:	40a3      	lsls	r3, r4
 800b06a:	b29b      	uxth	r3, r3
 800b06c:	4313      	orrs	r3, r2
 800b06e:	f8c0 383c 	str.w	r3, [r0, #2108]	; 0x83c
    
     USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
  }

  return HAL_OK;
}
 800b072:	2000      	movs	r0, #0
 800b074:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b078:	200009f4 	.word	0x200009f4

0800b07c <USB_DeactivateEndpoint>:
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800b07c:	784b      	ldrb	r3, [r1, #1]
 800b07e:	2b01      	cmp	r3, #1
  * @param  USBx: Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800b080:	b430      	push	{r4, r5}
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800b082:	d01d      	beq.n	800b0c0 <USB_DeactivateEndpoint+0x44>
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));   
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
  }
  else
  {
     USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
 800b084:	780d      	ldrb	r5, [r1, #0]
 800b086:	f8d0 483c 	ldr.w	r4, [r0, #2108]	; 0x83c
 800b08a:	2201      	movs	r2, #1
 800b08c:	fa02 f505 	lsl.w	r5, r2, r5
 800b090:	ea24 4405 	bic.w	r4, r4, r5, lsl #16
 800b094:	f8c0 483c 	str.w	r4, [r0, #2108]	; 0x83c
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));     
 800b098:	780d      	ldrb	r5, [r1, #0]
 800b09a:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 800b09e:	40aa      	lsls	r2, r5
 800b0a0:	ea24 4202 	bic.w	r2, r4, r2, lsl #16
 800b0a4:	f8c0 281c 	str.w	r2, [r0, #2076]	; 0x81c
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
 800b0a8:	780a      	ldrb	r2, [r1, #0]
 800b0aa:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 800b0ae:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800b0b2:	581a      	ldr	r2, [r3, r0]
 800b0b4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800b0b8:	501a      	str	r2, [r3, r0]
  }
  return HAL_OK;
}
 800b0ba:	2000      	movs	r0, #0
 800b0bc:	bc30      	pop	{r4, r5}
 800b0be:	4770      	bx	lr
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
 800b0c0:	780c      	ldrb	r4, [r1, #0]
 800b0c2:	f8d0 583c 	ldr.w	r5, [r0, #2108]	; 0x83c
 800b0c6:	fa03 f404 	lsl.w	r4, r3, r4
 800b0ca:	b2a4      	uxth	r4, r4
 800b0cc:	ea25 0404 	bic.w	r4, r5, r4
 800b0d0:	f8c0 483c 	str.w	r4, [r0, #2108]	; 0x83c
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));   
 800b0d4:	780d      	ldrb	r5, [r1, #0]
 800b0d6:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 800b0da:	40ab      	lsls	r3, r5
 800b0dc:	b29b      	uxth	r3, r3
 800b0de:	ea24 0303 	bic.w	r3, r4, r3
 800b0e2:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
 800b0e6:	780a      	ldrb	r2, [r1, #0]
 800b0e8:	f44f 6310 	mov.w	r3, #2304	; 0x900
 800b0ec:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800b0f0:	581a      	ldr	r2, [r3, r0]
 800b0f2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800b0f6:	501a      	str	r2, [r3, r0]
     USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));     
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
  }
  return HAL_OK;
}
 800b0f8:	2000      	movs	r0, #0
 800b0fa:	bc30      	pop	{r4, r5}
 800b0fc:	4770      	bx	lr
 800b0fe:	bf00      	nop

0800b100 <USB_DeactivateDedicatedEndpoint>:
  * @param  USBx: Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800b100:	b430      	push	{r4, r5}
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 800b102:	784b      	ldrb	r3, [r1, #1]
 800b104:	2b01      	cmp	r3, #1
 800b106:	d015      	beq.n	800b134 <USB_DeactivateDedicatedEndpoint+0x34>
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
  }
  else
  {
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP; 
 800b108:	780a      	ldrb	r2, [r1, #0]
 800b10a:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 800b10e:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800b112:	581a      	ldr	r2, [r3, r0]
 800b114:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800b118:	501a      	str	r2, [r3, r0]
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
 800b11a:	7809      	ldrb	r1, [r1, #0]
 800b11c:	f8d0 281c 	ldr.w	r2, [r0, #2076]	; 0x81c
 800b120:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800b124:	408b      	lsls	r3, r1
 800b126:	ea22 0303 	bic.w	r3, r2, r3
 800b12a:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
  }
  return HAL_OK;
}
 800b12e:	bc30      	pop	{r4, r5}
 800b130:	2000      	movs	r0, #0
 800b132:	4770      	bx	lr
HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;
 800b134:	780c      	ldrb	r4, [r1, #0]
 800b136:	f44f 6210 	mov.w	r2, #2304	; 0x900
 800b13a:	eb02 1244 	add.w	r2, r2, r4, lsl #5
 800b13e:	5814      	ldr	r4, [r2, r0]
 800b140:	f424 4400 	bic.w	r4, r4, #32768	; 0x8000
 800b144:	5014      	str	r4, [r2, r0]
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
 800b146:	7809      	ldrb	r1, [r1, #0]
 800b148:	f8d0 281c 	ldr.w	r2, [r0, #2076]	; 0x81c
 800b14c:	408b      	lsls	r3, r1
 800b14e:	b29b      	uxth	r3, r3
 800b150:	ea22 0303 	bic.w	r3, r2, r3
 800b154:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
  {
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP; 
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
  }
  return HAL_OK;
}
 800b158:	bc30      	pop	{r4, r5}
 800b15a:	2000      	movs	r0, #0
 800b15c:	4770      	bx	lr
 800b15e:	bf00      	nop

0800b160 <USB_EPStartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 800b160:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t pktcnt = 0;
  
  /* IN endpoint */
  if (ep->is_in == 1)
 800b162:	784b      	ldrb	r3, [r1, #1]
 800b164:	2b01      	cmp	r3, #1
 800b166:	d074      	beq.n	800b252 <USB_EPStartXfer+0xf2>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */  
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 800b168:	780c      	ldrb	r4, [r1, #0]
 800b16a:	2320      	movs	r3, #32
 800b16c:	f44f 6630 	mov.w	r6, #2816	; 0xb00
 800b170:	fb13 6404 	smlabb	r4, r3, r4, r6
 800b174:	4404      	add	r4, r0
 800b176:	6925      	ldr	r5, [r4, #16]
 800b178:	0ced      	lsrs	r5, r5, #19
 800b17a:	04ed      	lsls	r5, r5, #19
 800b17c:	6125      	str	r5, [r4, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 800b17e:	780c      	ldrb	r4, [r1, #0]
 800b180:	fb13 6404 	smlabb	r4, r3, r4, r6
 800b184:	4404      	add	r4, r0
 800b186:	6925      	ldr	r5, [r4, #16]
 800b188:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800b18c:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 800b190:	6125      	str	r5, [r4, #16]
      
    if (ep->xfer_len == 0)
 800b192:	694c      	ldr	r4, [r1, #20]
 800b194:	b37c      	cbz	r4, 800b1f6 <USB_EPStartXfer+0x96>
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;      
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket; 
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19)); ;
 800b196:	780f      	ldrb	r7, [r1, #0]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;      
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket; 
 800b198:	688d      	ldr	r5, [r1, #8]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19)); ;
 800b19a:	f8df e220 	ldr.w	lr, [pc, #544]	; 800b3bc <USB_EPStartXfer+0x25c>
 800b19e:	fb13 6707 	smlabb	r7, r3, r7, r6
 800b1a2:	4407      	add	r7, r0
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;      
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket; 
 800b1a4:	442c      	add	r4, r5
 800b1a6:	3c01      	subs	r4, #1
 800b1a8:	fbb4 f4f5 	udiv	r4, r4, r5
 800b1ac:	b2a4      	uxth	r4, r4
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19)); ;
 800b1ae:	693d      	ldr	r5, [r7, #16]
 800b1b0:	ea4f 4cc4 	mov.w	ip, r4, lsl #19
 800b1b4:	ea0c 0e0e 	and.w	lr, ip, lr
 800b1b8:	ea4e 0505 	orr.w	r5, lr, r5
 800b1bc:	613d      	str	r5, [r7, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt)); 
 800b1be:	780f      	ldrb	r7, [r1, #0]
 800b1c0:	688d      	ldr	r5, [r1, #8]
 800b1c2:	fb13 6307 	smlabb	r3, r3, r7, r6
 800b1c6:	4403      	add	r3, r0
 800b1c8:	fb05 f504 	mul.w	r5, r5, r4
 800b1cc:	691c      	ldr	r4, [r3, #16]
 800b1ce:	f3c5 0512 	ubfx	r5, r5, #0, #19
 800b1d2:	4325      	orrs	r5, r4
    }

    if (dma == 1)
 800b1d4:	2a01      	cmp	r2, #1
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket; 
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19)); ;
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt)); 
 800b1d6:	611d      	str	r5, [r3, #16]
    }

    if (dma == 1)
 800b1d8:	d021      	beq.n	800b21e <USB_EPStartXfer+0xbe>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
    }
    
    if (ep->type == EP_TYPE_ISOC)
 800b1da:	78cb      	ldrb	r3, [r1, #3]
 800b1dc:	2b01      	cmp	r3, #1
 800b1de:	d027      	beq.n	800b230 <USB_EPStartXfer+0xd0>
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
      }
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800b1e0:	780a      	ldrb	r2, [r1, #0]
 800b1e2:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 800b1e6:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800b1ea:	58c2      	ldr	r2, [r0, r3]
 800b1ec:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800b1f0:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 800b1f2:	2000      	movs	r0, #0
 800b1f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
      
    if (ep->xfer_len == 0)
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 800b1f6:	780c      	ldrb	r4, [r1, #0]
 800b1f8:	688d      	ldr	r5, [r1, #8]
 800b1fa:	fb13 6404 	smlabb	r4, r3, r4, r6
 800b1fe:	4404      	add	r4, r0
 800b200:	f3c5 0512 	ubfx	r5, r5, #0, #19
 800b204:	6927      	ldr	r7, [r4, #16]
 800b206:	433d      	orrs	r5, r7
 800b208:	6125      	str	r5, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;      
 800b20a:	780c      	ldrb	r4, [r1, #0]
 800b20c:	fb13 6304 	smlabb	r3, r3, r4, r6
 800b210:	4403      	add	r3, r0
      pktcnt = (ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket; 
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19)); ;
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt)); 
    }

    if (dma == 1)
 800b212:	2a01      	cmp	r2, #1
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
      
    if (ep->xfer_len == 0)
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;      
 800b214:	691c      	ldr	r4, [r3, #16]
 800b216:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 800b21a:	611c      	str	r4, [r3, #16]
      pktcnt = (ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket; 
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19)); ;
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt)); 
    }

    if (dma == 1)
 800b21c:	d1dd      	bne.n	800b1da <USB_EPStartXfer+0x7a>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
 800b21e:	780b      	ldrb	r3, [r1, #0]
 800b220:	68ca      	ldr	r2, [r1, #12]
 800b222:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800b226:	f8c3 2b14 	str.w	r2, [r3, #2836]	; 0xb14
    }
    
    if (ep->type == EP_TYPE_ISOC)
 800b22a:	78cb      	ldrb	r3, [r1, #3]
 800b22c:	2b01      	cmp	r3, #1
 800b22e:	d1d7      	bne.n	800b1e0 <USB_EPStartXfer+0x80>
    {
      if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
 800b230:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 800b234:	780a      	ldrb	r2, [r1, #0]
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
    }
    
    if (ep->type == EP_TYPE_ISOC)
    {
      if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
 800b236:	f413 7f80 	tst.w	r3, #256	; 0x100
 800b23a:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 800b23e:	eb03 1342 	add.w	r3, r3, r2, lsl #5
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 800b242:	58c2      	ldr	r2, [r0, r3]
 800b244:	bf0c      	ite	eq
 800b246:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
      }
      else
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 800b24a:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
 800b24e:	50c2      	str	r2, [r0, r3]
 800b250:	e7c6      	b.n	800b1e0 <USB_EPStartXfer+0x80>
  
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 800b252:	694b      	ldr	r3, [r1, #20]
 800b254:	2b00      	cmp	r3, #0
 800b256:	d066      	beq.n	800b326 <USB_EPStartXfer+0x1c6>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800b258:	780b      	ldrb	r3, [r1, #0]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket) << 19)) ;
 800b25a:	4f58      	ldr	r7, [pc, #352]	; (800b3bc <USB_EPStartXfer+0x25c>)
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800b25c:	2420      	movs	r4, #32
 800b25e:	f44f 6610 	mov.w	r6, #2304	; 0x900
 800b262:	fb14 6303 	smlabb	r3, r4, r3, r6
 800b266:	4403      	add	r3, r0
 800b268:	691d      	ldr	r5, [r3, #16]
 800b26a:	0ced      	lsrs	r5, r5, #19
 800b26c:	04ed      	lsls	r5, r5, #19
 800b26e:	611d      	str	r5, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 800b270:	780b      	ldrb	r3, [r1, #0]
 800b272:	fb14 6303 	smlabb	r3, r4, r3, r6
 800b276:	4403      	add	r3, r0
 800b278:	691d      	ldr	r5, [r3, #16]
 800b27a:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800b27e:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 800b282:	611d      	str	r5, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket) << 19)) ;
 800b284:	780d      	ldrb	r5, [r1, #0]
 800b286:	f8d1 c008 	ldr.w	ip, [r1, #8]
 800b28a:	694b      	ldr	r3, [r1, #20]
 800b28c:	fb14 6505 	smlabb	r5, r4, r5, r6
 800b290:	4405      	add	r5, r0
 800b292:	4463      	add	r3, ip
 800b294:	f8d5 e010 	ldr.w	lr, [r5, #16]
 800b298:	3b01      	subs	r3, #1
 800b29a:	fbb3 f3fc 	udiv	r3, r3, ip
 800b29e:	04db      	lsls	r3, r3, #19
 800b2a0:	401f      	ands	r7, r3
 800b2a2:	ea47 070e 	orr.w	r7, r7, lr
 800b2a6:	612f      	str	r7, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 800b2a8:	780b      	ldrb	r3, [r1, #0]
 800b2aa:	694d      	ldr	r5, [r1, #20]
 800b2ac:	fb14 6303 	smlabb	r3, r4, r3, r6
 800b2b0:	4403      	add	r3, r0
 800b2b2:	f3c5 0512 	ubfx	r5, r5, #0, #19
 800b2b6:	691f      	ldr	r7, [r3, #16]
 800b2b8:	433d      	orrs	r5, r7
 800b2ba:	611d      	str	r5, [r3, #16]
      
      if (ep->type == EP_TYPE_ISOC)
 800b2bc:	78cb      	ldrb	r3, [r1, #3]
 800b2be:	2b01      	cmp	r3, #1
 800b2c0:	d06b      	beq.n	800b39a <USB_EPStartXfer+0x23a>
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1 << 29)); 
      }       
    }

    if (dma == 1)
 800b2c2:	2a01      	cmp	r2, #1
 800b2c4:	d062      	beq.n	800b38c <USB_EPStartXfer+0x22c>
    else
    {
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
 800b2c6:	694b      	ldr	r3, [r1, #20]
 800b2c8:	b153      	cbz	r3, 800b2e0 <USB_EPStartXfer+0x180>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1 << ep->num;
 800b2ca:	780e      	ldrb	r6, [r1, #0]
 800b2cc:	f8d0 5834 	ldr.w	r5, [r0, #2100]	; 0x834
 800b2d0:	2401      	movs	r4, #1
 800b2d2:	40b4      	lsls	r4, r6
 800b2d4:	432c      	orrs	r4, r5
 800b2d6:	f8c0 4834 	str.w	r4, [r0, #2100]	; 0x834
        }
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 800b2da:	78cb      	ldrb	r3, [r1, #3]
 800b2dc:	2b01      	cmp	r3, #1
 800b2de:	d044      	beq.n	800b36a <USB_EPStartXfer+0x20a>
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
      }
    } 
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800b2e0:	780c      	ldrb	r4, [r1, #0]
 800b2e2:	f44f 6310 	mov.w	r3, #2304	; 0x900
 800b2e6:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 800b2ea:	58c4      	ldr	r4, [r0, r3]
 800b2ec:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 800b2f0:	50c4      	str	r4, [r0, r3]
    
    if (ep->type == EP_TYPE_ISOC)
 800b2f2:	78cb      	ldrb	r3, [r1, #3]
 800b2f4:	2b01      	cmp	r3, #1
 800b2f6:	f47f af7c 	bne.w	800b1f2 <USB_EPStartXfer+0x92>
    {
      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
 800b2fa:	68cb      	ldr	r3, [r1, #12]
 800b2fc:	780d      	ldrb	r5, [r1, #0]
 800b2fe:	694c      	ldr	r4, [r1, #20]
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
  uint32_t count32b= 0 , i= 0;
  
  if (dma == 0)
 800b300:	2a00      	cmp	r2, #0
 800b302:	f47f af76 	bne.w	800b1f2 <USB_EPStartXfer+0x92>
 800b306:	b2a4      	uxth	r4, r4
  {
    count32b =  (len + 3) / 4;
 800b308:	3403      	adds	r4, #3
    for (i = 0; i < count32b; i++, src += 4)
 800b30a:	10a4      	asrs	r4, r4, #2
 800b30c:	f43f af71 	beq.w	800b1f2 <USB_EPStartXfer+0x92>
 800b310:	eb00 3005 	add.w	r0, r0, r5, lsl #12
 800b314:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 800b318:	3201      	adds	r2, #1
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 800b31a:	f853 1b04 	ldr.w	r1, [r3], #4
 800b31e:	6001      	str	r1, [r0, #0]
  uint32_t count32b= 0 , i= 0;
  
  if (dma == 0)
  {
    count32b =  (len + 3) / 4;
    for (i = 0; i < count32b; i++, src += 4)
 800b320:	4294      	cmp	r4, r2
 800b322:	d1f9      	bne.n	800b318 <USB_EPStartXfer+0x1b8>
 800b324:	e765      	b.n	800b1f2 <USB_EPStartXfer+0x92>
  if (ep->is_in == 1)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 800b326:	780c      	ldrb	r4, [r1, #0]
 800b328:	2320      	movs	r3, #32
 800b32a:	f44f 6610 	mov.w	r6, #2304	; 0x900
 800b32e:	fb13 6404 	smlabb	r4, r3, r4, r6
 800b332:	4404      	add	r4, r0
 800b334:	6925      	ldr	r5, [r4, #16]
 800b336:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800b33a:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 800b33e:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
 800b340:	780c      	ldrb	r4, [r1, #0]
 800b342:	fb13 6404 	smlabb	r4, r3, r4, r6
 800b346:	4404      	add	r4, r0
 800b348:	6925      	ldr	r5, [r4, #16]
 800b34a:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800b34e:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 800b350:	780c      	ldrb	r4, [r1, #0]
 800b352:	fb13 6304 	smlabb	r3, r3, r4, r6
 800b356:	4403      	add	r3, r0
 800b358:	691c      	ldr	r4, [r3, #16]
 800b35a:	0ce4      	lsrs	r4, r4, #19
 800b35c:	04e4      	lsls	r4, r4, #19
 800b35e:	611c      	str	r4, [r3, #16]
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1 << 29)); 
      }       
    }

    if (dma == 1)
 800b360:	2a01      	cmp	r2, #1
 800b362:	d013      	beq.n	800b38c <USB_EPStartXfer+0x22c>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 800b364:	78cb      	ldrb	r3, [r1, #3]
 800b366:	2b01      	cmp	r3, #1
 800b368:	d1ad      	bne.n	800b2c6 <USB_EPStartXfer+0x166>
      }
    }

    if (ep->type == EP_TYPE_ISOC)
    {
      if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
 800b36a:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 800b36e:	780c      	ldrb	r4, [r1, #0]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
    {
      if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
 800b370:	f413 7f80 	tst.w	r3, #256	; 0x100
 800b374:	f44f 6310 	mov.w	r3, #2304	; 0x900
 800b378:	eb03 1344 	add.w	r3, r3, r4, lsl #5
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 800b37c:	58c4      	ldr	r4, [r0, r3]
 800b37e:	bf0c      	ite	eq
 800b380:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
      }
      else
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 800b384:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
 800b388:	50c4      	str	r4, [r0, r3]
 800b38a:	e7a9      	b.n	800b2e0 <USB_EPStartXfer+0x180>
      }       
    }

    if (dma == 1)
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 800b38c:	780b      	ldrb	r3, [r1, #0]
 800b38e:	690c      	ldr	r4, [r1, #16]
 800b390:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800b394:	f8c3 4914 	str.w	r4, [r3, #2324]	; 0x914
 800b398:	e79f      	b.n	800b2da <USB_EPStartXfer+0x17a>
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket) << 19)) ;
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
      
      if (ep->type == EP_TYPE_ISOC)
      {
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
 800b39a:	780b      	ldrb	r3, [r1, #0]
 800b39c:	fb14 6303 	smlabb	r3, r4, r3, r6
 800b3a0:	4403      	add	r3, r0
 800b3a2:	691d      	ldr	r5, [r3, #16]
 800b3a4:	f025 45c0 	bic.w	r5, r5, #1610612736	; 0x60000000
 800b3a8:	611d      	str	r5, [r3, #16]
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1 << 29)); 
 800b3aa:	780b      	ldrb	r3, [r1, #0]
 800b3ac:	fb14 6403 	smlabb	r4, r4, r3, r6
 800b3b0:	4404      	add	r4, r0
 800b3b2:	6923      	ldr	r3, [r4, #16]
 800b3b4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800b3b8:	6123      	str	r3, [r4, #16]
 800b3ba:	e7d1      	b.n	800b360 <USB_EPStartXfer+0x200>
 800b3bc:	1ff80000 	.word	0x1ff80000

0800b3c0 <USB_EP0StartXfer>:
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
  /* IN endpoint */
  if (ep->is_in == 1)
 800b3c0:	784b      	ldrb	r3, [r1, #1]
 800b3c2:	2b01      	cmp	r3, #1
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 800b3c4:	b4f0      	push	{r4, r5, r6, r7}
  /* IN endpoint */
  if (ep->is_in == 1)
 800b3c6:	d03d      	beq.n	800b444 <USB_EP0StartXfer+0x84>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 800b3c8:	780d      	ldrb	r5, [r1, #0]
 800b3ca:	2420      	movs	r4, #32
 800b3cc:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 800b3d0:	fb14 3505 	smlabb	r5, r4, r5, r3
 800b3d4:	4405      	add	r5, r0
 800b3d6:	692e      	ldr	r6, [r5, #16]
 800b3d8:	0cf6      	lsrs	r6, r6, #19
 800b3da:	04f6      	lsls	r6, r6, #19
 800b3dc:	612e      	str	r6, [r5, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 800b3de:	780d      	ldrb	r5, [r1, #0]
 800b3e0:	fb14 3305 	smlabb	r3, r4, r5, r3
 800b3e4:	4403      	add	r3, r0
 800b3e6:	691c      	ldr	r4, [r3, #16]
 800b3e8:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 800b3ec:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 800b3f0:	611c      	str	r4, [r3, #16]
      
    if (ep->xfer_len > 0)
 800b3f2:	694b      	ldr	r3, [r1, #20]
 800b3f4:	bb1b      	cbnz	r3, 800b43e <USB_EP0StartXfer+0x7e>
    {
      ep->xfer_len = ep->maxpacket;
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19));
 800b3f6:	780b      	ldrb	r3, [r1, #0]
 800b3f8:	2420      	movs	r4, #32
 800b3fa:	f44f 6630 	mov.w	r6, #2816	; 0xb00
 800b3fe:	fb14 6303 	smlabb	r3, r4, r3, r6
 800b402:	4403      	add	r3, r0
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
    

    if (dma == 1)
 800b404:	2a01      	cmp	r2, #1
    if (ep->xfer_len > 0)
    {
      ep->xfer_len = ep->maxpacket;
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19));
 800b406:	691d      	ldr	r5, [r3, #16]
 800b408:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800b40c:	611d      	str	r5, [r3, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 800b40e:	780b      	ldrb	r3, [r1, #0]
 800b410:	688d      	ldr	r5, [r1, #8]
 800b412:	fb14 6303 	smlabb	r3, r4, r3, r6
 800b416:	4403      	add	r3, r0
 800b418:	f3c5 0712 	ubfx	r7, r5, #0, #19
 800b41c:	691d      	ldr	r5, [r3, #16]
 800b41e:	ea45 0507 	orr.w	r5, r5, r7
 800b422:	611d      	str	r5, [r3, #16]
    

    if (dma == 1)
 800b424:	d058      	beq.n	800b4d8 <USB_EP0StartXfer+0x118>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
    }
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
 800b426:	780a      	ldrb	r2, [r1, #0]
 800b428:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 800b42c:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800b430:	58c2      	ldr	r2, [r0, r3]
 800b432:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800b436:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 800b438:	2000      	movs	r0, #0
 800b43a:	bcf0      	pop	{r4, r5, r6, r7}
 800b43c:	4770      	bx	lr
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
      
    if (ep->xfer_len > 0)
    {
      ep->xfer_len = ep->maxpacket;
 800b43e:	688b      	ldr	r3, [r1, #8]
 800b440:	614b      	str	r3, [r1, #20]
 800b442:	e7d8      	b.n	800b3f6 <USB_EP0StartXfer+0x36>
{
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 800b444:	694b      	ldr	r3, [r1, #20]
 800b446:	2b00      	cmp	r3, #0
 800b448:	d04d      	beq.n	800b4e6 <USB_EP0StartXfer+0x126>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800b44a:	780d      	ldrb	r5, [r1, #0]
 800b44c:	2420      	movs	r4, #32
 800b44e:	f44f 6310 	mov.w	r3, #2304	; 0x900
 800b452:	fb14 3505 	smlabb	r5, r4, r5, r3
 800b456:	4405      	add	r5, r0
 800b458:	692e      	ldr	r6, [r5, #16]
 800b45a:	0cf6      	lsrs	r6, r6, #19
 800b45c:	04f6      	lsls	r6, r6, #19
 800b45e:	612e      	str	r6, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 800b460:	780d      	ldrb	r5, [r1, #0]
 800b462:	fb14 3305 	smlabb	r3, r4, r5, r3
 800b466:	4403      	add	r3, r0
 800b468:	691c      	ldr	r4, [r3, #16]
 800b46a:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 800b46e:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 800b472:	611c      	str	r4, [r3, #16]
      
      if(ep->xfer_len > ep->maxpacket)
 800b474:	688b      	ldr	r3, [r1, #8]
 800b476:	694c      	ldr	r4, [r1, #20]
      {
        ep->xfer_len = ep->maxpacket;
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
 800b478:	780d      	ldrb	r5, [r1, #0]
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
      
      if(ep->xfer_len > ep->maxpacket)
 800b47a:	429c      	cmp	r4, r3
      {
        ep->xfer_len = ep->maxpacket;
 800b47c:	bf88      	it	hi
 800b47e:	614b      	strhi	r3, [r1, #20]
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
 800b480:	2420      	movs	r4, #32
 800b482:	f44f 6310 	mov.w	r3, #2304	; 0x900
 800b486:	fb14 3505 	smlabb	r5, r4, r5, r3
 800b48a:	4405      	add	r5, r0
 800b48c:	692e      	ldr	r6, [r5, #16]
 800b48e:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 800b492:	612e      	str	r6, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 800b494:	780e      	ldrb	r6, [r1, #0]
 800b496:	694d      	ldr	r5, [r1, #20]
 800b498:	fb14 3306 	smlabb	r3, r4, r6, r3
 800b49c:	4403      	add	r3, r0
 800b49e:	f3c5 0512 	ubfx	r5, r5, #0, #19
 800b4a2:	691c      	ldr	r4, [r3, #16]
 800b4a4:	432c      	orrs	r4, r5
 800b4a6:	611c      	str	r4, [r3, #16]
    
    }
    
    if (dma == 1)
 800b4a8:	2a01      	cmp	r2, #1
 800b4aa:	d03a      	beq.n	800b522 <USB_EP0StartXfer+0x162>
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
    }
    else
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
 800b4ac:	694b      	ldr	r3, [r1, #20]
 800b4ae:	b13b      	cbz	r3, 800b4c0 <USB_EP0StartXfer+0x100>
      {
        USBx_DEVICE->DIEPEMPMSK |= 1 << (ep->num);
 800b4b0:	780d      	ldrb	r5, [r1, #0]
 800b4b2:	f8d0 4834 	ldr.w	r4, [r0, #2100]	; 0x834
 800b4b6:	2201      	movs	r2, #1
 800b4b8:	40aa      	lsls	r2, r5
 800b4ba:	4322      	orrs	r2, r4
 800b4bc:	f8c0 2834 	str.w	r2, [r0, #2100]	; 0x834
      }
    }
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);   
 800b4c0:	780a      	ldrb	r2, [r1, #0]
 800b4c2:	f44f 6310 	mov.w	r3, #2304	; 0x900
 800b4c6:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800b4ca:	58c2      	ldr	r2, [r0, r3]
 800b4cc:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800b4d0:	50c2      	str	r2, [r0, r3]
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
  }
  return HAL_OK;
}
 800b4d2:	2000      	movs	r0, #0
 800b4d4:	bcf0      	pop	{r4, r5, r6, r7}
 800b4d6:	4770      	bx	lr
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
    

    if (dma == 1)
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 800b4d8:	780a      	ldrb	r2, [r1, #0]
 800b4da:	68cb      	ldr	r3, [r1, #12]
 800b4dc:	fb14 6402 	smlabb	r4, r4, r2, r6
 800b4e0:	4404      	add	r4, r0
 800b4e2:	6163      	str	r3, [r4, #20]
 800b4e4:	e79f      	b.n	800b426 <USB_EP0StartXfer+0x66>
  if (ep->is_in == 1)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 800b4e6:	780c      	ldrb	r4, [r1, #0]
 800b4e8:	2320      	movs	r3, #32
 800b4ea:	f44f 6610 	mov.w	r6, #2304	; 0x900
 800b4ee:	fb13 6404 	smlabb	r4, r3, r4, r6
 800b4f2:	4404      	add	r4, r0
 800b4f4:	6925      	ldr	r5, [r4, #16]
 800b4f6:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800b4fa:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 800b4fe:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
 800b500:	780c      	ldrb	r4, [r1, #0]
 800b502:	fb13 6404 	smlabb	r4, r3, r4, r6
 800b506:	4404      	add	r4, r0
 800b508:	6925      	ldr	r5, [r4, #16]
 800b50a:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800b50e:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 800b510:	780c      	ldrb	r4, [r1, #0]
 800b512:	fb13 6304 	smlabb	r3, r3, r4, r6
 800b516:	4403      	add	r3, r0
 800b518:	691c      	ldr	r4, [r3, #16]
 800b51a:	0ce4      	lsrs	r4, r4, #19
 800b51c:	04e4      	lsls	r4, r4, #19
 800b51e:	611c      	str	r4, [r3, #16]
 800b520:	e7c2      	b.n	800b4a8 <USB_EP0StartXfer+0xe8>
    
    }
    
    if (dma == 1)
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 800b522:	780b      	ldrb	r3, [r1, #0]
 800b524:	690a      	ldr	r2, [r1, #16]
 800b526:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800b52a:	f8c3 2914 	str.w	r2, [r3, #2324]	; 0x914
 800b52e:	e7c7      	b.n	800b4c0 <USB_EP0StartXfer+0x100>

0800b530 <USB_WritePacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 800b530:	b430      	push	{r4, r5}
 800b532:	f89d 4008 	ldrb.w	r4, [sp, #8]
  uint32_t count32b= 0 , i= 0;
  
  if (dma == 0)
 800b536:	b964      	cbnz	r4, 800b552 <USB_WritePacket+0x22>
  {
    count32b =  (len + 3) / 4;
 800b538:	3303      	adds	r3, #3
    for (i = 0; i < count32b; i++, src += 4)
 800b53a:	109b      	asrs	r3, r3, #2
 800b53c:	d009      	beq.n	800b552 <USB_WritePacket+0x22>
 800b53e:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 800b542:	eb00 3202 	add.w	r2, r0, r2, lsl #12
 800b546:	3401      	adds	r4, #1
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 800b548:	f851 5b04 	ldr.w	r5, [r1], #4
 800b54c:	6015      	str	r5, [r2, #0]
  uint32_t count32b= 0 , i= 0;
  
  if (dma == 0)
  {
    count32b =  (len + 3) / 4;
    for (i = 0; i < count32b; i++, src += 4)
 800b54e:	42a3      	cmp	r3, r4
 800b550:	d1f9      	bne.n	800b546 <USB_WritePacket+0x16>
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
    }
  }
  return HAL_OK;
}
 800b552:	2000      	movs	r0, #0
 800b554:	bc30      	pop	{r4, r5}
 800b556:	4770      	bx	lr

0800b558 <USB_ReadPacket>:
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 800b558:	3203      	adds	r2, #3
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 800b55a:	1092      	asrs	r2, r2, #2
 800b55c:	d00f      	beq.n	800b57e <USB_ReadPacket+0x26>
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 800b55e:	b470      	push	{r4, r5, r6}
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 800b560:	2300      	movs	r3, #0
 800b562:	f500 5680 	add.w	r6, r0, #4096	; 0x1000
 800b566:	460c      	mov	r4, r1
 800b568:	3301      	adds	r3, #1
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0);
 800b56a:	6835      	ldr	r5, [r6, #0]
 800b56c:	f844 5b04 	str.w	r5, [r4], #4
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 800b570:	429a      	cmp	r2, r3
 800b572:	d1f9      	bne.n	800b568 <USB_ReadPacket+0x10>
 800b574:	eb01 0182 	add.w	r1, r1, r2, lsl #2
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0);
    
  }
  return ((void *)dest);
}
 800b578:	4608      	mov	r0, r1
 800b57a:	bc70      	pop	{r4, r5, r6}
 800b57c:	4770      	bx	lr
 800b57e:	4608      	mov	r0, r1
 800b580:	4770      	bx	lr
 800b582:	bf00      	nop

0800b584 <USB_EPSetStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1)
 800b584:	784b      	ldrb	r3, [r1, #1]
  * @param  USBx: Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
 800b586:	b470      	push	{r4, r5, r6}
  if (ep->is_in == 1)
 800b588:	2b01      	cmp	r3, #1
  {
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0)
 800b58a:	780b      	ldrb	r3, [r1, #0]
 800b58c:	bf0c      	ite	eq
 800b58e:	f44f 6510 	moveq.w	r5, #2304	; 0x900
 800b592:	f44f 6530 	movne.w	r5, #2816	; 0xb00
 800b596:	2220      	movs	r2, #32
 800b598:	fb12 5303 	smlabb	r3, r2, r3, r5
    } 
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0)
 800b59c:	181c      	adds	r4, r3, r0
 800b59e:	581e      	ldr	r6, [r3, r0]
 800b5a0:	2e00      	cmp	r6, #0
 800b5a2:	db07      	blt.n	800b5b4 <USB_EPSetStall+0x30>
    {
      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
 800b5a4:	581c      	ldr	r4, [r3, r0]
 800b5a6:	f024 4480 	bic.w	r4, r4, #1073741824	; 0x40000000
 800b5aa:	501c      	str	r4, [r3, r0]
 800b5ac:	780b      	ldrb	r3, [r1, #0]
 800b5ae:	fb12 5203 	smlabb	r2, r2, r3, r5
 800b5b2:	1814      	adds	r4, r2, r0
    } 
    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 800b5b4:	6823      	ldr	r3, [r4, #0]
 800b5b6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800b5ba:	6023      	str	r3, [r4, #0]
  }
  return HAL_OK;
}
 800b5bc:	2000      	movs	r0, #0
 800b5be:	bc70      	pop	{r4, r5, r6}
 800b5c0:	4770      	bx	lr
 800b5c2:	bf00      	nop

0800b5c4 <USB_EPClearStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1)
 800b5c4:	784b      	ldrb	r3, [r1, #1]
  * @param  USBx: Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800b5c6:	b430      	push	{r4, r5}
  if (ep->is_in == 1)
 800b5c8:	2b01      	cmp	r3, #1
  {
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800b5ca:	780b      	ldrb	r3, [r1, #0]
 800b5cc:	bf0c      	ite	eq
 800b5ce:	f44f 6510 	moveq.w	r5, #2304	; 0x900
 800b5d2:	f44f 6530 	movne.w	r5, #2816	; 0xb00
 800b5d6:	2420      	movs	r4, #32
 800b5d8:	fb14 5303 	smlabb	r3, r4, r3, r5
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  else
  {
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800b5dc:	581a      	ldr	r2, [r3, r0]
 800b5de:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800b5e2:	501a      	str	r2, [r3, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 800b5e4:	78cb      	ldrb	r3, [r1, #3]
 800b5e6:	3b02      	subs	r3, #2
 800b5e8:	2b01      	cmp	r3, #1
 800b5ea:	d806      	bhi.n	800b5fa <USB_EPClearStall+0x36>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800b5ec:	780b      	ldrb	r3, [r1, #0]
 800b5ee:	fb14 5403 	smlabb	r4, r4, r3, r5
 800b5f2:	5823      	ldr	r3, [r4, r0]
 800b5f4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800b5f8:	5023      	str	r3, [r4, r0]
    }    
  }
  return HAL_OK;
}
 800b5fa:	2000      	movs	r0, #0
 800b5fc:	bc30      	pop	{r4, r5}
 800b5fe:	4770      	bx	lr

0800b600 <USB_StopDevice>:
  * @brief  USB_StopDevice : Stop the USB device mode
  * @param  USBx: Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
{
 800b600:	b410      	push	{r4}
 800b602:	f500 6310 	add.w	r3, r0, #2304	; 0x900
 800b606:	f500 642e 	add.w	r4, r0, #2784	; 0xae0
  uint32_t i;
  
  /* Clear Pending interrupt */
  for (i = 0; i < 15 ; i++)
  {
    USBx_INEP(i)->DIEPINT  = 0xFF;
 800b60a:	22ff      	movs	r2, #255	; 0xff
 800b60c:	609a      	str	r2, [r3, #8]
 800b60e:	f503 7100 	add.w	r1, r3, #512	; 0x200
 800b612:	3320      	adds	r3, #32
HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t i;
  
  /* Clear Pending interrupt */
  for (i = 0; i < 15 ; i++)
 800b614:	42a3      	cmp	r3, r4
  {
    USBx_INEP(i)->DIEPINT  = 0xFF;
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
 800b616:	608a      	str	r2, [r1, #8]
HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t i;
  
  /* Clear Pending interrupt */
  for (i = 0; i < 15 ; i++)
 800b618:	d1f8      	bne.n	800b60c <USB_StopDevice+0xc>
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
  }
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
  
  /* Clear interrupt masks */
  USBx_DEVICE->DIEPMSK  = 0;
 800b61a:	2100      	movs	r1, #0
  for (i = 0; i < 15 ; i++)
  {
    USBx_INEP(i)->DIEPINT  = 0xFF;
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
  }
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
 800b61c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800b620:	2410      	movs	r4, #16
  for (i = 0; i < 15 ; i++)
  {
    USBx_INEP(i)->DIEPINT  = 0xFF;
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
  }
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
 800b622:	f8c0 3818 	str.w	r3, [r0, #2072]	; 0x818
  
  /* Clear interrupt masks */
  USBx_DEVICE->DIEPMSK  = 0;
 800b626:	f8c0 1810 	str.w	r1, [r0, #2064]	; 0x810
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800b62a:	4b0d      	ldr	r3, [pc, #52]	; (800b660 <USB_StopDevice+0x60>)
  }
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
  
  /* Clear interrupt masks */
  USBx_DEVICE->DIEPMSK  = 0;
  USBx_DEVICE->DOEPMSK  = 0;
 800b62c:	f8c0 1814 	str.w	r1, [r0, #2068]	; 0x814
  USBx_DEVICE->DAINTMSK = 0;
 800b630:	f8c0 181c 	str.w	r1, [r0, #2076]	; 0x81c
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800b634:	6104      	str	r4, [r0, #16]
 800b636:	e001      	b.n	800b63c <USB_StopDevice+0x3c>
  
  do
  {
    if (++count > 200000)
 800b638:	3b01      	subs	r3, #1
 800b63a:	d002      	beq.n	800b642 <USB_StopDevice+0x42>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 800b63c:	6902      	ldr	r2, [r0, #16]
 800b63e:	06d1      	lsls	r1, r2, #27
 800b640:	d4fa      	bmi.n	800b638 <USB_StopDevice+0x38>
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 800b642:	f44f 6384 	mov.w	r3, #1056	; 0x420
 800b646:	6103      	str	r3, [r0, #16]
 800b648:	4b05      	ldr	r3, [pc, #20]	; (800b660 <USB_StopDevice+0x60>)
 800b64a:	e001      	b.n	800b650 <USB_StopDevice+0x50>
 
  do
  {
    if (++count > 200000)
 800b64c:	3b01      	subs	r3, #1
 800b64e:	d002      	beq.n	800b656 <USB_StopDevice+0x56>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800b650:	6902      	ldr	r2, [r0, #16]
 800b652:	0692      	lsls	r2, r2, #26
 800b654:	d4fa      	bmi.n	800b64c <USB_StopDevice+0x4c>
  /* Flush the FIFO */
  USB_FlushRxFifo(USBx);
  USB_FlushTxFifo(USBx ,  0x10 );  
  
  return HAL_OK;
}
 800b656:	2000      	movs	r0, #0
 800b658:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b65c:	4770      	bx	lr
 800b65e:	bf00      	nop
 800b660:	00030d40 	.word	0x00030d40

0800b664 <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
  USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
 800b664:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800b668:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800b66c:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= (address << 4) & USB_OTG_DCFG_DAD ;
 800b670:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800b674:	0109      	lsls	r1, r1, #4
 800b676:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 800b67a:	4319      	orrs	r1, r3
 800b67c:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  
  return HAL_OK;  
}
 800b680:	2000      	movs	r0, #0
 800b682:	4770      	bx	lr

0800b684 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx: Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
 800b684:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ; 
 800b686:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 800b68a:	6853      	ldr	r3, [r2, #4]
 800b68c:	f023 0302 	bic.w	r3, r3, #2
  HAL_Delay(3);
 800b690:	2003      	movs	r0, #3
  * @param  USBx: Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ; 
 800b692:	6053      	str	r3, [r2, #4]
  HAL_Delay(3);
 800b694:	f7f5 fa3e 	bl	8000b14 <HAL_Delay>
  
  return HAL_OK;  
}
 800b698:	2000      	movs	r0, #0
 800b69a:	bd08      	pop	{r3, pc}

0800b69c <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx: Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 800b69c:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ; 
 800b69e:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 800b6a2:	6853      	ldr	r3, [r2, #4]
 800b6a4:	f043 0302 	orr.w	r3, r3, #2
  HAL_Delay(3);
 800b6a8:	2003      	movs	r0, #3
  * @param  USBx: Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ; 
 800b6aa:	6053      	str	r3, [r2, #4]
  HAL_Delay(3);
 800b6ac:	f7f5 fa32 	bl	8000b14 <HAL_Delay>
  
  return HAL_OK;  
}
 800b6b0:	2000      	movs	r0, #0
 800b6b2:	bd08      	pop	{r3, pc}

0800b6b4 <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v = 0;
  
  v = USBx->GINTSTS;
 800b6b4:	6943      	ldr	r3, [r0, #20]
  v &= USBx->GINTMSK;
 800b6b6:	6980      	ldr	r0, [r0, #24]
  return v;  
}
 800b6b8:	4018      	ands	r0, r3
 800b6ba:	4770      	bx	lr

0800b6bc <USB_ReadDevAllOutEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 800b6bc:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 800b6c0:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v &= USBx_DEVICE->DAINTMSK;
 800b6c4:	69c0      	ldr	r0, [r0, #28]
 800b6c6:	4018      	ands	r0, r3
  return ((v & 0xffff0000) >> 16);
}
 800b6c8:	0c00      	lsrs	r0, r0, #16
 800b6ca:	4770      	bx	lr

0800b6cc <USB_ReadDevAllInEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 800b6cc:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 800b6d0:	f8d0 0818 	ldr.w	r0, [r0, #2072]	; 0x818
  v &= USBx_DEVICE->DAINTMSK;
 800b6d4:	69db      	ldr	r3, [r3, #28]
 800b6d6:	4018      	ands	r0, r3
  return ((v & 0xFFFF));
}
 800b6d8:	b280      	uxth	r0, r0
 800b6da:	4770      	bx	lr

0800b6dc <USB_ReadDevOutEPInterrupt>:
  * @param  epnum: endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
 800b6dc:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 800b6e0:	eb03 1141 	add.w	r1, r3, r1, lsl #5
  v &= USBx_DEVICE->DOEPMSK;
 800b6e4:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 800b6e8:	688b      	ldr	r3, [r1, #8]
  v &= USBx_DEVICE->DOEPMSK;
 800b6ea:	6940      	ldr	r0, [r0, #20]
  return v;
}
 800b6ec:	4018      	ands	r0, r3
 800b6ee:	4770      	bx	lr

0800b6f0 <USB_ReadDevInEPInterrupt>:
  * @param  epnum: endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
 800b6f0:	b410      	push	{r4}
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
 800b6f2:	f8d0 4810 	ldr.w	r4, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 800b6f6:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
 800b6fa:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> epnum) & 0x1) << 7;
 800b6fe:	40cb      	lsrs	r3, r1
 800b700:	01db      	lsls	r3, r3, #7
 800b702:	b2db      	uxtb	r3, r3
  v = USBx_INEP(epnum)->DIEPINT & msk;
 800b704:	f8d0 0908 	ldr.w	r0, [r0, #2312]	; 0x908
{
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
  emp = USBx_DEVICE->DIEPEMPMSK;
  msk |= ((emp >> epnum) & 0x1) << 7;
 800b708:	4323      	orrs	r3, r4
  v = USBx_INEP(epnum)->DIEPINT & msk;
  return v;
}
 800b70a:	4018      	ands	r0, r3
 800b70c:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b710:	4770      	bx	lr
 800b712:	bf00      	nop

0800b714 <USB_ClearInterrupts>:
  * @param  interrupt: interrupt flag
  * @retval None
  */
void  USB_ClearInterrupts (USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt)
{
  USBx->GINTSTS |= interrupt; 
 800b714:	6943      	ldr	r3, [r0, #20]
 800b716:	4319      	orrs	r1, r3
 800b718:	6141      	str	r1, [r0, #20]
 800b71a:	4770      	bx	lr

0800b71c <USB_GetMode>:
  *           0 : Host 
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS ) & 0x1);
 800b71c:	6940      	ldr	r0, [r0, #20]
}
 800b71e:	f000 0001 	and.w	r0, r0, #1
 800b722:	4770      	bx	lr

0800b724 <USB_ActivateSetup>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 800b724:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800b728:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 800b72c:	f023 0307 	bic.w	r3, r3, #7
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 800b730:	f500 6200 	add.w	r2, r0, #2048	; 0x800
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 800b734:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 800b738:	6893      	ldr	r3, [r2, #8]
 800b73a:	f003 0306 	and.w	r3, r3, #6
 800b73e:	2b04      	cmp	r3, #4
 800b740:	d105      	bne.n	800b74e <USB_ActivateSetup+0x2a>
  {
    USBx_INEP(0)->DIEPCTL |= 3;
 800b742:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800b746:	f043 0303 	orr.w	r3, r3, #3
 800b74a:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  }
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 800b74e:	6853      	ldr	r3, [r2, #4]
 800b750:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b754:	6053      	str	r3, [r2, #4]

  return HAL_OK;
}
 800b756:	2000      	movs	r0, #0
 800b758:	4770      	bx	lr
 800b75a:	bf00      	nop

0800b75c <USB_EP0_OutStart>:
  *           1 : DMA feature used  
  * @param  psetup: pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 800b75c:	b410      	push	{r4}
  USBx_OUTEP(0)->DOEPTSIZ = 0;
 800b75e:	2400      	movs	r4, #0
 800b760:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;
 800b764:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 800b768:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 800b76c:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0)->DOEPTSIZ |= (3 * 8);
 800b770:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 800b774:	f044 0418 	orr.w	r4, r4, #24
 800b778:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 800b77c:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1)
 800b780:	2901      	cmp	r1, #1
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
  USBx_OUTEP(0)->DOEPTSIZ = 0;
  USBx_OUTEP(0)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;
  USBx_OUTEP(0)->DOEPTSIZ |= (3 * 8);
  USBx_OUTEP(0)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 800b782:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
 800b786:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1)
 800b78a:	d105      	bne.n	800b798 <USB_EP0_OutStart+0x3c>
  {
    USBx_OUTEP(0)->DOEPDMA = (uint32_t)psetup;
    /* EP enable */
    USBx_OUTEP(0)->DOEPCTL = 0x80008000;
 800b78c:	f04f 2180 	mov.w	r1, #2147516416	; 0x80008000
  USBx_OUTEP(0)->DOEPTSIZ |= (3 * 8);
  USBx_OUTEP(0)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
  
  if (dma == 1)
  {
    USBx_OUTEP(0)->DOEPDMA = (uint32_t)psetup;
 800b790:	f8c0 2b14 	str.w	r2, [r0, #2836]	; 0xb14
    /* EP enable */
    USBx_OUTEP(0)->DOEPCTL = 0x80008000;
 800b794:	f8c0 1b00 	str.w	r1, [r0, #2816]	; 0xb00
  }
  
  return HAL_OK;  
}
 800b798:	2000      	movs	r0, #0
 800b79a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b79e:	4770      	bx	lr

0800b7a0 <USB_InitFSLSPClkSel>:
  *           HCFG_6_MHZ : Low Speed 6 MHz Clock 
  * @retval HAL status
  */
HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx , uint8_t freq)
{
  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 800b7a0:	f8d0 3400 	ldr.w	r3, [r0, #1024]	; 0x400
 800b7a4:	f023 0303 	bic.w	r3, r3, #3
 800b7a8:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
  USBx_HOST->HCFG |= (freq & USB_OTG_HCFG_FSLSPCS);
 800b7ac:	f8d0 3400 	ldr.w	r3, [r0, #1024]	; 0x400
 800b7b0:	f001 0203 	and.w	r2, r1, #3
 800b7b4:	4313      	orrs	r3, r2
  
  if (freq ==  HCFG_48_MHZ)
 800b7b6:	2901      	cmp	r1, #1
  * @retval HAL status
  */
HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx , uint8_t freq)
{
  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
  USBx_HOST->HCFG |= (freq & USB_OTG_HCFG_FSLSPCS);
 800b7b8:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
  *           HCFG_6_MHZ : Low Speed 6 MHz Clock 
  * @retval HAL status
  */
HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx , uint8_t freq)
{
  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 800b7bc:	f500 6080 	add.w	r0, r0, #1024	; 0x400
  USBx_HOST->HCFG |= (freq & USB_OTG_HCFG_FSLSPCS);
  
  if (freq ==  HCFG_48_MHZ)
 800b7c0:	d006      	beq.n	800b7d0 <USB_InitFSLSPClkSel+0x30>
  {
    USBx_HOST->HFIR = (uint32_t)48000;
  }
  else if (freq ==  HCFG_6_MHZ)
 800b7c2:	2902      	cmp	r1, #2
  {
    USBx_HOST->HFIR = (uint32_t)6000;
 800b7c4:	bf04      	itt	eq
 800b7c6:	f241 7370 	movweq	r3, #6000	; 0x1770
 800b7ca:	6043      	streq	r3, [r0, #4]
  } 
  return HAL_OK;  
}
 800b7cc:	2000      	movs	r0, #0
 800b7ce:	4770      	bx	lr
  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
  USBx_HOST->HCFG |= (freq & USB_OTG_HCFG_FSLSPCS);
  
  if (freq ==  HCFG_48_MHZ)
  {
    USBx_HOST->HFIR = (uint32_t)48000;
 800b7d0:	f64b 3380 	movw	r3, #48000	; 0xbb80
 800b7d4:	6043      	str	r3, [r0, #4]
  else if (freq ==  HCFG_6_MHZ)
  {
    USBx_HOST->HFIR = (uint32_t)6000;
  } 
  return HAL_OK;  
}
 800b7d6:	2000      	movs	r0, #0
 800b7d8:	4770      	bx	lr
 800b7da:	bf00      	nop

0800b7dc <USB_ResetPort>:
  * @retval HAL status
  * @note   (1)The application must wait at least 10 ms
  *   before clearing the reset bit.
  */
HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
{
 800b7dc:	b510      	push	{r4, lr}
 800b7de:	4604      	mov	r4, r0
 800b7e0:	b082      	sub	sp, #8
  __IO uint32_t hprt0;
  
  hprt0 = USBx_HPRT0;
 800b7e2:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
 800b7e6:	9301      	str	r3, [sp, #4]
  
  hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
 800b7e8:	9b01      	ldr	r3, [sp, #4]
 800b7ea:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 800b7ee:	9301      	str	r3, [sp, #4]
    USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
  
  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);  
 800b7f0:	9b01      	ldr	r3, [sp, #4]
 800b7f2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b7f6:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay (10);                                /* See Note #1 */
 800b7fa:	200a      	movs	r0, #10
 800b7fc:	f7f5 f98a 	bl	8000b14 <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0); 
 800b800:	9b01      	ldr	r3, [sp, #4]
  return HAL_OK;
}
 800b802:	2000      	movs	r0, #0
  hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
    USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
  
  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);  
  HAL_Delay (10);                                /* See Note #1 */
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0); 
 800b804:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800b808:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  return HAL_OK;
}
 800b80c:	b002      	add	sp, #8
 800b80e:	bd10      	pop	{r4, pc}

0800b810 <USB_DriveVbus>:
  *           0 : VBUS Active 
  *           1 : VBUS Inactive
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DriveVbus (USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
 800b810:	b082      	sub	sp, #8
  __IO uint32_t hprt0;

  hprt0 = USBx_HPRT0;
 800b812:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
 800b816:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
 800b818:	9b01      	ldr	r3, [sp, #4]
 800b81a:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 800b81e:	9301      	str	r3, [sp, #4]
                         USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
  
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0 ) && (state == 1 ))
 800b820:	9b01      	ldr	r3, [sp, #4]
 800b822:	f413 5f80 	tst.w	r3, #4096	; 0x1000
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0); 
 800b826:	9b01      	ldr	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
  hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
                         USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
  
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0 ) && (state == 1 ))
 800b828:	d101      	bne.n	800b82e <USB_DriveVbus+0x1e>
 800b82a:	2901      	cmp	r1, #1
 800b82c:	d00a      	beq.n	800b844 <USB_DriveVbus+0x34>
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0); 
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0 ))
 800b82e:	04db      	lsls	r3, r3, #19
 800b830:	d505      	bpl.n	800b83e <USB_DriveVbus+0x2e>
 800b832:	b921      	cbnz	r1, 800b83e <USB_DriveVbus+0x2e>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0); 
 800b834:	9b01      	ldr	r3, [sp, #4]
 800b836:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800b83a:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
  }
  return HAL_OK; 
}
 800b83e:	2000      	movs	r0, #0
 800b840:	b002      	add	sp, #8
 800b842:	4770      	bx	lr
  hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
                         USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
  
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0 ) && (state == 1 ))
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0); 
 800b844:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800b848:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0 ))
 800b84c:	9b01      	ldr	r3, [sp, #4]
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0); 
  }
  return HAL_OK; 
}
 800b84e:	2000      	movs	r0, #0
 800b850:	b002      	add	sp, #8
 800b852:	4770      	bx	lr

0800b854 <USB_HostInit>:
  * @param  cfg: pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800b854:	b084      	sub	sp, #16
 800b856:	b570      	push	{r4, r5, r6, lr}
 800b858:	ad05      	add	r5, sp, #20
 800b85a:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  uint32_t i;
  
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0;
 800b85e:	2300      	movs	r3, #0
 800b860:	f8c0 3e00 	str.w	r3, [r0, #3584]	; 0xe00
    
  /*Activate VBUS Sensing B */
  USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 800b864:	6b83      	ldr	r3, [r0, #56]	; 0x38
  
  /* Disable the FS/LS support mode only */
  if((cfg.speed == USB_OTG_SPEED_FULL)&&
 800b866:	9a07      	ldr	r2, [sp, #28]
 800b868:	9906      	ldr	r1, [sp, #24]
  
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0;
    
  /*Activate VBUS Sensing B */
  USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 800b86a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800b86e:	6383      	str	r3, [r0, #56]	; 0x38
  
  /* Disable the FS/LS support mode only */
  if((cfg.speed == USB_OTG_SPEED_FULL)&&
 800b870:	2a03      	cmp	r2, #3
  * @param  cfg: pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800b872:	4604      	mov	r4, r0
  
  /* Disable the FS/LS support mode only */
  if((cfg.speed == USB_OTG_SPEED_FULL)&&
     (USBx != USB_OTG_FS))
  {
    USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS; 
 800b874:	f8d0 3400 	ldr.w	r3, [r0, #1024]	; 0x400
    
  /*Activate VBUS Sensing B */
  USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
  
  /* Disable the FS/LS support mode only */
  if((cfg.speed == USB_OTG_SPEED_FULL)&&
 800b878:	d046      	beq.n	800b908 <USB_HostInit+0xb4>
  {
    USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS; 
  }
  else
  {
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);  
 800b87a:	f023 0304 	bic.w	r3, r3, #4
 800b87e:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 800b882:	f44f 6384 	mov.w	r3, #1056	; 0x420
 800b886:	6123      	str	r3, [r4, #16]
 800b888:	4b23      	ldr	r3, [pc, #140]	; (800b918 <USB_HostInit+0xc4>)
 800b88a:	e001      	b.n	800b890 <USB_HostInit+0x3c>
 
  do
  {
    if (++count > 200000)
 800b88c:	3b01      	subs	r3, #1
 800b88e:	d002      	beq.n	800b896 <USB_HostInit+0x42>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800b890:	6922      	ldr	r2, [r4, #16]
 800b892:	0690      	lsls	r0, r2, #26
 800b894:	d4fa      	bmi.n	800b88c <USB_HostInit+0x38>
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800b896:	2310      	movs	r3, #16
 800b898:	6123      	str	r3, [r4, #16]
 800b89a:	4b1f      	ldr	r3, [pc, #124]	; (800b918 <USB_HostInit+0xc4>)
 800b89c:	e001      	b.n	800b8a2 <USB_HostInit+0x4e>
  
  do
  {
    if (++count > 200000)
 800b89e:	3b01      	subs	r3, #1
 800b8a0:	d002      	beq.n	800b8a8 <USB_HostInit+0x54>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 800b8a2:	6922      	ldr	r2, [r4, #16]
 800b8a4:	06d2      	lsls	r2, r2, #27
 800b8a6:	d4fa      	bmi.n	800b89e <USB_HostInit+0x4a>
  /* Make sure the FIFOs are flushed. */
  USB_FlushTxFifo(USBx, 0x10 ); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);

  /* Clear all pending HC Interrupts */
  for (i = 0; i < cfg.Host_channels; i++)
 800b8a8:	b161      	cbz	r1, 800b8c4 <USB_HostInit+0x70>
 800b8aa:	2200      	movs	r2, #0
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFF;
    USBx_HC(i)->HCINTMSK = 0;
 800b8ac:	4615      	mov	r5, r2
 800b8ae:	f504 63a0 	add.w	r3, r4, #1280	; 0x500
  USB_FlushRxFifo(USBx);

  /* Clear all pending HC Interrupts */
  for (i = 0; i < cfg.Host_channels; i++)
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFF;
 800b8b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  /* Make sure the FIFOs are flushed. */
  USB_FlushTxFifo(USBx, 0x10 ); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);

  /* Clear all pending HC Interrupts */
  for (i = 0; i < cfg.Host_channels; i++)
 800b8b6:	3201      	adds	r2, #1
 800b8b8:	428a      	cmp	r2, r1
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFF;
 800b8ba:	6098      	str	r0, [r3, #8]
    USBx_HC(i)->HCINTMSK = 0;
 800b8bc:	60dd      	str	r5, [r3, #12]
 800b8be:	f103 0320 	add.w	r3, r3, #32
  /* Make sure the FIFOs are flushed. */
  USB_FlushTxFifo(USBx, 0x10 ); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);

  /* Clear all pending HC Interrupts */
  for (i = 0; i < cfg.Host_channels; i++)
 800b8c2:	d1f8      	bne.n	800b8b6 <USB_HostInit+0x62>
    USBx_HC(i)->HCINT = 0xFFFFFFFF;
    USBx_HC(i)->HCINTMSK = 0;
  }
  
  /* Enable VBUS driving */
  USB_DriveVbus(USBx, 1);
 800b8c4:	2101      	movs	r1, #1
 800b8c6:	4620      	mov	r0, r4
 800b8c8:	f7ff ffa2 	bl	800b810 <USB_DriveVbus>
  
  HAL_Delay(200);
 800b8cc:	20c8      	movs	r0, #200	; 0xc8
 800b8ce:	f7f5 f921 	bl	8000b14 <HAL_Delay>
  USBx->GRXFSIZ  = (uint32_t )0x80; 
  USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x60 << 16)& USB_OTG_NPTXFD) | 0x80);
  USBx->HPTXFSIZ = (uint32_t )(((0x40 << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0);
  
  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 800b8d2:	9b08      	ldr	r3, [sp, #32]
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xFFFFFFFF;
  
  /* set Rx FIFO size */
  USBx->GRXFSIZ  = (uint32_t )0x80; 
  USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x60 << 16)& USB_OTG_NPTXFD) | 0x80);
 800b8d4:	4911      	ldr	r1, [pc, #68]	; (800b91c <USB_HostInit+0xc8>)
  USBx->HPTXFSIZ = (uint32_t )(((0x40 << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0);
 800b8d6:	4a12      	ldr	r2, [pc, #72]	; (800b920 <USB_HostInit+0xcc>)
  USB_DriveVbus(USBx, 1);
  
  HAL_Delay(200);
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0;
 800b8d8:	2600      	movs	r6, #0
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xFFFFFFFF;
 800b8da:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  
  /* set Rx FIFO size */
  USBx->GRXFSIZ  = (uint32_t )0x80; 
 800b8de:	2080      	movs	r0, #128	; 0x80
  USB_DriveVbus(USBx, 1);
  
  HAL_Delay(200);
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0;
 800b8e0:	61a6      	str	r6, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xFFFFFFFF;
 800b8e2:	6165      	str	r5, [r4, #20]
  
  /* set Rx FIFO size */
  USBx->GRXFSIZ  = (uint32_t )0x80; 
 800b8e4:	6260      	str	r0, [r4, #36]	; 0x24
  USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x60 << 16)& USB_OTG_NPTXFD) | 0x80);
 800b8e6:	62a1      	str	r1, [r4, #40]	; 0x28
  USBx->HPTXFSIZ = (uint32_t )(((0x40 << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0);
 800b8e8:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
  
  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 800b8ec:	b91b      	cbnz	r3, 800b8f6 <USB_HostInit+0xa2>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 800b8ee:	69a3      	ldr	r3, [r4, #24]
 800b8f0:	f043 0310 	orr.w	r3, r3, #16
 800b8f4:	61a3      	str	r3, [r4, #24]
  }

    /* Enable interrupts matching to the Host mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM |\
 800b8f6:	69a2      	ldr	r2, [r4, #24]
 800b8f8:	4b0a      	ldr	r3, [pc, #40]	; (800b924 <USB_HostInit+0xd0>)
 800b8fa:	4313      	orrs	r3, r2
 800b8fc:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_SOFM             |USB_OTG_GINTSTS_DISCINT|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);
  
  return HAL_OK;
}
 800b8fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800b902:	2000      	movs	r0, #0
 800b904:	b004      	add	sp, #16
 800b906:	4770      	bx	lr
    
  /*Activate VBUS Sensing B */
  USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
  
  /* Disable the FS/LS support mode only */
  if((cfg.speed == USB_OTG_SPEED_FULL)&&
 800b908:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 800b90c:	d0b5      	beq.n	800b87a <USB_HostInit+0x26>
     (USBx != USB_OTG_FS))
  {
    USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS; 
 800b90e:	f043 0304 	orr.w	r3, r3, #4
 800b912:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
 800b916:	e7b4      	b.n	800b882 <USB_HostInit+0x2e>
 800b918:	00030d40 	.word	0x00030d40
 800b91c:	00600080 	.word	0x00600080
 800b920:	004000e0 	.word	0x004000e0
 800b924:	a3200008 	.word	0xa3200008

0800b928 <USB_GetHostSpeed>:
  *            @arg USB_OTG_SPEED_HIGH: High speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed (USB_OTG_GlobalTypeDef *USBx)
{
 800b928:	b082      	sub	sp, #8
  __IO uint32_t hprt0;
  
  hprt0 = USBx_HPRT0;
 800b92a:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
 800b92e:	9301      	str	r3, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 800b930:	9801      	ldr	r0, [sp, #4]
}
 800b932:	f3c0 4041 	ubfx	r0, r0, #17, #2
 800b936:	b002      	add	sp, #8
 800b938:	4770      	bx	lr
 800b93a:	bf00      	nop

0800b93c <USB_GetCurrentFrame>:
  * @param  USBx: Selected device
  * @retval current frame number
*/
uint32_t USB_GetCurrentFrame (USB_OTG_GlobalTypeDef *USBx)
{
  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
 800b93c:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800b940:	6880      	ldr	r0, [r0, #8]
}
 800b942:	b280      	uxth	r0, r0
 800b944:	4770      	bx	lr
 800b946:	bf00      	nop

0800b948 <USB_HC_Init>:
                              uint8_t epnum,
                              uint8_t dev_address,
                              uint8_t speed,
                              uint8_t ep_type,
                              uint16_t mps)
{
 800b948:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b94c:	f500 64a0 	add.w	r4, r0, #1280	; 0x500
    
  /* Clear old interrupt conditions for this host channel. */
  USBx_HC(ch_num)->HCINT = 0xFFFFFFFF;
 800b950:	eb04 1441 	add.w	r4, r4, r1, lsl #5
                              uint8_t epnum,
                              uint8_t dev_address,
                              uint8_t speed,
                              uint8_t ep_type,
                              uint16_t mps)
{
 800b954:	f89d 6020 	ldrb.w	r6, [sp, #32]
 800b958:	f89d 701c 	ldrb.w	r7, [sp, #28]
 800b95c:	f8bd 5024 	ldrh.w	r5, [sp, #36]	; 0x24
    
  /* Clear old interrupt conditions for this host channel. */
  USBx_HC(ch_num)->HCINT = 0xFFFFFFFF;
 800b960:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
 800b964:	f8c4 e008 	str.w	lr, [r4, #8]
  
  /* Enable channel interrupts required for this transfer. */
  switch (ep_type) 
 800b968:	2e03      	cmp	r6, #3
 800b96a:	d865      	bhi.n	800ba38 <USB_HC_Init+0xf0>
 800b96c:	e8df f006 	tbb	[pc, r6]
 800b970:	02544454 	.word	0x02544454
                                USB_OTG_HCINTMSK_DTERRM |\
                                USB_OTG_HCINTMSK_NAKM   |\
                                USB_OTG_HCINTMSK_AHBERR |\
                                USB_OTG_HCINTMSK_FRMORM ;    
    
    if (epnum & 0x80) 
 800b974:	fa4f fc82 	sxtb.w	ip, r2
    }
    break;
    
  case EP_TYPE_INTR:
    
    USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
 800b978:	f240 6e9d 	movw	lr, #1693	; 0x69d
                                USB_OTG_HCINTMSK_DTERRM |\
                                USB_OTG_HCINTMSK_NAKM   |\
                                USB_OTG_HCINTMSK_AHBERR |\
                                USB_OTG_HCINTMSK_FRMORM ;    
    
    if (epnum & 0x80) 
 800b97c:	f1bc 0f00 	cmp.w	ip, #0
    }
    break;
    
  case EP_TYPE_INTR:
    
    USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
 800b980:	f8c4 e00c 	str.w	lr, [r4, #12]
                                USB_OTG_HCINTMSK_DTERRM |\
                                USB_OTG_HCINTMSK_NAKM   |\
                                USB_OTG_HCINTMSK_AHBERR |\
                                USB_OTG_HCINTMSK_FRMORM ;    
    
    if (epnum & 0x80) 
 800b984:	db51      	blt.n	800ba2a <USB_HC_Init+0xe2>
    }
    break;
  }
  
  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= (1 << ch_num);
 800b986:	f8d0 8418 	ldr.w	r8, [r0, #1048]	; 0x418
  
  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
  
  /* Program the HCCHAR register */
  USBx_HC(ch_num)->HCCHAR = (((dev_address << 22) & USB_OTG_HCCHAR_DAD)  |\
 800b98a:	059b      	lsls	r3, r3, #22
    }
    break;
  }
  
  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= (1 << ch_num);
 800b98c:	f04f 0901 	mov.w	r9, #1
  
  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
  
  /* Program the HCCHAR register */
  USBx_HC(ch_num)->HCCHAR = (((dev_address << 22) & USB_OTG_HCCHAR_DAD)  |\
 800b990:	f003 53fe 	and.w	r3, r3, #532676608	; 0x1fc00000
                             (((epnum & 0x7F)<< 11) & USB_OTG_HCCHAR_EPNUM)|\
 800b994:	02d2      	lsls	r2, r2, #11
                             ((((epnum & 0x80) == 0x80)<< 15) & USB_OTG_HCCHAR_EPDIR)|\
                             (((speed == HPRT0_PRTSPD_LOW_SPEED)<< 17) & USB_OTG_HCCHAR_LSDEV)|\
                             ((ep_type << 18) & USB_OTG_HCCHAR_EPTYP)|\
                             (mps & USB_OTG_HCCHAR_MPSIZ));
 800b996:	f3c5 050a 	ubfx	r5, r5, #0, #11
    }
    break;
  }
  
  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= (1 << ch_num);
 800b99a:	fa09 f901 	lsl.w	r9, r9, r1
  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
  
  /* Program the HCCHAR register */
  USBx_HC(ch_num)->HCCHAR = (((dev_address << 22) & USB_OTG_HCCHAR_DAD)  |\
                             (((epnum & 0x7F)<< 11) & USB_OTG_HCCHAR_EPNUM)|\
 800b99e:	f402 41f0 	and.w	r1, r2, #30720	; 0x7800
 800b9a2:	ea43 0205 	orr.w	r2, r3, r5
                             ((((epnum & 0x80) == 0x80)<< 15) & USB_OTG_HCCHAR_EPDIR)|\
                             (((speed == HPRT0_PRTSPD_LOW_SPEED)<< 17) & USB_OTG_HCCHAR_LSDEV)|\
                             ((ep_type << 18) & USB_OTG_HCCHAR_EPTYP)|\
 800b9a6:	04b3      	lsls	r3, r6, #18
    }
    break;
  }
  
  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= (1 << ch_num);
 800b9a8:	ea49 0508 	orr.w	r5, r9, r8
  /* Program the HCCHAR register */
  USBx_HC(ch_num)->HCCHAR = (((dev_address << 22) & USB_OTG_HCCHAR_DAD)  |\
                             (((epnum & 0x7F)<< 11) & USB_OTG_HCCHAR_EPNUM)|\
                             ((((epnum & 0x80) == 0x80)<< 15) & USB_OTG_HCCHAR_EPDIR)|\
                             (((speed == HPRT0_PRTSPD_LOW_SPEED)<< 17) & USB_OTG_HCCHAR_LSDEV)|\
                             ((ep_type << 18) & USB_OTG_HCCHAR_EPTYP)|\
 800b9ac:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
  
  /* Program the HCCHAR register */
  USBx_HC(ch_num)->HCCHAR = (((dev_address << 22) & USB_OTG_HCCHAR_DAD)  |\
                             (((epnum & 0x7F)<< 11) & USB_OTG_HCCHAR_EPNUM)|\
                             ((((epnum & 0x80) == 0x80)<< 15) & USB_OTG_HCCHAR_EPDIR)|\
 800b9b0:	f1bc 0f00 	cmp.w	ip, #0
    }
    break;
  }
  
  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= (1 << ch_num);
 800b9b4:	f8c0 5418 	str.w	r5, [r0, #1048]	; 0x418
 800b9b8:	ea42 0201 	orr.w	r2, r2, r1
 800b9bc:	ea42 0203 	orr.w	r2, r2, r3
  
  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 800b9c0:	6981      	ldr	r1, [r0, #24]
  
  /* Program the HCCHAR register */
  USBx_HC(ch_num)->HCCHAR = (((dev_address << 22) & USB_OTG_HCCHAR_DAD)  |\
                             (((epnum & 0x7F)<< 11) & USB_OTG_HCCHAR_EPNUM)|\
                             ((((epnum & 0x80) == 0x80)<< 15) & USB_OTG_HCCHAR_EPDIR)|\
 800b9c2:	bfb4      	ite	lt
 800b9c4:	f44f 4300 	movlt.w	r3, #32768	; 0x8000
 800b9c8:	2300      	movge	r3, #0
                             (((speed == HPRT0_PRTSPD_LOW_SPEED)<< 17) & USB_OTG_HCCHAR_LSDEV)|\
 800b9ca:	2f02      	cmp	r7, #2
 800b9cc:	ea42 0203 	orr.w	r2, r2, r3
 800b9d0:	bf0c      	ite	eq
 800b9d2:	f44f 3300 	moveq.w	r3, #131072	; 0x20000
 800b9d6:	2300      	movne	r3, #0
                             ((ep_type << 18) & USB_OTG_HCCHAR_EPTYP)|\
 800b9d8:	431a      	orrs	r2, r3
                             (mps & USB_OTG_HCCHAR_MPSIZ));
    
  if (ep_type == EP_TYPE_INTR)
 800b9da:	2e03      	cmp	r6, #3
  
  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= (1 << ch_num);
  
  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 800b9dc:	f041 7300 	orr.w	r3, r1, #33554432	; 0x2000000
 800b9e0:	6183      	str	r3, [r0, #24]
    }
    break;
  }
  
  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= (1 << ch_num);
 800b9e2:	f500 6e80 	add.w	lr, r0, #1024	; 0x400
  
  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
  
  /* Program the HCCHAR register */
  USBx_HC(ch_num)->HCCHAR = (((dev_address << 22) & USB_OTG_HCCHAR_DAD)  |\
 800b9e6:	6022      	str	r2, [r4, #0]
                             ((((epnum & 0x80) == 0x80)<< 15) & USB_OTG_HCCHAR_EPDIR)|\
                             (((speed == HPRT0_PRTSPD_LOW_SPEED)<< 17) & USB_OTG_HCCHAR_LSDEV)|\
                             ((ep_type << 18) & USB_OTG_HCCHAR_EPTYP)|\
                             (mps & USB_OTG_HCCHAR_MPSIZ));
    
  if (ep_type == EP_TYPE_INTR)
 800b9e8:	d103      	bne.n	800b9f2 <USB_HC_Init+0xaa>
  {
    USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
 800b9ea:	6823      	ldr	r3, [r4, #0]
 800b9ec:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800b9f0:	6023      	str	r3, [r4, #0]
  }

  return HAL_OK; 
}
 800b9f2:	2000      	movs	r0, #0
 800b9f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
                                USB_OTG_HCINTMSK_ACKM   |\
                                USB_OTG_HCINTMSK_AHBERR |\
                                USB_OTG_HCINTMSK_FRMORM ;   
    
    if (epnum & 0x80) 
 800b9f8:	fa4f fc82 	sxtb.w	ip, r2
    }
    
    break;
  case EP_TYPE_ISOC:
    
    USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
 800b9fc:	f240 2e25 	movw	lr, #549	; 0x225
                                USB_OTG_HCINTMSK_ACKM   |\
                                USB_OTG_HCINTMSK_AHBERR |\
                                USB_OTG_HCINTMSK_FRMORM ;   
    
    if (epnum & 0x80) 
 800ba00:	f1bc 0f00 	cmp.w	ip, #0
    }
    
    break;
  case EP_TYPE_ISOC:
    
    USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
 800ba04:	f8c4 e00c 	str.w	lr, [r4, #12]
                                USB_OTG_HCINTMSK_ACKM   |\
                                USB_OTG_HCINTMSK_AHBERR |\
                                USB_OTG_HCINTMSK_FRMORM ;   
    
    if (epnum & 0x80) 
 800ba08:	dabd      	bge.n	800b986 <USB_HC_Init+0x3e>
    {
      USBx_HC(ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);      
 800ba0a:	f8d4 e00c 	ldr.w	lr, [r4, #12]
 800ba0e:	f44e 7ec0 	orr.w	lr, lr, #384	; 0x180
 800ba12:	f8c4 e00c 	str.w	lr, [r4, #12]
 800ba16:	e7b6      	b.n	800b986 <USB_HC_Init+0x3e>
                                USB_OTG_HCINTMSK_TXERRM |\
                                USB_OTG_HCINTMSK_DTERRM |\
                                USB_OTG_HCINTMSK_AHBERR |\
                                USB_OTG_HCINTMSK_NAKM ;
 
    if (epnum & 0x80) 
 800ba18:	fa4f fc82 	sxtb.w	ip, r2
  switch (ep_type) 
  {
  case EP_TYPE_CTRL:
  case EP_TYPE_BULK:
    
    USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
 800ba1c:	f240 4e9d 	movw	lr, #1181	; 0x49d
                                USB_OTG_HCINTMSK_TXERRM |\
                                USB_OTG_HCINTMSK_DTERRM |\
                                USB_OTG_HCINTMSK_AHBERR |\
                                USB_OTG_HCINTMSK_NAKM ;
 
    if (epnum & 0x80) 
 800ba20:	f1bc 0f00 	cmp.w	ip, #0
  switch (ep_type) 
  {
  case EP_TYPE_CTRL:
  case EP_TYPE_BULK:
    
    USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
 800ba24:	f8c4 e00c 	str.w	lr, [r4, #12]
                                USB_OTG_HCINTMSK_TXERRM |\
                                USB_OTG_HCINTMSK_DTERRM |\
                                USB_OTG_HCINTMSK_AHBERR |\
                                USB_OTG_HCINTMSK_NAKM ;
 
    if (epnum & 0x80) 
 800ba28:	daad      	bge.n	800b986 <USB_HC_Init+0x3e>
                                USB_OTG_HCINTMSK_AHBERR |\
                                USB_OTG_HCINTMSK_FRMORM ;    
    
    if (epnum & 0x80) 
    {
      USBx_HC(ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 800ba2a:	f8d4 e00c 	ldr.w	lr, [r4, #12]
 800ba2e:	f44e 7e80 	orr.w	lr, lr, #256	; 0x100
 800ba32:	f8c4 e00c 	str.w	lr, [r4, #12]
 800ba36:	e7a6      	b.n	800b986 <USB_HC_Init+0x3e>
 800ba38:	fa4f fc82 	sxtb.w	ip, r2
 800ba3c:	e7a3      	b.n	800b986 <USB_HC_Init+0x3e>
 800ba3e:	bf00      	nop

0800ba40 <USB_HC_StartXfer>:
#pragma O0
#elif defined (__GNUC__) /*!< GNU Compiler */
#pragma GCC optimize ("O0")
#endif /* __CC_ARM */
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
{
 800ba40:	b590      	push	{r4, r7, lr}
 800ba42:	b08b      	sub	sp, #44	; 0x2c
 800ba44:	af02      	add	r7, sp, #8
 800ba46:	60f8      	str	r0, [r7, #12]
 800ba48:	60b9      	str	r1, [r7, #8]
 800ba4a:	4613      	mov	r3, r2
 800ba4c:	71fb      	strb	r3, [r7, #7]
  uint8_t  is_oddframe = 0; 
 800ba4e:	2300      	movs	r3, #0
 800ba50:	777b      	strb	r3, [r7, #29]
  uint16_t len_words = 0;   
 800ba52:	2300      	movs	r3, #0
 800ba54:	837b      	strh	r3, [r7, #26]
  uint16_t num_packets = 0;
 800ba56:	2300      	movs	r3, #0
 800ba58:	83fb      	strh	r3, [r7, #30]
  uint16_t max_hc_pkt_count = 256;
 800ba5a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ba5e:	833b      	strh	r3, [r7, #24]
  uint32_t tmpreg = 0;
 800ba60:	2300      	movs	r3, #0
 800ba62:	617b      	str	r3, [r7, #20]
    
  /* Compute the expected number of packets associated to the transfer */
  if (hc->xfer_len > 0)
 800ba64:	68bb      	ldr	r3, [r7, #8]
 800ba66:	691b      	ldr	r3, [r3, #16]
 800ba68:	2b00      	cmp	r3, #0
 800ba6a:	d019      	beq.n	800baa0 <USB_HC_StartXfer+0x60>
  {
    num_packets = (hc->xfer_len + hc->max_packet - 1) / hc->max_packet;
 800ba6c:	68bb      	ldr	r3, [r7, #8]
 800ba6e:	691b      	ldr	r3, [r3, #16]
 800ba70:	68ba      	ldr	r2, [r7, #8]
 800ba72:	8912      	ldrh	r2, [r2, #8]
 800ba74:	4413      	add	r3, r2
 800ba76:	3b01      	subs	r3, #1
 800ba78:	68ba      	ldr	r2, [r7, #8]
 800ba7a:	8912      	ldrh	r2, [r2, #8]
 800ba7c:	fbb3 f3f2 	udiv	r3, r3, r2
 800ba80:	83fb      	strh	r3, [r7, #30]
    
    if (num_packets > max_hc_pkt_count)
 800ba82:	8bfa      	ldrh	r2, [r7, #30]
 800ba84:	8b3b      	ldrh	r3, [r7, #24]
 800ba86:	429a      	cmp	r2, r3
 800ba88:	d90c      	bls.n	800baa4 <USB_HC_StartXfer+0x64>
    {
      num_packets = max_hc_pkt_count;
 800ba8a:	8b3b      	ldrh	r3, [r7, #24]
 800ba8c:	83fb      	strh	r3, [r7, #30]
      hc->xfer_len = num_packets * hc->max_packet;
 800ba8e:	8bfb      	ldrh	r3, [r7, #30]
 800ba90:	68ba      	ldr	r2, [r7, #8]
 800ba92:	8912      	ldrh	r2, [r2, #8]
 800ba94:	fb02 f303 	mul.w	r3, r2, r3
 800ba98:	461a      	mov	r2, r3
 800ba9a:	68bb      	ldr	r3, [r7, #8]
 800ba9c:	611a      	str	r2, [r3, #16]
 800ba9e:	e001      	b.n	800baa4 <USB_HC_StartXfer+0x64>
    }
  }
  else
  {
    num_packets = 1;
 800baa0:	2301      	movs	r3, #1
 800baa2:	83fb      	strh	r3, [r7, #30]
  }
  if (hc->ep_is_in)
 800baa4:	68bb      	ldr	r3, [r7, #8]
 800baa6:	78db      	ldrb	r3, [r3, #3]
 800baa8:	2b00      	cmp	r3, #0
 800baaa:	d007      	beq.n	800babc <USB_HC_StartXfer+0x7c>
  {
    hc->xfer_len = num_packets * hc->max_packet;
 800baac:	8bfb      	ldrh	r3, [r7, #30]
 800baae:	68ba      	ldr	r2, [r7, #8]
 800bab0:	8912      	ldrh	r2, [r2, #8]
 800bab2:	fb02 f303 	mul.w	r3, r2, r3
 800bab6:	461a      	mov	r2, r3
 800bab8:	68bb      	ldr	r3, [r7, #8]
 800baba:	611a      	str	r2, [r3, #16]
  }
  
  /* Initialize the HCTSIZn register */
  USBx_HC(hc->ch_num)->HCTSIZ = (((hc->xfer_len) & USB_OTG_HCTSIZ_XFRSIZ)) |\
 800babc:	68bb      	ldr	r3, [r7, #8]
 800babe:	785b      	ldrb	r3, [r3, #1]
 800bac0:	015a      	lsls	r2, r3, #5
 800bac2:	68fb      	ldr	r3, [r7, #12]
 800bac4:	4413      	add	r3, r2
 800bac6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800baca:	4619      	mov	r1, r3
 800bacc:	68bb      	ldr	r3, [r7, #8]
 800bace:	691b      	ldr	r3, [r3, #16]
 800bad0:	f3c3 0212 	ubfx	r2, r3, #0, #19
    ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
 800bad4:	8bfb      	ldrh	r3, [r7, #30]
 800bad6:	04db      	lsls	r3, r3, #19
 800bad8:	4618      	mov	r0, r3
 800bada:	4b5e      	ldr	r3, [pc, #376]	; (800bc54 <USB_HC_StartXfer+0x214>)
 800badc:	4003      	ands	r3, r0
  {
    hc->xfer_len = num_packets * hc->max_packet;
  }
  
  /* Initialize the HCTSIZn register */
  USBx_HC(hc->ch_num)->HCTSIZ = (((hc->xfer_len) & USB_OTG_HCTSIZ_XFRSIZ)) |\
 800bade:	431a      	orrs	r2, r3
    ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
      (((hc->data_pid) << 29) & USB_OTG_HCTSIZ_DPID);
 800bae0:	68bb      	ldr	r3, [r7, #8]
 800bae2:	7a9b      	ldrb	r3, [r3, #10]
 800bae4:	075b      	lsls	r3, r3, #29
 800bae6:	f003 43c0 	and.w	r3, r3, #1610612736	; 0x60000000
    hc->xfer_len = num_packets * hc->max_packet;
  }
  
  /* Initialize the HCTSIZn register */
  USBx_HC(hc->ch_num)->HCTSIZ = (((hc->xfer_len) & USB_OTG_HCTSIZ_XFRSIZ)) |\
    ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
 800baea:	4313      	orrs	r3, r2
  {
    hc->xfer_len = num_packets * hc->max_packet;
  }
  
  /* Initialize the HCTSIZn register */
  USBx_HC(hc->ch_num)->HCTSIZ = (((hc->xfer_len) & USB_OTG_HCTSIZ_XFRSIZ)) |\
 800baec:	610b      	str	r3, [r1, #16]
    ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
      (((hc->data_pid) << 29) & USB_OTG_HCTSIZ_DPID);
  
  if (dma)
 800baee:	79fb      	ldrb	r3, [r7, #7]
 800baf0:	2b00      	cmp	r3, #0
 800baf2:	d00a      	beq.n	800bb0a <USB_HC_StartXfer+0xca>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(hc->ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
 800baf4:	68bb      	ldr	r3, [r7, #8]
 800baf6:	785b      	ldrb	r3, [r3, #1]
 800baf8:	015a      	lsls	r2, r3, #5
 800bafa:	68fb      	ldr	r3, [r7, #12]
 800bafc:	4413      	add	r3, r2
 800bafe:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bb02:	461a      	mov	r2, r3
 800bb04:	68bb      	ldr	r3, [r7, #8]
 800bb06:	68db      	ldr	r3, [r3, #12]
 800bb08:	6153      	str	r3, [r2, #20]
  }
  
  is_oddframe = (USBx_HOST->HFNUM & 0x01) ? 0 : 1;
 800bb0a:	68fb      	ldr	r3, [r7, #12]
 800bb0c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800bb10:	689b      	ldr	r3, [r3, #8]
 800bb12:	f003 0301 	and.w	r3, r3, #1
 800bb16:	2b00      	cmp	r3, #0
 800bb18:	bf0c      	ite	eq
 800bb1a:	2301      	moveq	r3, #1
 800bb1c:	2300      	movne	r3, #0
 800bb1e:	b2db      	uxtb	r3, r3
 800bb20:	777b      	strb	r3, [r7, #29]
  USBx_HC(hc->ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 800bb22:	68bb      	ldr	r3, [r7, #8]
 800bb24:	785b      	ldrb	r3, [r3, #1]
 800bb26:	015a      	lsls	r2, r3, #5
 800bb28:	68fb      	ldr	r3, [r7, #12]
 800bb2a:	4413      	add	r3, r2
 800bb2c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bb30:	4619      	mov	r1, r3
 800bb32:	68bb      	ldr	r3, [r7, #8]
 800bb34:	785b      	ldrb	r3, [r3, #1]
 800bb36:	015a      	lsls	r2, r3, #5
 800bb38:	68fb      	ldr	r3, [r7, #12]
 800bb3a:	4413      	add	r3, r2
 800bb3c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bb40:	681b      	ldr	r3, [r3, #0]
 800bb42:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 800bb46:	600b      	str	r3, [r1, #0]
  USBx_HC(hc->ch_num)->HCCHAR |= (is_oddframe << 29);
 800bb48:	68bb      	ldr	r3, [r7, #8]
 800bb4a:	785b      	ldrb	r3, [r3, #1]
 800bb4c:	015a      	lsls	r2, r3, #5
 800bb4e:	68fb      	ldr	r3, [r7, #12]
 800bb50:	4413      	add	r3, r2
 800bb52:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bb56:	4619      	mov	r1, r3
 800bb58:	68bb      	ldr	r3, [r7, #8]
 800bb5a:	785b      	ldrb	r3, [r3, #1]
 800bb5c:	015a      	lsls	r2, r3, #5
 800bb5e:	68fb      	ldr	r3, [r7, #12]
 800bb60:	4413      	add	r3, r2
 800bb62:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bb66:	681b      	ldr	r3, [r3, #0]
 800bb68:	7f7a      	ldrb	r2, [r7, #29]
 800bb6a:	0752      	lsls	r2, r2, #29
 800bb6c:	4313      	orrs	r3, r2
 800bb6e:	600b      	str	r3, [r1, #0]
  
  /* Set host channel enable */
  tmpreg = USBx_HC(hc->ch_num)->HCCHAR;
 800bb70:	68bb      	ldr	r3, [r7, #8]
 800bb72:	785b      	ldrb	r3, [r3, #1]
 800bb74:	015a      	lsls	r2, r3, #5
 800bb76:	68fb      	ldr	r3, [r7, #12]
 800bb78:	4413      	add	r3, r2
 800bb7a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bb7e:	681b      	ldr	r3, [r3, #0]
 800bb80:	617b      	str	r3, [r7, #20]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800bb82:	697b      	ldr	r3, [r7, #20]
 800bb84:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800bb88:	617b      	str	r3, [r7, #20]
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 800bb8a:	697b      	ldr	r3, [r7, #20]
 800bb8c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800bb90:	617b      	str	r3, [r7, #20]
  USBx_HC(hc->ch_num)->HCCHAR = tmpreg;
 800bb92:	68bb      	ldr	r3, [r7, #8]
 800bb94:	785b      	ldrb	r3, [r3, #1]
 800bb96:	015a      	lsls	r2, r3, #5
 800bb98:	68fb      	ldr	r3, [r7, #12]
 800bb9a:	4413      	add	r3, r2
 800bb9c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bba0:	461a      	mov	r2, r3
 800bba2:	697b      	ldr	r3, [r7, #20]
 800bba4:	6013      	str	r3, [r2, #0]
  
  if (dma == 0) /* Slave mode */
 800bba6:	79fb      	ldrb	r3, [r7, #7]
 800bba8:	2b00      	cmp	r3, #0
 800bbaa:	d14d      	bne.n	800bc48 <USB_HC_StartXfer+0x208>
  {  
    if((hc->ep_is_in == 0) && (hc->xfer_len > 0))
 800bbac:	68bb      	ldr	r3, [r7, #8]
 800bbae:	78db      	ldrb	r3, [r3, #3]
 800bbb0:	2b00      	cmp	r3, #0
 800bbb2:	d149      	bne.n	800bc48 <USB_HC_StartXfer+0x208>
 800bbb4:	68bb      	ldr	r3, [r7, #8]
 800bbb6:	691b      	ldr	r3, [r3, #16]
 800bbb8:	2b00      	cmp	r3, #0
 800bbba:	d045      	beq.n	800bc48 <USB_HC_StartXfer+0x208>
    {
      switch(hc->ep_type) 
 800bbbc:	68bb      	ldr	r3, [r7, #8]
 800bbbe:	79db      	ldrb	r3, [r3, #7]
 800bbc0:	2b03      	cmp	r3, #3
 800bbc2:	d833      	bhi.n	800bc2c <USB_HC_StartXfer+0x1ec>
 800bbc4:	a201      	add	r2, pc, #4	; (adr r2, 800bbcc <USB_HC_StartXfer+0x18c>)
 800bbc6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bbca:	bf00      	nop
 800bbcc:	0800bbdd 	.word	0x0800bbdd
 800bbd0:	0800bc03 	.word	0x0800bc03
 800bbd4:	0800bbdd 	.word	0x0800bbdd
 800bbd8:	0800bc03 	.word	0x0800bc03
      {
        /* Non periodic transfer */
      case EP_TYPE_CTRL:
      case EP_TYPE_BULK:
        
        len_words = (hc->xfer_len + 3) / 4;
 800bbdc:	68bb      	ldr	r3, [r7, #8]
 800bbde:	691b      	ldr	r3, [r3, #16]
 800bbe0:	3303      	adds	r3, #3
 800bbe2:	089b      	lsrs	r3, r3, #2
 800bbe4:	837b      	strh	r3, [r7, #26]
        
        /* check if there is enough space in FIFO space */
        if(len_words > (USBx->HNPTXSTS & 0xFFFF))
 800bbe6:	8b7a      	ldrh	r2, [r7, #26]
 800bbe8:	68fb      	ldr	r3, [r7, #12]
 800bbea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bbec:	b29b      	uxth	r3, r3
 800bbee:	429a      	cmp	r2, r3
 800bbf0:	d906      	bls.n	800bc00 <USB_HC_StartXfer+0x1c0>
        {
          /* need to process data in nptxfempty interrupt */
          USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
 800bbf2:	68fb      	ldr	r3, [r7, #12]
 800bbf4:	699b      	ldr	r3, [r3, #24]
 800bbf6:	f043 0220 	orr.w	r2, r3, #32
 800bbfa:	68fb      	ldr	r3, [r7, #12]
 800bbfc:	619a      	str	r2, [r3, #24]
        }
        break;
 800bbfe:	e016      	b.n	800bc2e <USB_HC_StartXfer+0x1ee>
 800bc00:	e015      	b.n	800bc2e <USB_HC_StartXfer+0x1ee>
        /* Periodic transfer */
      case EP_TYPE_INTR:
      case EP_TYPE_ISOC:
        len_words = (hc->xfer_len + 3) / 4;
 800bc02:	68bb      	ldr	r3, [r7, #8]
 800bc04:	691b      	ldr	r3, [r3, #16]
 800bc06:	3303      	adds	r3, #3
 800bc08:	089b      	lsrs	r3, r3, #2
 800bc0a:	837b      	strh	r3, [r7, #26]
        /* check if there is enough space in FIFO space */
        if(len_words > (USBx_HOST->HPTXSTS & 0xFFFF)) /* split the transfer */
 800bc0c:	8b7a      	ldrh	r2, [r7, #26]
 800bc0e:	68fb      	ldr	r3, [r7, #12]
 800bc10:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800bc14:	691b      	ldr	r3, [r3, #16]
 800bc16:	b29b      	uxth	r3, r3
 800bc18:	429a      	cmp	r2, r3
 800bc1a:	d906      	bls.n	800bc2a <USB_HC_StartXfer+0x1ea>
        {
          /* need to process data in ptxfempty interrupt */
          USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;          
 800bc1c:	68fb      	ldr	r3, [r7, #12]
 800bc1e:	699b      	ldr	r3, [r3, #24]
 800bc20:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
 800bc24:	68fb      	ldr	r3, [r7, #12]
 800bc26:	619a      	str	r2, [r3, #24]
        }
        break;
 800bc28:	e001      	b.n	800bc2e <USB_HC_StartXfer+0x1ee>
 800bc2a:	e000      	b.n	800bc2e <USB_HC_StartXfer+0x1ee>
        
      default:
        break;
 800bc2c:	bf00      	nop
      }
      
      /* Write packet into the Tx FIFO. */
      USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, hc->xfer_len, 0);
 800bc2e:	68bb      	ldr	r3, [r7, #8]
 800bc30:	68d9      	ldr	r1, [r3, #12]
 800bc32:	68bb      	ldr	r3, [r7, #8]
 800bc34:	785a      	ldrb	r2, [r3, #1]
 800bc36:	68bb      	ldr	r3, [r7, #8]
 800bc38:	691b      	ldr	r3, [r3, #16]
 800bc3a:	b29c      	uxth	r4, r3
 800bc3c:	2300      	movs	r3, #0
 800bc3e:	9300      	str	r3, [sp, #0]
 800bc40:	68f8      	ldr	r0, [r7, #12]
 800bc42:	4623      	mov	r3, r4
 800bc44:	f7ff fc74 	bl	800b530 <USB_WritePacket>
    }
  }
  
  return HAL_OK;
 800bc48:	2300      	movs	r3, #0
}
 800bc4a:	4618      	mov	r0, r3
 800bc4c:	3724      	adds	r7, #36	; 0x24
 800bc4e:	46bd      	mov	sp, r7
 800bc50:	bd90      	pop	{r4, r7, pc}
 800bc52:	bf00      	nop
 800bc54:	1ff80000 	.word	0x1ff80000

0800bc58 <USB_HC_ReadInterrupt>:
  * @brief Read all host channel interrupts status
  * @param  USBx: Selected device
  * @retval HAL state
  */
uint32_t USB_HC_ReadInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
 800bc58:	b480      	push	{r7}
 800bc5a:	b083      	sub	sp, #12
 800bc5c:	af00      	add	r7, sp, #0
 800bc5e:	6078      	str	r0, [r7, #4]
  return ((USBx_HOST->HAINT) & 0xFFFF);
 800bc60:	687b      	ldr	r3, [r7, #4]
 800bc62:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800bc66:	695b      	ldr	r3, [r3, #20]
 800bc68:	b29b      	uxth	r3, r3
}
 800bc6a:	4618      	mov	r0, r3
 800bc6c:	370c      	adds	r7, #12
 800bc6e:	46bd      	mov	sp, r7
 800bc70:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc74:	4770      	bx	lr
 800bc76:	bf00      	nop

0800bc78 <USB_HC_Halt>:
  * @param  hc_num: Host Channel number
  *         This parameter can be a value from 1 to 15
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx , uint8_t hc_num)
{
 800bc78:	b480      	push	{r7}
 800bc7a:	b085      	sub	sp, #20
 800bc7c:	af00      	add	r7, sp, #0
 800bc7e:	6078      	str	r0, [r7, #4]
 800bc80:	460b      	mov	r3, r1
 800bc82:	70fb      	strb	r3, [r7, #3]
  uint32_t count = 0;
 800bc84:	2300      	movs	r3, #0
 800bc86:	60fb      	str	r3, [r7, #12]
  
  /* Check for space in the request queue to issue the halt. */
  if (((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_CTRL << 18)) || ((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_BULK << 18)))
 800bc88:	78fb      	ldrb	r3, [r7, #3]
 800bc8a:	015a      	lsls	r2, r3, #5
 800bc8c:	687b      	ldr	r3, [r7, #4]
 800bc8e:	4413      	add	r3, r2
 800bc90:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bc94:	681b      	ldr	r3, [r3, #0]
 800bc96:	78fb      	ldrb	r3, [r7, #3]
 800bc98:	015a      	lsls	r2, r3, #5
 800bc9a:	687b      	ldr	r3, [r7, #4]
 800bc9c:	4413      	add	r3, r2
 800bc9e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bca2:	681b      	ldr	r3, [r3, #0]
 800bca4:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800bca8:	2b00      	cmp	r3, #0
 800bcaa:	d06e      	beq.n	800bd8a <USB_HC_Halt+0x112>
  {
    USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 800bcac:	78fb      	ldrb	r3, [r7, #3]
 800bcae:	015a      	lsls	r2, r3, #5
 800bcb0:	687b      	ldr	r3, [r7, #4]
 800bcb2:	4413      	add	r3, r2
 800bcb4:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bcb8:	4619      	mov	r1, r3
 800bcba:	78fb      	ldrb	r3, [r7, #3]
 800bcbc:	015a      	lsls	r2, r3, #5
 800bcbe:	687b      	ldr	r3, [r7, #4]
 800bcc0:	4413      	add	r3, r2
 800bcc2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bcc6:	681b      	ldr	r3, [r3, #0]
 800bcc8:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800bccc:	600b      	str	r3, [r1, #0]
    
    if ((USBx->HNPTXSTS & 0xFFFF) == 0)
 800bcce:	687b      	ldr	r3, [r7, #4]
 800bcd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bcd2:	b29b      	uxth	r3, r3
 800bcd4:	2b00      	cmp	r3, #0
 800bcd6:	d145      	bne.n	800bd64 <USB_HC_Halt+0xec>
    {
      USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800bcd8:	78fb      	ldrb	r3, [r7, #3]
 800bcda:	015a      	lsls	r2, r3, #5
 800bcdc:	687b      	ldr	r3, [r7, #4]
 800bcde:	4413      	add	r3, r2
 800bce0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bce4:	4619      	mov	r1, r3
 800bce6:	78fb      	ldrb	r3, [r7, #3]
 800bce8:	015a      	lsls	r2, r3, #5
 800bcea:	687b      	ldr	r3, [r7, #4]
 800bcec:	4413      	add	r3, r2
 800bcee:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bcf2:	681b      	ldr	r3, [r3, #0]
 800bcf4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800bcf8:	600b      	str	r3, [r1, #0]
      USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  
 800bcfa:	78fb      	ldrb	r3, [r7, #3]
 800bcfc:	015a      	lsls	r2, r3, #5
 800bcfe:	687b      	ldr	r3, [r7, #4]
 800bd00:	4413      	add	r3, r2
 800bd02:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bd06:	4619      	mov	r1, r3
 800bd08:	78fb      	ldrb	r3, [r7, #3]
 800bd0a:	015a      	lsls	r2, r3, #5
 800bd0c:	687b      	ldr	r3, [r7, #4]
 800bd0e:	4413      	add	r3, r2
 800bd10:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bd14:	681b      	ldr	r3, [r3, #0]
 800bd16:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800bd1a:	600b      	str	r3, [r1, #0]
      USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 800bd1c:	78fb      	ldrb	r3, [r7, #3]
 800bd1e:	015a      	lsls	r2, r3, #5
 800bd20:	687b      	ldr	r3, [r7, #4]
 800bd22:	4413      	add	r3, r2
 800bd24:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bd28:	4619      	mov	r1, r3
 800bd2a:	78fb      	ldrb	r3, [r7, #3]
 800bd2c:	015a      	lsls	r2, r3, #5
 800bd2e:	687b      	ldr	r3, [r7, #4]
 800bd30:	4413      	add	r3, r2
 800bd32:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bd36:	681b      	ldr	r3, [r3, #0]
 800bd38:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800bd3c:	600b      	str	r3, [r1, #0]
      do 
      {
        if (++count > 1000) 
 800bd3e:	68fb      	ldr	r3, [r7, #12]
 800bd40:	3301      	adds	r3, #1
 800bd42:	60fb      	str	r3, [r7, #12]
 800bd44:	68fb      	ldr	r3, [r7, #12]
 800bd46:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800bd4a:	d901      	bls.n	800bd50 <USB_HC_Halt+0xd8>
        {
          break;
 800bd4c:	bf00      	nop
 800bd4e:	e01b      	b.n	800bd88 <USB_HC_Halt+0x110>
        }
      } 
      while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     
 800bd50:	78fb      	ldrb	r3, [r7, #3]
 800bd52:	015a      	lsls	r2, r3, #5
 800bd54:	687b      	ldr	r3, [r7, #4]
 800bd56:	4413      	add	r3, r2
 800bd58:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bd5c:	681b      	ldr	r3, [r3, #0]
 800bd5e:	2b00      	cmp	r3, #0
 800bd60:	dbed      	blt.n	800bd3e <USB_HC_Halt+0xc6>
 800bd62:	e011      	b.n	800bd88 <USB_HC_Halt+0x110>
    }
    else
    {
      USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
 800bd64:	78fb      	ldrb	r3, [r7, #3]
 800bd66:	015a      	lsls	r2, r3, #5
 800bd68:	687b      	ldr	r3, [r7, #4]
 800bd6a:	4413      	add	r3, r2
 800bd6c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bd70:	4619      	mov	r1, r3
 800bd72:	78fb      	ldrb	r3, [r7, #3]
 800bd74:	015a      	lsls	r2, r3, #5
 800bd76:	687b      	ldr	r3, [r7, #4]
 800bd78:	4413      	add	r3, r2
 800bd7a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bd7e:	681b      	ldr	r3, [r3, #0]
 800bd80:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800bd84:	600b      	str	r3, [r1, #0]
  /* Check for space in the request queue to issue the halt. */
  if (((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_CTRL << 18)) || ((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_BULK << 18)))
  {
    USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
    
    if ((USBx->HNPTXSTS & 0xFFFF) == 0)
 800bd86:	e06f      	b.n	800be68 <USB_HC_Halt+0x1f0>
 800bd88:	e06e      	b.n	800be68 <USB_HC_Halt+0x1f0>
      USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
    }
  }
  else
  {
    USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 800bd8a:	78fb      	ldrb	r3, [r7, #3]
 800bd8c:	015a      	lsls	r2, r3, #5
 800bd8e:	687b      	ldr	r3, [r7, #4]
 800bd90:	4413      	add	r3, r2
 800bd92:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bd96:	4619      	mov	r1, r3
 800bd98:	78fb      	ldrb	r3, [r7, #3]
 800bd9a:	015a      	lsls	r2, r3, #5
 800bd9c:	687b      	ldr	r3, [r7, #4]
 800bd9e:	4413      	add	r3, r2
 800bda0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bda4:	681b      	ldr	r3, [r3, #0]
 800bda6:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800bdaa:	600b      	str	r3, [r1, #0]
    
    if ((USBx_HOST->HPTXSTS & 0xFFFF) == 0)
 800bdac:	687b      	ldr	r3, [r7, #4]
 800bdae:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800bdb2:	691b      	ldr	r3, [r3, #16]
 800bdb4:	b29b      	uxth	r3, r3
 800bdb6:	2b00      	cmp	r3, #0
 800bdb8:	d145      	bne.n	800be46 <USB_HC_Halt+0x1ce>
    {
      USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800bdba:	78fb      	ldrb	r3, [r7, #3]
 800bdbc:	015a      	lsls	r2, r3, #5
 800bdbe:	687b      	ldr	r3, [r7, #4]
 800bdc0:	4413      	add	r3, r2
 800bdc2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bdc6:	4619      	mov	r1, r3
 800bdc8:	78fb      	ldrb	r3, [r7, #3]
 800bdca:	015a      	lsls	r2, r3, #5
 800bdcc:	687b      	ldr	r3, [r7, #4]
 800bdce:	4413      	add	r3, r2
 800bdd0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bdd4:	681b      	ldr	r3, [r3, #0]
 800bdd6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800bdda:	600b      	str	r3, [r1, #0]
      USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  
 800bddc:	78fb      	ldrb	r3, [r7, #3]
 800bdde:	015a      	lsls	r2, r3, #5
 800bde0:	687b      	ldr	r3, [r7, #4]
 800bde2:	4413      	add	r3, r2
 800bde4:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bde8:	4619      	mov	r1, r3
 800bdea:	78fb      	ldrb	r3, [r7, #3]
 800bdec:	015a      	lsls	r2, r3, #5
 800bdee:	687b      	ldr	r3, [r7, #4]
 800bdf0:	4413      	add	r3, r2
 800bdf2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bdf6:	681b      	ldr	r3, [r3, #0]
 800bdf8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800bdfc:	600b      	str	r3, [r1, #0]
      USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 800bdfe:	78fb      	ldrb	r3, [r7, #3]
 800be00:	015a      	lsls	r2, r3, #5
 800be02:	687b      	ldr	r3, [r7, #4]
 800be04:	4413      	add	r3, r2
 800be06:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800be0a:	4619      	mov	r1, r3
 800be0c:	78fb      	ldrb	r3, [r7, #3]
 800be0e:	015a      	lsls	r2, r3, #5
 800be10:	687b      	ldr	r3, [r7, #4]
 800be12:	4413      	add	r3, r2
 800be14:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800be18:	681b      	ldr	r3, [r3, #0]
 800be1a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800be1e:	600b      	str	r3, [r1, #0]
      do 
      {
        if (++count > 1000) 
 800be20:	68fb      	ldr	r3, [r7, #12]
 800be22:	3301      	adds	r3, #1
 800be24:	60fb      	str	r3, [r7, #12]
 800be26:	68fb      	ldr	r3, [r7, #12]
 800be28:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800be2c:	d901      	bls.n	800be32 <USB_HC_Halt+0x1ba>
        {
          break;
 800be2e:	bf00      	nop
 800be30:	e01a      	b.n	800be68 <USB_HC_Halt+0x1f0>
        }
      } 
      while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     
 800be32:	78fb      	ldrb	r3, [r7, #3]
 800be34:	015a      	lsls	r2, r3, #5
 800be36:	687b      	ldr	r3, [r7, #4]
 800be38:	4413      	add	r3, r2
 800be3a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800be3e:	681b      	ldr	r3, [r3, #0]
 800be40:	2b00      	cmp	r3, #0
 800be42:	dbed      	blt.n	800be20 <USB_HC_Halt+0x1a8>
 800be44:	e010      	b.n	800be68 <USB_HC_Halt+0x1f0>
    }
    else
    {
       USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
 800be46:	78fb      	ldrb	r3, [r7, #3]
 800be48:	015a      	lsls	r2, r3, #5
 800be4a:	687b      	ldr	r3, [r7, #4]
 800be4c:	4413      	add	r3, r2
 800be4e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800be52:	4619      	mov	r1, r3
 800be54:	78fb      	ldrb	r3, [r7, #3]
 800be56:	015a      	lsls	r2, r3, #5
 800be58:	687b      	ldr	r3, [r7, #4]
 800be5a:	4413      	add	r3, r2
 800be5c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800be60:	681b      	ldr	r3, [r3, #0]
 800be62:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800be66:	600b      	str	r3, [r1, #0]
    }
  }
  
  return HAL_OK;
 800be68:	2300      	movs	r3, #0
}
 800be6a:	4618      	mov	r0, r3
 800be6c:	3714      	adds	r7, #20
 800be6e:	46bd      	mov	sp, r7
 800be70:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be74:	4770      	bx	lr
 800be76:	bf00      	nop

0800be78 <USB_DoPing>:
  * @param  hc_num: Host Channel number
  *         This parameter can be a value from 1 to 15
  * @retval HAL state
  */
HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx , uint8_t ch_num)
{
 800be78:	b480      	push	{r7}
 800be7a:	b085      	sub	sp, #20
 800be7c:	af00      	add	r7, sp, #0
 800be7e:	6078      	str	r0, [r7, #4]
 800be80:	460b      	mov	r3, r1
 800be82:	70fb      	strb	r3, [r7, #3]
  uint8_t  num_packets = 1;
 800be84:	2301      	movs	r3, #1
 800be86:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpreg = 0;
 800be88:	2300      	movs	r3, #0
 800be8a:	60bb      	str	r3, [r7, #8]
  
  USBx_HC(ch_num)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
 800be8c:	78fb      	ldrb	r3, [r7, #3]
 800be8e:	015a      	lsls	r2, r3, #5
 800be90:	687b      	ldr	r3, [r7, #4]
 800be92:	4413      	add	r3, r2
 800be94:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800be98:	461a      	mov	r2, r3
 800be9a:	7bfb      	ldrb	r3, [r7, #15]
 800be9c:	04db      	lsls	r3, r3, #19
 800be9e:	4619      	mov	r1, r3
 800bea0:	4b12      	ldr	r3, [pc, #72]	; (800beec <USB_DoPing+0x74>)
 800bea2:	400b      	ands	r3, r1
 800bea4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800bea8:	6113      	str	r3, [r2, #16]
                                USB_OTG_HCTSIZ_DOPING;
  
  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 800beaa:	78fb      	ldrb	r3, [r7, #3]
 800beac:	015a      	lsls	r2, r3, #5
 800beae:	687b      	ldr	r3, [r7, #4]
 800beb0:	4413      	add	r3, r2
 800beb2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800beb6:	681b      	ldr	r3, [r3, #0]
 800beb8:	60bb      	str	r3, [r7, #8]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800beba:	68bb      	ldr	r3, [r7, #8]
 800bebc:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800bec0:	60bb      	str	r3, [r7, #8]
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 800bec2:	68bb      	ldr	r3, [r7, #8]
 800bec4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800bec8:	60bb      	str	r3, [r7, #8]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 800beca:	78fb      	ldrb	r3, [r7, #3]
 800becc:	015a      	lsls	r2, r3, #5
 800bece:	687b      	ldr	r3, [r7, #4]
 800bed0:	4413      	add	r3, r2
 800bed2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bed6:	461a      	mov	r2, r3
 800bed8:	68bb      	ldr	r3, [r7, #8]
 800beda:	6013      	str	r3, [r2, #0]
  
  return HAL_OK;  
 800bedc:	2300      	movs	r3, #0
}
 800bede:	4618      	mov	r0, r3
 800bee0:	3714      	adds	r7, #20
 800bee2:	46bd      	mov	sp, r7
 800bee4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bee8:	4770      	bx	lr
 800beea:	bf00      	nop
 800beec:	1ff80000 	.word	0x1ff80000

0800bef0 <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx: Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
 800bef0:	b580      	push	{r7, lr}
 800bef2:	b086      	sub	sp, #24
 800bef4:	af00      	add	r7, sp, #0
 800bef6:	6078      	str	r0, [r7, #4]
  uint8_t i;
  uint32_t count = 0;
 800bef8:	2300      	movs	r3, #0
 800befa:	613b      	str	r3, [r7, #16]
  uint32_t value;
  
  USB_DisableGlobalInt(USBx);
 800befc:	6878      	ldr	r0, [r7, #4]
 800befe:	f7fe fee7 	bl	800acd0 <USB_DisableGlobalInt>
  
    /* Flush FIFO */
  USB_FlushTxFifo(USBx, 0x10);
 800bf02:	6878      	ldr	r0, [r7, #4]
 800bf04:	2110      	movs	r1, #16
 800bf06:	f7fe ffb5 	bl	800ae74 <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 800bf0a:	6878      	ldr	r0, [r7, #4]
 800bf0c:	f7fe ffc4 	bl	800ae98 <USB_FlushRxFifo>
  
  /* Flush out any leftover queued requests. */
  for (i = 0; i <= 15; i++)
 800bf10:	2300      	movs	r3, #0
 800bf12:	75fb      	strb	r3, [r7, #23]
 800bf14:	e01f      	b.n	800bf56 <USB_StopHost+0x66>
  {   

    value = USBx_HC(i)->HCCHAR ;
 800bf16:	7dfb      	ldrb	r3, [r7, #23]
 800bf18:	015a      	lsls	r2, r3, #5
 800bf1a:	687b      	ldr	r3, [r7, #4]
 800bf1c:	4413      	add	r3, r2
 800bf1e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bf22:	681b      	ldr	r3, [r3, #0]
 800bf24:	60fb      	str	r3, [r7, #12]
    value |=  USB_OTG_HCCHAR_CHDIS;
 800bf26:	68fb      	ldr	r3, [r7, #12]
 800bf28:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800bf2c:	60fb      	str	r3, [r7, #12]
    value &= ~USB_OTG_HCCHAR_CHENA;  
 800bf2e:	68fb      	ldr	r3, [r7, #12]
 800bf30:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800bf34:	60fb      	str	r3, [r7, #12]
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800bf36:	68fb      	ldr	r3, [r7, #12]
 800bf38:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800bf3c:	60fb      	str	r3, [r7, #12]
    USBx_HC(i)->HCCHAR = value;
 800bf3e:	7dfb      	ldrb	r3, [r7, #23]
 800bf40:	015a      	lsls	r2, r3, #5
 800bf42:	687b      	ldr	r3, [r7, #4]
 800bf44:	4413      	add	r3, r2
 800bf46:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bf4a:	461a      	mov	r2, r3
 800bf4c:	68fb      	ldr	r3, [r7, #12]
 800bf4e:	6013      	str	r3, [r2, #0]
    /* Flush FIFO */
  USB_FlushTxFifo(USBx, 0x10);
  USB_FlushRxFifo(USBx);
  
  /* Flush out any leftover queued requests. */
  for (i = 0; i <= 15; i++)
 800bf50:	7dfb      	ldrb	r3, [r7, #23]
 800bf52:	3301      	adds	r3, #1
 800bf54:	75fb      	strb	r3, [r7, #23]
 800bf56:	7dfb      	ldrb	r3, [r7, #23]
 800bf58:	2b0f      	cmp	r3, #15
 800bf5a:	d9dc      	bls.n	800bf16 <USB_StopHost+0x26>
    value &= ~USB_OTG_HCCHAR_EPDIR;
    USBx_HC(i)->HCCHAR = value;
  }
  
  /* Halt all channels to put them into a known state. */  
  for (i = 0; i <= 15; i++)
 800bf5c:	2300      	movs	r3, #0
 800bf5e:	75fb      	strb	r3, [r7, #23]
 800bf60:	e030      	b.n	800bfc4 <USB_StopHost+0xd4>
  {   
    value = USBx_HC(i)->HCCHAR ;
 800bf62:	7dfb      	ldrb	r3, [r7, #23]
 800bf64:	015a      	lsls	r2, r3, #5
 800bf66:	687b      	ldr	r3, [r7, #4]
 800bf68:	4413      	add	r3, r2
 800bf6a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bf6e:	681b      	ldr	r3, [r3, #0]
 800bf70:	60fb      	str	r3, [r7, #12]
    
    value |= USB_OTG_HCCHAR_CHDIS;
 800bf72:	68fb      	ldr	r3, [r7, #12]
 800bf74:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800bf78:	60fb      	str	r3, [r7, #12]
    value |= USB_OTG_HCCHAR_CHENA;  
 800bf7a:	68fb      	ldr	r3, [r7, #12]
 800bf7c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800bf80:	60fb      	str	r3, [r7, #12]
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800bf82:	68fb      	ldr	r3, [r7, #12]
 800bf84:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800bf88:	60fb      	str	r3, [r7, #12]
    
    USBx_HC(i)->HCCHAR = value;
 800bf8a:	7dfb      	ldrb	r3, [r7, #23]
 800bf8c:	015a      	lsls	r2, r3, #5
 800bf8e:	687b      	ldr	r3, [r7, #4]
 800bf90:	4413      	add	r3, r2
 800bf92:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bf96:	461a      	mov	r2, r3
 800bf98:	68fb      	ldr	r3, [r7, #12]
 800bf9a:	6013      	str	r3, [r2, #0]
    do 
    {
      if (++count > 1000) 
 800bf9c:	693b      	ldr	r3, [r7, #16]
 800bf9e:	3301      	adds	r3, #1
 800bfa0:	613b      	str	r3, [r7, #16]
 800bfa2:	693b      	ldr	r3, [r7, #16]
 800bfa4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800bfa8:	d900      	bls.n	800bfac <USB_StopHost+0xbc>
      {
        break;
 800bfaa:	e008      	b.n	800bfbe <USB_StopHost+0xce>
      }
    } 
    while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 800bfac:	7dfb      	ldrb	r3, [r7, #23]
 800bfae:	015a      	lsls	r2, r3, #5
 800bfb0:	687b      	ldr	r3, [r7, #4]
 800bfb2:	4413      	add	r3, r2
 800bfb4:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800bfb8:	681b      	ldr	r3, [r3, #0]
 800bfba:	2b00      	cmp	r3, #0
 800bfbc:	dbee      	blt.n	800bf9c <USB_StopHost+0xac>
    value &= ~USB_OTG_HCCHAR_EPDIR;
    USBx_HC(i)->HCCHAR = value;
  }
  
  /* Halt all channels to put them into a known state. */  
  for (i = 0; i <= 15; i++)
 800bfbe:	7dfb      	ldrb	r3, [r7, #23]
 800bfc0:	3301      	adds	r3, #1
 800bfc2:	75fb      	strb	r3, [r7, #23]
 800bfc4:	7dfb      	ldrb	r3, [r7, #23]
 800bfc6:	2b0f      	cmp	r3, #15
 800bfc8:	d9cb      	bls.n	800bf62 <USB_StopHost+0x72>
    } 
    while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
  }

  /* Clear any pending Host interrupts */  
  USBx_HOST->HAINT = 0xFFFFFFFF;
 800bfca:	687b      	ldr	r3, [r7, #4]
 800bfcc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800bfd0:	461a      	mov	r2, r3
 800bfd2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bfd6:	6153      	str	r3, [r2, #20]
  USBx->GINTSTS = 0xFFFFFFFF;
 800bfd8:	687b      	ldr	r3, [r7, #4]
 800bfda:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800bfde:	615a      	str	r2, [r3, #20]
  USB_EnableGlobalInt(USBx);
 800bfe0:	6878      	ldr	r0, [r7, #4]
 800bfe2:	f7fe fe6d 	bl	800acc0 <USB_EnableGlobalInt>
  return HAL_OK;  
 800bfe6:	2300      	movs	r3, #0
}
 800bfe8:	4618      	mov	r0, r3
 800bfea:	3718      	adds	r7, #24
 800bfec:	46bd      	mov	sp, r7
 800bfee:	bd80      	pop	{r7, pc}

0800bff0 <HAL_PWR_DeInit>:
  * @brief Deinitialize the HAL PWR peripheral registers to their default reset values.
  * @retval None
  */
void HAL_PWR_DeInit(void)
{
  __HAL_RCC_PWR_FORCE_RESET();
 800bff0:	4b04      	ldr	r3, [pc, #16]	; (800c004 <HAL_PWR_DeInit+0x14>)
 800bff2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800bff4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800bff8:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_RCC_PWR_RELEASE_RESET();
 800bffa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800bffc:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 800c000:	639a      	str	r2, [r3, #56]	; 0x38
 800c002:	4770      	bx	lr
 800c004:	40021000 	.word	0x40021000

0800c008 <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.                
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);    
 800c008:	4a02      	ldr	r2, [pc, #8]	; (800c014 <HAL_PWR_EnableBkUpAccess+0xc>)
 800c00a:	6813      	ldr	r3, [r2, #0]
 800c00c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800c010:	6013      	str	r3, [r2, #0]
 800c012:	4770      	bx	lr
 800c014:	40007000 	.word	0x40007000

0800c018 <HAL_PWR_DisableBkUpAccess>:
  *        (RTC registers, RTC backup data registers).    
  * @retval None
  */
void HAL_PWR_DisableBkUpAccess(void)
{
  CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);   
 800c018:	4a02      	ldr	r2, [pc, #8]	; (800c024 <HAL_PWR_DisableBkUpAccess+0xc>)
 800c01a:	6813      	ldr	r3, [r2, #0]
 800c01c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800c020:	6013      	str	r3, [r2, #0]
 800c022:	4770      	bx	lr
 800c024:	40007000 	.word	0x40007000

0800c028 <HAL_PWR_ConfigPVD>:
  *         more details about the voltage thresholds corresponding to each
  *         detection level.
  * @retval None
  */
HAL_StatusTypeDef HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
{
 800c028:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));

  /* Set PLS bits according to PVDLevel value */
  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, sConfigPVD->PVDLevel);
 800c02a:	4c1d      	ldr	r4, [pc, #116]	; (800c0a0 <HAL_PWR_ConfigPVD+0x78>)
  
  /* Clear any previous config. Keep it clear if no event or IT mode is selected */
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 800c02c:	4b1d      	ldr	r3, [pc, #116]	; (800c0a4 <HAL_PWR_ConfigPVD+0x7c>)
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));

  /* Set PLS bits according to PVDLevel value */
  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, sConfigPVD->PVDLevel);
 800c02e:	6862      	ldr	r2, [r4, #4]
 800c030:	f022 010e 	bic.w	r1, r2, #14
 800c034:	6802      	ldr	r2, [r0, #0]
 800c036:	430a      	orrs	r2, r1
 800c038:	6062      	str	r2, [r4, #4]
  
  /* Clear any previous config. Keep it clear if no event or IT mode is selected */
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 800c03a:	685a      	ldr	r2, [r3, #4]
 800c03c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800c040:	605a      	str	r2, [r3, #4]
  __HAL_PWR_PVD_EXTI_DISABLE_IT();
 800c042:	681a      	ldr	r2, [r3, #0]
 800c044:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800c048:	601a      	str	r2, [r3, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
 800c04a:	68da      	ldr	r2, [r3, #12]
 800c04c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800c050:	60da      	str	r2, [r3, #12]
  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
 800c052:	689a      	ldr	r2, [r3, #8]
 800c054:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800c058:	609a      	str	r2, [r3, #8]

  /* Configure interrupt mode */
  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
 800c05a:	6842      	ldr	r2, [r0, #4]
 800c05c:	03d1      	lsls	r1, r2, #15
 800c05e:	d504      	bpl.n	800c06a <HAL_PWR_ConfigPVD+0x42>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT();
 800c060:	681a      	ldr	r2, [r3, #0]
 800c062:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800c066:	601a      	str	r2, [r3, #0]
 800c068:	6842      	ldr	r2, [r0, #4]
  }
  
  /* Configure event mode */
  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 800c06a:	0394      	lsls	r4, r2, #14
 800c06c:	d505      	bpl.n	800c07a <HAL_PWR_ConfigPVD+0x52>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
 800c06e:	4a0d      	ldr	r2, [pc, #52]	; (800c0a4 <HAL_PWR_ConfigPVD+0x7c>)
 800c070:	6853      	ldr	r3, [r2, #4]
 800c072:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800c076:	6053      	str	r3, [r2, #4]
 800c078:	6842      	ldr	r2, [r0, #4]
  }
  
  /* Configure the edge */
  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 800c07a:	07d1      	lsls	r1, r2, #31
 800c07c:	d505      	bpl.n	800c08a <HAL_PWR_ConfigPVD+0x62>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 800c07e:	4a09      	ldr	r2, [pc, #36]	; (800c0a4 <HAL_PWR_ConfigPVD+0x7c>)
 800c080:	6893      	ldr	r3, [r2, #8]
 800c082:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800c086:	6093      	str	r3, [r2, #8]
 800c088:	6842      	ldr	r2, [r0, #4]
  }
  
  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 800c08a:	0793      	lsls	r3, r2, #30
 800c08c:	d504      	bpl.n	800c098 <HAL_PWR_ConfigPVD+0x70>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 800c08e:	4a05      	ldr	r2, [pc, #20]	; (800c0a4 <HAL_PWR_ConfigPVD+0x7c>)
 800c090:	68d3      	ldr	r3, [r2, #12]
 800c092:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800c096:	60d3      	str	r3, [r2, #12]
  }
  
  return HAL_OK;
}
 800c098:	2000      	movs	r0, #0
 800c09a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c09e:	4770      	bx	lr
 800c0a0:	40007000 	.word	0x40007000
 800c0a4:	40010400 	.word	0x40010400

0800c0a8 <HAL_PWR_EnablePVD>:
  * @brief Enable the Power Voltage Detector (PVD).
  * @retval None
  */
void HAL_PWR_EnablePVD(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_PVDE);  
 800c0a8:	4a02      	ldr	r2, [pc, #8]	; (800c0b4 <HAL_PWR_EnablePVD+0xc>)
 800c0aa:	6853      	ldr	r3, [r2, #4]
 800c0ac:	f043 0301 	orr.w	r3, r3, #1
 800c0b0:	6053      	str	r3, [r2, #4]
 800c0b2:	4770      	bx	lr
 800c0b4:	40007000 	.word	0x40007000

0800c0b8 <HAL_PWR_DisablePVD>:
  * @brief Disable the Power Voltage Detector (PVD).
  * @retval None
  */
void HAL_PWR_DisablePVD(void)
{
  CLEAR_BIT(PWR->CR2, PWR_CR2_PVDE);   
 800c0b8:	4a02      	ldr	r2, [pc, #8]	; (800c0c4 <HAL_PWR_DisablePVD+0xc>)
 800c0ba:	6853      	ldr	r3, [r2, #4]
 800c0bc:	f023 0301 	bic.w	r3, r3, #1
 800c0c0:	6053      	str	r3, [r2, #4]
 800c0c2:	4770      	bx	lr
 800c0c4:	40007000 	.word	0x40007000

0800c0c8 <HAL_PWR_EnableWakeUpPin>:
{
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinPolarity)); 
  
  /* Specifies the Wake-Up pin polarity for the event detection 
    (rising or falling edge) */
  MODIFY_REG(PWR->CR4, (PWR_CR3_EWUP & WakeUpPinPolarity), (WakeUpPinPolarity >> PWR_WUP_POLARITY_SHIFT)); 
 800c0c8:	4a06      	ldr	r2, [pc, #24]	; (800c0e4 <HAL_PWR_EnableWakeUpPin+0x1c>)
 800c0ca:	68d3      	ldr	r3, [r2, #12]
 800c0cc:	f000 011f 	and.w	r1, r0, #31
 800c0d0:	ea23 0301 	bic.w	r3, r3, r1
 800c0d4:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 800c0d8:	60d0      	str	r0, [r2, #12]
    
  /* Enable wake-up pin */
  SET_BIT(PWR->CR3, (PWR_CR3_EWUP & WakeUpPinPolarity));
 800c0da:	6893      	ldr	r3, [r2, #8]
 800c0dc:	430b      	orrs	r3, r1
 800c0de:	6093      	str	r3, [r2, #8]
 800c0e0:	4770      	bx	lr
 800c0e2:	bf00      	nop
 800c0e4:	40007000 	.word	0x40007000

0800c0e8 <HAL_PWR_DisableWakeUpPin>:
  */
void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
{
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));

  CLEAR_BIT(PWR->CR3, WakeUpPinx); 
 800c0e8:	4a02      	ldr	r2, [pc, #8]	; (800c0f4 <HAL_PWR_DisableWakeUpPin+0xc>)
 800c0ea:	6893      	ldr	r3, [r2, #8]
 800c0ec:	ea23 0000 	bic.w	r0, r3, r0
 800c0f0:	6090      	str	r0, [r2, #8]
 800c0f2:	4770      	bx	lr
 800c0f4:	40007000 	.word	0x40007000

0800c0f8 <HAL_PWR_EnterSLEEPMode>:
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as 
  *        the interrupt wake up source.   
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
 800c0f8:	b510      	push	{r4, lr}

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 800c0fa:	4b0d      	ldr	r3, [pc, #52]	; (800c130 <HAL_PWR_EnterSLEEPMode+0x38>)
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as 
  *        the interrupt wake up source.   
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
 800c0fc:	460c      	mov	r4, r1

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 800c0fe:	695b      	ldr	r3, [r3, #20]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 800c100:	b960      	cbnz	r0, 800c11c <HAL_PWR_EnterSLEEPMode+0x24>
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
 800c102:	059a      	lsls	r2, r3, #22
 800c104:	d40f      	bmi.n	800c126 <HAL_PWR_EnterSLEEPMode+0x2e>
      HAL_PWREx_EnableLowPowerRunMode();  
    } 
  } 
    
  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800c106:	4a0b      	ldr	r2, [pc, #44]	; (800c134 <HAL_PWR_EnterSLEEPMode+0x3c>)
 800c108:	6913      	ldr	r3, [r2, #16]
  
  /* Select SLEEP mode entry -------------------------------------------------*/
  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 800c10a:	2c01      	cmp	r4, #1
      HAL_PWREx_EnableLowPowerRunMode();  
    } 
  } 
    
  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800c10c:	f023 0304 	bic.w	r3, r3, #4
 800c110:	6113      	str	r3, [r2, #16]
  
  /* Select SLEEP mode entry -------------------------------------------------*/
  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 800c112:	d00b      	beq.n	800c12c <HAL_PWR_EnterSLEEPMode+0x34>

    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
{
  __ASM volatile ("sev");
 800c114:	bf40      	sev
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 800c116:	bf20      	wfe
 800c118:	bf20      	wfe
 800c11a:	bd10      	pop	{r4, pc}
  }
  else
  {
    /* If in run mode, first move to low-power run mode.
       The system clock frequency must be below 2 MHz at this point. */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF) == RESET)
 800c11c:	059b      	lsls	r3, r3, #22
 800c11e:	d4f2      	bmi.n	800c106 <HAL_PWR_EnterSLEEPMode+0xe>
    {
      HAL_PWREx_EnableLowPowerRunMode();  
 800c120:	f7f9 fbda 	bl	80058d8 <HAL_PWREx_EnableLowPowerRunMode>
 800c124:	e7ef      	b.n	800c106 <HAL_PWR_EnterSLEEPMode+0xe>
  if (Regulator == PWR_MAINREGULATOR_ON)
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
    {
      HAL_PWREx_DisableLowPowerRunMode();  
 800c126:	f7f9 fbdf 	bl	80058e8 <HAL_PWREx_DisableLowPowerRunMode>
 800c12a:	e7ec      	b.n	800c106 <HAL_PWR_EnterSLEEPMode+0xe>
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 800c12c:	bf30      	wfi
 800c12e:	bd10      	pop	{r4, pc}
 800c130:	40007000 	.word	0x40007000
 800c134:	e000ed00 	.word	0xe000ed00

0800c138 <HAL_PWR_EnterSTOPMode>:
  *            @arg PWR_STOPENTRY_WFE: Enter Stop 1 mode with WFE instruction           
  * @retval None
  */
void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
{
  HAL_PWREx_EnterSTOP1Mode(Regulator, STOPEntry);
 800c138:	f7f9 bbfa 	b.w	8005930 <HAL_PWREx_EnterSTOP1Mode>

0800c13c <HAL_PWR_EnterSTANDBYMode>:
  * @retval None
  */
void HAL_PWR_EnterSTANDBYMode(void)
{
  /* Set Stand-by mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STANDBY);
 800c13c:	4906      	ldr	r1, [pc, #24]	; (800c158 <HAL_PWR_EnterSTANDBYMode+0x1c>)

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800c13e:	4a07      	ldr	r2, [pc, #28]	; (800c15c <HAL_PWR_EnterSTANDBYMode+0x20>)
  * @retval None
  */
void HAL_PWR_EnterSTANDBYMode(void)
{
  /* Set Stand-by mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STANDBY);
 800c140:	680b      	ldr	r3, [r1, #0]
 800c142:	f023 0307 	bic.w	r3, r3, #7
 800c146:	f043 0303 	orr.w	r3, r3, #3
 800c14a:	600b      	str	r3, [r1, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800c14c:	6913      	ldr	r3, [r2, #16]
 800c14e:	f043 0304 	orr.w	r3, r3, #4
 800c152:	6113      	str	r3, [r2, #16]
 800c154:	bf30      	wfi
 800c156:	4770      	bx	lr
 800c158:	40007000 	.word	0x40007000
 800c15c:	e000ed00 	.word	0xe000ed00

0800c160 <HAL_PWR_EnableSleepOnExit>:
  * @retval None
  */
void HAL_PWR_EnableSleepOnExit(void)
{
  /* Set SLEEPONEXIT bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 800c160:	4a02      	ldr	r2, [pc, #8]	; (800c16c <HAL_PWR_EnableSleepOnExit+0xc>)
 800c162:	6913      	ldr	r3, [r2, #16]
 800c164:	f043 0302 	orr.w	r3, r3, #2
 800c168:	6113      	str	r3, [r2, #16]
 800c16a:	4770      	bx	lr
 800c16c:	e000ed00 	.word	0xe000ed00

0800c170 <HAL_PWR_DisableSleepOnExit>:
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit(void)
{
  /* Clear SLEEPONEXIT bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 800c170:	4a02      	ldr	r2, [pc, #8]	; (800c17c <HAL_PWR_DisableSleepOnExit+0xc>)
 800c172:	6913      	ldr	r3, [r2, #16]
 800c174:	f023 0302 	bic.w	r3, r3, #2
 800c178:	6113      	str	r3, [r2, #16]
 800c17a:	4770      	bx	lr
 800c17c:	e000ed00 	.word	0xe000ed00

0800c180 <HAL_PWR_EnableSEVOnPend>:
  * @retval None
  */
void HAL_PWR_EnableSEVOnPend(void)
{
  /* Set SEVONPEND bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 800c180:	4a02      	ldr	r2, [pc, #8]	; (800c18c <HAL_PWR_EnableSEVOnPend+0xc>)
 800c182:	6913      	ldr	r3, [r2, #16]
 800c184:	f043 0310 	orr.w	r3, r3, #16
 800c188:	6113      	str	r3, [r2, #16]
 800c18a:	4770      	bx	lr
 800c18c:	e000ed00 	.word	0xe000ed00

0800c190 <HAL_PWR_DisableSEVOnPend>:
  * @retval None
  */
void HAL_PWR_DisableSEVOnPend(void)
{
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 800c190:	4a02      	ldr	r2, [pc, #8]	; (800c19c <HAL_PWR_DisableSEVOnPend+0xc>)
 800c192:	6913      	ldr	r3, [r2, #16]
 800c194:	f023 0310 	bic.w	r3, r3, #16
 800c198:	6113      	str	r3, [r2, #16]
 800c19a:	4770      	bx	lr
 800c19c:	e000ed00 	.word	0xe000ed00

0800c1a0 <HAL_PWR_PVDCallback>:
/**
  * @brief PWR PVD interrupt callback
  * @retval None
  */
__weak void HAL_PWR_PVDCallback(void)
{
 800c1a0:	4770      	bx	lr
 800c1a2:	bf00      	nop

0800c1a4 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800c1a4:	f8df d034 	ldr.w	sp, [pc, #52]	; 800c1dc <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 800c1a8:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 800c1aa:	e003      	b.n	800c1b4 <LoopCopyDataInit>

0800c1ac <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 800c1ac:	4b0c      	ldr	r3, [pc, #48]	; (800c1e0 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 800c1ae:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 800c1b0:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800c1b2:	3104      	adds	r1, #4

0800c1b4 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 800c1b4:	480b      	ldr	r0, [pc, #44]	; (800c1e4 <LoopForever+0xa>)
	ldr	r3, =_edata
 800c1b6:	4b0c      	ldr	r3, [pc, #48]	; (800c1e8 <LoopForever+0xe>)
	adds	r2, r0, r1
 800c1b8:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 800c1ba:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 800c1bc:	d3f6      	bcc.n	800c1ac <CopyDataInit>
	ldr	r2, =_sbss
 800c1be:	4a0b      	ldr	r2, [pc, #44]	; (800c1ec <LoopForever+0x12>)
	b	LoopFillZerobss
 800c1c0:	e002      	b.n	800c1c8 <LoopFillZerobss>

0800c1c2 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 800c1c2:	2300      	movs	r3, #0
	str	r3, [r2], #4
 800c1c4:	f842 3b04 	str.w	r3, [r2], #4

0800c1c8 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 800c1c8:	4b09      	ldr	r3, [pc, #36]	; (800c1f0 <LoopForever+0x16>)
	cmp	r2, r3
 800c1ca:	429a      	cmp	r2, r3
	bcc	FillZerobss
 800c1cc:	d3f9      	bcc.n	800c1c2 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800c1ce:	f7f4 f827 	bl	8000220 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800c1d2:	f000 f839 	bl	800c248 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 800c1d6:	f000 f80f 	bl	800c1f8 <main>

0800c1da <LoopForever>:

LoopForever:
    b LoopForever
 800c1da:	e7fe      	b.n	800c1da <LoopForever>

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800c1dc:	20018000 	.word	0x20018000
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 800c1e0:	0800c4c8 	.word	0x0800c4c8
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 800c1e4:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 800c1e8:	20000430 	.word	0x20000430
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 800c1ec:	20000430 	.word	0x20000430
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 800c1f0:	200009f8 	.word	0x200009f8

0800c1f4 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 800c1f4:	e7fe      	b.n	800c1f4 <ADC1_2_IRQHandler>
	...

0800c1f8 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 800c1f8:	b508      	push	{r3, lr}
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800c1fa:	f7f4 fc6b 	bl	8000ad4 <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 800c1fe:	f7f4 f981 	bl	8000504 <SystemClock_Config>

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800c202:	f7f4 f8c1 	bl	8000388 <MX_GPIO_Init>
  MX_DMA_Init();
 800c206:	f7f4 f88d 	bl	8000324 <MX_DMA_Init>
  MX_I2C2_Init();
 800c20a:	f7f4 f91f 	bl	800044c <MX_I2C2_Init>
  MX_RTC_Init();
 800c20e:	f7f4 f9d7 	bl	80005c0 <MX_RTC_Init>
  MX_SPI1_Init();
 800c212:	f7f4 fa45 	bl	80006a0 <MX_SPI1_Init>
  MX_SPI3_Init();
 800c216:	f7f4 fa69 	bl	80006ec <MX_SPI3_Init>
  MX_USB_OTG_FS_PCD_Init();
 800c21a:	f7f4 fbaf 	bl	800097c <MX_USB_OTG_FS_PCD_Init>
  char test[5]= "test";
  /* USER CODE BEGIN WHILE */
  while (1)
  {
 //   fillRect(0,0,128,128,ColorHSV(1200,255,255));
    HAL_GPIO_WritePin(RED_GPIO_Port, RED_Pin, GPIO_PIN_SET);
 800c21e:	2108      	movs	r1, #8
 800c220:	2201      	movs	r2, #1
 800c222:	4808      	ldr	r0, [pc, #32]	; (800c244 <main+0x4c>)
 800c224:	f7f6 f85c 	bl	80022e0 <HAL_GPIO_WritePin>
    HAL_Delay(500);
 800c228:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800c22c:	f7f4 fc72 	bl	8000b14 <HAL_Delay>
    HAL_GPIO_WritePin(RED_GPIO_Port, RED_Pin, GPIO_PIN_RESET);
 800c230:	4804      	ldr	r0, [pc, #16]	; (800c244 <main+0x4c>)
 800c232:	2108      	movs	r1, #8
 800c234:	2200      	movs	r2, #0
 800c236:	f7f6 f853 	bl	80022e0 <HAL_GPIO_WritePin>
    HAL_Delay(500);
 800c23a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800c23e:	f7f4 fc69 	bl	8000b14 <HAL_Delay>



  }
 800c242:	e7ec      	b.n	800c21e <main+0x26>
 800c244:	48000400 	.word	0x48000400

0800c248 <__libc_init_array>:
 800c248:	e92d4070 	push	{r4, r5, r6, lr}
 800c24c:	e59f6064 	ldr	r6, [pc, #100]	; 800c2b8 <__libc_init_array+0x70>
 800c250:	e59f5064 	ldr	r5, [pc, #100]	; 800c2bc <__libc_init_array+0x74>
 800c254:	e0656006 	rsb	r6, r5, r6
 800c258:	e1b06146 	asrs	r6, r6, #2
 800c25c:	13a04000 	movne	r4, #0
 800c260:	0a000005 	beq	800c27c <__libc_init_array+0x34>
 800c264:	e2844001 	add	r4, r4, #1
 800c268:	e4953004 	ldr	r3, [r5], #4
 800c26c:	e1a0e00f 	mov	lr, pc
 800c270:	e12fff13 	bx	r3
 800c274:	e1560004 	cmp	r6, r4
 800c278:	1afffff9 	bne	800c264 <__libc_init_array+0x1c>
 800c27c:	e59f603c 	ldr	r6, [pc, #60]	; 800c2c0 <__libc_init_array+0x78>
 800c280:	e59f503c 	ldr	r5, [pc, #60]	; 800c2c4 <__libc_init_array+0x7c>
 800c284:	e0656006 	rsb	r6, r5, r6
 800c288:	eb000069 	bl	800c434 <_init>
 800c28c:	e1b06146 	asrs	r6, r6, #2
 800c290:	13a04000 	movne	r4, #0
 800c294:	0a000005 	beq	800c2b0 <__libc_init_array+0x68>
 800c298:	e2844001 	add	r4, r4, #1
 800c29c:	e4953004 	ldr	r3, [r5], #4
 800c2a0:	e1a0e00f 	mov	lr, pc
 800c2a4:	e12fff13 	bx	r3
 800c2a8:	e1560004 	cmp	r6, r4
 800c2ac:	1afffff9 	bne	800c298 <__libc_init_array+0x50>
 800c2b0:	e8bd4070 	pop	{r4, r5, r6, lr}
 800c2b4:	e12fff1e 	bx	lr
 800c2b8:	0800c4b8 	.word	0x0800c4b8
 800c2bc:	0800c4b8 	.word	0x0800c4b8
 800c2c0:	0800c4c0 	.word	0x0800c4c0
 800c2c4:	0800c4b8 	.word	0x0800c4b8

0800c2c8 <register_fini>:
 800c2c8:	e92d4008 	push	{r3, lr}
 800c2cc:	e59f3010 	ldr	r3, [pc, #16]	; 800c2e4 <register_fini+0x1c>
 800c2d0:	e3530000 	cmp	r3, #0
 800c2d4:	159f000c 	ldrne	r0, [pc, #12]	; 800c2e8 <register_fini+0x20>
 800c2d8:	1b000003 	blne	800c2ec <atexit>
 800c2dc:	e8bd4008 	pop	{r3, lr}
 800c2e0:	e12fff1e 	bx	lr
 800c2e4:	00000000 	.word	0x00000000
 800c2e8:	0800c30c 	.word	0x0800c30c

0800c2ec <atexit>:
 800c2ec:	e1a01000 	mov	r1, r0
 800c2f0:	e3a00000 	mov	r0, #0
 800c2f4:	e92d4008 	push	{r3, lr}
 800c2f8:	e1a02000 	mov	r2, r0
 800c2fc:	e1a03000 	mov	r3, r0
 800c300:	eb000013 	bl	800c354 <__register_exitproc>
 800c304:	e8bd4008 	pop	{r3, lr}
 800c308:	e12fff1e 	bx	lr

0800c30c <__libc_fini_array>:
 800c30c:	e92d4038 	push	{r3, r4, r5, lr}
 800c310:	e59f5034 	ldr	r5, [pc, #52]	; 800c34c <__libc_fini_array+0x40>
 800c314:	e59f3034 	ldr	r3, [pc, #52]	; 800c350 <__libc_fini_array+0x44>
 800c318:	e0653003 	rsb	r3, r5, r3
 800c31c:	e1b04143 	asrs	r4, r3, #2
 800c320:	10835005 	addne	r5, r3, r5
 800c324:	0a000005 	beq	800c340 <__libc_fini_array+0x34>
 800c328:	e2444001 	sub	r4, r4, #1
 800c32c:	e5353004 	ldr	r3, [r5, #-4]!
 800c330:	e1a0e00f 	mov	lr, pc
 800c334:	e12fff13 	bx	r3
 800c338:	e3540000 	cmp	r4, #0
 800c33c:	1afffff9 	bne	800c328 <__libc_fini_array+0x1c>
 800c340:	eb000041 	bl	800c44c <_fini>
 800c344:	e8bd4038 	pop	{r3, r4, r5, lr}
 800c348:	e12fff1e 	bx	lr
 800c34c:	0800c4c0 	.word	0x0800c4c0
 800c350:	0800c4c4 	.word	0x0800c4c4

0800c354 <__register_exitproc>:
 800c354:	e59fc0d0 	ldr	ip, [pc, #208]	; 800c42c <__register_exitproc+0xd8>
 800c358:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 800c35c:	e59c4000 	ldr	r4, [ip]
 800c360:	e594c148 	ldr	ip, [r4, #328]	; 0x148
 800c364:	e35c0000 	cmp	ip, #0
 800c368:	0284cf53 	addeq	ip, r4, #332	; 0x14c
 800c36c:	e59ce004 	ldr	lr, [ip, #4]
 800c370:	0584c148 	streq	ip, [r4, #328]	; 0x148
 800c374:	e35e001f 	cmp	lr, #31
 800c378:	e1a06001 	mov	r6, r1
 800c37c:	e1a05000 	mov	r5, r0
 800c380:	e1a08002 	mov	r8, r2
 800c384:	e1a07003 	mov	r7, r3
 800c388:	d28e1001 	addle	r1, lr, #1
 800c38c:	da00000f 	ble	800c3d0 <__register_exitproc+0x7c>
 800c390:	e59f3098 	ldr	r3, [pc, #152]	; 800c430 <__register_exitproc+0xdc>
 800c394:	e3530000 	cmp	r3, #0
 800c398:	0a000021 	beq	800c424 <__register_exitproc+0xd0>
 800c39c:	e3a00e19 	mov	r0, #400	; 0x190
 800c3a0:	e320f000 	nop	{0}
 800c3a4:	e250c000 	subs	ip, r0, #0
 800c3a8:	0a00001d 	beq	800c424 <__register_exitproc+0xd0>
 800c3ac:	e3a00000 	mov	r0, #0
 800c3b0:	e3a01001 	mov	r1, #1
 800c3b4:	e1a0e000 	mov	lr, r0
 800c3b8:	e5943148 	ldr	r3, [r4, #328]	; 0x148
 800c3bc:	e58c0004 	str	r0, [ip, #4]
 800c3c0:	e58c3000 	str	r3, [ip]
 800c3c4:	e584c148 	str	ip, [r4, #328]	; 0x148
 800c3c8:	e58c0188 	str	r0, [ip, #392]	; 0x188
 800c3cc:	e58c018c 	str	r0, [ip, #396]	; 0x18c
 800c3d0:	e3550000 	cmp	r5, #0
 800c3d4:	1a000005 	bne	800c3f0 <__register_exitproc+0x9c>
 800c3d8:	e3a00000 	mov	r0, #0
 800c3dc:	e28ee002 	add	lr, lr, #2
 800c3e0:	e58c1004 	str	r1, [ip, #4]
 800c3e4:	e78c610e 	str	r6, [ip, lr, lsl #2]
 800c3e8:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
 800c3ec:	e12fff1e 	bx	lr
 800c3f0:	e3a00001 	mov	r0, #1
 800c3f4:	e08c310e 	add	r3, ip, lr, lsl #2
 800c3f8:	e5838088 	str	r8, [r3, #136]	; 0x88
 800c3fc:	e59c4188 	ldr	r4, [ip, #392]	; 0x188
 800c400:	e1a02e10 	lsl	r2, r0, lr
 800c404:	e1840002 	orr	r0, r4, r2
 800c408:	e58c0188 	str	r0, [ip, #392]	; 0x188
 800c40c:	e5837108 	str	r7, [r3, #264]	; 0x108
 800c410:	e3550002 	cmp	r5, #2
 800c414:	059c318c 	ldreq	r3, [ip, #396]	; 0x18c
 800c418:	01832002 	orreq	r2, r3, r2
 800c41c:	058c218c 	streq	r2, [ip, #396]	; 0x18c
 800c420:	eaffffec 	b	800c3d8 <__register_exitproc+0x84>
 800c424:	e3e00000 	mvn	r0, #0
 800c428:	eaffffee 	b	800c3e8 <__register_exitproc+0x94>
 800c42c:	0800c4b4 	.word	0x0800c4b4
 800c430:	00000000 	.word	0x00000000

0800c434 <_init>:
 800c434:	e1a0c00d 	mov	ip, sp
 800c438:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 800c43c:	e24cb004 	sub	fp, ip, #4
 800c440:	e24bd028 	sub	sp, fp, #40	; 0x28
 800c444:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
 800c448:	e12fff1e 	bx	lr

0800c44c <_fini>:
 800c44c:	e1a0c00d 	mov	ip, sp
 800c450:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 800c454:	e24cb004 	sub	fp, ip, #4
 800c458:	e24bd028 	sub	sp, fp, #40	; 0x28
 800c45c:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
 800c460:	e12fff1e 	bx	lr
 800c464:	00000000 	andeq	r0, r0, r0
